{"C++": {"451": "int minCost(int cost[][N])\n{\n\tint dist[N];\n\tfor (int i=0; i<N; i++)\n\tdist[i] = INF;\n\tdist[0] = 0;\n\tfor (int i=0; i<N; i++)\n\tfor (int j=i+1; j<N; j++)\n\t\tif (dist[j] > dist[i] + cost[i][j])\n\t\t\tdist[j] = dist[i] + cost[i][j];\n\treturn dist[N-1];\n}", "455": "int numOfways(int n, int k)\n{\n\tint p = 1;\n\tif (k % 2)\n\t\tp = -1;\n\treturn (pow(n - 1, k) + p * (n - 1)) / n;\n}", "496": "int fib(int n)\n{\n\tif (n <= 1)\n\t\treturn n;\n\treturn fib(n - 1) + fib(n - 2);\n}\nint findVertices (int n)\n{\n\treturn fib(n + 2);\n}", "617": "void reverse(struct Node** head_ref)\n{\n\tstruct Node* temp = NULL;\n\tstruct Node* current = *head_ref;\n\twhile (current != NULL) {\n\t\ttemp = current->prev;\n\t\tcurrent->prev = current->next;\n\t\tcurrent->next = temp;\n\t\tcurrent = current->prev;\n\t}\n\tif (temp != NULL)\n\t\t*head_ref = temp->prev;\n}\nstruct Node* merge(struct Node* first, struct Node* second)\n{\n\tif (!first)\n\t\treturn second;\n\tif (!second)\n\t\treturn first;\n\tif (first->data < second->data) {\n\t\tfirst->next = merge(first->next, second);\n\t\tfirst->next->prev = first;\n\t\tfirst->prev = NULL;\n\t\treturn first;\n\t} else {\n\t\tsecond->next = merge(first, second->next);\n\t\tsecond->next->prev = second;\n\t\tsecond->prev = NULL;\n\t\treturn second;\n\t}\n}\nstruct Node* sort(struct Node* head)\n{\n\tif (head == NULL head->next == NULL)\n\t\treturn head;\n\tstruct Node* current = head->next;\n\twhile (current != NULL) {\n\t\tif (current->data < current->prev->data)\n\t\t\tbreak;\n\t\tcurrent = current->next;\n\t}\n\tif (current == NULL)\n\t\treturn head;\n\tcurrent->prev->next = NULL;\n\tcurrent->prev = NULL;\n\treverse(&current);\n\treturn merge(head, current);\n}\nvoid push(struct Node** head_ref, int new_data)\n{\n\tstruct Node* new_node =\n\t\t(struct Node*)malloc(sizeof(struct Node));\n\tnew_node->data = new_data;\n\tnew_node->prev = NULL;\n\tnew_node->next = (*head_ref);\n\tif ((*head_ref) != NULL)\n\t\t(*head_ref)->prev = new_node;\n\t(*head_ref) = new_node;\n}\nvoid printList(struct Node* head)\n{\n\tif (head == NULL)\n\t\tcout << \"Doubly Linked list empty\";\n\twhile (head != NULL) {\n\t\tcout << head->data << \" \";\n\t\thead = head->next;\n\t}\n}", "647": "Node *newNode(char key)\n{\n\tNode *temp = new Node;\n\ttemp->data = key;\n\ttemp->next = NULL;\n\treturn temp;\n}\nvoid printlist(Node *head)\n{\n\tif (! head)\n\t{\n\t\tcout << \"Empty List\\n\";\n\t\treturn;\n\t}\n\twhile (head != NULL)\n\t{\n\t\tcout << head->data << \" \";\n\t\tif (head->next)\n\t\tcout << \"-> \";\n\t\thead = head->next;\n\t}\n\tcout << endl;\n}\nbool isVowel(char x)\n{\n\treturn (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n}\nNode *arrange(Node *head)\n{\n\tNode *newHead = head;\n\tNode *latestVowel;\n\tNode *curr = head;\n\tif (head == NULL)\n\t\treturn NULL;\n\tif (isVowel(head->data))\n\t\tlatestVowel = head;\n\telse\n\t{\n\t\twhile (curr->next != NULL &&\n\t\t\t!isVowel(curr->next->data))\n\t\t\tcurr = curr->next;\n\t\tif (curr->next == NULL)\n\t\t\treturn head;\n\t\tlatestVowel = newHead = curr->next;\n\t\tcurr->next = curr->next->next;\n\t\tlatestVowel->next = head;\n\t}\n\twhile (curr != NULL && curr->next != NULL)\n\t{\n\t\tif (isVowel(curr->next->data))\n\t\t{\n\t\t\tif (curr == latestVowel)\n\t\t\t{\n\t\t\t\tlatestVowel = curr = curr->next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNode *temp = latestVowel->next;\n\t\t\t\tlatestVowel->next = curr->next;\n\t\t\t\tlatestVowel = latestVowel->next;\n\t\t\t\tcurr->next = curr->next->next;\n\t\t\t\tlatestVowel->next = temp;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurr = curr->next;\n\t\t}\n\t}\n\treturn newHead;\n}", "694": "Node* newNode(int data)\n{\n\tNode* temp = new Node;\n\ttemp->data = data;\n\ttemp->right = temp->left = NULL;\n\treturn temp;\n}\nNode* KthLargestUsingMorrisTraversal(Node* root, int k)\n{\n\tNode* curr = root;\n\tNode* Klargest = NULL;\n\tint count = 0;\n\twhile (curr != NULL) {\n\t\tif (curr->right == NULL) {\n\t\t\tif (++count == k)\n\t\t\t\tKlargest = curr;\n\t\t\tcurr = curr->left;\n\t\t}\n\t\telse {\n\t\t\tNode* succ = curr->right;\n\t\t\twhile (succ->left != NULL && succ->left != curr)\n\t\t\t\tsucc = succ->left;\n\t\t\tif (succ->left == NULL) {\n\t\t\t\tsucc->left = curr;\n\t\t\t\tcurr = curr->right;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsucc->left = NULL;\n\t\t\t\tif (++count == k)\n\t\t\t\t\tKlargest = curr;\n\t\t\t\tcurr = curr->left;\n\t\t\t}\n\t\t}\n\t}\n\treturn Klargest;\n}", "803": "void sortByRow(int mat[][MAX_SIZE], int n, bool ascending)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\tif (ascending) \n\t\tsort(mat[i], mat[i] + n);\n\telse\n\t\tsort(mat[i], mat[i] + n, greater<int>());\n\t}\t\n}\nvoid transpose(int mat[][MAX_SIZE], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tswap(mat[i][j], mat[j][i]);\n}\nvoid sortMatRowAndColWise(int mat[][MAX_SIZE], int n)\n{\n\tsortByRow(mat, n, true);\n\ttranspose(mat, n);\n\tsortByRow(mat, n, false);\n\ttranspose(mat, n);\n}\nvoid printMat(int mat[][MAX_SIZE], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcout << mat[i][j] << \" \";\n\t\tcout << endl;\n\t}\n}", "815": "void sortByRow(int mat[MAX_SIZE][MAX_SIZE], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tsort(mat[i], mat[i] + n);\n}\nvoid transpose(int mat[MAX_SIZE][MAX_SIZE], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tswap(mat[i][j], mat[j][i]);\n}\nvoid sortMatRowAndColWise(int mat[MAX_SIZE][MAX_SIZE], int n)\n{\n\tsortByRow(mat, n);\n\ttranspose(mat, n);\n\tsortByRow(mat, n);\n\ttranspose(mat, n);\n}\nvoid printMat(int mat[MAX_SIZE][MAX_SIZE], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcout << mat[i][j] << \" \";\n\t\tcout << endl;\n\t}\n}", "818": "void doublyEven( int n )\n{\n\tint arr[n][n], i, j;\n\tfor ( i = 0; i < n; i++)\n\t\tfor ( j = 0; j < n; j++)\n\t\t\tarr[i][j] = (n*i) + j + 1;\n\tfor ( i = 0; i < n/4; i++)\n\t\tfor ( j = 0; j < n/4; j++)\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor ( i = 0; i < n/4; i++)\n\t\tfor ( j = 3 * (n/4); j < n; j++)\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor ( i = 3 * n/4; i < n; i++)\n\t\tfor ( j = 0; j < n/4; j++)\n\t\t\tarr[i][j] = (n*n+1) - arr[i][j];\n\tfor ( i = 3 * n/4; i < n; i++)\n\t\tfor ( j = 3 * n/4; j < n; j++)\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor ( i = n/4; i < 3 * n/4; i++)\n\t\tfor ( j = n/4; j < 3 * n/4; j++)\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor ( j = 0; j < n; j++)\n\t\t\tcout << arr[i][j] << \" \";\n\t\tcout << \"\\n\";\n\t}\n}", "821": "void Kroneckerproduct(int A[][cola], int B[][colb])\n{\n\tint C[rowa * rowb][cola * colb];\n\tfor (int i = 0; i < rowa; i++) {\n\t\tfor (int k = 0; k < rowb; k++) {\n\t\t\tfor (int j = 0; j < cola; j++) {\n\t\t\t\tfor (int l = 0; l < colb; l++) {\n\t\t\t\t\tC[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n\t\t\t\t\tcout << C[i + l + 1][j + k + 1] << \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}", "832": "bool isLowerTriangularMatrix(int mat[N][N])\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t\tif (mat[i][j] != 0)\n\t\t\t\treturn false;\n\treturn true;\n}", "833": "bool isUpperTriangularMatrix(int mat[N][N])\n{\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (mat[i][j] != 0)\n\t\t\t\treturn false;\n\treturn true;\n}", "846": "long long countSets(int a[n][m])\n{ \n\tlong long res = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint u = 0, v = 0;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\ta[i][j] ? u++ : v++;\t\t\n\t\tres += pow(2,u)-1 + pow(2,v)-1;\n\t}\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint u = 0, v = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ta[j][i] ? u++ : v++; \n\t\tres += pow(2,u)-1 + pow(2,v)-1;\n\t}\n\treturn res-(n*m);\n}", "861": "void transpose(int mat[][MAX], int tr[][MAX], int N)\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\ttr[i][j] = mat[j][i];\n}\nbool isSymmetric(int mat[][MAX], int N)\n{\n\tint tr[N][MAX];\n\ttranspose(mat, tr, N);\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != tr[i][j])\n\t\t\t\treturn false;\n\treturn true;\n}", "862": "bool isSymmetric(int mat[][MAX], int N)\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != mat[j][i])\n\t\t\t\treturn false;\n\treturn true;\n}", "883": "int findNormal(int mat[][MAX], int n)\n{\n\tint sum = 0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tsum += mat[i][j]*mat[i][j];\n\treturn sqrt(sum);\n}\nint findTrace(int mat[][MAX], int n)\n{\n\tint sum = 0;\n\tfor (int i=0; i<n; i++)\n\t\tsum += mat[i][i];\n\treturn sum;\n}", "895": "int maxDet(int n)\n{\n\treturn (2*n*n*n);\n}\nvoid resMatrix ( int n)\n{\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (i == 0 && j == 2)\n\t\t\t\tcout << \"0 \";\n\t\t\telse if (i == 1 && j == 0)\n\t\t\t\tcout << \"0 \";\n\t\t\telse if (i == 2 && j == 1)\n\t\t\t\tcout << \"0 \";\n\t\t\telse\n\t\t\t\tcout << n << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n}", "918": "int countNegative(int M[][4], int n, int m)\n{\n\tint count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (M[i][j] < 0)\n\t\t\t\tcount += 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}", "919": "int countNegative(int M[][4], int n, int m)\n{\n\tint count = 0;\n\tint i = 0;\n\tint j = m - 1;\n\twhile (j >= 0 && i < n) {\n\t\tif (M[i][j] < 0) {\n\t\t\tcount += j + 1;\n\t\t\ti += 1;\n\t\t}\n\t\telse\n\t\t\tj -= 1;\n\t}\n\treturn count;\n}", "920": "int getLastNegativeIndex(int array[], int start, int end,int n)\n{\n\tif (start == end)\n\t{\n\t\treturn start;\n\t}\n\tint mid = start + (end - start) / 2;\n\tif (array[mid] < 0)\n\t{\n\t\tif (mid + 1 < n && array[mid + 1] >= 0)\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\treturn getLastNegativeIndex(array, mid + 1, end, n);\n\t}\n\telse\n\t{\n\t\treturn getLastNegativeIndex(array, start, mid - 1, n);\n\t}\n}\nint countNegative(int M[][4], int n, int m)\n{\n\tint count = 0;\n\tint nextEnd = m - 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (M[i][0] >= 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tnextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4);\n\t\tcount += nextEnd + 1;\n\t}\n\treturn count;\n}", "926": "int findMaxValue(int mat[][N])\n{\n\tint maxValue = INT_MIN;\n\tfor (int a = 0; a < N - 1; a++)\n\tfor (int b = 0; b < N - 1; b++)\n\t\tfor (int d = a + 1; d < N; d++)\n\t\tfor (int e = b + 1; e < N; e++)\n\t\t\tif (maxValue < (mat[d][e] - mat[a][b]))\n\t\t\t\tmaxValue = mat[d][e] - mat[a][b];\n\treturn maxValue;\n}", "927": "int findMaxValue(int mat[][N])\n{\n\tint maxValue = INT_MIN;\n\tint maxArr[N][N];\n\tmaxArr[N-1][N-1] = mat[N-1][N-1];\nint maxv = mat[N-1][N-1]; \n\tfor (int j = N - 2; j >= 0; j--)\n\t{\n\t\tif (mat[N-1][j] > maxv)\n\t\t\tmaxv = mat[N - 1][j];\n\t\tmaxArr[N-1][j] = maxv;\n\t}\nmaxv = mat[N - 1][N - 1]; \n\tfor (int i = N - 2; i >= 0; i--)\n\t{\n\t\tif (mat[i][N - 1] > maxv)\n\t\t\tmaxv = mat[i][N - 1];\n\t\tmaxArr[i][N - 1] = maxv;\n\t}\n\tfor (int i = N-2; i >= 0; i--)\n\t{\n\t\tfor (int j = N-2; j >= 0; j--)\n\t\t{\n\t\t\tif (maxArr[i+1][j+1] - mat[i][j] > maxValue)\n\t\t\t\tmaxValue = maxArr[i + 1][j + 1] - mat[i][j];\n\t\t\tmaxArr[i][j] = max(mat[i][j],\n\t\t\t\t\t\t\tmax(maxArr[i][j + 1], maxArr[i + 1][j]) );\n\t\t}\n\t}\n\treturn maxValue;\n}", "953": "void youngify(int mat[][N], int i, int j)\n{\n\tint downVal = (i+1 < N)? mat[i+1][j]: INF;\n\tint rightVal = (j+1 < N)? mat[i][j+1]: INF;\n\tif (downVal==INF && rightVal==INF)\n\t\treturn;\n\tif (downVal < rightVal)\n\t{\n\t\tmat[i][j] = downVal;\n\t\tmat[i+1][j] = INF;\n\t\tyoungify(mat, i+1, j);\n\t}\n\telse\n\t{\n\t\tmat[i][j] = rightVal;\n\t\tmat[i][j+1] = INF;\n\t\tyoungify(mat, i, j+1);\n\t}\n}\nint extractMin(int mat[][N])\n{\n\tint ret = mat[0][0];\n\tmat[0][0] = INF;\n\tyoungify(mat, 0, 0);\n\treturn ret;\n}\nvoid printSorted(int mat[][N])\n{\n cout << \"Elements of matrix in sorted order n\";\n for (int i=0; i<N*N; i++)\n\tcout << extractMin(mat) << \" \";\n}", "955": "void printSumSimple(int mat[][n], int k)\n{\n if (k > n) return;\n for (int i=0; i<n-k+1; i++)\n {\n\tfor (int j=0; j<n-k+1; j++)\n\t{\n\t\tint sum = 0;\n\t\tfor (int p=i; p<k+i; p++)\n\t\t\tfor (int q=j; q<k+j; q++)\n\t\t\t\tsum += mat[p][q];\n\t\tcout << sum << \" \";\n\t}\n\tcout << endl;\n }\n}", "956": "void printSumTricky(int mat[][n], int k)\n{\n if (k > n) return;\n int stripSum[n][n];\n for (int j=0; j<n; j++)\n {\n\tint sum = 0;\n\tfor (int i=0; i<k; i++)\n\t\tsum += mat[i][j];\n\tstripSum[0][j] = sum;\n\tfor (int i=1; i<n-k+1; i++)\n\t{\n\t\t\tsum += (mat[i+k-1][j] - mat[i-1][j]);\n\t\t\tstripSum[i][j] = sum;\n\t}\n }\n for (int i=0; i<n-k+1; i++)\n {\n\tint sum = 0;\n\tfor (int j = 0; j<k; j++)\n\t\tsum += stripSum[i][j];\n\tcout << sum << \" \";\n\tfor (int j=1; j<n-k+1; j++)\n\t{\n\t\tsum += (stripSum[i][j+k-1] - stripSum[i][j-1]);\n\t\tcout << sum << \" \";\n\t}\n\tcout << endl;\n }\n}", "958": "void transpose(int A[][N], int B[][M])\n{\n\tint i, j;\n\tfor (i = 0; i < N; i++)\n\t\tfor (j = 0; j < M; j++)\n\t\t\tB[i][j] = A[j][i];\n}", "959": "void transpose(int A[][N])\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = i+1; j < N; j++)\n\t\t\tswap(A[i][j], A[j][i]);\n}", "965": "int pathCountRec(int mat[][C], int m, int n, int k)\n{\n\tif (m < 0 n < 0) return 0;\n\tif (m==0 && n==0) return (k == mat[m][n]);\n\treturn pathCountRec(mat, m-1, n, k-mat[m][n]) +\n\t\tpathCountRec(mat, m, n-1, k-mat[m][n]);\n}\nint pathCount(int mat[][C], int k)\n{\n\treturn pathCountRec(mat, R-1, C-1, k);\n}", "966": "int pathCountDPRecDP(int mat[][C], int m, int n, int k)\n{\n\tif (m < 0 n < 0) return 0;\n\tif (m==0 && n==0) return (k == mat[m][n]);\n\tif (dp[m][n][k] != -1) return dp[m][n][k];\n\tdp[m][n][k] = pathCountDPRecDP(mat, m-1, n, k-mat[m][n]) +\n\t\t\t\tpathCountDPRecDP(mat, m, n-1, k-mat[m][n]);\n\treturn dp[m][n][k];\n}\nint pathCountDP(int mat[][C], int k)\n{\n\tmemset(dp, -1, sizeof dp);\n\treturn pathCountDPRecDP(mat, R-1, C-1, k);\n}", "1045": "bool check(int A[], int N)\n{\n\tstack<int> S;\n\tint B_end = 0;\n\tfor (int i = 0; i < N; i++) \n\t{\n\t\tif (!S.empty()) \n\t\t{\n\t\t\tint top = S.top();\n\t\t\twhile (top == B_end + 1) \n\t\t\t{\n\t\t\t\tB_end = B_end + 1;\n\t\t\t\tS.pop();\n\t\t\t\tif (S.empty()) \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttop = S.top();\n\t\t\t}\n\t\t\tif (S.empty()) {\n\t\t\t\tS.push(A[i]);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\ttop = S.top();\n\t\t\t\tif (A[i] < top) \n\t\t\t\t{\n\t\t\t\t\tS.push(A[i]);\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tS.push(A[i]);\n\t\t}\n\t}\n\treturn true;\n}", "1064": "int countMinReversals(string expr)\n{\n\tint len = expr.length();\n\tif (len%2)\n\treturn -1;\n\tstack<char> s;\n\tfor (int i=0; i<len; i++)\n\t{\n\t\tif (expr[i]=='}' && !s.empty())\n\t\t{\n\t\t\tif (s.top()=='{')\n\t\t\t\ts.pop();\n\t\t\telse\n\t\t\t\ts.push(expr[i]);\n\t\t}\n\t\telse\n\t\t\ts.push(expr[i]);\n\t}\n\tint red_len = s.size();\n\tint n = 0;\n\twhile (!s.empty() && s.top() == '{')\n\t{\n\t\ts.pop();\n\t\tn++;\n\t}\n\treturn (red_len/2 + n%2);\n}", "1065": "int countMinReversals(string expr)\n{\n\tint len = expr.length();\n\tif (len % 2 != 0) {\n\t\treturn -1;\n\t}\n\tint left_brace = 0, right_brace = 0;\n\tint ans;\n\tfor (int i = 0; i < len; i++) {\n\t\tif (expr[i] == '{') {\n\t\t\tleft_brace++;\n\t\t}\n\t\telse {\n\t\t\tif (left_brace == 0) {\n\t\t\t\tright_brace++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft_brace--;\n\t\t\t}\n\t\t}\n\t}\n\tans = ceil(left_brace / 2) + ceil(right_brace / 2);\n\treturn ans;\n}", "1072": "void PrintMinNumberForPattern(string arr)\n{\n\tint curr_max = 0;\n\tint last_entry = 0;\n\tint j;\n\tfor (int i=0; i<arr.length(); i++)\n\t{\n\t\tint noOfNextD = 0;\n\t\tswitch(arr[i])\n\t\t{\n\t\tcase 'I':\n\t\t\tj = i+1;\n\t\t\twhile (arr[j] == 'D' && j < arr.length())\n\t\t\t{\n\t\t\t\tnoOfNextD++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (i==0)\n\t\t\t{\n\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\tcout << \" \" << ++last_entry;\n\t\t\t\tcout << \" \" << curr_max;\n\t\t\t\tlast_entry = curr_max;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurr_max = curr_max + noOfNextD + 1;\n\t\t\t\tlast_entry = curr_max;\n\t\t\t\tcout << \" \" << last_entry;\n\t\t\t}\n\t\t\tfor (int k=0; k<noOfNextD; k++)\n\t\t\t{\n\t\t\t\tcout << \" \" << --last_entry;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tj = i+1;\n\t\t\t\twhile (arr[j] == 'D' && j < arr.length())\n\t\t\t\t{\n\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\tcout << \" \" << curr_max << \" \" << curr_max - 1;\n\t\t\t\tlast_entry = curr_max - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \" \" << last_entry - 1;\n\t\t\t\tlast_entry--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << endl;\n}", "1073": "void printLeast(string arr)\n{\n\tint min_avail = 1, pos_of_I = 0;\n\tvector<int>v;\n\tif (arr[0]=='I')\n\t{\n\t\tv.push_back(1);\n\t\tv.push_back(2);\n\t\tmin_avail = 3;\n\t\tpos_of_I = 1;\n\t}\n\telse\n\t{\n\t\tv.push_back(2);\n\t\tv.push_back(1);\n\t\tmin_avail = 3;\n\t\tpos_of_I = 0;\n\t}\n\tfor (int i=1; i<arr.length(); i++)\n\t{\n\t\tif (arr[i]=='I')\n\t\t{\n\t\t\tv.push_back(min_avail);\n\t\t\tmin_avail++;\n\t\t\tpos_of_I = i+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.push_back(v[i]);\n\t\t\tfor (int j=pos_of_I; j<=i; j++)\n\t\t\t\tv[j]++;\n\t\t\tmin_avail++;\n\t\t}\n\t}\n\tfor (int i=0; i<v.size(); i++)\n\t\tcout << v[i] << \" \";\n\tcout << endl;\n}", "1074": "void PrintMinNumberForPattern(string seq)\n{\n\tstring result;\n\tstack<int> stk;\n\tfor (int i = 0; i <= seq.length(); i++)\n\t{\n\t\tstk.push(i + 1);\n\t\tif (i == seq.length() seq[i] == 'I')\n\t\t{\n\t\t\twhile (!stk.empty())\n\t\t\t{\n\t\t\t\tresult += to_string(stk.top());\n\t\t\t\tresult += \" \";\n\t\t\t\tstk.pop();\n\t\t\t}\n\t\t}\n\t}\n\tcout << result << endl;\n}", "1075": "string getMinNumberForPattern(string seq)\n{\n\tint n = seq.length();\n\tif (n >= 9)\n\t\treturn \"-1\";\n\tstring result(n+1, ' ');\n\tint count = 1; \n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tif (i == n seq[i] == 'I')\n\t\t{\n\t\t\tfor (int j = i - 1 ; j >= -1 ; j--)\n\t\t\t{\n\t\t\t\tresult[j + 1] = '0' + count++;\n\t\t\t\tif(j >= 0 && seq[j] == 'I')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "1132": "void rearrangeString(string str)\n{\n\tint n = str.length();\n\tint count[MAX_CHAR] = { 0 };\n\tfor (int i = 0; i < n; i++)\n\t\tcount[str[i] - 'a']++;\n\tpriority_queue<Key> pq;\n for (char c = 'a'; c <= 'z'; c++) {\n\t\tint val = c - 'a';\n\t\tif (count[val]) {\n\t\t\tpq.push(Key{ count[val], c });\n\t\t}\n\t}\n\tstr = \"\";\n\tKey prev{ -1, '#' };\n\twhile (!pq.empty()) {\n\t\tKey k = pq.top();\n\t\tpq.pop();\n\t\tstr = str + k.ch;\n\t\tif (prev.freq > 0)\n\t\t\tpq.push(prev);\n\t\t(k.freq)--;\n\t\tprev = k;\n\t}\n\tif (n != str.length())\n\t\tcout << \" Not valid String \" << endl;\nelse \n\t\tcout << str << endl;\n}\nbool operator<(const Key& k) const\n\t{\n\t\treturn freq < k.freq;\n\t}", "1252": "int subset(int ar[], int n)\n{\n\tint res = 0;\n\tsort(ar, ar + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint count = 1;\n\t\tfor (; i < n - 1; i++) {\n\t\t\tif (ar[i] == ar[i + 1])\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tres = max(res, count);\n\t}\n\treturn res;\n}", "1253": "int subset(int arr[], int n)\n{ \n\tunordered_map<int, int> mp; \n\tfor (int i = 0; i < n; i++)\n\t\tmp[arr[i]]++;\n\tint res = 0;\n\tfor (auto x : mp)\n\tres = max(res, x.second);\n\treturn res;\n}", "1345": "bool areElementsContiguous(int arr[], int n)\n{\n\tint max = *max_element(arr, arr + n);\n\tint min = *min_element(arr, arr + n);\n\tint m = max - min + 1;\n\tif (m > n)\n\t\treturn false;\n\tbool visited[m];\n\tmemset(visited, false, sizeof(visited));\n\tfor (int i=0; i<n; i++)\n\tvisited[arr[i] - min] = true;\n\tfor (int i=0; i<m; i++)\n\tif (visited[i] == false)\n\t\t\treturn false;\n\treturn true;\n}", "1346": "bool areElementsContiguous(int arr[], int n)\n{\n\tunordered_set<int> us;\n\tfor (int i = 0; i < n; i++)\n\t\tus.insert(arr[i]);\n\tint count = 1;\n\tint curr_ele = arr[0] - 1;\n\twhile (us.find(curr_ele) != us.end()) {\n\t\tcount++;\n\t\tcurr_ele--;\n\t}\n\tcurr_ele = arr[0] + 1;\n\twhile (us.find(curr_ele) != us.end()) {\n\t\tcount++;\n\t\tcurr_ele++;\n\t}\n\treturn (count == (int)(us.size()));\n}", "1366": "void longest(int a[], int n, int k)\n{\n\tunordered_map<int, int> freq;\n\tint start = 0, end = 0, now = 0, l = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfreq[a[i]]++;\n\t\tif (freq[a[i]] == 1)\n\t\t\tnow++;\n\t\twhile (now > k) {\n\t\t\tfreq[a[l]]--;\n\t\t\tif (freq[a[l]] == 0)\n\t\t\t\tnow--;\n\t\t\tl++;\n\t\t}\n\t\tif (i - l + 1 >= end - start + 1)\n\t\t\tend = i, start = l;\n\t}\n\tfor (int i = start; i <= end; i++)\n\t\tcout << a[i] << \" \";\n}", "1390": "void findSmallestRange(int arr[][N], int n, int k)\n{\n\tint i, minval, maxval, minrange, minel, maxel, flag, minind;\n\tfor (i = 0; i <= k; i++)\n\t\tptr[i] = 0;\n\tminrange = INT_MAX;\n\twhile (1) {\n\t\tminind = -1;\n\t\tminval = INT_MAX;\n\t\tmaxval = INT_MIN;\n\t\tflag = 0;\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tif (ptr[i] == n) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ptr[i] < n && arr[i][ptr[i]] < minval) {\nminind = i; \n\t\t\t\tminval = arr[i][ptr[i]];\n\t\t\t}\n\t\t\tif (ptr[i] < n && arr[i][ptr[i]] > maxval) {\n\t\t\t\tmaxval = arr[i][ptr[i]];\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t\tbreak;\n\t\tptr[minind]++;\n\t\tif ((maxval - minval) < minrange) {\n\t\t\tminel = minval;\n\t\t\tmaxel = maxval;\n\t\t\tminrange = maxel - minel;\n\t\t}\n\t}\n\tprintf(\"The smallest range is [%d, %d]\\n\", minel, maxel);\n}", "1405": "int findLargestd(int S[], int n)\n{\n\tbool found = false;\n\tsort(S, S + n);\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tif (i == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int l = k + 1; l < n; l++)\n\t\t\t\t{\n\t\t\t\t\tif (i == l)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l])\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\treturn S[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (found == false)\n\t\treturn INT_MIN;\n}", "1406": "int findFourElements(int arr[], int n)\n{\n\tunordered_map<int, pair<int, int> > mp;\n\tfor (int i = 0; i < n - 1; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tmp[arr[i] + arr[j]] = { i, j };\n\tint d = INT_MIN;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint abs_diff = abs(arr[i] - arr[j]);\n\t\t\tif (mp.find(abs_diff) != mp.end()) {\n\t\t\t\tpair<int, int> p = mp[abs_diff];\n\t\t\t\tif (p.first != i && p.first != j && p.second != i && p.second != j)\n\t\t\t\t\td = max(d, max(arr[i], arr[j]));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}", "1428": "void leftRotatebyOne(int arr[], int n)\n{\n\tint temp = arr[0], i;\n\tfor (i = 0; i < n - 1; i++)\n\t\tarr[i] = arr[i + 1];\n\tarr[n-1] = temp;\n}\nvoid leftRotate(int arr[], int d, int n)\n{\n\tfor (int i = 0; i < d; i++)\n\t\tleftRotatebyOne(arr, n);\n}\nvoid printArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tcout << arr[i] << \" \";\n}", "1468": "void pushZerosToEnd(int arr[], int n)\n{\nint count = 0; \n\tfor (int i = 0; i < n; i++)\n\t\tif (arr[i] != 0)\narr[count++] = arr[i]; \n\twhile (count < n)\n\t\tarr[count++] = 0;\n}", "1469": "void moveZerosToEnd(int arr[], int n)\n{\n\tint count = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr[i] != 0)\n\t\t\tswap(arr[count++], arr[i]);\n}\nvoid printArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tcout << arr[i] << \" \";\n}", "1473": "void pushZerosToEnd(int arr[], int n)\n{\n\tint count = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr[i] != 0)\n\t\t\tarr[count++] = arr[i];\n\twhile (count < n)\n\t\tarr[count++] = 0;\n}\nvoid modifyAndRearrangeArr(int arr[], int n)\n{\n\tif (n == 1)\n\t\treturn;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif ((arr[i] != 0) && (arr[i] == arr[i + 1])) {\n\t\t\tarr[i] = 2 * arr[i];\n\t\t\tarr[i + 1] = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\tpushZerosToEnd(arr, n);\n}\nvoid printArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tcout << arr[i] << \" \";\n}", "1474": "void swap(int& a, int& b) { a = b + a - (b = a); }\nvoid shiftAllZeroToLeft(int array[], int n)\n{\n\tint lastSeenNonZero = 0;\n\tfor (index = 0; index < n; index++)\n\t{\n\t\tif (array[index] != 0)\n\t\t{\n\t\t\tswap(array[index], array[lastSeenNonZero]);\n\t\t\tlastSeenNonZero++;\n\t\t}\n\t}\n}", "1478": "void printArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%d \", arr[i]);\n\tprintf(\"\\n\");\n}\nvoid RearrangePosNeg(int arr[], int n)\n{\n\tint key, j;\n\tfor (int i = 1; i < n; i++) {\n\t\tkey = arr[i];\n\t\tif (key > 0)\n\t\t\tcontinue;\n\t\tj = i - 1;\n\t\twhile (j >= 0 && arr[j] > 0) {\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\tarr[j + 1] = key;\n\t}\n}", "1480": "void printArray(int A[], int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t\tcout << A[i] << \" \";\n\tcout << endl;\n}\nvoid reverse(int arr[], int l, int r)\n{\n\tif (l < r) {\n\t\tswap(arr[l], arr[r]);\n\t\treverse(arr, ++l, --r);\n\t}\n}\nvoid merge(int arr[], int l, int m, int r)\n{\nint i = l; \nint j = m + 1; \n\twhile (i <= m && arr[i] < 0)\n\t\ti++;\n\twhile (j <= r && arr[j] < 0)\n\t\tj++;\n\treverse(arr, i, m);\n\treverse(arr, m + 1, j - 1);\n\treverse(arr, i, j - 1);\n}\nvoid RearrangePosNeg(int arr[], int l, int r)\n{\n\tif (l < r) {\n\t\tint m = l + (r - l) / 2;\n\t\tRearrangePosNeg(arr, l, m);\n\t\tRearrangePosNeg(arr, m + 1, r);\n\t\tmerge(arr, l, m, r);\n\t}\n}", "1481": "void RearrangePosNeg(int arr[], int n)\n{\n\tint i = 0;\n\tint j = n - 1;\n\twhile (true) {\n\t\twhile (arr[i] < 0 && i < n)\n\t\t\ti++;\n\t\twhile (arr[j] > 0 && j >= 0)\n\t\t\tj--;\n\t\tif (i < j) {\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n}", "1515": "void findElements(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint count = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (arr[j] > arr[i])\n\t\t\t\tcount++;\n\t\tif (count >= 2)\n\t\t\tcout << arr[i] << \" \";\n\t}\n}", "1516": "void findElements(int arr[], int n)\n{\n\tsort(arr, arr + n);\n\tfor (int i = 0; i < n - 2; i++)\n\tcout << arr[i] << \" \";\n}", "1517": "void findElements(int arr[], int n)\n{\n\tint first = INT_MIN,\n\t\tsecond = INT_MIN;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > first)\n\t\t{\n\t\t\tsecond = first;\n\t\t\tfirst = arr[i];\n\t\t}\n\t\telse if (arr[i] > second)\n\t\t\tsecond = arr[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr[i] < second)\n\t\t\tcout << arr[i] << \" \";\n}", "1535": "int findFirstMissing(int array[], int start, int end)\n{\n\tif (start > end)\n\t\treturn end + 1;\n\tif (start != array[start])\n\t\treturn start;\n\tint mid = (start + end) / 2;\n\tif (array[mid] == mid)\n\t\treturn findFirstMissing(array, mid+1, end);\n\treturn findFirstMissing(array, start, mid);\n}", "1536": "int findSmallestMissinginSortedArray(vector<int> arr)\n{\n if(arr[0] != 0)\n\treturn 0;\n if(arr[arr.size() - 1] == arr.size() - 1)\n\treturn arr.size();\n int first = arr[0];\n return findFirstMissing(arr, 0, arr.size() - 1, first);\n}\nint findFirstMissing(vector<int> arr , int start , int end,int first)\n{\n if (start < end)\n {\n\tint mid = (start + end) / 2;\n\tif (arr[mid] != mid+first)\n\treturn findFirstMissing(arr, start, mid , first);\n\telse\n\treturn findFirstMissing(arr, mid + 1, end , first);\n }\n return start + first;\n}", "1537": "int FindMaxSum(vector<int> arr, int n)\n{\n\tint incl = arr[0];\n\tint excl = 0;\n\tint excl_new;\n\tint i;\n\tfor (i = 1; i < n; i++)\n\t{\n\t\texcl_new = (incl > excl) ? incl : excl;\n\t\tincl = excl + arr[i];\n\t\texcl = excl_new;\n\t}\n\treturn ((incl > excl) ? incl : excl);\n}", "1545": "void buildSparseTable(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tlookup[i][0] = arr[i];\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; (i + (1 << j) - 1) < n; i++) {\n\t\t\tif (lookup[i][j - 1] <\n\t\t\t\t\t\tlookup[i + (1 << (j - 1))][j - 1])\n\t\t\t\tlookup[i][j] = lookup[i][j - 1];\n\t\t\telse\n\t\t\t\tlookup[i][j] =\n\t\t\t\t\t\tlookup[i + (1 << (j - 1))][j - 1];\n\t\t}\n\t}\n}\nint query(int L, int R)\n{\n\tint j = (int)log2(R - L + 1);\n\tif (lookup[L][j] <= lookup[R - (1 << j) + 1][j])\n\t\treturn lookup[L][j];\n\telse\n\t\treturn lookup[R - (1 << j) + 1][j];\n}", "1546": "void buildSparseTable(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\ttable[i][0] = arr[i];\n\tfor (int j = 1; j <= n; j++)\n\t\tfor (int i = 0; i <= n - (1 << j); i++)\n\t\t\ttable[i][j] = __gcd(table[i][j - 1],\n\t\t\t\t\ttable[i + (1 << (j - 1))][j - 1]);\n}\nint query(int L, int R)\n{\n\tint j = (int)log2(R - L + 1);\n\treturn __gcd(table[L][j], table[R - (1 << j) + 1][j]);\n}", "1590": "int findMaxAverage(int arr[], int n, int k)\n{\n\tif (k > n)\n\t\treturn -1;\n\tint *csum = new int[n];\n\tcsum[0] = arr[0];\n\tfor (int i=1; i<n; i++)\n\tcsum[i] = csum[i-1] + arr[i];\n\tint max_sum = csum[k-1], max_end = k-1;\n\tfor (int i=k; i<n; i++)\n\t{\n\t\tint curr_sum = csum[i] - csum[i-k];\n\t\tif (curr_sum > max_sum)\n\t\t{\n\t\t\tmax_sum = curr_sum;\n\t\t\tmax_end = i;\n\t\t}\n\t}\ndelete [] csum; \n\treturn max_end - k + 1;\n}", "1591": "int findMaxAverage(int arr[], int n, int k)\n{\n\tif (k > n)\n\t\treturn -1;\n\tint sum = arr[0];\n\tfor (int i=1; i<k; i++)\n\t\tsum += arr[i];\n\tint max_sum = sum, max_end = k-1;\n\tfor (int i=k; i<n; i++)\n\t{\n\t\tint sum = sum + arr[i] - arr[i-k];\n\t\tif (sum > max_sum)\n\t\t{\n\t\t\tmax_sum = sum;\n\t\t\tmax_end = i;\n\t\t}\n\t}\n\treturn max_end - k + 1;\n}", "1694": "bool isMajority(int arr[], int n, int x)\n{\n\tint i;\n\tint last_index = n % 2 ? (n / 2 + 1): (n / 2);\n\tfor (i = 0; i < last_index; i++)\n\t{\n\t\tif (arr[i] == x && arr[i + n / 2] == x)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "1695": "int _binarySearch(int arr[], int low, int high, int x)\n{\n\tif (high >= low)\n\t{\n\t\tint mid = (low + high)/2; \n\t\tif ((mid == 0 x > arr[mid - 1]) &&\n\t\t\t(arr[mid] == x) )\n\t\t\treturn mid;\n\t\telse if (x > arr[mid])\n\t\t\treturn _binarySearch(arr, (mid + 1), high, x);\n\t\telse\n\t\t\treturn _binarySearch(arr, low, \n\t\t\t\t\t\t\t\t(mid - 1), x);\n\t}\n\treturn -1;\n}\nbool isMajority(int arr[], int n, int x)\n{\n\tint i = _binarySearch(arr, 0, n - 1, x);\n\tif (i == -1)\n\t\treturn false;\n\tif (((i + n / 2) <= (n - 1)) && arr[i + n / 2] == x)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "1696": "bool isMajorityElement(int arr[], int n, int key)\n{\n\tif (arr[n / 2] == key)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "1730": "void sortMat(int mat[SIZE][SIZE], int n)\n{\n\tint temp[n * n];\n\tint k = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttemp[k++] = mat[i][j];\n\tsort(temp, temp + k);\n\tk = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tmat[i][j] = temp[k++];\n}\nvoid printMat(int mat[SIZE][SIZE], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcout << mat[i][j] << \" \";\n\t\tcout << endl;\n\t}\n}", "1795": "void swap(int *xp, int *yp) \n{ \n\tint temp = *xp; \n\t*xp = *yp; \n\t*yp = temp; \n}\nvoid selectionSort(int arr[], int n) \n{ \n\tint i, j, min_idx; \n\tfor (i = 0; i < n-1; i++) \n\t{ \n\t\tmin_idx = i; \n\t\tfor (j = i+1; j < n; j++) \n\t\tif (arr[j] < arr[min_idx]) \n\t\t\tmin_idx = j; \n\t\tswap(&arr[min_idx], &arr[i]); \n\t} \n}\nvoid printArray(int arr[], int size) \n{ \n\tint i; \n\tfor (i=0; i < size; i++) \n\t\tcout << arr[i] << \" \"; \n\tcout << endl; \n}", "1797": "void swap(int *xp, int *yp)\n{\n\tint temp = *xp;\n\t*xp = *yp;\n\t*yp = temp;\n}\nvoid bubbleSort(int arr[], int n)\n{\n int i, j;\n bool swapped;\n for (i = 0; i < n-1; i++)\n {\n\tswapped = false;\n\tfor (j = 0; j < n-i-1; j++)\n\t{\n\t\tif (arr[j] > arr[j+1])\n\t\t{\n\t\tswap(&arr[j], &arr[j+1]);\n\t\tswapped = true;\n\t\t}\n\t}\n\tif (swapped == false)\n\t\tbreak;\n }\n}\nvoid printArray(int arr[], int size)\n{\n\tint i;\n\tfor (i=0; i < size; i++)\n\t\tprintf(\"%d \", arr[i]);\n\tprintf(\"n\");\n}", "1813": "int findCrossOver(int arr[], int low, int high, int x)\n{\nif (arr[high] <= x) \n\treturn high;\nif (arr[low] > x) \n\treturn low;\nint mid = (low + high)/2; \nif (arr[mid] <= x && arr[mid+1] > x)\n\treturn mid;\nif(arr[mid] < x)\n\treturn findCrossOver(arr, mid+1, high, x);\nreturn findCrossOver(arr, low, mid - 1, x);\n}\nvoid printKclosest(int arr[], int x, int k, int n)\n{\n\tint l = findCrossOver(arr, 0, n-1, x);\nint r = l+1; \nint count = 0; \n\tif (arr[l] == x) l--;\n\twhile (l >= 0 && r < n && count < k)\n\t{\n\t\tif (x - arr[l] < arr[r] - x)\n\t\t\tprintf(\"%d \", arr[l--]);\n\t\telse\n\t\t\tprintf(\"%d \", arr[r++]);\n\t\tcount++;\n\t}\n\twhile (count < k && l >= 0)\n\t\tprintf(\"%d \", arr[l--]), count++;\n\twhile (count < k && r < n)\n\t\tprintf(\"%d \", arr[r++]), count++;\n}", "1847": "int count( int S[], int m, int n )\n{\n\tif (n == 0)\n\t\treturn 1;\n\tif (n < 0)\n\t\treturn 0;\n\tif (m <=0 && n >= 1)\n\t\treturn 0;\n\treturn count( S, m - 1, n ) + count( S, m, n-S[m-1] );\n}", "1849": "int count( int S[], int m, int n )\t\t\n{\t\t\n int table[n+1];\t\t\n memset(table, 0, sizeof(table));\t\t\n table[0] = 1;\t\t\n for(int i=0; i<m; i++)\t\t\n for(int j=S[i]; j<=n; j++)\t\t\n table[j] += table[j-S[i]];\t\t\n return table[n];\t\t\n}", "1852": "int matrixChainMemoised(int* p, int i, int j)\n{\n\tif (i == j)\n\t{\n\t\treturn 0;\n\t}\n\tif (dp[i][j] != -1)\n\t{\n\t\treturn dp[i][j];\n\t}\n\tdp[i][j] = INT_MAX;\n\tfor (int k = i; k < j; k++)\n\t{\n\t\tdp[i][j] = min(\n\t\t\tdp[i][j], matrixChainMemoised(p, i, k)\n\t\t\t\t\t+ matrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n\t}\n\treturn dp[i][j];\n}\nint MatrixChainOrder(int* p, int n)\n{\n\tint i = 1, j = n - 1;\n\treturn matrixChainMemoised(p, i, j);\n}", "1853": "int MatrixChainOrder(int p[], int n)\n{\n\tint m[n][n];\n\tint i, j, k, L, q;\n\tfor (i = 1; i < n; i++)\n\t\tm[i][i] = 0;\n\tfor (L = 2; L < n; L++)\n\t{\n\t\tfor (i = 1; i < n - L + 1; i++)\n\t\t{\n\t\t\tj = i + L - 1;\n\t\t\tm[i][j] = INT_MAX;\n\t\t\tfor (k = i; k <= j - 1; k++)\n\t\t\t{\n\t\t\t\tq = m[i][k] + m[k + 1][j]\n\t\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\t\t\tif (q < m[i][j])\n\t\t\t\t\tm[i][j] = q;\n\t\t\t}\n\t\t}\n\t}\n\treturn m[1][n - 1];\n}", "1869": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n if (n <= 0)\n\treturn 0;\n int max_val = INT_MIN;\n for (int i = 0; i<n; i++)\n\t\tmax_val = max(max_val, price[i] + cutRod(price, n-i-1));\n return max_val;\n}", "1870": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n int val[n+1];\n val[0] = 0;\n int i, j;\n for (i = 1; i<=n; i++)\n {\n\tint max_val = INT_MIN;\n\tfor (j = 0; j < i; j++)\n\t\tmax_val = max(max_val, price[j] + val[i-j-1]);\n\tval[i] = max_val;\n }\n return val[n];\n}", "1871": "int un_kp(int price[], int length[], int Max_len, int n)\n{\n\tif (n == 0 Max_len == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (length[n - 1] <= Max_len)\n\t{\n\t\tt[n][Max_len]\n\t\t\t= max(price[n - 1]\n\t\t\t\t\t+ un_kp(price, length, Max_len - length[n - 1], n),\n\t\t\t\tun_kp(price, length, Max_len, n - 1));\n\t}\n\telse\n\t{\n\t\tt[n][Max_len]\n\t\t\t= un_kp(price, length, Max_len, n - 1);\n\t}\n\treturn t[n][Max_len];\n}", "1998": "int multiply(int x, int y)\n{\n\tif(y == 0)\n\treturn 0;\n\tif(y > 0 )\n\treturn (x + multiply(x, y-1));\n\tif(y < 0 )\n\treturn -multiply(x, -y);\n}", "2013": "void SieveOfEratosthenes(int n)\n{\n\tbool prime[n + 1];\n\tmemset(prime, true, sizeof(prime));\n\tfor (int p = 2; p * p <= n; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tcout << p << \" \";\n}", "2024": "int binomialCoeff(int n, int k)\n{\n\tint res = 1;\n\tif (k > n - k)\n\tk = n - k;\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}\nvoid printPascal(int n)\n{\n\tfor (int line = 0; line < n; line++)\n\t{\n\t\tfor (int i = 0; i <= line; i++)\n\t\t\tprintf(\"%d \",\n\t\t\t\t\tbinomialCoeff(line, i));\n\t\tprintf(\"\\n\");\n\t}\n}", "2025": "void printPascal(int n)\n{\n\tint arr[n][n];\n\tfor (int line = 0; line < n; line++)\n\t{\n\t\tfor (int i = 0; i <= line; i++)\n\t\t{\n\t\tif (line == i i == 0)\n\t\t\tarr[line][i] = 1;\n\t\telse\n\t\t\tarr[line][i] = arr[line - 1][i - 1] +\n\t\t\t\t\t\t\tarr[line - 1][i];\n\t\tcout << arr[line][i] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n}", "2026": "void printPascal(int n)\n{\nfor (int line = 1; line <= n; line++)\n{\nint C = 1; \n\tfor (int i = 1; i <= line; i++)\n\t{\n\t\tcout<< C<<\" \";\n\t\tC = C * (line - i) / i;\n\t}\n\tcout<<\"\\n\";\n}\n}", "2079": "int Add(int x, int y)\n{\n\twhile (y != 0)\n\t{\n\t\tint carry = x & y;\n\t\tx = x ^ y;\n\t\ty = carry << 1;\n\t}\n\treturn x;\n}", "2101": "unsigned int getModulo(unsigned int n, unsigned int d)\n{\nreturn ( n & (d - 1) );\n}", "2114": "unsigned int countSetBits(unsigned int n)\n{\n\tunsigned int count = 0;\n\twhile (n) {\n\t\tcount += n & 1;\n\t\tn >>= 1;\n\t}\n\treturn count;\n}", "2117": "int countSetBits(int n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\telse\n\t\treturn 1 + countSetBits(n & (n - 1));\n}", "2118": "void initialize()\n{\n\tBitsSetTable256[0] = 0;\n\tfor (int i = 0; i < 256; i++)\n\t{\n\t\tBitsSetTable256[i] = (i & 1) +\n\t\tBitsSetTable256[i / 2];\n\t}\n}\nint countSetBits(int n)\n{\n\treturn (BitsSetTable256[n & 0xff] +\n\t\t\tBitsSetTable256[(n >> 8) & 0xff] +\n\t\t\tBitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24]);\n}", "2119": "", "2120": "unsigned int countSetBitsRec(unsigned int num)\n{\n\tint nibble = 0;\n\tif (0 == num)\n\t\treturn num_to_bits[0];\n\tnibble = num & 0xf;\n\treturn num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}", "2121": "int countSetBits(int N)\n{\n\tint count = 0;\n\tfor (int i = 0; i < sizeof(int) * 8; i++) {\n\t\tif (N & (1 << i))\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "2127": "bool getParity(unsigned int n)\n{\n\tbool parity = 0;\n\twhile (n)\n\t{\n\t\tparity = !parity;\n\t\tn\t= n & (n - 1);\n\t}\t\n\treturn parity;\n}", "2129": "bool isPowerOfTwo(int n)\n{\n if(n==0)\n return false;\n return (ceil(log2(n)) == floor(log2(n)));\n}", "2130": "bool isPowerOfTwo(int n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\twhile (n != 1)\n\t{\n\t\tif (n%2 != 0)\n\t\t\treturn 0;\n\t\tn = n/2;\n\t}\n\treturn 1;\n}", "2131": "bool powerOf2(int n)\n{\n\tif (n == 1)\n\treturn true;\n\telse if (n % 2 != 0 n ==0)\n\treturn false;\n\treturn powerOf2(n / 2);\n}", "2132": "bool isPowerOfTwo (int x)\n{\n\treturn x && (!(x&(x-1)));\n}", "2210": "int maxRepeating(int* arr, int n, int k)\n{\n\tfor (int i = 0; i< n; i++)\n\t\tarr[arr[i]%k] += k;\n\tint max = arr[0], result = 0;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (arr[i] > max)\n\t\t{\n\t\t\tmax = arr[i];\n\t\t\tresult = i;\n\t\t}\n\t}\n\treturn result;\n}", "2226": "int fun(int x)\n{\n\tint y = (x / 4) * 4;\n\tint ans = 0;\n\tfor (int i = y; i <= x; i++)\n\t\tans ^= i;\n\treturn ans;\n}\nint query(int x)\n{\n\tif (x == 0)\n\t\treturn 0;\n\tint k = (x + 1) / 2;\n\treturn (x %= 2) ? 2 * fun(k) : ((fun(k - 1) * 2) ^ (k & 1));\n}\nvoid allQueries(int q, int l[], int r[])\n{\n\tfor (int i = 0; i < q; i++)\n\t\tcout << (query(r[i]) ^ query(l[i] - 1)) << endl;\n}", "2243": "void prefixXOR(int arr[], int preXOR[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (arr[i] % 2 != 1)\n\t\t\tarr[i] /= 2;\n\t\tpreXOR[i] = arr[i];\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tpreXOR[i] = preXOR[i - 1] ^ preXOR[i];\n}\nint query(int preXOR[], int l, int r)\n{\n\tif (l == 0)\n\t\treturn preXOR[r];\n\telse\n\t\treturn preXOR[r] ^ preXOR[l - 1];\n}", "2258": "int findMinSwaps(int arr[], int n)\n{\n\tint noOfZeroes[n];\n\tmemset(noOfZeroes, 0, sizeof(noOfZeroes));\n\tint i, count = 0;\n\tnoOfZeroes[n - 1] = 1 - arr[n - 1];\n\tfor (i = n - 2; i >= 0; i--) {\n\t\tnoOfZeroes[i] = noOfZeroes[i + 1];\n\t\tif (arr[i] == 0)\n\t\t\tnoOfZeroes[i]++;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tif (arr[i] == 1)\n\t\t\tcount += noOfZeroes[i];\n\t}\n\treturn count;\n}", "2259": "int minswaps(int arr[], int n)\n{\n\tint count = 0;\n\tint num_unplaced_zeros = 0;\n\tfor(int index=n-1;index>=0;index--)\n\t{\n\t\tif(arr[index] == 0)\n\t\t\tnum_unplaced_zeros += 1;\n\t\telse\n\t\t\tcount += num_unplaced_zeros;\n\t}\n\treturn count;\n}", "2281": "bool arraySortedOrNot(int arr[], int n)\n{\n\tif (n == 0 n == 1)\n\t\treturn true;\n\tfor (int i = 1; i < n; i++)\n\t\tif (arr[i - 1] > arr[i])\n\t\t\treturn false;\n\treturn true;\n}", "2308": "void printTwoOdd(int arr[], int size)\n{\n\tint xor2 = arr[0]; \n\tint set_bit_no; \n\tint i;\n\tint n = size - 2;\n\tint x = 0, y = 0;\n\tfor(i = 1; i < size; i++)\n\t\txor2 = xor2 ^ arr[i];\n\tset_bit_no = xor2 & ~(xor2-1);\n\tfor(i = 0; i < size; i++)\n\t{\n\t\tif(arr[i] & set_bit_no)\n\t\tx = x ^ arr[i];\n\t\telse\n\t\ty = y ^ arr[i];\n\t}\n\tcout << \"The two ODD elements are \" << x << \" & \" << y;\n}", "2309": "void printTwoOdd(int arr[], int size)\n{\n\tmap<int, int> m;\n\tfor (int i = 0; i < size; i++) {\n\t\tm[arr[i]]++;\n\t}\n\tcout << \"The two ODD elements are \";\n\tfor (auto& x : m) {\n\t\tif (x.second % 2 != 0)\n\t\t\tcout << x.first << \", \";\n\t}\n}", "2310": "bool findPair(int arr[], int size, int n)\n{\n\tint i = 0;\n\tint j = 1;\n\twhile (i < size && j < size)\n\t{\n\t\tif (i != j && arr[j] - arr[i] == n)\n\t\t{\n\t\t\tcout << \"Pair Found: (\" << arr[i] << \", \" << arr[j] << \")\";\n\t\t\treturn true;\n\t\t}\n\t\telse if (arr[j]-arr[i] < n)\n\t\t\tj++;\n\t\telse\n\t\t\ti++;\n\t}\n\tcout << \"No such pair\";\n\treturn false;\n}", "2360": "void printMax(int arr[], int k, int n)\n{\n\tvector<int> brr(arr, arr + n);\n\tsort(brr.begin(), brr.end(), greater<int>());\n\tfor (int i = 0; i < n; ++i)\n\t\tif (binary_search(brr.begin(),\n\t\t\t\tbrr.begin() + k, arr[i],\n\t\t\t\t\t\tgreater<int>()))\n\t\t\tcout << arr[i] << \" \";\n}", "2372": "void printSmall(int arr[], int asize, int n)\n{\n\tvector<int> copy_arr(arr, arr + asize);\n\tsort(copy_arr.begin(), copy_arr.begin() + asize);\n\tfor (int i = 0; i < asize; ++i)\n\t\tif (binary_search(copy_arr.begin(),\n\t\t\t\tcopy_arr.begin() + n, arr[i]))\n\t\t\tcout << arr[i] << \" \";\n}", "2379": "bool checkIsAP(int arr[], int n)\n{\n if (n == 1)\n\treturn true;\n sort(arr, arr + n);\n int d = arr[1] - arr[0];\n for (int i=2; i<n; i++)\n\tif (arr[i] - arr[i-1] != d)\n\treturn false;\n return true;\n}", "2380": "bool checkIsAP(int arr[], int n)\n{\n\tunordered_map<int, int> hm;\n\tint smallest = INT_MAX, second_smallest = INT_MAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] < smallest) {\n\t\t\tsecond_smallest = smallest;\n\t\t\tsmallest = arr[i];\n\t\t}\n\t\telse if (arr[i] != smallest && arr[i] < second_smallest)\n\t\t\tsecond_smallest = arr[i];\n\t\tif (hm.find(arr[i]) == hm.end())\n\t\t\thm[arr[i]]++;\n\t\telse\n\t\t\treturn false;\n\t}\n\tint diff = second_smallest - smallest;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (hm.find(second_smallest) == hm.end())\n\t\t\treturn false;\n\t\tsecond_smallest += diff;\n\t}\n\treturn true;\n}", "2382": "int countPairs(int a[], int n)\n{\n\tint mn = INT_MAX;\n\tint mx = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tmn = min(mn, a[i]);\n\t\tmx = max(mx, a[i]);\n\t}\n\tint c1 = 0;\nint c2 = 0; \n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == mn)\n\t\t\tc1++;\n\t\tif (a[i] == mx)\n\t\t\tc2++;\n\t}\n\tif (mn == mx)\n\t\treturn n * (n - 1) / 2;\n\telse\n\t\treturn c1 * c2;\n}", "2437": "void rearrange(Node* head)\n{\nif (head == NULL) \n\t\treturn;\n\tNode *prev = head, *curr = head->next;\n\twhile (curr) {\n\t\tif (prev->data > curr->data)\n\t\t\tswap(prev->data, curr->data);\n\t\tif (curr->next && curr->next->data > curr->data)\n\t\t\tswap(curr->next->data, curr->data);\n\t\tprev = curr->next;\n\t\tif (!curr->next)\n\t\t\tbreak;\n\t\tcurr = curr->next->next;\n\t}\n}\nvoid push(Node** head, int k)\n{\n\tNode* tem = (Node*)malloc(sizeof(Node));\n\ttem->data = k;\n\ttem->next = *head;\n\t*head = tem;\n}\nvoid display(Node* head)\n{\n\tNode* curr = head;\n\twhile (curr != NULL) {\n\t\tprintf(\"%d \", curr->data);\n\t\tcurr = curr->next;\n\t}\n}", "2464": "Node* newNode(int data)\n{\n\tNode* temp = new Node;\n\ttemp->data = data;\n\ttemp->next = NULL;\n\treturn temp;\n}\nint getLength(Node* Node)\n{\n\tint size = 0;\n\twhile (Node != NULL) {\n\t\tNode = Node->next;\n\t\tsize++;\n\t}\n\treturn size;\n}\nNode* paddZeros(Node* sNode, int diff)\n{\n\tif (sNode == NULL)\n\t\treturn NULL;\n\tNode* zHead = newNode(0);\n\tdiff--;\n\tNode* temp = zHead;\n\twhile (diff--) {\n\t\ttemp->next = newNode(0);\n\t\ttemp = temp->next;\n\t}\n\ttemp->next = sNode;\n\treturn zHead;\n}\nNode* subtractLinkedListHelper(Node* l1, Node* l2, bool& borrow)\n{\n\tif (l1 == NULL && l2 == NULL && borrow == 0)\n\t\treturn NULL;\n\tNode* previous\n\t\t= subtractLinkedListHelper( l1 ? l1->next : NULL, l2 ? l2->next : NULL, borrow);\n\tint d1 = l1->data;\n\tint d2 = l2->data;\n\tint sub = 0;\n\tif (borrow) {\n\t\td1--;\n\t\tborrow = false;\n\t}\n\tif (d1 < d2) {\n\t\tborrow = true;\n\t\td1 = d1 + 10;\n\t}\n\tsub = d1 - d2;\n\tNode* current = newNode(sub);\n\tcurrent->next = previous;\n\treturn current;\n}\nNode* subtractLinkedList(Node* l1, Node* l2)\n{\n\tif (l1 == NULL && l2 == NULL)\n\t\treturn NULL;\n\tint len1 = getLength(l1);\n\tint len2 = getLength(l2);\n\tNode *lNode = NULL, *sNode = NULL;\n\tNode* temp1 = l1;\n\tNode* temp2 = l2;\n\tif (len1 != len2) {\n\t\tlNode = len1 > len2 ? l1 : l2;\n\t\tsNode = len1 > len2 ? l2 : l1;\n\t\tsNode = paddZeros(sNode, abs(len1 - len2));\n\t}\n\telse {\n\t\twhile (l1 && l2) {\n\t\t\tif (l1->data != l2->data) {\n\t\t\t\tlNode = l1->data > l2->data ? temp1 : temp2;\n\t\t\t\tsNode = l1->data > l2->data ? temp2 : temp1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl1 = l1->next;\n\t\t\tl2 = l2->next;\n\t\t}\n\t}\n\tbool borrow = false;\n\treturn subtractLinkedListHelper(lNode, sNode, borrow);\n}\nvoid printList(struct Node* Node)\n{\n\twhile (Node != NULL) {\n\t\tprintf(\"%d \", Node->data);\n\t\tNode = Node->next;\n\t}\n\tprintf(\"\\n\");\n}", "2501": "Node* getNode(int data)\n{\n\tNode* newNode = (Node*)malloc(sizeof(Node));\n\tnewNode->data = data;\n\tnewNode->next = NULL;\n\treturn newNode;\n}\nvoid insertAtMid(Node** head_ref, int x)\n{\n\tif (*head_ref == NULL)\n\t\t*head_ref = getNode(x);\n\telse {\n\t\tNode* newNode = getNode(x);\n\t\tNode* ptr = *head_ref;\n\t\tint len = 0;\n\t\twhile (ptr != NULL) {\n\t\t\tlen++;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\tint count = ((len % 2) == 0) ? (len / 2) :\n\t\t\t\t\t\t\t\t\t(len + 1) / 2;\n\t\tptr = *head_ref;\n\t\twhile (count-- > 1)\n\t\t\tptr = ptr->next;\n\t\tnewNode->next = ptr->next;\n\t\tptr->next = newNode;\n\t}\n}\nvoid display(Node* head)\n{\n\twhile (head != NULL) {\n\t\tcout << head->data << \" \";\n\t\thead = head->next;\n\t}\n}", "2502": "Node* getNode(int data)\n{\n\tNode* newNode = (Node*)malloc(sizeof(Node));\n\tnewNode->data = data;\n\tnewNode->next = NULL;\n\treturn newNode;\n}\nvoid insertAtMid(Node** head_ref, int x)\n{\n\tif (*head_ref == NULL)\n\t\t*head_ref = getNode(x);\n\telse {\n\t\tNode* newNode = getNode(x);\n\t\tNode* slow = *head_ref;\n\t\tNode* fast = (*head_ref)->next;\n\t\twhile (fast && fast->next) {\n\t\t\tslow = slow->next;\n\t\t\tfast = fast->next->next;\n\t\t}\n\t\tnewNode->next = slow->next;\n\t\tslow->next = newNode;\n\t}\n}\nvoid display(Node* head)\n{\n\twhile (head != NULL) {\n\t\tcout << head->data << \" \";\n\t\thead = head->next;\n\t}\n}", "2518": "struct Node* getNode(int data)\n{\n\tstruct Node* newNode =\n\t\t(struct Node*)malloc(sizeof(struct Node));\n\tnewNode->data = data;\n\tnewNode->prev = newNode->next = NULL;\n\treturn newNode;\n}\nvoid sortedInsert(struct Node** head_ref, struct Node* newNode)\n{\n\tstruct Node* current;\n\tif (*head_ref == NULL)\n\t\t*head_ref = newNode;\n\telse if ((*head_ref)->data >= newNode->data) {\n\t\tnewNode->next = *head_ref;\n\t\tnewNode->next->prev = newNode;\n\t\t*head_ref = newNode;\n\t}\n\telse {\n\t\tcurrent = *head_ref;\n\t\twhile (current->next != NULL && current->next->data < newNode->data)\n\t\t\tcurrent = current->next;\n\t\tnewNode->next = current->next;\n\t\tif (current->next != NULL)\n\t\t\tnewNode->next->prev = newNode;\n\t\tcurrent->next = newNode;\n\t\tnewNode->prev = current;\n\t}\n}\nvoid insertionSort(struct Node** head_ref)\n{\n\tstruct Node* sorted = NULL;\n\tstruct Node* current = *head_ref;\n\twhile (current != NULL) {\n\t\tstruct Node* next = current->next;\n\t\tcurrent->prev = current->next = NULL;\n\t\tsortedInsert(&sorted, current);\n\t\tcurrent = next;\n\t}\n\t*head_ref = sorted;\n}\nvoid printList(struct Node* head)\n{\n\twhile (head != NULL) {\n\t\tcout << head->data << \" \";\n\t\thead = head->next;\n\t}\n}\nvoid push(struct Node** head_ref, int new_data)\n{\n\tstruct Node* new_node =\n\t\t(struct Node*)malloc(sizeof(struct Node));\n\tnew_node->data = new_data;\n\tnew_node->next = (*head_ref);\n\tnew_node->prev = NULL;\n\tif ((*head_ref) != NULL)\n\t\t(*head_ref)->prev = new_node;\n\t(*head_ref) = new_node;\n}", "2575": "void reverse(int arr[], int s, int e)\n{\n while(s < e)\n {\n\tint tem = arr[s];\n\tarr[s] = arr[e];\n\tarr[e] = tem;\n\ts = s + 1;\n\te = e - 1;\n }\n}\nvoid fun(int arr[], int k)\n{\n int n = 4 - 1;\n int v = n - k;\n if (v >= 0)\n {\n\treverse(arr, 0, v);\n\treverse(arr, v + 1, n);\n\treverse(arr, 0, n);\n }\n}", "2578": "void build(int node, int l, int r, int a[])\n{\n\tif (l == r)\n\t\tseg[node] = a[l];\n\telse {\n\t\tint mid = (l + r) / 2;\n\t\tbuild(2 * node, l, mid, a);\n\t\tbuild(2 * node + 1, mid + 1, r, a);\n\t\tseg[node] = (seg[2 * node] seg[2 * node + 1]);\n\t}\n}\nint query(int node, int l, int r, int start, int end, int a[])\n{\n\tif (l > end or r < start)\n\t\treturn 0;\n\tif (start <= l and r <= end)\n\t\treturn seg[node];\n\tint mid = (l + r) / 2;\n\treturn ((query(2 * node, l, mid, start, end, a))\n\t\t\t| (query(2 * node + 1, mid + 1, r, start, end, a)));\n}\nvoid orsum(int a[], int n, int q, int k[])\n{\n\tbuild(1, 0, n - 1, a);\n\tfor (int j = 0; j < q; j++) {\n\t\tint i = k[j] % (n / 2);\n\t\tint sec = query(1, 0, n - 1, n / 2 - i, n - i - 1, a);\n\t\tint first = (query(1, 0, n - 1, 0, n / 2 - 1 - i, a)\n\t\t\t\t\t| query(1, 0, n - 1, n - i, n - 1, a));\n\t\tint temp = sec + first;\n\t\tcout << temp << endl;\n\t}\n}", "2579": "void maximumEqual(int a[], int b[], int n)\n{\n\tvector<int> store(1e5);\n\tfor (int i = 0; i < n; i++) {\n\t\tstore[b[i]] = i + 1;\n\t}\n\tvector<int> ans(1e5);\n\tfor (int i = 0; i < n; i++) {\n\t\tint d = abs(store[a[i]]\n\t\t\t\t\t- (i + 1));\n\t\tif (store[a[i]] < i + 1) {\n\t\t\td = n - d;\n\t\t}\n\t\tans[d]++;\n\t}\n\tint finalans = 0;\n\tfor (int i = 0; i < 1e5; i++)\n\t\tfinalans = max(finalans, ans[i]);\n\tcout << finalans << \"\\n\";\n}", "2583": "void RightRotate(int a[], int n, int k)\n{\n\tk = k % n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tif(i < k)\n\t{\n\t\tcout << a[n + i - k] << \" \";\n\t}\n\telse\n\t{\n\t\tcout << (a[i - k]) << \" \";\n\t}\n\t}\n\tcout << \"\\n\";\n}", "2615": "void restoreSortedArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] > arr[i + 1]) {\n\t\t\treverse(arr, arr+i+1);\n\t\t\treverse(arr + i + 1, arr + n);\n\t\t\treverse(arr, arr + n);\n\t\t}\n\t}\n}\nvoid printArray(int arr[], int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t\tcout << arr[i] << \" \";\n}", "2616": "int findStartIndexOfArray(int arr[], int low,int high)\n{\n\tif (low>high)\n\t{\n\t\treturn -1;\n\t}\n\tif (low == high)\n\t{\n\t\treturn low;\n\t}\n\tint mid = low + (high-low)/2;\n\tif(arr[mid] > arr[mid+1])\n\t\treturn mid+1;\n\tif(arr[mid-1] > arr[mid])\n\t\treturn mid;\n\tif(arr[low] > arr[mid])\n\t\treturn findStartIndexOfArray(arr, low, mid-1);\n\telse\n\t\treturn findStartIndexOfArray(arr, mid+1, high);\n}\nvoid restoreSortedArray(int arr[], int n)\n{\n\tif (arr[0] < arr[n-1])\n\t\treturn;\n\tint start = findStartIndexOfArray(arr, 0, n-1);\n\treverse(arr, arr + start);\n\treverse(arr + start, arr + n);\n\treverse(arr, arr + n);\n}\nvoid printArray(int arr[], int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t\tcout << arr[i] << \" \";\n}", "2623": "void leftrotate(string &s, int d)\n{\n\treverse(s.begin(), s.begin()+d);\n\treverse(s.begin()+d, s.end());\n\treverse(s.begin(), s.end());\n}\nvoid rightrotate(string &s, int d)\n{\n leftrotate(s, s.length()-d);\n}", "2673": "void insertNode(struct Node** start, int value)\n{\n\tif (*start == NULL)\n\t{\n\t\tstruct Node* new_node = new Node;\n\t\tnew_node->data = value;\n\t\tnew_node->next = new_node->prev = new_node;\n\t\t*start = new_node;\n\t\treturn;\n\t}\n\tNode *last = (*start)->prev;\n\tstruct Node* new_node = new Node;\n\tnew_node->data = value;\n\tnew_node->next = *start;\n\t(*start)->prev = new_node;\n\tnew_node->prev = last;\n\tlast->next = new_node;\n}\nvoid displayList(struct Node* start)\n{\n\tstruct Node *temp = start;\n\twhile (temp->next != start)\n\t{\n\t\tprintf(\"%d \", temp->data);\n\t\ttemp = temp->next;\n\t}\n\tprintf(\"%d \", temp->data);\n}\nint searchList(struct Node* start, int search)\n{\n\tstruct Node *temp = start;\n\tint count=0,flag=0,value;\n\tif(temp == NULL)\n\t\treturn -1;\n\telse\n\t{\n\t\twhile(temp->next != start)\n\t\t{\n\t\t\tcount++;\n\t\t\tif(temp->data == search)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp = temp->next; \n\t\t}\n\t\tif(temp->data == search)\n\t\t{\n\t\t\tcount++;\n\t\t\tflag = 1;\n\t\t}\n\t\tif(flag == 1)\n\t\t\tcout<<\"\\n\"<<search <<\" found at location \"<<\n\t\t\t\t\t\t\t\t\t\t\tcount<<endl;\n\t\telse\n\t\t\tcout<<\"\\n\"<<search <<\" not found\"<<endl;\n\t}\n}", "2675": "Node* getNode(int data)\n{\n\tNode* newNode = (Node*)malloc(sizeof(Node));\n\tnewNode->data = data;\n\treturn newNode;\n}\nvoid insertEnd(Node** head, Node* new_node)\n{\n\tif (*head == NULL) {\n\t\tnew_node->next = new_node->prev = new_node;\n\t\t*head = new_node;\n\t\treturn;\n\t}\n\tNode* last = (*head)->prev;\n\tnew_node->next = *head;\n\t(*head)->prev = new_node;\n\tnew_node->prev = last;\n\tlast->next = new_node;\n}\nNode* reverse(Node* head)\n{\n\tif (!head)\n\t\treturn NULL;\n\tNode* new_head = NULL;\n\tNode* last = head->prev;\n\tNode *curr = last, *prev;\n\twhile (curr->prev != last) {\n\t\tprev = curr->prev;\n\t\tinsertEnd(&new_head, curr);\n\t\tcurr = prev;\n\t}\n\tinsertEnd(&new_head, curr);\n\treturn new_head;\n}\nvoid display(Node* head)\n{\n\tif (!head)\n\t\treturn;\n\tNode* temp = head;\n\tcout << \"Forward direction: \";\n\twhile (temp->next != head) {\n\t\tcout << temp->data << \" \";\n\t\ttemp = temp->next;\n\t}\n\tcout << temp->data;\n\tNode* last = head->prev;\n\ttemp = last;\n\tcout << \"\\nBackward direction: \";\n\twhile (temp->prev != last) {\n\t\tcout << temp->data << \" \";\n\t\ttemp = temp->prev;\n\t}\n\tcout << temp->data;\n}", "2696": "void addEdge(int u,int v)\n{\n\tadj[u].push_back(v);\n\tadj[v].push_back(u);\n}\nvoid dfs(int cur, int prev)\n{\n\tparent[cur] = prev;\n\tdepth[cur] = depth[prev] + 1;\n\tfor (int i=0; i<adj[cur].size(); i++)\n\t\tif (adj[cur][i] != prev)\n\t\t\tdfs(adj[cur][i],cur);\n}\nvoid preprocess()\n{\n\tdepth[0] = -1;\n\tdfs(1,0);\n}\nint LCANaive(int u,int v)\n{\n\tif (u == v) return u;\n\tif (depth[u] > depth[v])\n\t\tswap(u, v);\n\tv = parent[v];\n\treturn LCANaive(u,v);\n}", "2697": "void addEdge(int u,int v)\n{\n\tadj[u].push_back(v);\n\tadj[v].push_back(u);\n}\nint LCANaive(int u,int v)\n{\n\tif (u == v) return u;\n\tif (depth[u] > depth[v])\n\t\tswap(u,v);\n\tv = parent[v];\n\treturn LCANaive(u,v);\n}\nvoid dfs(int cur, int prev)\n{\n\tdepth[cur] = depth[prev] + 1;\n\tparent[cur] = prev;\n\tif (depth[cur] % block_sz == 0)\n\t\tjump_parent[cur] = parent[cur];\n\telse\n\t\tjump_parent[cur] = jump_parent[prev];\n\tfor (int i = 0; i<adj[cur].size(); ++i)\n\t\tif (adj[cur][i] != prev)\n\t\t\tdfs(adj[cur][i], cur);\n}\nint LCASQRT(int u, int v)\n{\n\twhile (jump_parent[u] != jump_parent[v])\n\t{\n\t\tif (depth[u] > depth[v])\n\t\t\tswap(u,v);\n\t\tv = jump_parent[v];\n\t}\n\treturn LCANaive(u,v);\n}\nvoid preprocess(int height)\n{\n\tblock_sz = sqrt(height);\n\tdepth[0] = -1;\n\tdfs(1, 0);\n}", "2740": "int find_permutations(vector<int>& arr)\n{\n\tint cnt = 0;\n\tint max_ind = -1, min_ind = 10000000;\n\tint n = arr.size();\n\tunordered_map<int, int> index_of;\n\tfor (int i = 0; i < n; i++) {\n\t\tindex_of[arr[i]] = i + 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmax_ind = max(max_ind, index_of[i]);\n\t\tmin_ind = min(min_ind, index_of[i]);\n\t\tif (max_ind - min_ind + 1 == i)\n\t\t\tcnt++;\n\t}\n\treturn cnt;\n}", "2753": "", "2773": "ll int countOfNum(ll int n, ll int a, ll int b)\n{\n\tll int cnt_of_a, cnt_of_b, cnt_of_ab, sum;\n\tcnt_of_a = n / a;\n\tcnt_of_b = n / b;\n\tsum = cnt_of_b + cnt_of_a;\n\tcnt_of_ab = n / (a * b);\n\tsum = sum - cnt_of_ab;\n\treturn sum;\n}\nll int sumOfNum(ll int n, ll int a, ll int b)\n{\n\tll int i;\n\tll int sum = 0;\n\tset<ll int> ans;\n\tfor (i = a; i <= n; i = i + a) {\n\t\tans.insert(i);\n\t}\n\tfor (i = b; i <= n; i = i + b) {\n\t\tans.insert(i);\n\t}\n\tfor (auto it = ans.begin();\n\t\tit != ans.end(); it++) {\n\t\tsum = sum + *it;\n\t}\n\treturn sum;\n}", "2783": "void maximumArea(int l, int b, int x, int y)\n{\n\tint left, right, above, below;\n\tleft = x * b;\n\tright = (l - x - 1) * b;\n\tabove = l * y;\n\tbelow = (b - y - 1) * l;\n\tcout << max(max(left, right),\n\t\t\t\tmax(above, below));\n}", "2802": "void precompute()\n{\n\tF[1] = 2;\n\tF[2] = 3;\n\tF[3] = 4;\n\tfor (int i = 4; i < N; i++)\n\t\tF[i] = (F[i - 1] + F[i - 2]) % MOD;\n}", "2804": "double get(double L, double R)\n{\n\tdouble x = 1.0 / L;\n\tdouble y = 1.0 / (R + 1.0);\n\treturn (x - y);\n}", "2809": "int consecutiveOnes(int x)\n{\n\tint p = 0;\n\twhile (x > 0) {\n\t\tif (x % 2 == 1 and p == 1)\n\t\t\treturn true;\n\t\tp = x % 2;\n\t\tx /= 2;\n\t}\n\treturn false;\n}\nvoid preCompute()\n{\n\tfor (int i = 0; i <= MAX; i++) {\n\t\tif (!consecutiveOnes(i))\n\t\t\tv.push_back(i);\n\t}\n}\nint nextValid(int n)\n{\n\tint it = upper_bound(v.begin(),\n\t\t\t\t\t\tv.end(), n)\n\t\t\t- v.begin();\n\tint val = v[it];\n\treturn val;\n}\nvoid performQueries(int queries[], int q)\n{\n\tfor (int i = 0; i < q; i++)\n\t\tcout << nextValid(queries[i]) << \"\\n\";\n}", "2816": "int changeToOnes(string str)\n{\n\tint i, l, ctr = 0;\n\tl = str.length();\n\tfor (i = l - 1; i >= 0; i--) {\n\t\tif (str[i] == '1')\n\t\t\tctr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn l - ctr;\n}\nstring removeZeroesFromFront(string str)\n{\n\tstring s;\n\tint i = 0;\n\twhile (i < str.length() && str[i] == '0')\n\t\ti++;\n\tif (i == str.length())\n\t\ts = \"0\";\n\telse\n\t\ts = str.substr(i, str.length() - i);\n\treturn s;\n}", "2818": "int getCount(int a[], int n)\n{\n\tint gcd = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tgcd = __gcd(gcd, a[i]);\n\tint cnt = 0;\n\tfor (int i = 1; i * i <= gcd; i++) {\n\t\tif (gcd % i == 0) {\n\t\t\tif (i * i == gcd)\n\t\t\t\tcnt++;\n\t\t\telse\n\t\t\t\tcnt += 2;\n\t\t}\n\t}\n\treturn cnt;\n}", "2827": "int MinDeletion(int a[], int n)\n{\n\tunordered_map<int, int> map;\n\tfor (int i = 0; i < n; i++)\n\t\tmap[a[i]]++;\n\tint ans = 0;\n\tfor (auto i : map) {\n\t\tint x = i.first;\n\t\tint frequency = i.second;\n\t\tif (x <= frequency) {\n\t\t\tans += (frequency - x);\n\t\t}\n\t\telse\n\t\t\tans += frequency;\n\t}\n\treturn ans;\n}", "2831": "int maxCountAB(string s[], int n)\n{\n\tint A = 0, B = 0, BA = 0, ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring S = s[i];\n\t\tint L = S.size();\n\t\tfor (int j = 0; j < L - 1; j++) {\n\t\t\tif (S.at(j) == 'A' &&\n\t\t\t\t\t\tS.at(j + 1) == 'B') {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tif (S.at(0) == 'B' && S.at(L - 1) == 'A')\n\t\t\tBA++;\n\t\telse if (S.at(0) == 'B')\n\t\t\tB++;\n\t\telse if (S.at(L - 1) == 'A')\n\t\t\tA++;\n\t}\n\tif (BA == 0)\n\t\tans += min(B, A);\n\telse if (A + B == 0)\n\t\tans += BA - 1;\n\telse\n\t\tans += BA + min(B, A);\n\treturn ans;\n}", "2832": "int MinOperations(int n, int x, int* arr)\n{\n\tint total = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (arr[i] > x) {\n\t\t\tint difference = arr[i] - x;\n\t\t\ttotal = total + difference;\n\t\t\tarr[i] = x;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint LeftNeigbouringSum = arr[i] + arr[i - 1];\n\t\tif (LeftNeigbouringSum > x) {\n\t\t\tint current_diff = LeftNeigbouringSum - x;\n\t\t\tarr[i] = max(0, arr[i] - current_diff);\n\t\t\ttotal = total + current_diff;\n\t\t}\n\t}\n\treturn total;\n}", "2847": "void findNumbers(int arr[], int n)\n\t{\n\t\tint sumN = (n * (n + 1)) / 2;\n\t\tint sumSqN = (n * (n + 1) * (2 * n + 1)) / 6;\n\t\tint sum = 0, sumSq = 0, i;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tsum += arr[i];\n\t\t\tsumSq = sumSq + (pow(arr[i], 2));\n\t\t}\n\t\tint B = (((sumSq - sumSqN) / (sum - sumN)) + sumN - sum) / 2;\n\t\tint A = sum - sumN + B;\n\t\tcout << \"A = \" ;\n\t\tcout << A << endl;\n\t\tcout << \"B = \" ;\n\t\tcout << B << endl;\n\t}", "2883": "bool is_prefix(string temp, string str)\n{\n\tif (temp.length() < str.length())\n\t\treturn 0;\n\telse {\n\t\tfor (int i = 0;\n\t\t\ti < str.length(); i++) {\n\t\t\tif (str[i] != temp[i])\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n}\nstring lexicographicallyString( string input[], int n, string str)\n{\n\tsort(input, input + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tstring temp = input[i];\n\t\tif (is_prefix(temp, str)) {\n\t\t\treturn temp;\n\t\t}\n\t}\n\treturn \"-1\";\n}", "2892": "void Rearrange(int arr[], int K, int N)\n{\n\tint ans[N + 1];\n\tint f = -1;\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] = -1;\n\t}\n\tK = find(arr, arr + N, K) - arr;\n\tvector<int> smaller, greater;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] < arr[K])\n\t\t\tsmaller.push_back(arr[i]);\n\t\telse if (arr[i] > arr[K])\n\t\t\tgreater.push_back(arr[i]);\n\t}\n\tint low = 0, high = N - 1;\n\twhile (low <= high) {\n\t\tint mid = (low + high) / 2;\n\t\tif (mid == K) {\n\t\t\tans[mid] = arr[K];\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (mid < K) {\n\t\t\tif (smaller.size() == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans[mid] = smaller.back();\n\t\t\tsmaller.pop_back();\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse {\n\t\t\tif (greater.size() == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans[mid] = greater.back();\n\t\t\tgreater.pop_back();\n\t\t\thigh = mid - 1;\n\t\t}\n\t}\n\tif (f == -1) {\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (ans[i] == -1) {\n\t\t\tif (smaller.size()) {\n\t\t\t\tans[i] = smaller.back();\n\t\t\t\tsmaller.pop_back();\n\t\t\t}\n\t\t\telse if (greater.size()) {\n\t\t\t\tans[i] = greater.back();\n\t\t\t\tgreater.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t\tcout << ans[i] << \" \";\n\tcout << endl;\n}", "2923": "void minimumK(vector<int> &arr, int M, int N)\n{\n\tint good = ceil((N * 1.0)\n\t\t\t\t\t/ ((M + 1) * 1.0));\n\tfor (int i = 1; i <= N; i++) {\n\t\tint K = i;\n\t\tint candies = N;\n\t\tint taken = 0;\n\t\twhile (candies > 0) {\n\t\t\ttaken += min(K, candies);\n\t\t\tcandies -= min(K, candies);\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tint consume = (arr[j] * candies) / 100;\n\t\t\t\tcandies -= consume;\n\t\t\t}\n\t\t}\n\t\tif (taken >= good) {\n\t\t\tcout << i;\n\t\t\treturn;\n\t\t}\n\t}\n}", "2924": "bool check(int K, int n, int m, vector<int> arr, int good_share)\n{\n\tint candies = n, taken = 0;\n\twhile (candies > 0) {\n\t\ttaken += min(K, candies);\n\t\tcandies -= min(K, candies);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint consume = (arr[j] * candies) / 100;\n\t\t\tcandies -= consume;\n\t\t}\n\t}\n\treturn (taken >= good_share);\n}\nvoid minimumK(vector<int> &arr, int N, int M)\n{\n\tint good_share = ceil((N * 1.0)\n\t\t\t\t\t\t/ ((M + 1) * 1.0));\n\tint lo = 1, hi = N;\n\twhile (lo < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (check(mid, N, M, arr, good_share)) {\n\t\t\thi = mid;\n\t\t}\n\t\telse {\n\t\t\tlo = mid + 1;\n\t\t}\n\t}\n\tcout << hi;\n}", "2940": "void calcTotalTime(string path)\n{\n\tint time = 0;\n\tint x = 0, y = 0;\n\tset<pair<int, int> > s;\n\tfor (int i = 0; i < path.size(); i++) {\n\t\tint p = x;\n\t\tint q = y;\n\t\tif (path[i] == 'N')\n\t\t\ty++;\n\t\telse if (path[i] == 'S')\n\t\t\ty--;\n\t\telse if (path[i] == 'E')\n\t\t\tx++;\n\t\telse if (path[i] == 'W')\n\t\t\tx--;\n\t\tif (s.find({ p + x, q + y })\n\t\t\t== s.end()) {\n\t\t\ttime += 2;\n\t\t\ts.insert({ p + x, q + y });\n\t\t}\n\t\telse\n\t\t\ttime += 1;\n\t}\n\tcout << time << endl;\n}", "2950": "void calcPsquare(int N)\n{\n\tfor (int i = 1; i * i <= N; i++)\n\t\tpsquare.push_back(i * i);\n}\nint countWays(int index, int target)\n{\n\tif (target == 0)\n\t\treturn 1;\n\tif (index < 0 target < 0)\n\t\treturn 0;\n\tint inc = countWays( index, target - psquare[index]);\n\tint exc = countWays(index - 1, target);\n\treturn inc + exc;\n}", "2983": "int findCost(int A[], int N)\n{\n\tint totalCost = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == 0) {\n\t\t\tA[i] = 1;\n\t\t\ttotalCost += i;\n\t\t}\n\t}\n\treturn totalCost;\n}", "3003": "static int search(vector<int> list, int num)\n{\n\tint low = 0, high = list.size() - 1;\n\tint ans = -1;\n\twhile (low <= high)\n\t{\n\t\tint mid = low + (high - low) / 2;\n\t\tif (list[mid] <= num)\n\t\t{\n\t\t\tans = mid;\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn ans;\n}\nbool isPalindrome(int n)\n{\n\tint rev = 0;\n\tint temp = n;\n\twhile (n > 0)\n\t{\n\t\trev = rev * 10 + n % 10;\n\t\tn /= 10;\n\t}\n\treturn rev == temp;\n}\nint countNumbers(int L, int R, int K)\n{\n\tvector<int> list;\n\tfor(int i = L; i <= R; i++)\n\t{\n\t\tif (isPalindrome(i))\n\t\t{\n\t\t\tlist.push_back(i);\n\t\t}\n\t}\n\tint count = 0;\n\tfor(int i = 0; i < list.size(); i++)\n\t{\n\t\tint right_index = search(list, list[i] + K - 1);\n\t\tif (right_index != -1)\n\t\t\tcount = max(count, right_index - i + 1);\n\t}\n\treturn count;\n}", "3010": "int peakIndex(int arr[], int N)\n{\n\tif (N < 3)\n\t\treturn -1;\n\tint i = 0;\n\twhile (i + 1 < N)\n\t{\n\t\tif (arr[i + 1] < arr[i] arr[i] == arr[i + 1])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i == 0 i == N - 1)\n\t\treturn -1;\n\tint ans = i;\n\twhile (i < N - 1)\n\t{\n\t\tif (arr[i] < arr[i + 1] arr[i] == arr[i + 1])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i == N - 1)\n\t\treturn ans;\n\treturn -1;\n}", "3053": "void hasArrayTwoPairs(int nums[], int n, int target)\n{\n\tsort(nums, nums + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = target - nums[i];\n\t\tint low = 0, high = n - 1;\n\t\twhile (low <= high) {\n\t\t\tint mid = low\n\t\t\t\t\t+ ((high - low) / 2);\n\t\t\tif (nums[mid] > x) {\n\t\t\t\thigh = mid - 1;\n\t\t\t}\n\t\t\telse if (nums[mid] < x) {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mid == i) {\n\t\t\t\t\tif ((mid - 1 >= 0) && nums[mid - 1] == x) {\n\t\t\t\t\t\tcout << nums[i] << \", \";\n\t\t\t\t\t\tcout << nums[mid - 1];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mid + 1 < n) && nums[mid + 1] == x) {\n\t\t\t\t\t\tcout << nums[i] << \", \";\n\t\t\t\t\t\tcout << nums[mid + 1];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << nums[i] << \", \";\n\t\t\t\t\tcout << nums[mid];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1;\n}", "3096": "TreeNode* newNode(int data)\n{\n\tTreeNode* Node = new TreeNode();\n\tNode->data = data;\n\tNode->left = NULL;\n\tNode->right = NULL;\n\treturn (Node);\n}\npair<int, int> sumofsubtree(TreeNode* root)\n{\n\tpair<int, int> p = make_pair(1, 0);\n\tif (root->left) {\n\t\tpair<int, int> ptemp\n\t\t\t= sumofsubtree(root->left);\n\t\tp.second += ptemp.first\n\t\t\t\t\t+ ptemp.second;\n\t\tp.first += ptemp.first;\n\t}\n\tif (root->right) {\n\t\tpair<int, int> ptemp\n\t\t\t= sumofsubtree(root->right);\n\t\tp.second += ptemp.first\n\t\t\t\t\t+ ptemp.second;\n\t\tp.first += ptemp.first;\n\t}\n\troot->size = p.first;\n\treturn p;\n}\nvoid distance(TreeNode* root, int target, int distancesum, int n)\n{\n\tif (root->data == target) {\n\t\tsum = distancesum;\n\t}\n\tif (root->left) {\n\t\tint tempsum = distancesum\n\t\t\t\t\t- root->left->size\n\t\t\t\t\t+ (n - root->left->size);\n\t\tdistance(root->left, target, tempsum, n);\n\t}\n\tif (root->right) {\n\t\tint tempsum = distancesum\n\t\t\t\t\t- root->right->size\n\t\t\t\t\t+ (n - root->right->size);\n\t\tdistance(root->right, target, tempsum, n);\n\t}\n}", "3120": "int delCost(string s, int cost[], int l1, int l2)\n{\n\tbool visited[l1];\n\tmemset(visited, 0, sizeof(visited));\n\tint ans = 0;\n\tfor (int i = 0; i < l1; i++)\n\t{\n\t\tif (visited[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint maxDel = 0;\n\t\tint totalCost = 0;\n\t\tvisited[i] = 1;\n\t\tfor (int j = i; j < l1; j++)\n\t\t{\n\t\t\tif (s[i] == s[j])\n\t\t\t{\n\t\t\t\tmaxDel = max(maxDel, cost[j]);\n\t\t\t\ttotalCost += cost[j];\n\t\t\t\tvisited[j] = 1;\n\t\t\t}\n\t\t}\n\t\tans += totalCost - maxDel;\n\t}\n\treturn ans;\n}", "3121": "int delCost(string s, int cost[])\n{\n\tint ans = 0;\n\tmap<char, int> forMax;\n\tmap<char, int> forTot;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (!forMax[s[i]]) {\n\t\t\tforMax[s[i]] = cost[i];\n\t\t}\n\t\telse {\n\t\t\tforMax[s[i]] = max(cost[i], forMax[s[i]]);\n\t\t}\n\t\tif (!forTot[s[i]]) {\n\t\t\tforTot[s[i]] = cost[i];\n\t\t}\n\t\telse {\n\t\t\tforTot[s[i]] = forTot[s[i]] + cost[i];\n\t\t}\n\t}\n\tfor (auto i : forMax) {\n\t\tans += forTot[i.first] - i.second;\n\t}\n\treturn ans;\n}", "3128": "int findClosest(int N, int target)\n{\n\tint closest = -1;\n\tint diff = INT_MAX;\n\tfor (int i = 1; i <= sqrt(N); i++) {\n\t\tif (N % i == 0) {\n\t\t\tif (N / i == i) {\n\t\t\t\tif (abs(target - i) < diff) {\n\t\t\t\t\tdiff = abs(target - i);\n\t\t\t\t\tclosest = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (abs(target - i) < diff) {\n\t\t\t\t\tdiff = abs(target - i);\n\t\t\t\t\tclosest = i;\n\t\t\t\t}\n\t\t\t\tif (abs(target - N / i) < diff) {\n\t\t\t\t\tdiff = abs(target - N / i);\n\t\t\t\t\tclosest = N / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << closest;\n}", "3129": "void computeDivisors()\n{\n\tfor (int i = 1; i <= MAX; i++) {\n\t\tfor (int j = i; j <= MAX; j += i) {\n\t\t\tdivisors[j].push_back(i);\n\t\t}\n\t}\n}\nint getClosest(int val1, int val2, int target)\n{\n\tif (target - val1 >= val2 - target)\n\t\treturn val2;\n\telse\n\t\treturn val1;\n}\nint findClosest(vector<int>& arr, int n, int target)\n{\n\tif (target <= arr[0])\n\t\treturn arr[0];\n\tif (target >= arr[n - 1])\n\t\treturn arr[n - 1];\n\tint i = 0, j = n, mid = 0;\n\twhile (i < j) {\n\t\tmid = (i + j) / 2;\n\t\tif (arr[mid] == target)\n\t\t\treturn arr[mid];\n\t\tif (target < arr[mid]) {\n\t\t\tif (mid > 0 && target > arr[mid - 1])\n\t\t\t\treturn getClosest(arr[mid - 1], arr[mid], target);\n\t\t\tj = mid;\n\t\t}\n\t\telse {\n\t\t\tif (mid < n - 1 && target < arr[mid + 1])\n\t\t\t\treturn getClosest(arr[mid], arr[mid + 1], target);\n\t\t\ti = mid + 1;\n\t\t}\n\t}\n\treturn arr[mid];\n}\nvoid printClosest(int N, int X)\n{\n\tcomputeDivisors();\n\tint ans\n\t\t= findClosest(divisors[N], divisors[N].size(), X);\n\tcout << ans;\n}", "3135": "int countTriplets(int* arr, int N)\n{\n\tvector<int> zero_i;\n\tvector<int> one_i;\n\tunordered_map<int, int> mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] == 0)\n\t\t\tzero_i.push_back(i + 1);\n\t\telse if (arr[i] == 1)\n\t\t\tone_i.push_back(i + 1);\n\t\telse\n\t\t\tmp[i + 1] = 1;\n\t}\n\tint total = zero_i.size()\n\t\t\t\t* one_i.size() * mp.size();\n\tfor (int i = 0; i < zero_i.size(); i++) {\n\t\tfor (int j = 0; j < one_i.size(); j++) {\n\t\t\tint p = zero_i[i];\n\t\t\tint q = one_i[j];\n\t\t\tint r = 2 * p - q;\n\t\t\tif (mp[r] > 0)\n\t\t\t\ttotal--;\n\t\t\tr = 2 * q - p;\n\t\t\tif (mp[r] > 0)\n\t\t\t\ttotal--;\n\t\t\tr = (p + q) / 2;\n\t\t\tif (mp[r] > 0 && abs(r - p) == abs(r - q))\n\t\t\t\ttotal--;\n\t\t}\n\t}\n\tcout << total;\n}", "3138": "int power(long long int A, long long int N)\n{\n\tint count = 0;\n\tif (A == 1)\n\t\treturn 0;\n\twhile (N) {\n\t\tcount++;\n\t\tN /= A;\n\t}\n\treturn count;\n}\nvoid Pairs(long long int N, long long int A, long long int B)\n{\n\tint powerA, powerB;\n\tpowerA = power(A, N);\n\tpowerB = power(B, N);\n\tlong long int intialB = B, intialA = A;\n\tA = 1;\n\tfor (int i = 0; i <= powerA; i++) {\n\t\tB = 1;\n\t\tfor (int j = 0; j <= powerB; j++) {\n\t\t\tif (B == N - A) {\n\t\t\t\tcout << i << \" \" << j << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tB *= intialB;\n\t\t}\n\t\tA *= intialA;\n\t}\n\tcout << -1 << endl;\n\treturn;\n}", "3142": "int findNonMultiples(int arr[], int n, int k)\n{\n\tset<int> multiples;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (multiples.find(arr[i])\n\t\t\t== multiples.end()) {\n\t\t\tfor (int j = 1; j <= k / arr[i]; j++) {\n\t\t\t\tmultiples.insert(arr[i] * j);\n\t\t\t}\n\t\t}\n\t}\n\treturn k - multiples.size();\n}\nint countValues(int arr[], int N, int L, int R)\n{\n\treturn findNonMultiples(arr, N, R)\n\t\t- findNonMultiples(arr, N, L - 1);\n}", "3163": "int maxMatch(int A[], int B[], int M, int N)\n{\n\tmap<int,int> Aindex;\n\tmap<int,int> diff;\n\tfor(int i = 0; i < M; i++)\n\t{\n\t\tAindex[A[i]] = i ;\n\t}\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (i - Aindex[B[i]] < 0)\n\t\t{\t\n\t\t\tdiff[M + i - Aindex[B[i]]] += 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiff[i - Aindex[B[i]]] += 1;\n\t\t}\n\t}\n\tint max = 0;\n\tfor(auto ele = diff.begin(); ele != diff.end(); ele++)\n\t{\n\t\tif(ele->second > max)\n\t\t{\n\t\t\tmax = ele->second;\n\t\t}\n\t}\n\treturn max;\n}", "3176": "void checkXOR(int arr[], int N)\n{\n\tif (N % 2 == 0) {\n\t\tint xro = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\txro ^= arr[i];\n\t\t}\n\t\tif (xro != 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N - 3; i += 2) {\n\t\t\tcout << i << \" \" << i + 1\n\t\t\t\t<< \" \" << i + 2 << endl;\n\t\t}\n\t\tfor (int i = 0; i < N - 3; i += 2) {\n\t\t\tcout << i << \" \" << i + 1\n\t\t\t\t<< \" \" << N - 1 << endl;\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < N - 2; i += 2) {\n\t\t\tcout << i << \" \" << i + 1 << \" \"\n\t\t\t\t<< i + 2 << endl;\n\t\t}\n\t\tfor (int i = 0; i < N - 2; i += 2) {\n\t\t\tcout << i << \" \" << i + 1\n\t\t\t\t<< \" \" << N - 1 << endl;\n\t\t}\n\t}\n}", "3179": "int make_array_element_even(int arr[], int N)\n{\n\tint res = 0;\n\tint odd_cont_seg = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] % 2 == 1) {\n\t\t\todd_cont_seg++;\n\t\t}\n\t\telse {\n\t\t\tif (odd_cont_seg > 0) {\n\t\t\t\tif (odd_cont_seg % 2 == 0) {\n\t\t\t\t\tres += odd_cont_seg / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres += (odd_cont_seg / 2) + 2;\n\t\t\t\t}\n\t\t\t\todd_cont_seg = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (odd_cont_seg > 0) {\n\t\tif (odd_cont_seg % 2 == 0) {\n\t\t\tres += odd_cont_seg / 2;\n\t\t}\n\t\telse {\n\t\t\tres += odd_cont_seg / 2 + 2;\n\t\t}\n\t}\n\treturn res;\n}", "3183": "int minCollectingSpeed(vector<int>& piles, int H)\n{\n\tint ans = -1;\n\tint low = 1, high;\n\thigh = *max_element(piles.begin(),\n\t\t\t\t\t\tpiles.end());\n\twhile (low <= high)\n\t{\n\t\tint K = low + (high - low) / 2;\n\t\tint time = 0;\n\t\tfor (int ai : piles) {\n\t\t\ttime += (ai + K - 1) / K;\n\t\t}\n\t\tif (time <= H) {\n\t\t\tans = K;\n\t\t\thigh = K - 1;\n\t\t}\n\t\telse {\n\t\t\tlow = K + 1;\n\t\t}\n\t}\n\tcout << ans;\n}", "3198": "int cntDisPairs(int arr[], int N, int K)\n{\n\tint cntPairs = 0;\n\tsort(arr, arr + N);\n\tint i = 0;\n\tint j = N - 1;\n\twhile (i < j) {\n\t\tif (arr[i] + arr[j] == K) {\n\t\t\twhile (i < j && arr[i] == arr[i + 1]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (i < j && arr[j] == arr[j - 1]) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tcntPairs += 1;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse if (arr[i] + arr[j] < K) {\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\tj--;\n\t\t}\n\t}\n\treturn cntPairs;\n}", "3199": "int cntDisPairs(int arr[], int N, int K)\n{\n\tint cntPairs = 0;\n\tunordered_map<int, int> cntFre;\n\tfor (int i = 0; i < N; i++) {\n\t\tcntFre[arr[i]]++;\n\t}\n\tfor (auto it : cntFre) {\n\t\tint i = it.first;\n\t\tif (2 * i == K) {\n\t\t\tif (cntFre[i] > 1)\n\t\t\t\tcntPairs += 2;\n\t\t}\n\t\telse {\n\t\t\tif (cntFre[K - i]) {\n\t\t\t\tcntPairs += 1;\n\t\t\t}\n\t\t}\n\t}\n\tcntPairs = cntPairs / 2;\n\treturn cntPairs;\n}", "3229": "void push(Node** head_ref, int new_data)\n{\n\tNode* new_node\n\t\t= (Node*)malloc(sizeof(struct Node));\n\tnew_node->data = new_data;\n\tnew_node->prev = NULL;\n\tnew_node->next = (*head_ref);\n\tif ((*head_ref) != NULL) {\n\t\t(*head_ref)->prev = new_node;\n\t}\n\t(*head_ref) = new_node;\n}\nint search(Node** head_ref, int x)\n{\n\tNode* temp = *head_ref;\n\tint pos = 0;\n\twhile (temp->data != x && temp->next != NULL) {\n\t\tpos++;\n\t\ttemp = temp->next;\n\t}\n\tif (temp->data != x)\n\t\treturn -1;\n\treturn (pos + 1);\n}", "3234": "void longestSubsequence(int N, int Q, int arr[], int Queries[][2])\n{\n\tfor (int i = 0; i < Q; i++) {\n\t\tint x = Queries[i][0];\n\t\tint y = Queries[i][1];\n\t\tarr[x - 1] = y;\n\t\tint count = 1;\n\t\tfor (int j = 1; j < N; j++) {\n\t\t\tif (arr[j] != arr[j - 1]) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tcout << count << ' ';\n\t}\n}", "3235": "void longestSubsequence(int N, int Q, int arr[], int Queries[][2])\n{\n\tint count = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (arr[i] != arr[i - 1]) {\n\t\t\tcount += 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tint x = Queries[i][0];\n\t\tint y = Queries[i][1];\n\t\tif (x > 1) {\n\t\t\tif (arr[x - 1] != arr[x - 2]) {\n\t\t\t\tcount -= 1;\n\t\t\t}\n\t\t\tif (arr[x - 2] != y) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tif (x < N) {\n\t\t\tif (arr[x] != arr[x - 1]) {\n\t\t\t\tcount -= 1;\n\t\t\t}\n\t\t\tif (y != arr[x]) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tcout << count << ' ';\n\t\tarr[x - 1] = y;\n\t}\n}", "3253": "void sum(int arr[], int n)\n{\n\tmap<int, vector<int> > mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tmp[arr[i]].push_back(i);\n\t}\n\tint ans[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tint sum = 0;\n\t\tfor (auto it : mp[arr[i]]) {\n\t\t\tsum += abs(it - i);\n\t\t}\n\t\tans[i] = sum;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << ans[i] << \" \";\n\t}\n\treturn;\n}", "3270": "void rearrangeArray(int A[], int B[], int N, int K)\n{\n\tsort(B, B + N, greater<int>());\n\tbool flag = true;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] + B[i] > K) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!flag) {\n\t\tcout << \"-1\" << endl;\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << B[i] << \" \";\n\t\t}\n\t}\n}", "3311": "bool isinRange(int board[][N])\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (board[i][j] <= 0 board[i][j] > 9) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nbool isValidSudoku(int board[][N])\n{\n\tif (isinRange(board) == false) {\n\t\treturn false;\n\t}\n\tbool unique[N + 1];\n\tfor (int i = 0; i < N; i++) {\n\t\tmemset(unique, false,\n\t\t\tsizeof(unique));\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tint Z = board[i][j];\n\t\t\tif (unique[Z]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tunique[Z] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tmemset(unique, false,\n\t\t\tsizeof(unique));\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tint Z = board[j][i];\n\t\t\tif (unique[Z]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tunique[Z] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < N - 2; i += 3) {\n\t\tfor (int j = 0; j < N - 2; j += 3) {\n\t\t\tmemset(unique, false,\n\t\t\t\tsizeof(unique));\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tint X = i + k;\n\t\t\t\t\tint Y = j + l;\n\t\t\t\t\tint Z = board[X][Y];\n\t\t\t\t\tif (unique[Z]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tunique[Z] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "3332": "string conVowUpp(string& str)\n{\n\tint N = str.length();\n\tfor (int i = 0; i < N; i++) {\n\t\tif (str[i] == 'a' str[i] == 'e' str[i] == 'i' str[i] == 'o' str[i] == 'u') {\n\t\t\tstr[i] = str[i] - 'a' + 'A';\n\t\t}\n\t}\n\treturn str;\n}", "3337": "int zvalue(vector<int>& nums)\n{\n\tint m = *max_element(nums.begin(),\n\t\t\t\t\t\tnums.end());\n\tint cnt = 0;\n\tfor (int i = 0; i <= m; i++) {\n\t\tcnt = 0;\n\t\tfor (int j = 0; j < nums.size(); j++) {\n\t\t\tif (nums[j] >= i)\n\t\t\t\tcnt++;\n\t\t}\n\t\tif (cnt == i)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}", "3345": "bool palindrome(vector<int> a, int i, int j)\n{\n\twhile(i<j)\n\t{\n\t\tif(a[i] != a[j])\n\t\t\treturn false;\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\nint findSubArray(vector<int> arr, int k)\n{\n\tint n= sizeof(arr)/sizeof(arr[0]);\n\tfor(int i=0; i<=n-k; i++){\n\t\tif(palindrome(arr, i, i+k-1))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}", "3346": "bool helper(int mid)\n{\n\tint cnt = 0;\n\tfor (auto i : mp) {\n\t\tint temp = i.second;\n\t\twhile (temp >= mid) {\n\t\t\ttemp -= mid;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt >= N;\n}\nint findMaximumDays(int arr[])\n{\n\tfor (int i = 0; i < P; i++) {\n\t\tmp[arr[i]]++;\n\t}\n\tint start = 0, end = P, ans = 0;\n\twhile (start <= end) {\n\t\tint mid = start\n\t\t\t\t+ ((end - start) / 2);\n\t\tif (mid != 0 and helper(mid)) {\n\t\t\tans = mid;\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse if (mid == 0) {\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse {\n\t\t\tend = mid - 1;\n\t\t}\n\t}\n\treturn ans;\n}", "3374": "long long int countSubarrays( int a[], int n, int k)\n{\n\tint ans = 0;\n\tvector<int> pref;\n\tpref.push_back(0);\n\tfor (int i = 0; i < n; i++)\n\t\tpref.push_back((a[i] + pref[i]) % k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\tif ((pref[j] - pref[i - 1] + k) % k == j - i + 1) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << ' ';\n}", "3375": "long long int countSubarrays( int a[], int n, int k)\n{\n\tunordered_map<int, int> cnt;\n\tlong long int ans = 0;\n\tvector<int> pref;\n\tpref.push_back(0);\n\tfor (int i = 0; i < n; i++)\n\t\tpref.push_back((a[i] + pref[i]) % k);\n\tcnt[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint remIdx = i - k;\n\t\tif (remIdx >= 0) {\n\t\t\tcnt[(pref[remIdx] - remIdx % k + k) % k]--;\n\t\t}\n\t\tans += cnt[(pref[i] - i % k + k) % k];\n\t\tcnt[(pref[i] - i % k + k) % k]++;\n\t}\n\tcout << ans << ' ';\n}", "3398": "void countRows(int mat[M][N])\n{\n int count = 0;\n int totalSum = 0;\n for (int i = 0; i < N; i++)\n {\n\tfor (int j = 0; j < M; j++)\n\t{\n\ttotalSum += mat[i][j];\n\t}\n }\n for (int i = 0; i < N; i++)\n {\n\tint currSum = 0;\n\tfor (int j = 0; j < M; j++)\n\t{\n\tcurrSum += mat[i][j];\n\t}\n\tif (currSum > totalSum - currSum)\n\tcount++;\n }\n cout << count;\n}", "3417": "bool isCrossed(string path)\n{\n\tif (path.size() == 0)\n\t\treturn false;\n\tbool ans = false;\n\tset<pair<int, int> > set;\n\tint x = 0, y = 0;\n\tset.insert({ x, y });\n\tfor (int i = 0; i < path.size(); i++) {\n\t\tif (path[i] == 'N')\n\t\t\tset.insert({ x, y++ });\n\t\tif (path[i] == 'S')\n\t\t\tset.insert({ x, y-- });\n\t\tif (path[i] == 'E')\n\t\t\tset.insert({ x++, y });\n\t\tif (path[i] == 'W')\n\t\t\tset.insert({ x--, y });\n\t\tif (set.find({ x, y })\n\t\t\t!= set.end()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ans)\n\t\tcout << \"Crossed\";\n\telse\n\t\tcout << \"Not Crossed\";\n}", "3427": "int maxWidth(int N, int M, vector<int> cost, vector<vector<int> > s)\n{\n\tvector<int> adj[N];\n\tfor (int i = 0; i < M; i++) {\n\t\tadj[s[i][0]].push_back( s[i][1]);\n\t}\n\tint result = 0;\n\tqueue<int> q;\n\tq.push(0);\n\twhile (!q.empty()) {\n\t\tint count = q.size();\n\t\tresult = max(count, result);\n\t\twhile (count--) {\n\t\t\tint temp = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < adj[temp].size(); i++) {\n\t\t\t\tq.push(adj[temp][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "3463": "void SieveOfEratosthenes()\n{\n\tmemset(isPrime, true, sizeof(isPrime));\n\tfor (int p = 2; p * p <= MAX; p++) {\n\t\tif (isPrime[p] == true) {\n\t\t\tfor (int i = p * p; i <= MAX; i += p)\n\t\t\t\tisPrime[i] = false;\n\t\t}\n\t}\n\tfor (int p = 2; p <= MAX; p++)\n\t\tif (isPrime[p])\n\t\t\tprimes.push_back(p);\n}\nint prime_search(vector<int> primes, int diff)\n{\n\tint low = 0;\n\tint high = primes.size() - 1;\n\tint res;\n\twhile (low <= high) {\n\t\tint mid = (low + high) / 2;\n\t\tif (primes[mid] == diff) {\n\t\t\treturn primes[mid];\n\t\t}\n\t\telse if (primes[mid] < diff) {\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse {\n\t\t\tres = primes[mid];\n\t\t\thigh = mid - 1;\n\t\t}\n\t}\n\treturn res;\n}\nint minCost(int arr[], int n)\n{\n\tSieveOfEratosthenes();\n\tint res = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (arr[i] < arr[i - 1]) {\n\t\t\tint diff = arr[i - 1] - arr[i];\n\t\t\tint closest_prime\n\t\t\t\t= prime_search(primes, diff);\n\t\t\tres += closest_prime;\n\t\t\tarr[i] += closest_prime;\n\t\t}\n\t}\n\treturn res;\n}", "3464": "pair<string, int> lexico_smallest(string s1, string s2)\n{\n\tmap<char, int> M;\n\tset<char> S;\n\tpair<string, int> pr;\n\tfor (int i = 0; i <= s1.size() - 1; ++i) {\n\t\tM[s1[i]]++;\n\t\tS.insert(s1[i]);\n\t}\n\tfor (int i = 0; i <= s2.size() - 1; ++i) {\n\t\tM[s2[i]]--;\n\t}\n\tchar c = s2[0];\n\tint index = 0;\n\tstring res = \"\";\n\tfor (auto x : S) {\n\t\tif (x != c) {\n\t\t\tfor (int i = 1; i <= M[x]; ++i) {\n\t\t\t\tres += x;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint j = 0;\n\t\t\tindex = res.size();\n\t\t\twhile (s2[j] == x) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (s2[j] < c) {\n\t\t\t\tres += s2;\n\t\t\t\tfor (int i = 1; i <= M[x]; ++i) {\n\t\t\t\t\tres += x;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 1; i <= M[x]; ++i) {\n\t\t\t\t\tres += x;\n\t\t\t\t}\n\t\t\t\tindex += M[x];\n\t\t\t\tres += s2;\n\t\t\t}\n\t\t}\n\t}\n\tpr.first = res;\n\tpr.second = index;\n\treturn pr;\n}\nstring lexico_largest(string s1, string s2)\n{\n\tpair<string, int> pr = lexico_smallest(s1, s2);\n\tstring d1 = \"\";\n\tfor (int i = pr.second - 1; i >= 0; i--) {\n\t\td1 += pr.first[i];\n\t}\n\tstring d2 = \"\";\n\tfor (int i = pr.first.size() - 1;\n\t\ti >= pr.second + s2.size(); --i) {\n\t\td2 += pr.first[i];\n\t}\n\tstring res = d2 + s2 + d1;\n\treturn res;\n}", "3468": "void addEdge(vector<int> v[], int x, int y)\n{\n\tv[x].push_back(y);\n\tv[y].push_back(x);\n}\nvoid dfs(vector<int> tree[], vector<int>& temp, int ancestor[], int u, int parent, int k)\n{\n\ttemp.push_back(u);\n\tfor (auto i : tree[u]) {\n\t\tif (i == parent)\n\t\t\tcontinue;\n\t\tdfs(tree, temp, ancestor, i, u, k);\n\t}\n\ttemp.pop_back();\n\tif (temp.size() < k) {\n\t\tancestor[u] = -1;\n\t}\n\telse {\n\t\tancestor[u]\n\t\t\t= temp[temp.size() - k];\n\t}\n}\nvoid KthAncestor(int N, int K, int E, int edges[][2])\n{\n\tvector<int> tree[N + 1];\n\tfor (int i = 0; i < E; i++) {\n\t\taddEdge(tree, edges[i][0], edges[i][1]);\n\t}\n\tvector<int> temp;\n\tint ancestor[N + 1];\n\tdfs(tree, temp, ancestor, 1, 0, K);\n\tfor (int i = 1; i <= N; i++) {\n\t\tcout << ancestor[i] << \" \";\n\t}\n}", "3471": "void build(vector<int>& sum, vector<int>& a, int l, int r, int rt)\n{\n\tif (l == r) {\n\t\tsum[rt] = a[l - 1];\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tbuild(sum, a, l, m, rt << 1);\n\tbuild(sum, a, m + 1, r, rt << 1 1);\n}\nvoid pushDown(vector<int>& sum, vector<int>& add, int rt, int ln, int rn)\n{\n\tif (add[rt]) {\n\t\tadd[rt << 1] += add[rt];\n\t\tadd[rt << 1 1] += add[rt];\n\t\tsum[rt << 1] += add[rt] * ln;\n\t\tsum[rt << 1 1] += add[rt] * rn;\n\t\tadd[rt] = 0;\n\t}\n}\nvoid update(vector<int>& sum, vector<int>& add, int L, int R, int C, int l, int r, int rt)\n{\n\tif (L <= l && r <= R) {\n\t\tsum[rt] += C * (r - l + 1);\n\t\tadd[rt] += C;\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tpushDown(sum, add, rt, m - l + 1, r - m);\n\tif (L <= m)\n\t\tupdate(sum, add, L, R, C, l, m, rt << 1);\n\tif (R > m)\n\t\tupdate(sum, add, L, R, C, m + 1, r, rt << 1 1);\n}\nint query(vector<int>& sum, vector<int>& add, int L, int R, int l, int r, int rt)\n{\n\tif (L <= l && r <= R) {\n\t\treturn sum[rt];\n\t}\n\tint m = (l + r) >> 1;\n\tpushDown(sum, add, rt, m - l + 1, r - m);\n\tint ans = 0;\n\tif (L <= m)\n\t\tans += query(sum, add, L, R, l, m, rt << 1);\n\tif (R > m)\n\t\tans += query(sum, add, L, R, m + 1, r, rt << 1 1);\n\treturn ans;\n}\nvoid sequenceMaintenance(int n, int q, vector<int>& a, vector<int>& b, int m)\n{\n\tsort(a.begin(), a.end());\n\tvector<int> sum, add, ans;\n\tsum.assign(n << 2, 0);\n\tadd.assign(n << 2, 0);\n\tbuild(sum, a, 1, n, 1);\n\tfor (int i = 0; i < q; i++) {\n\t\tint l = 1, r = n, pos = -1;\n\t\twhile (l <= r) {\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (query(sum, add, m, m, 1, n, 1) >= b[i]) {\n\t\t\t\tr = m - 1;\n\t\t\t\tpos = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1)\n\t\t\tans.push_back(0);\n\t\telse {\n\t\t\tans.push_back(n - pos + 1);\n\t\t\tupdate(sum, add, pos, n, -m, 1, n, 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << \" \";\n\t}\n}", "3487": "int count(string s)\n{\n\tint cnt = 0;\n\tfor(char c : s)\n\t{\n\t\tcnt += c == '0' ? 1 : 0;\n\t}\n\tif (cnt % 3 != 0)\n\t\treturn 0;\n\tint res = 0, k = cnt / 3, sum = 0;\n\tmap<int, int> mp;\n\tfor(int i = 0; i < s.length(); i++)\n\t{\n\t\tsum += s[i] == '0' ? 1 : 0;\n\t\tif (sum == 2 * k && mp.find(k) != mp.end() &&\n\t\t\ti < s.length() - 1 && i > 0)\n\t\t{\n\t\t\tres += mp[k];\n\t\t}\n\t\tmp[sum]++;\n\t}\n\treturn res;\n}", "3488": "int splitstring(string s)\n{\n\tint n = s.length();\n\tint zeros = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (s[i] == '0')\n\t\t\tzeros++;\n\tif (zeros % 3 != 0)\n\t\treturn 0;\n\tif (zeros == 0)\n\t\treturn ((n - 1) * (n - 2)) / 2;\n\tint zerosInEachSubstring = zeros / 3;\n\tint waysOfFirstCut = 0, waysOfSecondCut = 0;\n\tint count = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s[i] == '0')\n\t\t\tcount++;\n\t\tif (count == zerosInEachSubstring)\n\t\t\twaysOfFirstCut++;\n\t\telse if (count == 2 * zerosInEachSubstring)\n\t\t\twaysOfSecondCut++;\n\t}\n\treturn waysOfFirstCut * waysOfSecondCut;\n}", "3495": "int check(string& s, int k)\n{\n\tint n = s.size();\n\tfor (int i = 0; i < k; i++) {\n\t\tfor (int j = i; j < n; j += k) {\n\t\t\tif (s[i] != s[j])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tif (s[i] == '0')\n\t\t\tc++;\n\t\telse\n\t\t\tc--;\n\t}\n\tif (c == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "3503": "void addEdge(int a, int b)\n{\n\ttree[a].push_back(b);\n\ttree[b].push_back(a);\n}\nvoid dfs(int x)\n{\n\tvis[x] = true;\n\tsubtreeSize[x] = 1;\n\tfor (auto i : tree[x]) {\n\t\tif (!vis[i]) {\n\t\t\tdfs(i);\n\t\t\tsubtreeSize[x]\n\t\t\t\t+= subtreeSize[i];\n\t\t}\n\t}\n}\nvoid countPairs(int a, int b)\n{\n\tint sub = min(subtreeSize[a], subtreeSize[b]);\n\tcout << sub * (n - sub)\n\t\t<< endl;\n}", "3516": "int revNum(int N)\n{\n\tint x = 0;\n\twhile (N) {\n\t\tx = x * 10 + N % 10;\n\t\tN = N / 10;\n\t}\n\treturn x;\n}\nint ctNonPalin(int arr[], int N)\n{\n\tint Res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint x = revNum(arr[i]);\n\t\tif (x == arr[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tRes += (arr[i] % 10 == N % 10);\n\t\t}\n\t}\n\treturn Res;\n}", "3520": "bool isSame(string str, int n)\n{\n\tmap<int, int> mp;\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tmp[str[i] - 'a']++;\n\t}\n\tfor (auto it : mp) {\n\t\tif ((it.second) >= n) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "3531": "bool canTransform(string str1, string str2)\n{\n\tstring s1 = \"\";\n\tstring s2 = \"\";\n\tfor (char c : str1) {\n\t\tif (c != 'C') {\n\t\t\ts1 += c;\n\t\t}\n\t}\n\tfor (char c : str2) {\n\t\tif (c != 'C') {\n\t\t\ts2 += c;\n\t\t}\n\t}\n\tif (s1 != s2)\n\t\treturn false;\n\tint i = 0;\n\tint j = 0;\n\tint n = str1.length();\n\twhile (i < n and j < n) {\n\t\tif (str1[i] == 'C') {\n\t\t\ti++;\n\t\t}\n\t\telse if (str2[j] == 'C') {\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tif ((str1[i] == 'A' and i < j)\n\t\t\t\tor (str1[i] == 'B' and i > j)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\tstring str1 = \"BCCABCBCA\";\n\tstring str2 = \"CBACCBBAC\";\n\tif (canTransform(str1, str2)) {\n\t\tcout << \"Yes\";\n\t}\n\telse {\n\t\tcout << \"No\";\n\t}\n\treturn 0;\n}", "3540": "double func(double a, double b, double c, double x)\n{\n\treturn a * x * x + b * x + c;\n}\ndouble findRoot(double a, double b, double c, double low, double high)\n{\n\tdouble x;\n\twhile (fabs(high - low) > eps) {\n\t\tx = (low + high) / 2;\n\t\tif (func(a, b, c, low)\n\t\t\t\t* func(a, b, c, x) <= 0) {\n\t\t\thigh = x;\n\t\t}\n\t\telse {\n\t\t\tlow = x;\n\t\t}\n\t}\n\treturn x;\n}\nvoid solve(double a, double b, double c, double A, double B)\n{\n\tif (func(a, b, c, A)\n\t\t\t* func(a, b, c, B) > 0) {\n\t\tcout << \"No solution\";\n\t}\n\telse {\n\t\tcout << fixed\n\t\t\t<< setprecision(4)\n\t\t\t<< findRoot(a, b, c, A, B);\n\t}\n}", "3550": "bool hasCoprimePair(vector<int>& arr, int n)\n{\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (__gcd(arr[i], arr[j]) == 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "3555": "int findPermutation(unordered_set<int>& arr, int N)\n{\n\tint pos = arr.size() + 1;\n\tif (pos > N)\n\t\treturn 1;\n\tint res = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (arr.find(i) == arr.end()) {\n\t\t\tif (i % pos == 0 or pos % i == 0) {\n\t\t\t\tarr.insert(i);\n\t\t\t\tres += findPermutation(arr, N);\n\t\t\t\tarr.erase(arr.find(i));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "3562": "void solve(int arr[], int n, int X, int Y)\n{\n\tint diff = Y - X;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] != 1) {\n\t\t\tdiff = diff % (arr[i] - 1);\n\t\t}\n\t}\n\tif (diff == 0)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}", "3564": "int Numberofways(int n)\n{\n\tint count = 0;\n\tfor (int a = 1; a < n; a++) {\n\t\tfor (int b = 1; b < n; b++) {\n\t\t\tint c = n - (a + b);\n\t\t\tif (a + b > c && a + c > b && b + c > a) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "3567": "int maxsubstringLength(string S, int N)\n{\n\tint arr[N];\n\tfor (int i = 0; i < N; i++)\n\t\tif (S[i] == 'a' S[i] == 'e' S[i] == 'i' S[i] == 'o' S[i] == 'u')\n\t\t\tarr[i] = 1;\n\t\telse\n\t\t\tarr[i] = -1;\n\tint maxLen = 0;\n\tint curr_sum = 0;\n\tunordered_map<int, int> hash;\n\tfor (int i = 0; i < N; i++) {\n\t\tcurr_sum += arr[i];\n\t\tif (curr_sum == 0)\n\t\t\tmaxLen = max(maxLen, i + 1);\n\t\tif (hash.find(curr_sum) != hash.end())\n\t\t\tmaxLen = max(maxLen, i - hash[curr_sum]);\n\t\telse\n\t\t\thash[curr_sum] = i;\n\t}\n\treturn maxLen;\n}", "3584": "vector<int> findPrevious(vector<int> a, int n)\n{\n\tvector<int> ps(n);\n\tps[0] = -1;\n\tstack<int> Stack;\n\tStack.push(0);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\twhile (Stack.size() > 0 &&\n\t\t\ta[Stack.top()] >= a[i])\n\t\t\tStack.pop();\n\t\tps[i] = Stack.size() > 0 ?\n\t\t\t\tStack.top() : -1;\n\t\tStack.push(i);\n\t}\n\treturn ps;\n}\nvector<int> findNext(vector<int> a, int n)\n{\n\tvector<int> ns(n);\n\tns[n - 1] = n;\n\tstack<int> Stack;\n\tStack.push(n - 1);\n\tfor(int i = n - 2; i >= 0; i--)\n\t{\n\t\twhile (Stack.size() > 0 &&\n\t\t\ta[Stack.top()] >= a[i])\n\t\t\tStack.pop();\n\t\tns[i] = Stack.size() > 0 ?\n\t\t\t\tStack.top() : n;\n\t\tStack.push(i);\n\t}\n\treturn ns;\n}\nint findMaximumSum(vector<int> a, int n)\n{\n\tvector<int> prev_smaller = findPrevious(a, n);\n\tvector<int> next_smaller = findNext(a, n);\n\tint max_value = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tmax_value = max(max_value, a[i] *\n\t\t\t\t\t(next_smaller[i] - prev_smaller[i] - 1));\n\t}\n\treturn max_value;\n}", "3601": "bool possible(ll mid, vector<ll>& a)\n{\n\tll n = a.size();\n\tll total = (n * (n - 1)) / 2;\n\tll need = (total + 1) / 2;\n\tll count = 0;\n\tll start = 0, end = 1;\n\twhile (end < n) {\n\t\tif (a[end] - a[start] <= mid) {\n\t\t\tend++;\n\t\t}\n\t\telse {\n\t\t\tcount += (end - start - 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\tif (end == n && start < end && a[end - 1] - a[start] <= mid) {\n\t\tll t = end - start - 1;\n\t\tcount += (t * (t + 1) / 2);\n\t}\n\tif (count >= need)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nll findMedian(vector<ll>& a)\n{\n\tll n = a.size();\n\tll low = 0, high = a[n - 1] - a[0];\n\twhile (low <= high) {\n\t\tll mid = (low + high) / 2;\n\t\tif (possible(mid, a))\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\treturn high + 1;\n}", "3605": "void FindMinimumDistance()\n{\n\tqueue<pair<int, int> > q;\n\tq.push({ x, y });\n\tmat[x][y] = 0;\n\twhile (!q.empty()) {\n\t\tx = q.front().first;\n\t\ty = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tint a = x + dx[i];\n\t\t\tint b = y + dy[i];\n\t\t\tif (a < 0 a >= r b >= c b < 0)\n\t\t\t\tcontinue;\n\t\t\tif (mat[a][b] == 0) {\n\t\t\t\tmat[a][b] = mat[x][y] + 1;\n\t\t\t\tq.push({ a, b });\n\t\t\t}\n\t\t}\n\t}\n}", "3629": "void addEdge(int u, int v)\n{\n\tadj[u].push_back(v);\n\tadj[v].push_back(u);\n}\nvoid dfs1(int cur, int par)\n{\n\tfor (auto u : adj[cur]) {\n\t\tif (u != par) {\n\t\t\tdfs1(u, cur);\n\t\t\theight[cur]\n\t\t\t\t= max(height[cur], height[u]);\n\t\t}\n\t}\n\theight[cur] += 1;\n}\nvoid dfs2(int cur, int par)\n{\n\tint max1 = 0;\n\tint max2 = 0;\n\tfor (auto u : adj[cur]) {\n\t\tif (u != par) {\n\t\t\tif (height[u] >= max1) {\n\t\t\t\tmax2 = max1;\n\t\t\t\tmax1 = height[u];\n\t\t\t}\n\t\t\telse if (height[u] > max2) {\n\t\t\t\tmax2 = height[u];\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (auto u : adj[cur]) {\n\t\tif (u != par) {\n\t\t\tsum = ((max1 == height[u]) ? max2 : max1);\n\t\t\tif (max1 == height[u])\n\t\t\t\tdist[u]\n\t\t\t\t\t= 1 + max(1 + max2, dist[cur]);\n\t\t\telse\n\t\t\t\tdist[u]\n\t\t\t\t\t= 1 + max(1 + max1, dist[cur]);\n\t\t\tdfs2(u, cur);\n\t\t}\n\t}\n}", "3644": "void countPairs(int N, int arr[])\n{\n\tint count = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (i == arr[arr[i] - 1] - 1)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\tcout << (count / 2) << endl;\n}", "3664": "int minOperations(string S, int K)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tint zero = 0, one = 0;\n\t\tfor (int j = i;\n\t\t\tj < S.size(); j += K) {\n\t\t\tif (S[j] == '0')\n\t\t\t\tzero++;\n\t\t\telse\n\t\t\t\tone++;\n\t\t}\n\t\tans += min(zero, one);\n\t}\n\treturn ans;\n}", "3678": "void UniversalSubset(vector<string> A, vector<string> B)\n{\n\tint n1 = A.size();\n\tint n2 = B.size();\n\tvector<string> res;\n\tint A_fre[n1][26];\n\tfor (int i = 0; i < n1; i++) {\n\t\tfor (int j = 0; j < 26; j++)\n\t\t\tA_fre[i][j] = 0;\n\t}\n\tfor (int i = 0; i < n1; i++) {\n\t\tfor (int j = 0; j < A[i].size(); j++) {\n\t\t\tA_fre[i][A[i][j] - 'a']++;\n\t\t}\n\t}\n\tint B_fre[26] = { 0 };\n\tfor (int i = 0; i < n2; i++) {\n\t\tint arr[26] = { 0 };\n\t\tfor (int j = 0; j < B[i].size(); j++) {\n\t\t\tarr[B[i][j] - 'a']++;\n\t\t\tB_fre[B[i][j] - 'a']\n\t\t\t\t= max(B_fre[B[i][j] - 'a'], arr[B[i][j] - 'a']);\n\t\t}\n\t}\n\tfor (int i = 0; i < n1; i++) {\n\t\tint flag = 0;\n\t\tfor (int j = 0; j < 26; j++) {\n\t\t\tif (A_fre[i][j] < B_fre[j]) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0)\n\t\t\tres.push_back(A[i]);\n\t}\n\tif (res.size()) {\n\t\tfor (int i = 0; i < res.size(); i++) {\n\t\t\tfor (int j = 0; j < res[i].size(); j++)\n\t\t\t\tcout << res[i][j];\n\t\t}\n\t\tcout << \" \";\n\t}\n\telse\n\t\tcout << \"-1\";\n}", "3692": "void findPair(int a[], int n)\n{\n int min_dist = INT_MAX;\n int index_a = -1, index_b = -1;\n for (int i = 0; i < n; i++)\n {\n\tfor (int j = i + 1; j < n; j++)\n\t{\n\tif (j - i < min_dist)\n\t{\n\t\tif (a[i] % a[j] == 0 a[j] % a[i] == 0)\n\t\t{\n\t\tmin_dist = j - i;\n\t\tindex_a = i;\n\t\tindex_b = j;\n\t\t}\n\t}\n\t}\n }\n if (index_a == -1)\n {\n\tcout << (\"-1\");\n }\n else\n {\n\tcout << \"(\" << a[index_a] << \", \" << a[index_b] << \")\";\n }\n}", "3704": "void printNum(int L, int R)\n{\n\tfor (int i = L; i <= R; i++) {\n\t\tint temp = i;\n\t\tint c = 10;\n\t\tint flag = 0;\n\t\twhile (temp > 0) {\n\t\t\tif (temp % 10 >= c) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = temp % 10;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tif (flag == 0)\n\t\t\tcout << i << \" \";\n\t}\n}", "3742": "int findMissing(int arr[], int left, int right, int diff)\n{\n\tif (right <= left)\n\t\treturn INT_MAX;\n\tint mid = left + (right - left) / 2;\n\tif (arr[mid + 1] - arr[mid] != diff)\n\t\treturn (arr[mid] + diff);\n\tif (mid > 0 && arr[mid] - arr[mid - 1] != diff)\n\t\treturn (arr[mid - 1] + diff);\n\tif (arr[mid] == arr[0] + mid * diff)\n\t\treturn findMissing(arr, mid + 1, right, diff);\n\treturn findMissing(arr, left, mid - 1, diff);\n}\nint missingElement(int arr[], int n)\n{\n\tsort(arr, arr + n);\n\tint diff = (arr[n - 1] - arr[0]) / n;\n\treturn findMissing(arr, 0, n - 1, diff);\n}", "3743": "int missingElement(int arr[], int n)\n{\n\tint max_ele = arr[0];\n\tint min_ele = arr[0];\n\tint x = 0;\n\tint d;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] > max_ele)\n\t\t\tmax_ele = arr[i];\n\t\tif (arr[i] < min_ele)\n\t\t\tmin_ele = arr[i];\n\t}\n\td = (max_ele - min_ele) / n;\n\tfor (int i = 0; i < n; i++) {\n\t\tx = x ^ arr[i];\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tx = x ^ (min_ele + (i * d));\n\t}\n\treturn x;\n}", "3752": "int power(int x, unsigned int y)\n{\n\tint temp;\n\tif (y == 0)\n\t\treturn 1;\n\ttemp = power(x, y / 2);\n\tif (y % 2 == 0)\n\t\treturn temp * temp;\n\telse\n\t\treturn x * temp * temp;\n}\nint nthRootSearch(int low, int high, int N, int K)\n{\n\tif (low <= high) {\n\t\tint mid = (low + high) / 2;\n\t\tif ((power(mid, K) <= N)\n\t\t\t&& (power(mid + 1, K) > N)) {\n\t\t\treturn mid;\n\t\t}\n\t\telse if (power(mid, K) < N) {\n\t\t\treturn nthRootSearch(mid + 1, high, N, K);\n\t\t}\n\t\telse {\n\t\t\treturn nthRootSearch(low, mid - 1, N, K);\n\t\t}\n\t}\n\treturn low;\n}", "3755": "int get_subset_count(int arr[], int K, int N)\n{\n\tsort(arr, arr + N);\n\tint left, right;\n\tleft = 0;\n\tright = N - 1;\n\tint ans = 0;\n\twhile (left <= right) {\n\t\tif (arr[left] + arr[right] < K) {\n\t\t\tans += 1 << (right - left);\n\t\t\tleft++;\n\t\t}\n\t\telse {\n\t\t\tright--;\n\t\t}\n\t}\n\treturn ans;\n}", "3765": "int minMaxDiff(int arr[], int n, int k)\n{\n\tint max_adj_dif = INT_MIN;\n\tfor (int i = 0; i < n - 1; i++)\n\t\tmax_adj_dif\n\t\t\t= max(max_adj_dif,\n\t\t\t\tabs(arr[i] - arr[i + 1]));\n\tif (max_adj_dif == 0)\n\t\treturn 0;\n\tint best = 1;\n\tint worst = max_adj_dif;\n\tint mid, required;\n\twhile (best < worst) {\n\t\tmid = (best + worst) / 2;\n\t\trequired = 0;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\trequired += (abs(arr[i] - arr[i + 1]) - 1)\n\t\t\t\t\t\t/ mid;\n\t\t}\n\t\tif (required > k)\n\t\t\tbest = mid + 1;\n\t\telse\n\t\t\tworst = mid;\n\t}\n\treturn worst;\n}", "3773": "void checkMin(int arr[], int len)\n{\n\tint smallest = INT_MAX, secondSmallest = INT_MAX;\n\tfor (int i = 0; i < len; i++) {\n\t\tif (arr[i] < smallest) {\n\t\t\tsecondSmallest = smallest;\n\t\t\tsmallest = arr[i];\n\t\t}\n\t\telse if (arr[i] < secondSmallest) {\n\t\t\tsecondSmallest = arr[i];\n\t\t}\n\t}\n\tif (2 * smallest <= secondSmallest)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}", "3798": "void createHash(set<int>& hash, int maxElement)\n{\n\tint prev = 0, curr = 1;\n\thash.insert(prev);\n\thash.insert(curr);\n\twhile (curr <= maxElement) {\n\t\tint temp = curr + prev;\n\t\thash.insert(temp);\n\t\tprev = curr;\n\t\tcurr = temp;\n\t}\n}\nvoid fibonacci(int arr[], int n)\n{\n\tint max_val\n\t\t= *max_element( arr, arr + n);\n\tset<int> hash;\n\tcreateHash(hash, max_val);\n\tint minimum = INT_MAX;\n\tint maximum = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (hash.find(arr[i]) != hash.end()) {\n\t\t\tminimum = min(minimum, arr[i]);\n\t\t\tmaximum = max(maximum, arr[i]);\n\t\t}\n\t}\n\tcout << minimum << \", \"\n\t\t<< maximum << endl;\n}", "3814": "bool isValidLen(string s, int len, int k)\n{\n\tint n = s.size();\n\tunordered_map<char, int> mp;\n\tint right = 0;\n\twhile (right < len) {\n\t\tmp[s[right]]++;\n\t\tright++;\n\t}\n\tif (mp.size() <= k)\n\t\treturn true;\n\twhile (right < n) {\n\t\tmp[s[right]]++;\n\t\tmp[s[right - len]]--;\n\t\tif (mp[s[right - len]] == 0)\n\t\t\tmp.erase(s[right - len]);\n\t\tif (mp.size() <= k)\n\t\t\treturn true;\n\t\tright++;\n\t}\n\treturn mp.size() <= k;\n}\nint maxLenSubStr(string s, int k)\n{\n\tset<char> uni;\n\tfor (auto x : s)\n\t\tuni.insert(x);\n\tif (uni.size() < k)\n\t\treturn -1;\n\tint n = s.size();\n\tint lo = -1, hi = n + 1;\n\twhile (hi - lo > 1) {\n\t\tint mid = lo + hi >> 1;\n\t\tif (isValidLen(s, mid, k))\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid;\n\t}\n\treturn lo;\n}", "3822": "bool isSquarePossible(int arr[], int n, int l)\n{\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] >= l)\n\t\t\tcnt++;\n\t\tif (cnt >= l)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nint maxArea(int arr[], int n)\n{\n\tint l = 0, r = n;\n\tint len = 0;\n\twhile (l <= r) {\n\t\tint m = l + ((r - l) / 2);\n\t\tif (isSquarePossible(arr, n, m)) {\n\t\t\tlen = m;\n\t\t\tl = m + 1;\n\t\t}\n\t\telse\n\t\t\tr = m - 1;\n\t}\n\treturn (len * len);\n}", "3825": "bool sortby(const pair<int, int>& a, const pair<int, int>& b)\n{\n\tif (a.first != b.first)\n\t\treturn a.first < b.first;\n\treturn (a.second < b.second);\n}\nbool kOverlap(vector<pair<int, int> > pairs, int k)\n{\n\tvector<pair<int, int> > vec;\n\tfor (int i = 0; i < pairs.size(); i++) {\n\t\tvec.push_back({ pairs[i].first, -1 });\n\t\tvec.push_back({ pairs[i].second, +1 });\n\t}\n\tsort(vec.begin(), vec.end());\n\tstack<pair<int, int> > st;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tpair<int, int> cur = vec[i];\n\t\tif (cur.second == -1) {\n\t\t\tst.push(cur);\n\t\t}\n\t\telse {\n\t\t\tst.pop();\n\t\t}\n\t\tif (st.size() >= k) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "3829": "void insertNames(string arr[], int n)\n{\n\tunordered_set<string> set;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (set.find(arr[i]) == set.end()) {\n\t\t\tcout << \"No\\n\";\n\t\t\tset.insert(arr[i]);\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\\n\";\n\t\t}\n\t}\n}", "3871": "int countLessThan(int arr[], int n, int key)\n{\n\tint l = 0, r = n - 1;\n\tint index = -1;\n\twhile (l <= r) {\n\t\tint m = (l + r) / 2;\n\t\tif (arr[m] < key) {\n\t\t\tl = m + 1;\n\t\t\tindex = m;\n\t\t}\n\t\telse {\n\t\t\tr = m - 1;\n\t\t}\n\t}\n\treturn (index + 1);\n}\nint countGreaterThan(int arr[], int n, int key)\n{\n\tint l = 0, r = n - 1;\n\tint index = -1;\n\twhile (l <= r) {\n\t\tint m = (l + r) / 2;\n\t\tif (arr[m] <= key) {\n\t\t\tl = m + 1;\n\t\t}\n\t\telse {\n\t\t\tr = m - 1;\n\t\t\tindex = m;\n\t\t}\n\t}\n\tif (index == -1)\n\t\treturn 0;\n\treturn (n - index);\n}\nint countTriplets(int n, int* a, int* b, int* c)\n{\n\tsort(a, a + n);\n\tsort(b, b + n);\n\tsort(c, c + n);\n\tint count = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint current = b[i];\n\t\tint a_index = -1, c_index = -1;\n\t\tint low = countLessThan(a, n, current);\n\t\tint high = countGreaterThan(c, n, current);\n\t\tcount += (low * high);\n\t}\n\treturn count;\n}", "3885": "void Printksubstring(string str, int n, int k)\n{\n\tint total = (n * (n + 1)) / 2;\n\tif (k > total) {\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\tint substring[n + 1];\n\tsubstring[0] = 0;\n\tint temp = n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tsubstring[i] = substring[i - 1] + temp;\n\t\ttemp--;\n\t}\n\tint l = 1;\n\tint h = n;\n\tint start = 0;\n\twhile (l <= h) {\n\t\tint m = (l + h) / 2;\n\t\tif (substring[m] > k) {\n\t\t\tstart = m;\n\t\t\th = m - 1;\n\t\t}\n\t\telse if (substring[m] < k)\n\t\t\tl = m + 1;\n\t\telse {\n\t\t\tstart = m;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint end = n - (substring[start] - k);\n\tfor (int i = start - 1; i < end; i++)\n\t\tcout << str[i];\n}", "3932": "int LowerInsertionPoint(int arr[], int n, int X)\n{\n\tif (X < arr[0])\n\t\treturn 0;\n\telse if (X > arr[n - 1])\n\t\treturn n;\n\tint lowerPnt = 0;\n\tint i = 1;\n\twhile (i < n && arr[i] < X) {\n\t\tlowerPnt = i;\n\t\ti = i * 2;\n\t}\n\twhile (lowerPnt < n && arr[lowerPnt] < X)\n\t\tlowerPnt++;\n\treturn lowerPnt;\n}", "3967": "int LongestFibSubseq(int A[], int n)\n{\n\tunordered_set<int> S(A, A + n);\n\tint maxLen = 0, x, y;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tx = A[j];\n\t\t\ty = A[i] + A[j];\n\t\t\tint length = 2;\n\t\t\twhile (S.find(y) != S.end()) {\n\t\t\t\tint z = x + y;\n\t\t\t\tx = y;\n\t\t\t\ty = z;\n\t\t\t\tmaxLen = max(maxLen, ++length);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxLen >= 3 ? maxLen : 0;\n}", "4039": "int getCount(int M, int N)\n{\n\tint count = 0;\n\tif (M == 1)\n\t\treturn N;\n\tif (N == 1)\n\t\treturn M;\n\tif (N > M) {\n\t\tfor (int i = 1; i <= M; i++) {\n\t\t\tint numerator = N * i - N + M - i;\n\t\t\tint denominator = M - 1;\n\t\t\tif (numerator % denominator == 0) {\n\t\t\t\tint j = numerator / denominator;\n\t\t\t\tif (j >= 1 && j <= N)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tint numerator = M * j - M + N - j;\n\t\t\tint denominator = N - 1;\n\t\t\tif (numerator % denominator == 0) {\n\t\t\t\tint i = numerator / denominator;\n\t\t\t\tif (i >= 1 && i <= M)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "4048": "bool swapElement(int arr1[], int arr2[], int n)\n{\n\tint wrongIdx = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (arr1[i] < arr1[i - 1])\n\t\t\twrongIdx = i;\n\tint maximum = INT_MIN;\n\tint maxIdx = -1;\n\tbool res = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr2[i] > maximum && arr2[i] >= arr1[wrongIdx - 1]) {\n\t\t\tif (wrongIdx + 1 <= n - 1 && arr2[i] <= arr1[wrongIdx + 1]) {\n\t\t\t\tmaximum = arr2[i];\n\t\t\t\tmaxIdx = i;\n\t\t\t\tres = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (res)\n\t\tswap(arr1[wrongIdx], arr2[maxIdx]);\n\treturn res;\n}\nvoid getSortedArray(int arr1[], int arr2[], int n)\n{\n\tif (swapElement(arr1, arr2, n))\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcout << arr1[i] << \" \";\n\telse\n\t\tcout << \"Not Possible\" << endl;\n}\nint main()\n{\n\tint arr1[] = { 1, 3, 7, 4, 10 };\n\tint arr2[] = { 2, 1, 6, 8, 9 };\n\tint n = sizeof(arr1) / sizeof(arr1[0]);\n\tgetSortedArray(arr1, arr2, n);\n}\nvoid getSortedArray(int arr1[], int arr2[], int n)\n{\n\tif (swapElement(arr1, arr2, n))\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcout << arr1[i] << \" \";\n\telse\n\t\tcout << \"Not Possible\" << endl;\n}", "4052": "int costToBalance(string s)\n{\n\tif (s.length() == 0)\n\t\tcout << 0 << endl;\n\tint ans = 0;\n\tint o = 0, c = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (s[i] == '(')\n\t\t\to++;\n\t\tif (s[i] == ')')\n\t\t\tc++;\n\t}\n\tif (o != c)\n\t\treturn -1;\n\tint a[s.size()];\n\tif (s[0] == '(')\n\t\ta[0] = 1;\n\telse\n\t\ta[0] = -1;\n\tif (a[0] < 0)\n\t\tans += abs(a[0]);\n\tfor (int i = 1; i < s.length(); i++) {\n\t\tif (s[i] == '(')\n\t\t\ta[i] = a[i - 1] + 1;\n\t\telse\n\t\t\ta[i] = a[i - 1] - 1;\n\t\tif (a[i] < 0)\n\t\t\tans += abs(a[i]);\n\t}\n\treturn ans;\n}", "4079": "int middleOfThree(int a, int b, int c)\n{\nint middleOfThree(int a, int b, int c)\n{\n\tif ((a < b && b < c) || (c < b && b < a))\n\treturn b;\n\telse if ((b < a && a < c) || (c < a && a < b))\n\treturn a;\n\telse\n\treturn c;\n}\nint main()\n{\n\tint a = 20, b = 30, c = 40;\n\tcout << middleOfThree(a, b, c);\n\treturn 0;\n}\nint middleOfThree(int a, int b, int c)\n{\n\tif ((a < b && b < c) || (c < b && b < a))\n\treturn b;\n\telse if ((b < a && a < c) || (c < a && a < b))\n\treturn a;\n\telse\n\treturn c;\n}", "4080": "int middleOfThree(int a, int b, int c)\n{\n\tif (a > b)\n\t{\n\t\tif (b > c)\n\t\t\treturn b;\n\t\telse if (a > c)\n\t\t\treturn c;\n\t\telse\n\t\t\treturn a;\n\t}\n\telse\n\t{\n\t\tif (a > c)\n\t\t\treturn a;\n\t\telse if (b > c)\n\t\t\treturn c;\n\t\telse\n\t\t\treturn b;\n\t}\n}", "4081": "int middleOfThree(int a, int b, int c)\n{\n\tint x = a - b;\nint y = b - c; \nint z = a - c; \n\tif (x * y > 0)\n\t\treturn b;\n\telse if (x * z > 0)\n\t\treturn c;\n\telse\n\t\treturn a;\n}", "4099": "void missing4(int arr[], int n)\n{\n\tint helper[4];\n\tfor (int i = 0; i < n; i++) {\n\t\tint temp = abs(arr[i]);\n\t\tif (temp <= n)\n\t\t\tarr[temp - 1] *= (-1);\n\t\telse if (temp > n) {\n\t\t\tif (temp % n != 0)\n\t\t\t\thelper[temp % n - 1] = -1;\n\t\t\telse\n\t\t\t\thelper[(temp % n) + n - 1] = -1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr[i] > 0)\n\t\t\tcout << (i + 1) << \" \";\n\tfor (int i = 0; i < 4; i++)\n\t\tif (helper[i] >= 0)\n\t\t\tcout << (n + i + 1) << \" \";\n\treturn;\n}", "4129": "void lexiMiddleSmallest(int K, int N)\n{\n\tif (K % 2 == 0) {\n\t\tcout << K / 2 << \" \";\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tcout << K << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t\texit(0);\n\t}\n\tvector<int> a(N, (K + 1) / 2);\n\tfor (int i = 0; i < N / 2; ++i) {\n\t\tif (a.back() == 1) {\n\t\t\ta.pop_back();\n\t\t}\n\t\telse {\n\t\t\t--a.back();\n\t\t\twhile ((int)a.size() < N) {\n\t\t\t\ta.push_back(K);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : a) {\n\t\tcout << i << \" \";\n\t}\n\tcout << \"\\n\";\n}", "4155": "vector<vector<int> > transpose( vector<vector<int> > mat, int row, int col)\n{\n\tvector<vector<int> > tr(\n\t\tcol, vector<int>(row));\n\tfor (int i = 0; i < row; i++) {\n\t\tfor (int j = 0; j < col; j++) {\n\t\t\ttr[j][i] = mat[i][j];\n\t\t}\n\t}\n\treturn tr;\n}\nvoid RowWiseSort(vector<vector<int> >& B)\n{\n\tfor (int i = 0; i < (int)B.size(); i++) {\n\t\tsort(B[i].begin(), B[i].end());\n\t}\n}\nvoid sortCol(vector<vector<int> > mat, int N, int M)\n{\n\tvector<vector<int> > B\n\t\t= transpose(mat, N, M);\n\tRowWiseSort(B);\n\tmat = transpose(B, M, N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcout << mat[i][j] << \" \";\n\t\t}\n\t\tcout << '\\n';\n\t}\n}", "4169": "void largestArea(int N, int M, int H[], int V[], int h, int v)\n{\n set<int> s1;\n set<int> s2;\n for (int i = 1; i <= N + 1; i++)\n\ts1.insert(i);\n for (int i = 1; i <= M + 1; i++)\n\ts2.insert(i);\n for (int i = 0; i < h; i++) {\n\ts1.erase(H[i]);\n }\n for (int i = 0; i < v; i++) {\n\ts2.erase(V[i]);\n }\n int list1[s1.size()];\n int list2[s2.size()];\n int i = 0;\n for (auto it1 = s1.begin(); it1 != s1.end(); it1++) \n {\n\tlist1[i++] = *it1;\n }\n i = 0;\n for (auto it2 = s2.begin(); it2 != s2.end(); it2++) \n {\n\tlist2[i++] = *it2;\n }\n sort(list1, list1 + s1.size());\n sort(list2, list2 + s2.size());\n int maxH = 0, p1 = 0, maxV = 0, p2 = 0;\n for (int j = 0; j < s1.size(); j++) {\n\tmaxH = max(maxH, list1[j] - p1);\n\tp1 = list1[j];\n }\n for (int j = 0; j < s2.size(); j++) {\n\tmaxV = max(maxV, list2[j] - p2);\n\tp2 = list2[j];\n }\n cout << (maxV * maxH) << endl;\n}", "4179": "void findLastElement(int arr[], int N)\n{\n\tsort(arr, arr + N);\n\tint i = 0;\n\tfor (i = 1; i < N; i++) {\n\t\tif (arr[i] - arr[i - 1] != 0 && arr[i] - arr[i - 1] != 2) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << arr[N - 1] << endl;\n}", "4185": "bool checkifSorted(int A[], int B[], int N)\n{\n bool flag = false;\n for (int i = 0; i < N - 1; i++) {\n\tif (A[i] > A[i + 1]) {\n\tflag = true;\n\tbreak;\n\t}\n }\n if (!flag) {\n\treturn true;\n }\n int count = 0;\n for (int i = 0; i < N; i++) {\n\tif (B[i] == 0) {\n\tcount++;\n\tbreak;\n\t}\n }\n for (int i = 0; i < N; i++) {\n\tif (B[i] == 1) {\n\tcount++;\n\tbreak;\n\t}\n }\n if (count == 2) {\n\treturn true;\n }\n return false;\n}", "4186": "void maxDivisions(int arr[], int N, int X)\n{\n\tsort(arr, arr + N, greater<int>());\n\tint maxSub = 0;\n\tint size = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tsize++;\n\t\tif (arr[i] * size >= X) {\n\t\t\tmaxSub++;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\tcout << maxSub << endl;\n}", "4194": "void maxPossibleSum(int arr[], int N)\n{\n\tsort(arr, arr + N);\n\tint sum = 0;\n\tint j = N - 3;\n\twhile (j >= 0)\n\t{\n\t\tsum += arr[j];\n\t\tj -= 3;\n\t}\n\tcout << sum;\n}", "4197": "int minSteps(string A, string B, int M, int N)\n{\n\tif (A[0] > B[0])\n\t\treturn 0;\n\tif (B[0] > A[0]) {\n\t\treturn 1;\n\t}\n\tif (M <= N && A[0] == B[0]\n\t\t&& count(A.begin(), A.end(), A[0]) == M\n\t\t&& count(B.begin(), B.end(), B[0]) == N)\n\t\treturn -1;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (B[i] > B[0])\n\t\t\treturn 1;\n\t}\n\tfor (int i = 1; i < M; i++) {\n\t\tif (A[i] < A[0])\n\t\t\treturn 1;\n\t}\n\tfor (int i = 1; i < M; i++) {\n\t\tif (A[i] > A[0]) {\n\t\t\tswap(A[i], B[0]);\n\t\t\tswap(A[0], B[0]);\n\t\t\treturn 2;\n\t\t}\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tif (B[i] < B[0]) {\n\t\t\tswap(A[0], B[i]);\n\t\t\tswap(A[0], B[0]);\n\t\t\treturn 2;\n\t\t}\n\t}\n\treturn 0;\n}", "4209": "int CountMaximum(int arr[], int n, int k)\n{\n\tsort(arr, arr + n);\n\tint sum = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tsum += arr[i];\n\t\tif (sum > k)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\treturn count;\n}", "4210": "int CountMaximum(int arr[], int n, int k)\n{\n\tsort(arr, arr + n);\n\tint sum = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tsum += arr[i];\n\t\tif (sum > k)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\treturn count;\n}", "4219": "void insertionSort(int arr[], int n)\n{\n\tint i, key, j;\n\tfor (i = 1; i < n; i++) {\n\t\tkey = arr[i];\n\t\tj = i - 1;\n\t\twhile (j >= 0 && arr[j] > key) {\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\tarr[j + 1] = key;\n\t}\n}\nvoid printArray(int arr[], int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n\tcout << endl;\n}", "4220": "void swap(int* xp, int* yp)\n{\n\tint temp = *xp;\n\t*xp = *yp;\n\t*yp = temp;\n}\nvoid selectionSort(int arr[], int n)\n{\n\tint i, j, min_idx;\n\tfor (i = 0; i < n - 1; i++) {\n\t\tmin_idx = i;\n\t\tfor (j = i + 1; j < n; j++)\n\t\t\tif (arr[j] < arr[min_idx])\n\t\t\t\tmin_idx = j;\n\t\tswap(&arr[min_idx], &arr[i]);\n\t}\n}\nvoid printArray(int arr[], int size)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n\tcout << endl;\n}", "4237": "int getPairs(int arr[], int N, int K)\n{\n\tint count = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (arr[i] > K * arr[i + 1])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tcout << count;\n}", "4238": "int merge(int arr[], int temp[], int l, int m, int r, int K)\n{\n\tint i = l;\n\tint j = m + 1;\n\tint cnt = 0;\n\tfor (int l = 0; i <= m; i++) {\n\t\tbool found = false;\n\t\twhile (j <= r) {\n\t\t\tif (arr[i] >= K * arr[j]) {\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (found) {\n\t\t\tcnt += j - (m + 1);\n\t\t\tj--;\n\t\t}\n\t}\n\tint k = l;\n\ti = l;\n\tj = m + 1;\n\twhile (i <= m && j <= r) {\n\t\tif (arr[i] <= arr[j])\n\t\t\ttemp[k++] = arr[i++];\n\t\telse\n\t\t\ttemp[k++] = arr[j++];\n\t}\n\twhile (i <= m)\n\t\ttemp[k++] = arr[i++];\n\twhile (j <= r)\n\t\ttemp[k++] = arr[j++];\n\tfor (int i = l; i <= r; i++)\n\t\tarr[i] = temp[i];\n\treturn cnt;\n}\nint mergeSortUtil(int arr[], int temp[], int l, int r, int K)\n{\n\tint cnt = 0;\n\tif (l < r) {\n\t\tint m = (l + r) / 2;\n\t\tcnt += mergeSortUtil(arr, temp, l, m, K);\n\t\tcnt += mergeSortUtil(arr, temp, m + 1, r, K);\n\t\tcnt += merge(arr, temp, l, m, r, K);\n\t}\n\treturn cnt;\n}\nint mergeSort(int arr[], int N, int K)\n{\n\tint temp[N];\n\tcout << mergeSortUtil(arr, temp, 0, N - 1, K);\n}", "4249": "void minRemovals(int A[], int N)\n{\n\tsort(A, A + N);\n\tint mx = A[N - 1];\n\tint sum = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tsum += A[i];\n\t}\n\tif (sum - mx >= mx) {\n\t\tcout << 0 << \"\\n\";\n\t}\n\telse {\n\t\tcout << 2 * mx - sum << \"\\n\";\n\t}\n}", "4250": "void rearrangeArray(int a[], int n)\n{\n\tsort(a, a + n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (a[i] == i + 1) {\n\t\t\tswap(a[i], a[i + 1]);\n\t\t}\n\t}\n\tif (a[n - 1] == n) {\n\t\tswap(a[n - 1], a[n - 2]);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << a[i] << \" \";\n\t}\n}", "4256": "bool checkStr1CanConStr2(string& str1, string& str2)\n{\n\tint N = str1.length();\n\tint M = str2.length();\n\tset<int> st1;\n\tset<int> st2;\n\tint hash1[256] = { 0 };\n\tfor (int i = 0; i < N; i++) {\n\t\thash1[str1[i]]++;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tst1.insert(str1[i]);\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tst2.insert(str2[i]);\n\t}\n\tif (st1 != st2) {\n\t\treturn false;\n\t}\n\tint hash2[256] = { 0 };\n\tfor (int i = 0; i < M; i++) {\n\t\thash2[str2[i]]++;\n\t}\n\tsort(hash1, hash1 + 256);\n\tsort(hash2, hash2 + 256);\n\tfor (int i = 0; i < 256; i++) {\n\t\tif (hash1[i] != hash2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "4305": "int minOperations(int arr1[], int arr2[], int i, int j, int n)\n{\n int f = 0;\n for (int i = 0; i < n; i++)\n {\n\tif (arr1[i] != arr2[i])\n\tf = 1;\n\tbreak;\n }\n if (f == 0)\n\treturn 0;\n if (i >= n j >= n)\n\treturn 0;\n if (arr1[i] < arr2[j])\n\treturn 1 + minOperations(arr1, arr2, i + 1, j + 1, n);\n return max(minOperations(arr1, arr2, i, j + 1, n),\n\t\t\tminOperations(arr1, arr2, i + 1, j, n));\n}\nvoid minOperationsUtil(int arr[], int n)\n{\n int brr[n];\n for (int i = 0; i < n; i++)\n\tbrr[i] = arr[i];\n sort(brr, brr + n);\n int f = 0;\n for (int i = 0; i < n; i++)\n {\n\tif (arr[i] != brr[i])\n\tf = 1;\n\tbreak;\n }\n if (f == 1)\n\tcout << (minOperations(arr, brr, 0, 0, n));\n else\n\tcout << \"0\";\n}", "4307": "int minOperations(int arr[], int n)\n{\n\tvector<pair<int, int>> vect;\n\tfor (int i = 0; i < n; i++) {\n\t\tvect.push_back(make_pair(arr[i], i));\n\t}\n\tsort(vect.begin(), vect.end());\n\tint res = 1;\n\tint streak = 1;\n\tint prev = vect[0].second;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (prev < vect[i].second) {\n\t\t\tres++;\n\t\t\tstreak = max(streak, res);\n\t\t}\n\t\telse\n\t\t\tres = 1;\n\t\tprev = vect[i].second;\n\t}\n\treturn n - streak;\n}", "4310": "void canTransform(string& s, string& t)\n{\n\tint n = s.length();\n\tvector<int> occur[26];\n\tfor (int x = 0; x < n; x++) {\n\t\tchar ch = s[x] - 'a';\n\t\toccur[ch].push_back(x);\n\t}\n\tvector<int> idx(26, 0);\n\tbool poss = true;\n\tfor (int x = 0; x < n; x++) {\n\t\tchar ch = t[x] - 'a';\n\t\tif (idx[ch] >= occur[ch].size()) {\n\t\t\tposs = false;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int small = 0; small < ch; small++) {\n\t\t\tif (idx[small] < occur[small].size() && occur[small][idx[small]] < occur[ch][idx[ch]]) {\n\t\t\t\tposs = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tidx[ch]++;\n\t}\n\tif (poss) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}", "4326": "int getMaxSum(int i, int j, int k, int arr1[], int arr2[], int arr3[])\n{\n\tint cnt = 0;\n\tif (i >= n1)\n\t\tcnt++;\n\tif (j >= n2)\n\t\tcnt++;\n\tif (k >= n3)\n\t\tcnt++;\n\tif (cnt >= 2)\n\t\treturn 0;\n\tif (dp[i][j][k] != -1)\n\t\treturn dp[i][j][k];\n\tint ans = 0;\n\tif (i < n1 && j < n2)\n\t\tans = max(ans,\n\t\t\t\tgetMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j]);\n\tif (i < n1 && k < n3)\n\t\tans = max(ans,\n\t\t\t\tgetMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k]);\n\tif (j < n2 && k < n3)\n\t\tans = max(ans,\n\t\t\t\tgetMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k]);\n\tdp[i][j][k] = ans;\n\treturn dp[i][j][k];\n}\nint maxProductSum(int arr1[], int arr2[], int arr3[])\n{\n\tmemset(dp, -1, sizeof(dp));\n\tsort(arr1, arr1 + n1);\n\treverse(arr1, arr1 + n1);\n\tsort(arr2, arr2 + n2);\n\treverse(arr2, arr2 + n2);\n\tsort(arr3, arr3 + n3);\n\treverse(arr3, arr3 + n3);\n\treturn getMaxSum(0, 0, 0, arr1, arr2, arr3);\n}", "4347": "void findTriplet(int arr[], int N)\n{\n\tsort(arr, arr + N);\n\tint flag = 0, i;\n\tfor (i = N - 1; i - 2 >= 0; i--) {\n\t\tif (arr[i - 2] + arr[i - 1] > arr[i]) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag) {\n\t\tcout << arr[i - 2] << \" \"\n\t\t\t<< arr[i - 1] << \" \"\n\t\t\t<< arr[i] << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n}", "4354": "int inversionCount(string& s)\n{\n\tint freq[26] = { 0 };\n\tint inv = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tint temp = 0;\n\t\tfor (int j = 0; j < int(s[i] - 'a'); j++)\n\t\t\ttemp += freq[j];\n\t\tinv += (i - temp);\n\t\tfreq[s[i] - 'a']++;\n\t}\n\treturn inv;\n}\nbool haveRepeated(string& S1, string& S2)\n{\n\tint freq[26] = { 0 };\n\tfor (char i : S1) {\n\t\tif (freq[i - 'a'] > 0)\n\t\t\treturn true;\n\t\tfreq[i - 'a']++;\n\t}\n\tfor (int i = 0; i < 26; i++)\n\t\tfreq[i] = 0;\n\tfor (char i : S2) {\n\t\tif (freq[i - 'a'] > 0)\n\t\t\treturn true;\n\t\tfreq[i - 'a']++;\n\t}\n\treturn false;\n}\nvoid checkToMakeEqual(string S1, string S2)\n{\n\tint freq[26] = { 0 };\n\tfor (int i = 0; i < S1.length(); i++) {\n\t\tfreq[S1[i] - 'a']++;\n\t}\n\tbool flag = 0;\n\tfor (int i = 0; i < S2.length(); i++) {\n\t\tif (freq[S2[i] - 'a'] == 0) {\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t\tfreq[S2[i] - 'a']--;\n\t}\n\tif (flag == true) {\n\t\tcout << \"No\\n\";\n\t\treturn;\n\t}\n\tint invCount1 = inversionCount(S1);\n\tint invCount2 = inversionCount(S2);\n\tif (invCount1 == invCount2\n\t\t|| (invCount1 & 1) == (invCount2 & 1)\n\t\t|| haveRepeated(S1, S2)) {\n\t\tcout << \"Yes\\n\";\n\t}\n\telse\n\t\tcout << \"No\\n\";\n}", "4357": "int numberofpairs(int arr[], int N)\n{\n\tint answer = 0;\n\tsort(arr, arr + N);\n\tint minDiff = INT_MAX;\n\tfor (int i = 0; i < N - 1; i++)\n\t\tminDiff = min(minDiff, arr[i + 1] - arr[i]);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tif (arr[i + 1] - arr[i] == minDiff)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "4360": "void sortArr(int a[], int n)\n{\n\tint i, k;\n\tk = (int)log2(n);\n\tk = pow(2, k);\n\twhile (k > 0) {\n\t\tfor (i = 0; i + k < n; i++)\n\t\t\tif (a[i] > a[i + k])\n\t\t\t\tswap(a[i], a[i + k]);\n\t\tk = k / 2;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcout << a[i] << \" \";\n\t}\n}", "4362": "void maximumSum(int arr[], int n, int k)\n{\n\tint elt = n / k;\n\tint sum = 0;\n\tsort(arr, arr + n);\n\tint count = 0;\n\tint i = n - 1;\n\twhile (count < k) {\n\t\tsum += arr[i];\n\t\ti--;\n\t\tcount++;\n\t}\n\tcount = 0;\n\ti = 0;\n\twhile (count < k) {\n\t\tsum += arr[i];\n\t\ti += elt - 1;\n\t\tcount++;\n\t}\n\tcout << sum << \"\\n\";\n}", "4369": "int findMinSum(int arr[], int K, int L, int size)\n{\n\tif (K * L > size)\n\t\treturn -1;\n\tint minsum = 0;\n\tsort(arr, arr + size);\n\tfor (int i = 0; i < K; i++)\n\t\tminsum += arr[i];\n\treturn minsum;\n}", "4371": "void find_max_length( vector<int>& arr, int index, int sum, int k)\n{\n\tsum = sum + arr[index];\n\tstore.push_back(arr[index]);\n\tif (sum == k) {\n\t\tif (max_length < store.size()) {\n\t\t\tmax_length = store.size();\n\t\t\tans = store;\n\t\t}\n\t}\n\tfor (int i = index + 1;\n\t\ti < arr.size(); i++) {\n\t\tif (sum + arr[i] <= k) {\n\t\t\tfind_max_length(arr, i, sum, k);\n\t\t\tstore.pop_back();\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\treturn;\n}\nint longestSubsequence(vector<int> arr, int n, int k)\n{\n\tsort(arr.begin(), arr.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (max_length >= n - i)\n\t\t\tbreak;\n\t\tstore.clear();\n\t\tfind_max_length(arr, i, 0, k);\n\t}\n\treturn max_length;\n}", "4378": "int findKthSmallest(int arr[], int n, int k)\n{\n\tint max = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > max)\n\t\t\tmax = arr[i];\n\t}\n\tint counter[max + 1] = { 0 };\n\tint smallest = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcounter[arr[i]]++;\n\t}\n\tfor (int num = 1; num <= max; num++)\n\t{\n\t\tif (counter[num] > 0) {\n\t\t\tsmallest += counter[num];\n\t\t}\n\t\tif (smallest >= k)\n\t\t{\n\t\t\treturn num;\n\t\t}\n\t}\n}", "4385": "void lexNumbers(int n)\n{\n\tvector<string> s;\n\tfor (int i = 1; i <= n; i++) {\n\t\ts.push_back(to_string(i));\n\t}\n\tsort(s.begin(), s.end());\n\tvector<int> ans;\n\tfor (int i = 0; i < n; i++)\n\t\tans.push_back(stoi(s[i]));\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] << \" \";\n}", "4386": "void lexNumbers(int n)\n{\n\tvector<int> sol;\n\tdfs(1, n, sol);\n\tcout << \"[\" << sol[0];\n\tfor (int i = 1; i < sol.size(); i++)\n\tcout << \", \"<< sol[i]; cout << \"]\";\n}\nvoid dfs(int temp, int n, vector<int> &sol)\n{\n\tif (temp > n)\n\t\treturn;\n\tsol.push_back(temp);\n\tdfs(temp * 10, n, sol);\n\tif (temp % 10 != 9)\n\t\tdfs(temp + 1, n, sol);\n}", "4392": "void func(int a[][N])\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i % 2 == 0) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = j + 1; k < N; ++k) {\n\t\t\t\t\tif (a[i][j] > a[i][k]) {\n\t\t\t\t\t\tint temp = a[i][j];\n\t\t\t\t\t\ta[i][j] = a[i][k];\n\t\t\t\t\t\ta[i][k] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = j + 1; k < N; ++k) {\n\t\t\t\t\tif (a[i][j] < a[i][k]) {\n\t\t\t\t\t\tint temp = a[i][j];\n\t\t\t\t\t\ta[i][j] = a[i][k];\n\t\t\t\t\t\ta[i][k] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tprintf(\"%d \", a[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}", "4400": "int partition(int arr[], int l, int h)\n{\n\tint pivot = arr[l];\n\tint i = l + 1;\n\tint j = h;\n\twhile (i <= j) {\n\t\twhile (i <= h && arr[i] < pivot) {\n\t\t\ti++;\n\t\t}\n\t\twhile (j > l && arr[j] > pivot) {\n\t\t\tj--;\n\t\t}\n\t\tif (i < j) {\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[l] = arr[j];\n\tarr[j] = pivot;\n\treturn j;\n}\nvoid sortArray(int arr[], int l, int h)\n{\n\tif (l >= h)\n\t\treturn;\n\tint pivot = partition(arr, l, h);\n\tsortArray(arr, l, pivot - 1);\n\tsortArray(arr, pivot + 1, h);\n}\nint findMaxIntervals(int start[], int end[], int n, int R)\n{\n\tint ans = 0;\n\tint prev = 0;\n\tint currActive = 0;\n\tint i = 0;\n\tint j = 0;\n\tif (start[0] > 0)\n\t\tans++;\n\twhile (i < n && j < n) {\n\t\tif (start[i] < end[j]) {\n\t\t\ti++;\n\t\t\tcurrActive++;\n\t\t}\n\t\telse if (start[i] > end[j]) {\n\t\t\tj++;\n\t\t\tcurrActive--;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tif (currActive == 0) {\n\t\t\tans++;\n\t\t}\n\t}\n\tif (end[n - 1] < R)\n\t\tans++;\n\treturn ans;\n}", "4401": "void sortArray(int A[], int N)\n{\n\tint x, y, z;\n\tif (N % 4 == 0 N % 4 == 1) {\n\t\tfor (int i = 0; i < N / 2; i++) {\n\t\t\tx = i;\n\t\t\tif (i % 2 == 0) {\n\t\t\t\ty = N - i - 2;\n\t\t\t\tz = N - i - 1;\n\t\t\t}\n\t\t\tA[z] = A[y];\n\t\t\tA[y] = A[x];\n\t\t\tA[x] = x + 1;\n\t\t}\n\t\tcout << \"Sorted Array: \";\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcout << A[i] << \" \";\n\t}\n\telse\n\t\tcout << \"-1\";\n}", "4412": "void dfs(int x)\n{\n\tvector<int> v;\n\tv.clear();\n\tns.clear();\n\tfor (int it : s) {\n\t\tif (!g[x][it]) {\n\t\t\tv.push_back(it);\n\t\t}\n\t\telse {\n\t\t\tns.insert(it);\n\t\t}\n\t}\n\ts = ns;\n\tfor (int i : v) {\n\t\tdfs(i);\n\t}\n}\nvoid weightOfMST(int N)\n{\n\tint cnt = 0;\n\tfor (int i = 1; i <= N; ++i) {\n\t\ts.insert(i);\n\t}\n\tfor (; s.size();) {\n\t\t++cnt;\n\t\tint t = *s.begin();\n\t\ts.erase(t);\n\t\tdfs(t);\n\t}\n\tcout << cnt - 1;\n}", "4420": "int countPairs(vector<int> A, vector<int> B)\n{\n\tint n = A.size();\n\tsort(A.begin(),A.end());\n\tsort(B.begin(),B.end());\n\tint ans = 0, i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (A[i] > B[ans]) {\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4455": "bool compare(char arr1[], char arr2[])\n{\n\tfor (int i=0; i<MAX; i++)\n\t\tif (arr1[i] != arr2[i])\n\t\t\treturn false;\n\treturn true;\n}\nbool search(char *pat, char *txt)\n{\n\tint M = strlen(pat), N = strlen(txt);\n\tchar countP[MAX] = {0}, countTW[MAX] = {0};\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\t(countP[pat[i]])++;\n\t\t(countTW[txt[i]])++;\n\t}\n\tfor (int i = M; i < N; i++)\n\t{\n\t\tif (compare(countP, countTW))\n\t\treturn true;\n\t\t(countTW[txt[i]])++;\n\t\tcountTW[txt[i-M]]--;\n\t}\n\tif (compare(countP, countTW))\n\t\treturn true;\n\t\treturn false;\n}", "4459": "int findK(int arr[], int size, int N)\n{\n\tsort(arr, arr + size);\n\tint temp_sum = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\ttemp_sum += arr[i];\n\t\tif (N - temp_sum == arr[i] * (size - i - 1)) {\n\t\t\treturn arr[i];\n\t\t}\n\t}\n\treturn -1;\n}", "4460": "int minimumSwaps(int arr[],int n)\n{\n\tint count = 0;\n\tint i = 0;\n\twhile (i < n)\n\t{\n\t\tif (arr[i] != i + 1)\n\t\t{\n\t\t\twhile (arr[i] != i + 1)\n\t\t\t{\n\t\t\t\tint temp = 0;\n\t\t\t\ttemp = arr[arr[i] - 1];\n\t\t\t\tarr[arr[i] - 1] = arr[i];\n\t\t\t\tarr[i] = temp;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn count;\n}", "4482": "int maxMod(int arr[], int n)\n{\n\tint maxVal = *max_element(arr, arr + n);\n\tint secondMax = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] < maxVal && arr[i] > secondMax) {\n\t\t\tsecondMax = arr[i];\n\t\t}\n\t}\n\treturn secondMax;\n}", "4493": "bool isPossible(int A[], int B[], int n, int m, int x, int y)\n{\n\tif (x > n y > m)\n\t\treturn false;\n\tsort(A, A + n);\n\tsort(B, B + m);\n\tif (A[x - 1] < B[m - y])\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "4507": "int Min_Replace(int arr[], int n, int k)\n{\n\tsort(arr, arr + n);\n\tint freq[MAX];\n\tmemset(freq, 0, sizeof freq);\n\tint p = 0;\n\tfreq[p] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (arr[i] == arr[i - 1])\n\t\t\t++freq[p];\n\t\telse\n\t\t\t++freq[++p];\n\t}\n\tsort(freq, freq + n, greater<int>());\n\tint ans = 0;\n\tfor (int i = k; i <= p; i++)\n\t\tans += freq[i];\n\treturn ans;\n}", "4508": "void append(struct Node** head_ref, int new_data)\n{\n\tstruct Node* new_node\n\t\t= (struct Node*)malloc(sizeof(struct Node));\n\tstruct Node* last = *head_ref;\n\tnew_node->data = new_data;\n\tnew_node->next = NULL;\n\tif (*head_ref == NULL) {\n\t\tnew_node->prev = NULL;\n\t\t*head_ref = new_node;\n\t\treturn;\n\t}\n\twhile (last->next != NULL)\n\t\tlast = last->next;\n\tlast->next = new_node;\n\tnew_node->prev = last;\n\treturn;\n}\nvoid printList(Node* node)\n{\n\tNode* last;\n\twhile (node != NULL) {\n\t\tcout << node->data << \" \";\n\t\tlast = node;\n\t\tnode = node->next;\n\t}\n}\nNode* mergeList(Node* p, Node* q)\n{\n\tNode* s = NULL;\n\tif (p == NULL q == NULL) {\n\t\treturn (p == NULL ? q : p);\n\t}\n\tif (p->data < q->data) {\n\t\tp->prev = s;\n\t\ts = p;\n\t\tp = p->next;\n\t}\n\telse {\n\t\tq->prev = s;\n\t\ts = q;\n\t\tq = q->next;\n\t}\n\tNode* head = s;\n\twhile (p != NULL && q != NULL) {\n\t\tif (p->data < q->data) {\n\t\t\ts->next = p;\n\t\t\tp->prev = s;\n\t\t\ts = s->next;\n\t\t\tp = p->next;\n\t\t}\n\t\telse {\n\t\t\ts->next = q;\n\t\t\tq->prev = s;\n\t\t\ts = s->next;\n\t\t\tq = q->next;\n\t\t}\n\t}\n\tif (p == NULL) {\n\t\ts->next = q;\n\t\tq->prev = s;\n\t}\n\tif (q == NULL) {\n\t\ts->next = p;\n\t\tp->prev = s;\n\t}\n\treturn head;\n}\nNode* mergeAllList(Node* head[], int k)\n{\n\tNode* finalList = NULL;\n\tfor (int i = 0; i < k; i++) {\n\t\tfinalList = mergeList(finalList, head[i]);\n\t}\n\treturn finalList;\n}", "4510": "int Segment(int x[], int l[], int n)\n{\n\tif (n == 1)\n\t\treturn 1;\n\tint ans = 2;\n\tfor (int i = 1; i < n - 1; i++)\n\t{\n\t\tif (x[i] - l[i] > x[i - 1])\n\t\t\tans++;\n\t\telse if (x[i] + l[i] < x[i + 1])\n\t\t{\n\t\t\tx[i] = x[i] + l[i];\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4529": "bool existsTriplet(int a[], int b[], int c[], int x, int l1, int l2, int l3)\n{\n\tif (l2 <= l1 and l2 <= l3)\n\t\tswap(l2, l1), swap(a, b);\n\telse if (l3 <= l1 and l3 <= l2)\n\t\tswap(l3, l1), swap(a, c);\n\tfor (int i = 0; i < l1; i++) {\n\t\tint j = 0, k = l3 - 1;\n\t\twhile (j < l2 and k >= 0) {\n\t\t\tif (a[i] + b[j] + c[k] == x)\n\t\t\t\treturn true;\n\t\t\tif (a[i] + b[j] + c[k] < x)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tk--;\n\t\t}\n\t}\n\treturn false;\n}", "4570": "int MinimizeleftOverSum(int a[], int n)\n{\n\tvector<int> v1, v2;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] % 2)\n\t\t\tv1.push_back(a[i]);\n\t\telse\n\t\t\tv2.push_back(a[i]);\n\t}\n\tif (v1.size() > v2.size()) {\n\t\tsort(v1.begin(), v1.end());\n\t\tsort(v2.begin(), v2.end());\n\t\tint x = v1.size() - v2.size() - 1;\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile (i < x) {\n\t\t\tsum += v1[i++];\n\t\t}\n\t\treturn sum;\n\t}\n\telse if (v2.size() > v1.size()) {\n\t\tsort(v1.begin(), v1.end());\n\t\tsort(v2.begin(), v2.end());\n\t\tint x = v2.size() - v1.size() - 1;\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile (i < x) {\n\t\t\tsum += v2[i++];\n\t\t}\n\t\treturn sum;\n\t}\n\telse\n\t\treturn 0;\n}", "4578": "void printArr(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tcout << arr[i];\n}\nbool compare(int num1, int num2)\n{\n\tstring A = to_string(num1);\n\tstring B = to_string(num2);\n\treturn (A + B) <= (B + A);\n}\nvoid printSmallest(int N, int arr[])\n{\n\tsort(arr, arr + N, compare);\n\tprintArr(arr, N);\n}", "4585": "float getMaxMedian(int arr[], int n, int k)\n{\n\tint size = n + k;\n\tsort(arr, arr + n);\n\tif (size % 2 == 0) {\n\t\tfloat median = (float)(arr[(size / 2) - 1] + arr[size / 2])\n\t\t\t\t\t/ 2;\n\t\treturn median;\n\t}\n\tfloat median = arr[size / 2];\n\treturn median;\n}", "4591": "void minOperation(string S, int N, int K)\n{\n\tif (N % K) {\n\t\tcout << \"Not Possible\" << endl;\n\t\treturn;\n\t}\n\tint count[26] = { 0 };\n\tfor (int i = 0; i < N; i++) {\n\t\tcount[S[i] - 97]++;\n\t}\n\tint E = N / K;\n\tvector<int> greaterE;\n\tvector<int> lessE;\n\tfor (int i = 0; i < 26; i++) {\n\t\tif (count[i] < E)\n\t\t\tlessE.push_back(E - count[i]);\n\t\telse\n\t\t\tgreaterE.push_back(count[i] - E);\n\t}\n\tsort(greaterE.begin(), greaterE.end());\n\tsort(lessE.begin(), lessE.end());\n\tint mi = INT_MAX;\n\tfor (int i = 0; i <= K; i++) {\n\t\tint set1 = i;\n\t\tint set2 = K - i;\n\t\tif (greaterE.size() >= set1 && lessE.size() >= set2) {\n\t\t\tint step1 = 0;\n\t\t\tint step2 = 0;\n\t\t\tfor (int j = 0; j < set1; j++)\n\t\t\t\tstep1 += greaterE[j];\n\t\t\tfor (int j = 0; j < set2; j++)\n\t\t\t\tstep2 += lessE[j];\n\t\t\tmi = min(mi, max(step1, step2));\n\t\t}\n\t}\n\tcout << mi << endl;\n}", "4620": "void partSort(int arr[], int N, int a, int b)\n{\n\tint l = min(a, b);\n\tint r = max(a, b);\n\tint temp[r - l + 1];\n\tint j = 0;\n\tfor (int i = l; i <= r; i++) {\n\t\ttemp[j] = arr[i];\n\t\tj++;\n\t}\n\tsort(temp, temp + r - l + 1);\n\tj = 0;\n\tfor (int i = l; i <= r; i++) {\n\t\t\tarr[i] = temp[j];\n\t\t\tj++;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\t\tcout << arr[i] << \" \" ;\n\t\t}\n}", "4621": "void partSort(int arr[], int N, int a, int b)\n\t{\n\t\tint l = min(a, b);\n\t\tint r = max(a, b);\n\t\tvector<int> v(arr, arr + N);\n\t\tsort(v.begin() + l, v.begin() + r + 1);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcout << v[i] << \" \";\n\t}", "4622": "int minMovesToSort(int arr[], int n)\n{\n\tint moves = 0;\n\tint i, mn = arr[n - 1];\n\tfor (i = n - 2; i >= 0; i--) {\n\t\tif (arr[i] > mn)\n\t\t\tmoves += arr[i] - mn;\n\t}\n\treturn moves;\n}", "4624": "void sortByRow(int mat[][MAX_SIZE], int n, bool descending)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tif (descending == true)\n\t\t\tsort(mat[i], mat[i] + n, greater<int>());\n\t\telse\n\t\t\tsort(mat[i], mat[i] + n);\n\t}\n}\nvoid transpose(int mat[][MAX_SIZE], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tswap(mat[i][j], mat[j][i]);\n}\nvoid sortMatRowAndColWise(int mat[][MAX_SIZE], int n)\n{\n\tsortByRow(mat, n, true);\n\ttranspose(mat, n);\n\tsortByRow(mat, n, false);\n\ttranspose(mat, n);\n}\nvoid printMat(int mat[][MAX_SIZE], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tcout << mat[i][j] << \" \";\n\t\tcout << endl;\n\t}\n}", "4648": "void SieveOfEratosthenes(int n)\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[1] = false;\n\tfor (int p = 2; p * p <= n; p++) {\n\t\tif (prime[p]) {\n\t\t\tfor (int i = p * 2; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n}\nvoid sortPrimes(int arr[], int n)\n{\n\tSieveOfEratosthenes(100005);\n\tvector<int> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (prime[arr[i]])\n\t\t\tv.push_back(arr[i]);\n\t}\n\tsort(v.begin(), v.end(), greater<int>());\n\tint j = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (prime[arr[i]])\n\t\t\tarr[i] = v[j++];\n\t}\n}", "4701": "void findOptimalPairs(int arr[], int N)\n{\n\tsort(arr, arr + N);\n\tfor (int i = 0, j = N - 1; i <= j; i++, j--)\n\t\tcout << \"(\" << arr[i] << \", \" << arr[j] << \")\" << \" \";\n}", "4740": "void stableSelectionSort(int a[], int n)\n{\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint min = i;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (a[min] > a[j])\n\t\t\t\tmin = j;\n\t\tint key = a[min];\n\t\twhile (min > i)\n\t\t{\n\t\t\ta[min] = a[min - 1];\n\t\t\tmin--;\n\t\t}\n\t\ta[i] = key;\n\t}\n}\nvoid printArray(int a[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tcout << a[i] << \" \";\n\tcout << endl;\n}", "4762": "int minIndex(int a[], int i, int j)\n{\n\tif (i == j)\n\t\treturn i;\n\tint k = minIndex(a, i + 1, j);\n\treturn (a[i] < a[k])? i : k;\n}\nvoid recurSelectionSort(int a[], int n, int index = 0)\n{\n\tif (index == n)\n\treturn;\n\tint k = minIndex(a, index, n-1);\n\tif (k != index)\n\t\t\tswap(a[k], a[index]);\n\trecurSelectionSort(a, n, index + 1);\n}", "4783": "void printSorted(int a, int b, int c)\n{\n\tint get_max = max(a, max(b, c));\n\tint get_min = -max(-a, max(-b, -c));\n\tint get_mid = (a + b + c)\n\t\t\t\t- (get_max + get_min);\n\tcout << get_min << \" \" << get_mid\n\t\t<< \" \" << get_max;\n}", "4786": "void insertionSortRecursive(int arr[], int n)\n{\n\tif (n <= 1)\n\t\treturn;\n\tinsertionSortRecursive( arr, n-1 );\n\tint last = arr[n-1];\n\tint j = n-2;\n\twhile (j >= 0 && arr[j] > last)\n\t{\n\t\tarr[j+1] = arr[j];\n\t\tj--;\n\t}\n\tarr[j+1] = last;\n}\nvoid printArray(int arr[], int n)\n{\n\tfor (int i=0; i < n; i++)\n\t\tcout << arr[i] <<\" \";\n}", "4793": "void bubbleSort(int arr[], int n)\n{\n\tif (n == 1)\n\t\treturn;\n\tfor (int i=0; i<n-1; i++)\n\t\tif (arr[i] > arr[i+1])\n\t\t\tswap(arr[i], arr[i+1]);\n\tbubbleSort(arr, n-1);\n}\nvoid printArray(int arr[], int n)\n{\n\tfor (int i=0; i < n; i++)\n\t\tprintf(\"%d \", arr[i]);\n\tprintf(\"\\n\");\n}", "4804": "bool isPossible(int a[], int b[], int n, int k)\n{\n\tsort(a, a + n);\n\tsort(b, b + n, greater<int>());\n\tfor (int i = 0; i < n; i++)\n\t\tif (a[i] + b[i] < k)\n\t\t\treturn false;\n\treturn true;\n}", "4817": "int countBits(int a)\n{\n\tint count = 0;\n\twhile (a)\n\t{\n\t\tif (a & 1 )\n\t\t\tcount+= 1;\n\t\ta = a>>1;\n\t}\n\treturn count;\n}\nvoid insertionSort(int arr[],int aux[], int n)\n{\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint key1 = aux[i];\n\t\tint key2 = arr[i];\n\t\tint j = i-1;\n\t\twhile (j >= 0 && aux[j] < key1)\n\t\t{\n\t\t\taux[j+1] = aux[j];\n\t\t\tarr[j+1] = arr[j];\n\t\t\tj = j-1;\n\t\t}\n\t\taux[j+1] = key1;\n\t\tarr[j+1] = key2;\n\t}\n}\nvoid sortBySetBitCount(int arr[],int n)\n{\n\tint aux[n];\n\tfor (int i=0; i<n; i++)\n\t\taux[i] = countBits(arr[i]);\n\tinsertionSort(arr, aux, n);\n}\nvoid printArr(int arr[], int n)\n{\n\tfor (int i=0; i<n; i++)\n\t\tcout << arr[i] << \" \";\n}", "4819": "int countBits(int a)\n{\n\tint count = 0;\n\twhile (a)\n\t{\n\t\tif (a & 1 )\n\t\t\tcount+= 1;\n\t\ta = a>>1;\n\t}\n\treturn count;\n}\nvoid sortBySetBitCount(int arr[],int n)\n{\n\tvector<vector<int> > count(32);\n\tint setbitcount = 0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tsetbitcount = countBits(arr[i]);\n\t\tcount[setbitcount].push_back(arr[i]);\n\t}\n\tfor (int i=31; i>=0; i--)\n\t{\n\t\tvector<int> v1 = count[i];\n\t\tfor (int i=0; i<v1.size(); i++)\n\t\t\tarr[j++] = v1[i];\n\t}\n}\nvoid printArr(int arr[], int n)\n{\n\tfor (int i=0; i<n; i++)\n\t\tcout << arr[i] << \" \";\n}", "4820": "int setBitCount(int num){\n\tint count = 0;\n\twhile ( num )\n\t{\n\t\tif ( num & 1)\n\t\tcount++;\n\t\tnum >>= 1;\n\t}\n\treturn count;\n}\nvoid sortBySetBitCount(int arr[], int n)\n{ \n\tmultimap< int, int > count;\n\tfor( int i = 0 ; i < n ; ++i )\n\t{\n\t\tcount.insert({(-1) *\n\t\t\tsetBitCount(arr[i]), arr[i]});\n\t}\n\tfor(auto i : count)\n\tcout << i.second << \" \" ;\n\tcout << \"\\n\" ;\n}", "4847": "int binarySearch(int a[], int item, int low, int high)\n{\n\twhile (low <= high) {\n\t\tint mid = low + (high - low) / 2;\n\t\tif (item == a[mid])\n\t\t\treturn mid + 1;\n\t\telse if (item > a[mid])\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn low;\n}\nvoid insertionSort(int a[], int n)\n{\n\tint i, loc, j, k, selected;\n\tfor (i = 1; i < n; ++i) {\n\t\tj = i - 1;\n\t\tselected = a[i];\n\t\tloc = binarySearch(a, selected, 0, j);\n\t\twhile (j >= loc) {\n\t\t\ta[j + 1] = a[j];\n\t\t\tj--;\n\t\t}\n\t\ta[j + 1] = selected;\n\t}\n}", "4855": "void insertionSort(int arr[], int n)\n{\n\tint i, key, j;\n\tfor (i = 1; i < n; i++)\n\t{\n\t\tkey = arr[i];\n\t\tj = i - 1;\n\t\twhile (j >= 0 && arr[j] > key)\n\t\t{\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\tarr[j + 1] = key;\n\t}\n}\nvoid printArray(int arr[], int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tcout << arr[i] << \" \";\n\tcout << endl;\n}", "4859": "bool canReach(string s, int L, int R)\n{\n\tvector<int> dp(s.length());\n\tdp[0] = 1;\n\tint pre = 0;\n\tfor (int i = 1; i < s.length(); i++) {\n\t\tif (i >= L) {\n\t\t\tpre += dp[i - L];\n\t\t}\n\t\tif (i > R) {\n\t\t\tpre -= dp[i - R - 1];\n\t\t}\n\t\tdp[i] = (pre > 0) and (s[i] == '0');\n\t}\n\treturn dp[s.length() - 1];\n}", "4889": "void generateString(int k1, int k2, string s)\n{\n\tint C1s = 0, C0s = 0;\n\tint flag = 0;\n\tvector<int> pos;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (s[i] == '0') {\n\t\t\tC0s++;\n\t\t\tif ((i + 1) % k1 != 0\n\t\t\t\t&& (i + 1) % k2 != 0) {\n\t\t\t\tpos.push_back(i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tC1s++;\n\t\t}\n\t\tif (C0s >= C1s) {\n\t\t\tif (pos.size() == 0) {\n\t\t\t\tcout << -1;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint k = pos.back();\n\t\t\t\ts[k] = '1';\n\t\t\t\tC0s--;\n\t\t\t\tC1s++;\n\t\t\t\tpos.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\tcout << s;\n\t}\n}", "4893": "void maximizeProduct(int N)\n{\n\tint MSB = (int)log2(N);\n\tint X = 1 << MSB;\n\tint Y = N - (1 << MSB);\n\tfor (int i = 0; i < MSB; i++) {\n\t\tif (!(N & (1 << i))) {\n\t\t\tX += 1 << i;\n\t\t\tY += 1 << i;\n\t\t}\n\t}\n\tcout << X << \" \" << Y;\n}", "4899": "bool check(int num)\n{\n\tint sm = 0;\n\tint num2 = num * num;\n\twhile (num) {\n\t\tsm += num % 10;\n\t\tnum /= 10;\n\t}\n\tint sm2 = 0;\n\twhile (num2) {\n\t\tsm2 += num2 % 10;\n\t\tnum2 /= 10;\n\t}\n\treturn ((sm * sm) == sm2);\n}\nint convert(string s)\n{\n\tint val = 0;\n\treverse(s.begin(), s.end());\n\tint cur = 1;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tval += (s[i] - '0') * cur;\n\t\tcur *= 10;\n\t}\n\treturn val;\n}\nvoid generate(string s, int len, set<int>& uniq)\n{\n\tif (s.size() == len) {\n\t\tif (check(convert(s))) {\n\t\t\tuniq.insert(convert(s));\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= 3; i++) {\n\t\tgenerate(s + char(i + '0'), len, uniq);\n\t}\n}\nint totalNumbers(int L, int R)\n{\n\tint ans = 0;\n\tint max_len = log10(R) + 1;\n\tset<int> uniq;\n\tfor (int i = 1; i <= max_len; i++) {\n\t\tgenerate(\"\", i, uniq);\n\t}\n\tfor (auto x : uniq) {\n\t\tif (x >= L && x <= R) {\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4906": "int maxSumAfterPartition(int arr[], int n)\n{\n\tvector<int> pos;\n\tvector<int> neg;\n\tint zero = 0;\n\tint pos_sum = 0;\n\tint neg_sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tpos.push_back(arr[i]);\n\t\t\tpos_sum += arr[i];\n\t\t}\n\t\telse if (arr[i] < 0) {\n\t\t\tneg.push_back(arr[i]);\n\t\t\tneg_sum += arr[i];\n\t\t}\n\t\telse {\n\t\t\tzero++;\n\t\t}\n\t}\n\tint ans = 0;\n\tsort(pos.begin(), pos.end());\n\tsort(neg.begin(), neg.end(), greater<int>());\n\tif (pos.size() > 0 && neg.size() > 0) {\n\t\tans = (pos_sum - neg_sum);\n\t}\n\telse if (pos.size() > 0) {\n\t\tif (zero > 0) {\n\t\t\tans = (pos_sum);\n\t\t}\n\t\telse {\n\t\t\tans = (pos_sum - 2 * pos[0]);\n\t\t}\n\t}\n\telse {\n\t\tif (zero > 0) {\n\t\t\tans = (-1 * neg_sum);\n\t\t}\n\t\telse {\n\t\t\tans = (neg[0] - (neg_sum - neg[0]));\n\t\t}\n\t}\n\treturn ans;\n}", "4916": "int validPermutations(string str)\n{\n\tunordered_map<char, int> m;\n\tint count = str.length(), ans = 0;\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tm[str[i]]++;\n\t}\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tans += count - m[str[i]];\n\t\tm[str[i]]--;\n\t\tcount--;\n\t}\n\treturn ans + 1;\n}", "4961": "int num_candyTypes(vector<int>& candies)\n{\n\tunordered_set<int> s;\n\tfor (int i = 0; i < candies.size(); i++) {\n\t\ts.insert(candies[i]);\n\t}\n\treturn s.size();\n}\nvoid distribute_candies(vector<int>& candies)\n{\n\tint allowed = candies.size() / 2;\n\tint types = num_candyTypes(candies);\n\tif (types < allowed)\n\t\tcout << types;\n\telse\n\t\tcout << allowed;\n}", "4962": "void convertXintoY(int X, int Y)\n{\n\twhile (Y > X) {\n\t\tif (Y % 2 == 0)\n\t\t\tY /= 2;\n\t\telse if (Y % 10 == 1)\n\t\t\tY /= 10;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (X == Y)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}", "4964": "int maxXORUtil(int arr[], int N, int xrr, int orr)\n{\n\tif (N == 0)\n\t\treturn xrr ^ orr;\n\tint x = maxXORUtil(arr, N - 1, xrr ^ orr, arr[N - 1]);\n\tint y = maxXORUtil(arr, N - 1, xrr, orr arr[N - 1]);\n\treturn max(x, y);\n}\nint maximumXOR(int arr[], int N)\n{\n\treturn maxXORUtil(arr, N, 0, 0);\n}", "4965": "int MaxXOR(int arr[], int N)\n{\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tres |= arr[i];\n\t}\n\treturn res;\n}", "4989": "void generateString(int K)\n{\n\tstring s = \"\";\n\tfor (int i = 97; i < 97 + K; i++) {\n\t\ts = s + char(i);\n\t\tfor (int j = i + 1; j < 97 + K; j++) {\n\t\t\ts += char(i);\n\t\t\ts += char(j);\n\t\t}\n\t}\n\ts += char(97);\n\tcout << s;\n}", "4990": "int countEqual(int A[], int B[], int N)\n{\n\tint first = 0;\n\tint second = N - 1;\n\tint count = 0;\n\twhile (first < N && second >= 0) {\n\t\tif (A[first] < B[second]) {\n\t\t\tfirst++;\n\t\t}\n\t\telse if (B[second] < A[first]) {\n\t\t\tsecond--;\n\t\t}\n\t\telse {\n\t\t\tcount++;\n\t\t\tfirst++;\n\t\t\tsecond--;\n\t\t}\n\t}\n\treturn count;\n}", "5016": "void findEquation(int S, int M)\n{\n\tcout << \"1 \" << (-1) * S << \" \"\n\t\t<< M << endl;\n}", "5030": "bool isPalindrome(int N)\n{\n\tint temp = N;\n\tint res = 0;\n\twhile (temp != 0) {\n\t\tint rem = temp % 10;\n\t\tres = res * 10 + rem;\n\t\ttemp /= 10;\n\t}\n\tif (res == N) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint sumOfDigits(int N)\n{\n\tint sum = 0;\n\twhile (N != 0) {\n\t\tsum += N % 10;\n\t\tN /= 10;\n\t}\n\treturn sum;\n}\nbool isPrime(int n)\n{\n\tif (n <= 1) {\n\t\treturn false;\n\t}\n\tfor (int i = 2; i <= n / 2; ++i) {\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvoid precompute()\n{\n\tfor (int i = 1; i <= 100000; i++) {\n\t\tif (isPalindrome(i)) {\n\t\t\tint sum = sumOfDigits(i);\n\t\t\tif (isPrime(sum))\n\t\t\t\tarr[i] = 1;\n\t\t\telse\n\t\t\t\tarr[i] = 0;\n\t\t}\n\t\telse\n\t\t\tarr[i] = 0;\n\t}\n\tfor (int i = 1; i <= 100000; i++) {\n\t\tarr[i] = arr[i] + arr[i - 1];\n\t}\n}\nvoid countNumbers(int Q[][2], int N)\n{\n\tprecompute();\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << (arr[Q[i][1]] - arr[Q[i][0] - 1]);\n\t\tcout << endl;\n\t}\n}", "5038": "int minSteps(vector<int> a, int n)\n{\n\tvector<int> prefix_sum(n);\n\tprefix_sum[0] = a[0];\n\tfor (int i = 1; i < n; i++)\n\t\tprefix_sum[i] += prefix_sum[i - 1] + a[i];\n\tint mx = -1;\n\tfor (int subgroupsum :prefix_sum)\n\t{\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\tint grp_count = 0;\n\t\twhile (i < n)\n\t\t{\n\t\t\tsum += a[i];\n\t\t\tif (sum == subgroupsum)\n\t\t\t{\n\t\t\t\tgrp_count += 1;\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\telse if(sum > subgroupsum)\n\t\t\t{\n\t\t\t\tgrp_count = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t\tif (grp_count > mx)\n\t\t\tmx = grp_count;\n\t}\n\treturn n - mx;\n}", "5056": "void maxOccuringCharacter(string s)\n{\n\tint count0 = 0, count1 = 0;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (s[i] == '1') {\n\t\t\tcount1++;\n\t\t}\n\t\telse if (s[i] == '0') {\n\t\t\tcount0++;\n\t\t}\n\t}\n\tint prev = -1;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (s[i] == '1') {\n\t\t\tprev = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = prev + 1; i < s.length(); i++) {\n\t\tif (s[i] != 'X') {\n\t\t\tif (s[i] == '1') {\n\t\t\t\tcount1 += i - prev - 1;\n\t\t\t\tprev = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int j = i + 1; j < s.length(); j++) {\n\t\t\t\t\tif (s[j] == '1') {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tprev = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) {\n\t\t\t\t\ti = prev;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti = s.length();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprev = -1;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (s[i] == '0') {\n\t\t\tprev = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = prev + 1; i < s.length(); i++) {\n\t\tif (s[i] != 'X') {\n\t\t\tif (s[i] == '0') {\n\t\t\t\tcount0 += i - prev - 1;\n\t\t\t\tprev = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int j = i + 1; j < s.length(); j++) {\n\t\t\t\t\tif (s[j] == '0') {\n\t\t\t\t\t\tprev = j;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) {\n\t\t\t\t\ti = prev;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti = s.length();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (s[0] == 'X') {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile (s[i] == 'X') {\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}\n\t\tif (s[i] == '1') {\n\t\t\tcount1 += count;\n\t\t}\n\t}\n\tif (s[(s.length() - 1)] == 'X') {\n\t\tint count = 0;\n\t\tint i = s.length() - 1;\n\t\twhile (s[i] == 'X') {\n\t\t\tcount++;\n\t\t\ti--;\n\t\t}\n\t\tif (s[i] == '0') {\n\t\t\tcount0 += count;\n\t\t}\n\t}\n\tif (count0 == count1) {\n\t\tcout << \"X\" << endl;\n\t}\n\telse if (count0 > count1) {\n\t\tcout << 0 << endl;\n\t}\n\telse\n\t\tcout << 1 << endl;\n}", "5062": "void winner(int arr[], int N)\n{\n\tif (N % 2 == 1) {\n\t\tcout << \"A\";\n\t}\n\telse {\n\t\tcout << \"B\";\n\t}\n}", "5090": "int maxSheets(int A, int B)\n{\n\tint area = A * B;\n\tint count = 1;\n\twhile (area % 2 == 0) {\n\t\tarea /= 2;\n\t\tcount *= 2;\n\t}\n\treturn count;\n}", "5093": "void findMinMoves(int a, int b)\n{\n\tint ans = 0;\n\tif (a == b || abs(a - b) == 1) {\n\t\tans = a + b;\n\t}\n\telse {\n\t\tint k = min(a, b);\n\t\tint j = max(a, b);\n\t\tans = 2 * k + 2 * (j - k) - 1;\n\t}\n\tcout << ans;\n}", "5102": "long long cntEvenSumPairs(long long X, long long Y)\n{\n\tlong long cntXEvenNums = X / 2;\n\tlong long cntXOddNums = (X + 1) / 2;\n\tlong long cntYEvenNums = Y / 2;\n\tlong long cntYOddNums = (Y + 1) / 2;\n\tlong long cntPairs\n\t\t= (cntXEvenNums * 1LL * cntYEvenNums)\n\t\t+ (cntXOddNums * 1LL * cntYOddNums);\n\treturn cntPairs;\n}", "5118": "int minMoves(vector<int> arr)\n{\n\tint N = arr.size();\n\tif (N <= 2)\n\t\treturn 0;\n\tint ans = INT_MAX;\n\tfor (int i = -1; i <= 1; i++) {\n\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\tint num1 = arr[0] + i;\n\t\t\tint num2 = arr[1] + j;\n\t\t\tint flag = 1;\n\t\t\tint moves = abs(i) + abs(j);\n\t\t\tfor (int idx = 2; idx < N; idx++) {\n\t\t\t\tint num = num1 + num2;\n\t\t\t\tif (abs(arr[idx] - num) > 1)\n\t\t\t\t\tflag = 0;\n\t\t\t\telse\n\t\t\t\t\tmoves += abs(arr[idx] - num);\n\t\t\t\tnum1 = num2;\n\t\t\t\tnum2 = num;\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tans = min(ans, moves);\n\t\t}\n\t}\n\tif (ans == INT_MAX)\n\t\treturn -1;\n\treturn ans;\n}", "5119": "void querySum(int arr[], int N, int Q[][2], int M)\n{\n\tfor (int i = 0; i < M; i++) {\n\t\tint x = Q[i][0];\n\t\tint y = Q[i][1];\n\t\tint sum = 0;\n\t\twhile (x < N) {\n\t\t\tsum += arr[x];\n\t\t\tx += y;\n\t\t}\n\t\tcout << sum << \" \";\n\t}\n}", "5120": "void precomputeExpressionForAllVal(int arr[], int N, int dp[sz][sqr])\n{\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tfor (int j = 1; j <= sqrt(N); j++) {\n\t\t\tif (i + j < N) {\n\t\t\t\tdp[i][j] = arr[i] + dp[i + j][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint querySum(int arr[], int N, int Q[][2], int M)\n{\n\tint dp[sz][sqr];\n\tprecomputeExpressionForAllVal(arr, N, dp);\n\tfor (int i = 0; i < M; i++) {\n\t\tint x = Q[i][0];\n\t\tint y = Q[i][1];\n\t\tif (y <= sqrt(N)) {\n\t\t\tcout << dp[x][y] << \" \";\n\t\t\tcontinue;\n\t\t}\n\t\tint sum = 0;\n\t\twhile (x < N) {\n\t\t\tsum += arr[x];\n\t\t\tx += y;\n\t\t}\n\t\tcout << sum << \" \";\n\t}\n}", "5167": "void construct_tree(int weights[], int n)\n{\n\tint minimum = *min_element(weights, weights + n);\n\tint maximum = *max_element(weights, weights + n);\n\tif (minimum == maximum) {\n\t\tcout << \"No\";\n\t\treturn;\n\t}\n\telse {\n\t\tcout << \"Yes\" << endl;\n\t}\n\tint root = weights[0];\n\tvisited[1] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (weights[i] != root && visited[i + 1] == 0) {\n\t\t\tcout << 1 << \" \"\n\t\t\t\t<< i + 1 << \" \"\n\t\t\t\t<< endl;\n\t\t\tvisited[i + 1] = 1;\n\t\t}\n\t}\n\tint notroot = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (weights[i] != root) {\n\t\t\tnotroot = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (weights[i] == root && visited[i + 1] == 0) {\n\t\t\tcout << notroot << \" \"\n\t\t\t\t<< i + 1 << endl;\n\t\t\tvisited[i + 1] = 1;\n\t\t}\n\t}\n}", "5170": "int findBitwiseORGivenXORAND(int X, int Y)\n{\n\treturn X + Y;\n}", "5198": "int GCD(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn GCD(b, a % b);\n}\nvoid canReach(int N, int A, int B, int K)\n{\n\tint gcd = GCD(N, K);\n\tif (abs(A - B) % gcd == 0) {\n\t\tcout << \"Yes\";\n\t}\n\telse {\n\t\tcout << \"No\";\n\t}\n}", "5199": "int sum(int n)\n{\n\tint res = 0;\n\twhile (n > 0) {\n\t\tres += n % 10;\n\t\tn /= 10;\n\t}\n\treturn res;\n}\nint smallestNumber(int n, int s)\n{\n\tif (sum(n) <= s) {\n\t\treturn n;\n\t}\n\tint ans = n, k = 1;\n\tfor (int i = 0; i < 9; ++i) {\n\t\tint digit = (ans / k) % 10;\n\t\tint add = k * ((10 - digit) % 10);\n\t\tans += add;\n\t\tif (sum(ans) <= s) {\n\t\t\tbreak;\n\t\t}\n\t\tk *= 10;\n\t}\n\treturn ans;\n}", "5218": "int countOfSubarray(int arr[], int N)\n{\n\tunordered_map<int, int> mp;\n\tint answer = 0;\n\tint sum = 0;\n\tmp[1]++;\n\tfor (int i = 0; i < N; i++) {\n\t\tsum += arr[i];\n\t\tanswer += mp[sum - i];\n\t\tmp[sum - i]++;\n\t}\n\tcout << answer;\n}", "5227": "void minCost(string s, int k)\n{\n\tint n = s.size();\n\tint ans = 0;\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tint a[26];\n\t\tfor(int p = 0; p < 26; p++)\n\t\t{\n\t\t\ta[p] = 0;\n\t\t}\n\t\tfor(int j = i; j < n; j += k)\n\t\t{\n\t\t\ta[s[j] - 'a']++;\n\t\t}\n\t\tint min_cost = INT_MAX;\n\t\tfor(int ch = 0; ch < 26; ch++)\n\t\t{\n\t\t\tint cost = 0;\n\t\t\tfor(int tr = 0; tr < 26; tr++)\n\t\t\t\tcost += abs(ch - tr) * a[tr];\n\t\t\tmin_cost = min(min_cost, cost);\n\t\t}\n\t\tans += min_cost;\n\t}\n\tcout << (ans);\n}", "5233": "int minAbsDiff(int N)\n{\n\tint sumSet1 = 0;\n\tint sumSet2 = 0;\n\tfor (int i = N; i > 0; i--) {\n\t\tif (sumSet1 <= sumSet2) {\n\t\t\tsumSet1 += i;\n\t\t}\n\t\telse {\n\t\t\tsumSet2 += i;\n\t\t}\n\t}\n\treturn abs(sumSet1 - sumSet2);\n}", "5234": "int minAbsDiff(int N)\n{\n\tif (N % 4 == 0 N % 4 == 3) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "5250": "bool checkDigits(int n)\n{\n\tdo {\n\t\tint r = n % 10;\n\t\tif (r == 3 r == 4 r == 6 r == 7 r == 9)\n\t\t\treturn false;\n\t\tn /= 10;\n\t} while (n != 0);\n\treturn true;\n}\nbool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint isAllPrime(int n)\n{\n\treturn isPrime(n)\n\t\t&& checkDigits(n);\n}", "5262": "int maximumSubarrays(int arr[], int N, int target)\n{\n\tint ans = 0;\n\tint availIdx = -1;\n\tint cur_sum = 0;\n\tunordered_map<int, int> mp;\n\tmp[0] = -1;\n\tfor (int i = 0; i < N; i++) {\n\t\tcur_sum += arr[i];\n\t\tif (mp.find(cur_sum - target)\n\t\t\t\t!= mp.end() && mp[cur_sum - target] >= availIdx) {\n\t\t\tans++;\n\t\t\tavailIdx = i;\n\t\t}\n\t\tmp[cur_sum] = i;\n\t}\n\treturn ans;\n}", "5291": "int getMinOps(int arr[], int n)\n{\n\tint res = 0;\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tres += max(arr[i + 1] - arr[i], 0);\n\t}\n\treturn res;\n}", "5310": "void minCost(string str, int a, int b)\n{\n\tint openUnbalanced = 0;\n\tint closedUnbalanced = 0;\n\tint openCount = 0;\n\tint closedCount = 0;\n\tfor (int i = 0; str[i] != '\\0'; i++) {\n\t\tif (str[i] == '(') {\n\t\t\topenUnbalanced++;\n\t\t\topenCount++;\n\t\t}\n\t\telse {\n\t\t\tif (openUnbalanced == 0)\n\t\t\t\tclosedUnbalanced++;\n\t\t\telse\n\t\t\t\topenUnbalanced--;\n\t\t\tclosedCount++;\n\t\t}\n\t}\n\tint result = a * (abs(openCount - closedCount));\n\tif (closedCount > openCount)\n\t\tclosedUnbalanced\n\t\t\t-= (closedCount - openCount);\n\tif (openCount > closedCount)\n\t\topenUnbalanced\n\t\t\t-= (openCount - closedCount);\n\tresult += min(a * (openUnbalanced + closedUnbalanced), b * closedUnbalanced);\n\tcout << result << endl;\n}", "5322": "int countEvenSum(int low, int high, int k)\n{\n\tint even_count = high / 2 - (low - 1) / 2;\n\tint odd_count = (high + 1) / 2 - low / 2;\n\tlong even_sum = 1;\n\tlong odd_sum = 0;\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tlong prev_even = even_sum;\n\t\tlong prev_odd = odd_sum;\n\t\teven_sum = (prev_even * even_count) +\n\t\t\t\t\t(prev_odd * odd_count);\n\t\todd_sum = (prev_even * odd_count) +\n\t\t\t\t(prev_odd * even_count);\n\t}\n\tcout << (even_sum);\n}", "5329": "double Length_Diagonals(int a, double theta)\n{\n\tdouble p = a * sqrt(2 + (2 * cos(\n\t\ttheta * (3.141 / 180))));\n\tdouble q = a * sqrt(2 - (2 * cos(\n\t\ttheta * (3.141 / 180))));\n\tcout << fixed << setprecision(2) << p\n\t\t<< \" \" << q;\n}", "5333": "void AddEdge(int u, int v)\n{\n\tadj[u].push_back(v);\n\tadj[v].push_back(u);\n}\nvoid Matching_dfs(int u, int p)\n{\n\tfor (int i = 0;\n\t\ti < adj[u].size(); i++) {\n\t\tif (adj[u][i] != p) {\n\t\t\tMatching_dfs(adj[u][i], u);\n\t\t}\n\t}\n\tif (!used[u] and !used[p] and p != 0) {\n\t\tmax_matching++;\n\t\tused[u] = used[p] = 1;\n\t}\n}\nvoid maxMatching()\n{\n\tMatching_dfs(1, 0);\n\tcout << max_matching << \"\\n\";\n}", "5353": "string balancedMatrix(int mat[][M])\n{\n\tbool is_balanced = true;\n\tfor (int i = 0; i < N && is_balanced; i++) {\n\t\tfor (int j = 0; j < M && is_balanced; j++) {\n\t\t\tif ((i == 0 i == N - 1)\n\t\t\t\t&& (j == 0 j == M - 1)) {\n\t\t\t\tif (mat[i][j] >= 2)\n\t\t\t\t\tis_balanced = false;\n\t\t\t}\n\t\t\telse if (i == 0 i == N - 1 j == 0 j == M - 1) {\n\t\t\t\tif (mat[i][j] >= 3)\n\t\t\t\t\tis_balanced = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mat[i][j] >= 4)\n\t\t\t\t\tis_balanced = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (is_balanced)\n\t\treturn \"Balanced\";\n\telse\n\t\treturn \"Unbalanced\";\n}", "5361": "int getMinCost(vector<int> A, vector<int> B, int N)\n{\n\tint mini = INT_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tmini = min(mini, min(A[i], B[i]));\n\t}\n\treturn mini * (2 * N - 1);\n}", "5370": "int maxSubsequences(int arr[], int n)\n{\n\tunordered_map<int, int> m;\n\tint maxCount = 0;\n\tint count;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (m.find(arr[i]) != m.end()) {\n\t\t\tcount = m[arr[i]];\n\t\t\tif (count > 1) {\n\t\t\t\tm[arr[i]] = count - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tm.erase(arr[i]);\n\t\t\tif (arr[i] - 1 > 0)\n\t\t\t\tm[arr[i] - 1] += 1;\n\t\t}\n\t\telse {\n\t\t\tmaxCount++;\n\t\t\tif (arr[i] - 1 > 0)\n\t\t\t\tm[arr[i] - 1] += 1;\n\t\t}\n\t}\n\treturn maxCount;\n}", "5373": "void count(int n, int k)\n{\n\tlong count = (long)(pow(10, k) - pow(10, k - 1));\n\tcout << (count);\n}", "5380": "int func(int N, int P)\n{\n\tint sumUptoN = (N * (N + 1) / 2);\n\tint sumOfMultiplesOfP;\n\tif (N < P) {\n\t\treturn sumUptoN;\n\t}\n\telse if ((N / P) == 1) {\n\t\treturn sumUptoN - P + 1;\n\t}\n\tsumOfMultiplesOfP\n\t\t= ((N / P) * (2 * P + (N / P - 1) * P)) / 2;\n\treturn (sumUptoN\n\t\t\t+ func(N / P, P) - sumOfMultiplesOfP);\n}", "5383": "string removeOcc(string& s, char ch)\n{\n\tfor (int i = 0; s[i]; i++) {\n\t\tif (s[i] == ch) {\n\t\t\ts.erase(s.begin() + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = s.length() - 1; i > -1; i--) {\n\t\tif (s[i] == ch) {\n\t\t\ts.erase(s.begin() + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s;\n}", "5388": "void findShifts(int A[], int N)\n{\n\tint shift[N];\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i == A[i] - 1)\n\t\t\tshift[i] = 0;\n\t\telse\n\t\t\tshift[i]\n\t\t\t\t= (A[i] - 1 - i + N)\n\t\t\t\t% N;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t\tcout << shift[i] << \" \";\n}", "5398": "void printVector(vector<int>& arr)\n{\n\tif (arr.size() != 1) {\n\t\tfor (int i = 0; i < arr.size(); i++) {\n\t\t\tcout << arr[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvoid findWays(vector<int>& arr, int i, int n)\n{\n\tif (n == 0)\n\t\tprintVector(arr);\n\tfor (int j = i; j <= n; j++) {\n\t\tarr.push_back(j);\n\t\tfindWays(arr, j, n - j);\n\t\tarr.pop_back();\n\t}\n}", "5405": "void Maximum_subsequence(int A[], int N)\n{\n\tunordered_map<int, int> frequency;\n\tint max_freq = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfrequency[A[i]]++;\n\t}\n\tfor (auto it : frequency) {\n\t\tif (it.second > max_freq) {\n\t\t\tmax_freq = it.second;\n\t\t}\n\t}\n\tcout << max_freq << endl;\n}", "5407": "void minSteps(int N, int increasing[], int decreasing[], int m1, int m2)\n{\n\tint mini = INT_MAX;\n\tfor(int i = 0; i < m1; i++)\n\t{\n\t\tif (mini > increasing[i])\n\t\t\tmini = increasing[i];\n\t}\n\tint maxi = INT_MIN;\n\tfor(int i = 0; i < m2; i++)\n\t{\n\t\tif (maxi < decreasing[i])\n\t\t\tmaxi = decreasing[i];\n\t}\n\tint minSteps = max(maxi, N - mini);\n\tcout << minSteps << endl;\n}", "5416": "void constructmatrix(int N)\n{\n\tbool check = true;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (i == j) {\n\t\t\t\tcout << 1 << \" \";\n\t\t\t}\n\t\t\telse if (check) {\n\t\t\t\tcout << 2 << \" \";\n\t\t\t\tcheck = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << -2 << \" \";\n\t\t\t\tcheck = true;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}", "5418": "int countChanges(int matrix[][N], int n, int m)\n{\n\tint dist = n + m - 1;\n\tint freq[dist][10];\n\tfor (int i = 0; i < dist; i++) {\n\t\tfor (int j = 0; j < 10; j++)\n\t\t\tfreq[i][j] = 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfreq[i + j][matrix[i][j]]++;\n\t\t}\n\t}\n\tint min_changes_sum = 0;\n\tfor (int i = 0; i < dist / 2; i++) {\n\t\tint maximum = 0;\n\t\tint total_values = 0;\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tmaximum = max(maximum, freq[i][j] + freq[n + m - 2 - i][j]);\n\t\t\ttotal_values += (freq[i][j] + freq[n + m - 2 - i][j]);\n\t\t}\n\t\tmin_changes_sum += (total_values - maximum);\n\t}\n\treturn min_changes_sum;\n}", "5440": "void DivideString(string s, int n, int k)\n{\n\tint i, c = 0, no = 1;\n\tint c1 = 0, c2 = 0;\n\tint fr[26] = { 0 };\n\tstring ans = \"\";\n\tfor (i = 0; i < n; i++) {\n\t\tfr[s[i] - 'a']++;\n\t}\n\tchar ch, ch1;\n\tfor (i = 0; i < 26; i++) {\n\t\tif (fr[i] == k) {\n\t\t\tc++;\n\t\t}\n\t\tif (fr[i] > k && fr[i] != 2 * k) {\n\t\t\tc1++;\n\t\t\tch = i + 'a';\n\t\t}\n\t\tif (fr[i] == 2 * k) {\n\t\t\tc2++;\n\t\t\tch1 = i + 'a';\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++)\n\t\tans = ans + \"1\";\n\tmap<char, int> mp;\n\tif (c % 2 == 0 c1 > 0 c2 > 0) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (fr[s[i] - 'a'] == k) {\n\t\t\t\tif (mp.find(s[i])\n\t\t\t\t\t!= mp.end()) {\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (no <= (c / 2)) {\n\t\t\t\t\t\tans[i] = '2';\n\t\t\t\t\t\tno++;\n\t\t\t\t\t\tmp[s[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c % 2 == 1 && c1 > 0) {\n\t\t\tno = 1;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tif (s[i] == ch && no <= k) {\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tno++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c % 2 == 1 && c1 == 0) {\n\t\t\tno = 1;\n\t\t\tint flag = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (s[i] == ch1 && no <= k) {\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tno++;\n\t\t\t\t}\n\t\t\t\tif (fr[s[i] - 'a'] == k && flag == 0 && ans[i] == '1') {\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tcout << \"NO\" << endl;\n\t}\n}", "5447": "int check(int unit_digit, int X)\n{\n\tint times, digit;\n\tfor (int times = 1; times <= 10; times++) {\n\t\tdigit = (X * times) % 10;\n\t\tif (digit == unit_digit)\n\t\t\treturn times;\n\t}\n\treturn -1;\n}\nint getNum(int N, int X)\n{\n\tint unit_digit;\n\tunit_digit = N % 10;\n\tint times = check(unit_digit, X);\n\tif (times == -1)\n\t\treturn times;\n\telse {\n\t\tif (N >= (times * X))\n\t\t\treturn times;\n\t\telse\n\t\t\treturn -1;\n\t}\n}", "5455": "int minPoints(int n, int m)\n{\n\tint ans = 0;\n\tif ((n % 2 != 0)\n\t\t&& (m % 2 != 0)) {\n\t\tans = ((n * m) / 2) + 1;\n\t}\n\telse {\n\t\tans = (n * m) / 2;\n\t}\n\treturn ans;\n}", "5468": "void solve(vector<int>& P, int n)\n{\n\tvector<int> arr;\n\tarr.push_back(0);\n\tfor (auto x : P)\n\t\tarr.push_back(x);\n\tint cnt = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (arr[i] == i) {\n\t\t\tswap(arr[i], arr[i + 1]);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif (arr[n] == n) {\n\t\tswap(arr[n - 1], arr[n]);\n\t\tcnt++;\n\t}\n\tcout << cnt << endl;\n}", "5482": "void countEvenOdd(int arr[], int n, int K)\n{\n\tint even = 0, odd = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = __builtin_popcount(arr[i]);\n\t\tif (x % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\t\todd++;\n\t}\n\tint y;\n\ty = __builtin_popcount(K);\n\tif (y & 1) {\n\t\tcout << \"Even = \" << odd\n\t\t\t<< \", Odd = \" << even;\n\t}\n\telse {\n\t\tcout << \"Even = \" << even\n\t\t\t<< \", Odd = \" << odd;\n\t}\n}", "5495": "string check(int S, int prices[], int type[], int n)\n{\n\tfor (int j = 0; j < n; j++) {\n\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\tif ((type[j] == 0 && type[k] == 1)\n\t\t\t\t|| (type[j] == 1 && type[k] == 0)) {\n\t\t\t\tif (prices[j] + prices[k] <= S) {\n\t\t\t\t\treturn \"Yes\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"No\";\n}", "5501": "string getLargestString(string s, ll k)\n{\n\tvector<int> frequency_array(26, 0);\n\tfor (int i = 0;\n\t\ti < s.length(); i++) {\n\t\tfrequency_array[s[i] - 'a']++;\n\t}\n\tstring ans = \"\";\n\tfor (int i = 25; i >= 0;) {\n\t\tif (frequency_array[i] > k) {\n\t\t\tint temp = k;\n\t\t\tstring st(1, i + 'a');\n\t\t\twhile (temp > 0) {\n\t\t\t\tans += st;\n\t\t\t\ttemp--;\n\t\t\t}\n\t\t\tfrequency_array[i] -= k;\n\t\t\tint j = i - 1;\n\t\t\twhile (frequency_array[j] <= 0 && j >= 0) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (frequency_array[j] > 0 && j >= 0) {\n\t\t\t\tstring str(1, j + 'a');\n\t\t\t\tans += str;\n\t\t\t\tfrequency_array[j] -= 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (frequency_array[i] > 0) {\n\t\t\tint temp = frequency_array[i];\n\t\t\tfrequency_array[i] -= temp;\n\t\t\tstring st(1, i + 'a');\n\t\t\twhile (temp > 0) {\n\t\t\t\tans += st;\n\t\t\t\ttemp--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ans;\n}", "5512": "int minOperations(int a[], int b[], int n)\n{\n\tint minA = *min_element(a, a + n);\n\tfor (int x = minA; x >= 0; x--) {\n\t\tbool check = 1;\n\t\tint operations = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (x % b[i] == a[i] % b[i]) {\n\t\t\t\toperations +=\n\t\t\t\t\t(a[i] - x) / b[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcheck = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check)\n\t\t\treturn operations;\n\t}\n\treturn -1;\n}", "5538": "int getLargestSum(int N)\n{\n\tint max_sum = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\tif (i * j % (i + j) == 0)\n\t\t\t\tmax_sum = max(max_sum, i + j);\n\t\t}\n\t}\n\treturn max_sum;\n}", "5539": "int getLargestSum(int N)\n{\n\tfor (int i = 1; i * i <= N; i++) {\n\t\tfor (int j = i + 1; j * j <= N; j++) {\n\t\t\tint k = N / j;\n\t\t\tint a = k * i;\n\t\t\tint b = k * j;\n\t\t\tif (a <= N && b <= N\n\t\t\t\t&& a * b % (a + b) == 0)\n\t\t\t\tmax_sum = max(max_sum, a + b);\n\t\t}\n\t}\n\treturn max_sum;\n}", "5544": "int maxSubArraySum(int a[], int size)\n{\n\tint max_so_far = INT_MIN,\n\t\tmax_ending_here = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tmax_ending_here =\n\t\t\tmax_ending_here + a[i];\n\t\tif (max_ending_here < 0)\n\t\t\tmax_ending_here = 0;\n\t\tif (max_so_far < max_ending_here)\n\t\t\tmax_so_far = max_ending_here;\n\t}\n\treturn max_so_far;\n}\nint maxSum(int a[], int n)\n{\n\tint S = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tS += a[i];\n\tint X = maxSubArraySum(a, n);\n\treturn 2 * X - S;\n}", "5548": "bool isPrime(int n)\n{\n\tint flag = 1;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tflag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (flag == 1 ? true : false);\n}\nbool isPerfectSquare(int x)\n{\n\tlong double sr = sqrt(x);\n\treturn ((sr - floor(sr)) == 0);\n}\nint countInterestingPrimes(int n)\n{\n\tint answer = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isPrime(i)) {\n\t\t\tfor (int j = 1; j * j * j * j <= i; j++) {\n\t\t\t\tif (\n\t\t\t\t\tisPerfectSquare( i - j * j * j * j)) {\n\t\t\t\t\tanswer++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn answer;\n}", "5549": "void SieveOfEratosthenes( int n, unordered_set<int>& allPrimes)\n{\n\tbool prime[n + 1];\n\tmemset(prime, true, sizeof(prime));\n\tfor (int p = 2; p * p <= n; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tallPrimes.insert(p);\n}\nint countInterestingPrimes(int n)\n{\n\tunordered_set<int> allPrimes;\n\tSieveOfEratosthenes(n, allPrimes);\n\tunordered_set<int> intersetingPrimes;\n\tvector<int> squares, quadruples;\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tsquares.push_back(i * i);\n\t}\n\tfor (int i = 1; i * i * i * i <= n; i++) {\n\t\tquadruples.push_back(i * i * i * i);\n\t}\n\tfor (auto a : squares) {\n\t\tfor (auto b : quadruples) {\n\t\t\tif (allPrimes.count(a + b))\n\t\t\t\tintersetingPrimes.insert(a + b);\n\t\t}\n\t}\n\treturn intersetingPrimes.size();\n}", "5585": "void decBinary(int arr[], int n)\n{\n\tint k = log2(n);\n\twhile (n > 0) {\n\t\tarr[k--] = n % 2;\n\t\tn /= 2;\n\t}\n}\nint binaryDec(int arr[], int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans += arr[i] << (n - i - 1);\n\treturn ans;\n}\nint maxNum(int n, int k)\n{\n\tint l = log2(n) + 1;\n\tint a[l] = { 0 };\n\tdecBinary(a, n);\n\tint cn = 0;\n\tfor (int i = 0; i < l; i++) {\n\t\tif (a[i] == 0 && cn < k) {\n\t\t\ta[i] = 1;\n\t\t\tcn++;\n\t\t}\n\t}\n\treturn binaryDec(a, l);\n}", "5588": "void findSubSeq(int arr[], int n, int sum)\n{\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (sum < arr[i])\n\t\t\tarr[i] = -1;\n\t\telse\n\t\t\tsum -= arr[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] != -1)\n\t\t\tcout << arr[i] << \" \";\n\t}\n}", "5594": "char maxAlpha(string str, int len)\n{\n\tint first[MAX], last[MAX];\n\tfor (int i = 0; i < MAX; i++) {\n\t\tfirst[i] = -1;\n\t\tlast[i] = -1;\n\t}\n\tfor (int i = 0; i < len; i++) {\n\t\tint index = (str[i] - 'a');\n\t\tif (first[index] == -1)\n\t\t\tfirst[index] = i;\n\t\tlast[index] = i;\n\t}\n\tint ans = -1, maxVal = -1;\n\tfor (int i = 0; i < MAX; i++) {\n\t\tif (first[i] == -1)\n\t\t\tcontinue;\n\t\tif ((last[i] - first[i]) > maxVal) {\n\t\t\tmaxVal = last[i] - first[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn (char)(ans + 'a');\n}", "5621": "void find_distinct(int a[], int n, int q, int queries[])\n{\n\tint check[MAX] = { 0 };\n\tint idx[MAX];\n\tint cnt = 1;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (check[a[i]] == 0) {\n\t\t\tidx[i] = cnt;\n\t\t\tcheck[a[i]] = 1;\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tidx[i] = cnt - 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tint m = queries[i];\n\t\tcout << idx[m] << \" \";\n\t}\n}", "5627": "int countOp(int x)\n{\n\tint arr[MAX];\n\tarr[0] = 1;\n\tfor (int i = 1; i < MAX; i++)\n\t\tarr[i] = arr[i - 1] * 2;\n\tint temp = x;\n\tbool flag = true;\n\tint ans;\n\tint operations = 0;\n\tbool flag2 = false;\n\tfor (int i = 0; i < MAX; i++) {\n\t\tif (arr[i] - 1 == x)\n\t\t\tflag2 = true;\n\t\tif (arr[i] > x) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag2)\n\t\treturn 0;\n\twhile (flag) {\n\t\tif (arr[ans] < x)\n\t\t\tans++;\n\t\toperations++;\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tint take = x ^ (arr[i] - 1);\n\t\t\tif (take <= arr[ans] - 1) {\n\t\t\t\tif (take > temp)\n\t\t\t\t\ttemp = take;\n\t\t\t}\n\t\t}\n\t\tif (temp == arr[ans] - 1) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t\ttemp++;\n\t\toperations++;\n\t\tx = temp;\n\t\tif (x == arr[ans] - 1)\n\t\t\tflag = false;\n\t}\n\treturn operations;\n}", "5636": "int minOperations(int* arr, int n)\n{\n\tint maxi, result = 0;\n\tvector<int> freq(1000001, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = arr[i];\n\t\tfreq[x]++;\n\t}\n\tmaxi = *(max_element(arr, arr + n));\n\tfor (int i = 1; i <= maxi; i++) {\n\t\tif (freq[i] != 0) {\n\t\t\tfor (int j = i * 2; j <= maxi; j = j + i) {\n\t\t\t\tfreq[j] = 0;\n\t\t\t}\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}", "5675": "string encryptString(string str, int n)\n{\n\tint i = 0, cnt = 0;\n\tstring encryptedStr = \"\";\n\twhile (i < n) {\n\t\tcnt = i + 1;\n\t\twhile (cnt--)\n\t\t\tencryptedStr += str[i];\n\t\ti++;\n\t}\n\treturn encryptedStr;\n}", "5676": "int minGCD(int arr[], int n)\n{\n\tint minGCD = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tminGCD = __gcd(minGCD, arr[i]);\n\treturn minGCD;\n}\nint minLCM(int arr[], int n)\n{\n\tint minLCM = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t\tminLCM = min(minLCM, arr[i]);\n\treturn minLCM;\n}", "5687": "string formStringMinOperations(string s)\n{\n\tint count[3] = { 0 };\n\tfor (auto& c : s)\n\t\tcount++;\n\tint processed[3] = { 0 };\n\tint reqd = (int)s.size() / 3;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (count[s[i] - '0'] == reqd)\n\t\t\tcontinue;\n\t\tif (s[i] == '0' && count[0] > reqd && processed[0] >= reqd) {\n\t\t\tif (count[1] < reqd) {\n\t\t\t\ts[i] = '1';\n\t\t\t\tcount[1]++;\n\t\t\t\tcount[0]--;\n\t\t\t}\n\t\t\telse if (count[2] < reqd) {\n\t\t\t\ts[i] = '2';\n\t\t\t\tcount[2]++;\n\t\t\t\tcount[0]--;\n\t\t\t}\n\t\t}\n\t\tif (s[i] == '1' && count[1] > reqd) {\n\t\t\tif (count[0] < reqd) {\n\t\t\t\ts[i] = '0';\n\t\t\t\tcount[0]++;\n\t\t\t\tcount[1]--;\n\t\t\t}\n\t\t\telse if (count[2] < reqd && processed[1] >= reqd) {\n\t\t\t\ts[i] = '2';\n\t\t\t\tcount[2]++;\n\t\t\t\tcount[1]--;\n\t\t\t}\n\t\t}\n\t\tif (s[i] == '2' && count[2] > reqd) {\n\t\t\tif (count[0] < reqd) {\n\t\t\t\ts[i] = '0';\n\t\t\t\tcount[0]++;\n\t\t\t\tcount[2]--;\n\t\t\t}\n\t\t\telse if (count[1] < reqd) {\n\t\t\t\ts[i] = '1';\n\t\t\t\tcount[1]++;\n\t\t\t\tcount[2]--;\n\t\t\t}\n\t\t}\n\t\tprocessed[s[i] - '0']++;\n\t}\n\treturn s;\n}", "5730": "int minDiff(int n, int x, int A[])\n{\n\tint mn = A[0], mx = A[0];\n\tfor (int i = 0; i < n; ++i) {\n\t\tmn = min(mn, A[i]);\n\t\tmx = max(mx, A[i]);\n\t}\n\treturn max(0, mx - mn - 2 * x);\n}", "5739": "", "5742": "bool isWaveArray(int arr[], int n)\n{\n\tbool result = true;\n\tif (arr[1] > arr[0] && arr[1] > arr[2]) {\n\t\tfor (int i = 1; i < n - 1; i += 2) {\n\t\t\tif (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (result == true && n % 2 == 0) {\n\t\t\tif (arr[n - 1] <= arr[n - 2]) {\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (arr[1] < arr[0] && arr[1] < arr[2]) {\n\t\tfor (int i = 1; i < n - 1; i += 2) {\n\t\t\tif (arr[i] < arr[i - 1] && arr[i] < arr[i + 1]) {\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (result == true && n % 2 == 0) {\n\t\t\tif (arr[n - 1] >= arr[n - 2]) {\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "5762": "int findMinimumAdjacentSwaps(int arr[], int N)\n{\n\tbool visited[N + 1];\n\tint minimumSwaps = 0;\n\tmemset(visited, false, sizeof(visited));\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tif (visited[arr[i]] == false) {\n\t\t\tvisited[arr[i]] = true;\n\t\t\tint count = 0;\n\t\t\tfor (int j = i + 1; j < 2 * N; j++) {\n\t\t\t\tif (visited[arr[j]] == false)\n\t\t\t\t\tcount++;\n\t\t\t\telse if (arr[i] == arr[j])\n\t\t\t\t\tminimumSwaps += count;\n\t\t\t}\n\t\t}\n\t}\n\treturn minimumSwaps;\n}", "5772": "bool possibility(unordered_map<int, int> m, int length, string s)\n{\n\tint countodd = 0;\n\tfor (int i = 0; i < length; i++) {\n\t\tif (m[s[i] - '0'] & 1)\n\t\t\tcountodd++;\n\t\tif (countodd > 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvoid largestPalindrome(string s)\n{\n\tint l = s.length();\n\tunordered_map<int, int> m;\n\tfor (int i = 0; i < l; i++)\n\t\tm[s[i] - '0']++;\n\tif (possibility(m, l, s) == false) {\n\t\tcout << \"Palindrome cannot be formed\";\n\t\treturn;\n\t}\n\tchar largest[l];\n\tint front = 0;\n\tfor (int i = 9; i >= 0; i--) {\n\t\tif (m[i] & 1) {\n\t\t\tlargest[l / 2] = char(i + 48);\n\t\t\tm[i]--;\n\t\t\twhile (m[i] > 0) {\n\t\t\t\tlargest[front] = char(i + 48);\n\t\t\t\tlargest[l - front - 1] = char(i + 48);\n\t\t\t\tm[i] -= 2;\n\t\t\t\tfront++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (m[i] > 0) {\n\t\t\t\tlargest[front] = char(i + 48);\n\t\t\t\tlargest[l - front - 1] = char(i + 48);\n\t\t\t\tm[i] -= 2;\n\t\t\t\tfront++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < l; i++)\n\t\tcout << largest[i];\n}", "5797": "long swapCount(string s)\n{\n\tvector<int> pos;\n\tfor (int i = 0; i < s.length(); ++i)\n\t\tif (s[i] == '[')\n\t\t\tpos.push_back(i);\nint count = 0; \nint p = 0; \nlong sum = 0; \n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tif (s[i] == '[')\n\t\t{\n\t\t\t++count;\n\t\t\t++p;\n\t\t}\n\t\telse if (s[i] == ']')\n\t\t\t--count;\n\t\tif (count < 0)\n\t\t{\n\t\t\tsum += pos[p] - i;\n\t\t\tswap(s[i], s[pos[p]]);\n\t\t\t++p;\n\t\t\tcount = 1;\n\t\t}\n\t}\n\treturn sum;\n}", "5798": "long swapCount(string chars)\n{\n\tint countLeft = 0, countRight = 0;\n\tint swap = 0 , imbalance = 0;\n\tfor(int i = 0; i < chars.length(); i++)\n\t{\n\t\tif (chars[i] == '[')\n\t\t{\n\t\t\tcountLeft++;\n\t\t\tif (imbalance > 0)\n\t\t\t{\n\t\t\t\tswap += imbalance;\n\t\t\t\timbalance--;\t\n\t\t\t}\n\t\t}\n\t\telse if(chars[i] == ']' )\n\t\t{\n\t\t\tcountRight++;\n\t\t\timbalance = (countRight - countLeft);\n\t\t}\n\t}\n\treturn swap;\n}", "5811": "void minimizeWithKSwaps(int arr[], int n, int k)\n{\n\tfor (int i = 0; i<n-1 && k>0; ++i)\n\t{\n\t\tint pos = i;\n\t\tfor (int j = i+1; j<n ; ++j)\n\t\t{\n\t\t\tif (j-i > k)\n\t\t\t\tbreak;\n\t\t\tif (arr[j] < arr[pos])\n\t\t\t\tpos = j;\n\t\t}\n\t\tfor (int j = pos; j>i; --j)\n\t\t\tswap(arr[j], arr[j-1]);\n\t\tk -= pos-i;\n\t}\n}", "5816": "int minimumCostOfBreaking(int X[], int Y[], int m, int n)\n{\n\tint res = 0;\n\tsort(X, X + m, greater<int>());\n\tsort(Y, Y + n, greater<int>());\n\tint hzntl = 1, vert = 1;\n\tint i = 0, j = 0;\n\twhile (i < m && j < n)\n\t{\n\t\tif (X[i] > Y[j])\n\t\t{\n\t\t\tres += X[i] * vert;\n\t\t\thzntl++;\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += Y[j] * hzntl;\n\t\t\tvert++;\n\t\t\tj++;\n\t\t}\n\t}\n\tint total = 0;\n\twhile (i < m)\n\t\ttotal += X[i++];\n\tres += total * vert;\n\ttotal = 0;\n\twhile (j < n)\n\t\ttotal += Y[j++];\n\tres += total * hzntl;\n\treturn res;\n}", "5865": "int getMin(int x, int y, int z)\n{\n\treturn min(min(x, y), z);\n}\nint editDistance(string str1, string str2, int m, int n)\n{\n\tint dp[m + 1][n + 1];\n\tfor (int i = 0; i <= m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tif (i == 0)\n\t\t\t\tdp[i][j] = j;\n\t\t\telse if (j == 0)\n\t\t\t\tdp[i][j] = i;\n\t\t\telse if (str1[i - 1] == str2[j - 1])\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\telse {\n\t\t\t\tdp[i][j] = 1\n\t\t\t\t\t\t+ getMin( dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[m][n];\n}\nvoid minimumSteps(string& S, int N)\n{\n\tint ans = INT_MAX;\n\tfor (int i = 1; i < N; i++) {\n\t\tstring S1 = S.substr(0, i);\n\t\tstring S2 = S.substr(i);\n\t\tint count = editDistance(\n\t\t\tS1, S2, S1.length(),\n\t\t\tS2.length());\n\t\tans = min(ans, count);\n\t}\n\tcout << ans << '\\n';\n}", "5872": "int minimumOperations(int N)\n{\n\tint dp[N + 1];\n\tint i;\n\tfor (int i = 0; i <= N; i++) {\n\t\tdp[i] = 1e9;\n\t}\n\tdp[2] = 0;\n\tfor (i = 2; i <= N; i++) {\n\t\tif (dp[i] == 1e9)\n\t\t\tcontinue;\n\t\tif (i * 5 <= N) {\n\t\t\tdp[i * 5] = min(dp[i * 5], dp[i] + 1);\n\t\t}\n\t\tif (i + 3 <= N) {\n\t\t\tdp[i + 3] = min(dp[i + 3], dp[i] + 1);\n\t\t}\n\t}\n\tif (dp[N] == 1e9)\n\t\treturn -1;\n\treturn dp[N];\n}", "5880": "int MaxProfit(int arr[], int n, int transactionFee)\n{\n\tint buy = -arr[0];\n\tint sell = 0;\n\tfor (int i = 1; i < n; i++) {\n\t\tint temp = buy;\n\t\tbuy = max(buy, sell - arr[i]);\n\t\tsell = max(sell, temp + arr[i] - transactionFee);\n\t}\n\treturn max(sell, buy);\n}", "5904": "void countPossiblities(int arr[], int n)\n{\n\tint lastOccur[100000];\n\tfor (int i = 0; i < n; i++) {\n\t\tlastOccur[i] = -1;\n\t}\n\tint dp[n + 1];\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint curEle = arr[i - 1];\n\t\tdp[i] = dp[i - 1];\n\t\tif (lastOccur[curEle] != -1 & lastOccur[curEle] < i - 1) {\n\t\t\tdp[i] += dp[lastOccur[curEle]];\n\t\t}\n\t\tlastOccur[curEle] = i;\n\t}\n\tcout << dp[n] << endl;\n}", "5919": "int longestSubSequence(pair<int, int> A[], int N, int ind = 0, int lastf = INT_MIN, int lasts = INT_MAX)\n{\n\tif (ind == N)\n\t\treturn 0;\n\tint ans = longestSubSequence(A, N, ind + 1, lastf, lasts);\n\tif (A[ind].first > lastf && A[ind].second < lasts)\n\t\tans = max(ans, longestSubSequence(A, N, ind + 1, A[ind].first, A[ind].second) + 1);\n\treturn ans;\n}", "5920": "void longestSubSequence(pair<int, int> A[], int N)\n{\n\tint dp[N];\n\tfor (int i = 0; i < N; i++) {\n\t\tdp[i] = 1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (A[j].first < A[i].first && A[j].second > A[i].second) {\n\t\t\t\tdp[i] = max(dp[i], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N - 1] << endl;\n}", "5924": "void calculateStart(int n, int m)\n{\n\tfor (int i = 1; i < m; ++i) {\n\t\tstart[0][i] += start[0][i - 1];\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tstart[i][0] += start[i - 1][0];\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 1; j < m; ++j) {\n\t\t\tstart[i][j] += max(start[i - 1][j], start[i][j - 1]);\n\t\t}\n\t}\n}\nvoid calculateEnd(int n, int m)\n{\n\tfor (int i = n - 2; i >= 0; --i) {\n\t\tending[i][m - 1] += ending[i + 1][m - 1];\n\t}\n\tfor (int i = m - 2; i >= 0; --i) {\n\t\tending[n - 1][i] += ending[n - 1][i + 1];\n\t}\n\tfor (int i = n - 2; i >= 0; --i) {\n\t\tfor (int j = m - 2; j >= 0; --j) {\n\t\t\tending[i][j] += max(ending[i + 1][j], ending[i][j + 1]);\n\t\t}\n\t}\n}\nvoid maximumPathSum(int mat[][3], int n, int m, int q, int coordinates[][2])\n{\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tstart[i][j] = mat[i][j];\n\t\t\tending[i][j] = mat[i][j];\n\t\t}\n\t}\n\tcalculateStart(n, m);\n\tcalculateEnd(n, m);\n\tint ans = 0;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint X = coordinates[i][0] - 1;\n\t\tint Y = coordinates[i][1] - 1;\n\t\tans = max(ans, start[X][Y] + ending[X][Y] - mat[X][Y]);\n\t}\n\tcout << ans;\n}", "5946": "int MaxSubsetlength(vector<string> arr, int A, int B)\n{\n\tint dp[A + 1][B + 1];\n\tmemset(dp, 0, sizeof(dp));\n\tfor (auto& str : arr) {\n\t\tint zeros = count(str.begin(),\n\t\t\t\t\t\tstr.end(), '0');\n\t\tint ones = count(str.begin(),\n\t\t\t\t\t\tstr.end(), '1');\n\t\tfor (int i = A; i >= zeros; i--)\n\t\t\tfor (int j = B; j >= ones; j--)\n\t\t\t\tdp[i][j] = max( dp[i][j], dp[i - zeros][j - ones] + 1);\n\t}\n\treturn dp[A][B];\n}", "5957": "int numOfWays(vector<vector<int>> a, int n, int i, set<int> &blue)\n{\n\tif (i == n)\n\t\treturn 1;\n\tint count = 0;\n\tfor(int j = 0; j < n; j++)\n\t{\n\t\tif (a[i][j] == 1 && blue.find(j) == blue.end())\n\t\t{\n\t\t\tblue.insert(j);\n\t\t\tcount += numOfWays(a, n, i + 1, blue);\n\t\t\tblue.erase(j);\n\t\t}\n\t}\n\treturn count;\n}", "5970": "void minCost(int arr[], int n)\n{\n\tif (n < 3) {\n\t\tcout << arr[0];\n\t\treturn;\n\t}\n\tint* dp = new int[n];\n\tdp[0] = arr[0];\n\tdp[1] = dp[0] + arr[1] + arr[2];\n\tfor (int i = 2; i < n - 1; i++)\n\t\tdp[i] = min(dp[i - 2] + arr[i], dp[i - 1] + arr[i] + arr[i + 1]);\n\tdp[n - 1] = min(dp[n - 2], dp[n - 3] + arr[n - 1]);\n\tcout << dp[n - 1];\n}", "5995": "long long power(long long X, long long Y)\n{\n\tlong long res = 1;\n\tX = X % M;\n\tif (X == 0)\n\t\treturn 0;\n\twhile (Y > 0) {\n\t\tif (Y & 1) {\n\t\t\tres = (res * X) % M;\n\t\t}\n\t\tY = Y >> 1;\n\t\tX = (X * X) % M;\n\t}\n\treturn res;\n}\nint findValue(long long int n)\n{\n\tlong long X = 0;\n\tlong long pow_10 = 1;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tX += pow_10;\n\t\t}\n\t\tpow_10 *= 10;\n\t\tn /= 2;\n\t}\n\tX = (X * 2) % M;\n\tlong long res = power(2, X);\n\treturn res;\n}", "5996": "long long power(long long X, long long Y)\n{\n\tlong long res = 1;\n\tX = X % M;\n\tif (X == 0)\n\t\treturn 0;\n\twhile (Y > 0) {\n\t\tif (Y & 1) {\n\t\t\tres = (res * X) % M;\n\t\t}\n\t\tY = Y >> 1;\n\t\tX = (X * X) % M;\n\t}\n\treturn res;\n}\nlong long findValue(long long N)\n{\n\tlong long dp[N + 1];\n\tdp[1] = 2;\n\tdp[2] = 1024;\n\tfor (int i = 3; i <= N; i++) {\n\t\tint y = (i & (-i));\n\t\tint x = i - y;\n\t\tif (x == 0) {\n\t\t\tdp[i]\n\t\t\t\t= power(dp[i / 2], 10);\n\t\t}\n\t\telse {\n\t\t\tdp[i]\n\t\t\t\t= (dp[x] * dp[y]) % M;\n\t\t}\n\t}\n\treturn (dp[N] * dp[N]) % M;\n}", "6000": "int countTriplets(vector<int>& A)\n{\n\tint cnt = 0;\n\tunordered_map<int, int> tuples;\n\tfor (auto a : A)\n\t\tfor (auto b : A)\n\t\t\t++tuples[a & b];\n\tfor (auto a : A)\n\t\tfor (auto t : tuples)\n\t\t\tif ((t.first & a) == 0)\n\t\t\t\tcnt += t.second;\n\treturn cnt;\n}", "6021": "int countPenality(int arr[], int N)\n{\n\tint pos = 0;\n\tint turn = 0;\n\treturn findMinimum(arr, N, pos, turn);\n}\nvoid printAnswer(int* arr, int N)\n{\n\tint a = countPenality(arr, N);\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tsum += arr[i];\n\t}\n\tcout << a;\n}", "6028": "void maxSum(vector<vector<int> > arr, int n, int m)\n{\n\tvector<vector<int> > dp(n);\n\tfor (int i = 0; i < 2; i++) {\n\t\tdp[i] = vector<int>(m);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tdp[0][m - 1] = arr[0][m - 1];\n\tdp[1][m - 1] = arr[1][m - 1];\n\tfor (int j = m - 2; j >= 0; j--) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tif (i == 1) {\n\t\t\t\tdp[i][j] = max( arr[i][j] + dp[0][j + 1], arr[i][j] + dp[0][j + 2]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = max( arr[i][j] + dp[1][j + 1], arr[i][j] + dp[1][j + 2]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << max(dp[0][0], dp[1][0]);\n}", "6029": "void maxSum(vector<vector<int> > arr, int n)\n{\n\tint r1 = 0, r2 = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint temp = r1;\n\t\tr1 = max(r1, r2 + arr[0][i]);\n\t\tr2 = max(r2, temp + arr[1][i]);\n\t}\n\tcout << max(r1, r2);\n}", "6065": "int Max_Sum(int arr[], int K, int N)\n{\n\tint dp[N + 1];\n\tmemset(dp, 0, sizeof(dp));\n\tint prefix[N + 1];\n\tprefix[0] = 0;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tprefix[i] = prefix[i - 1] + arr[i-1];\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1; i < K ; i++)\n\t{\n\t\tdp[i] = prefix[i];\n\t}\n\tfor(int i = K ; i <= N; ++i)\n\t{\n\t\tfor(int j = i; j >= (i - K + 1); j--)\n\t\t{\n\t\t\tdp[i] = max(dp[i], dp[j - 1] + prefix[i] - prefix[j]);\n\t\t}\n\t}\n\treturn dp[N];\n}", "6068": "void Calculate_factorial()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i <= mx; i++) {\n\t\tfact[i] = i * fact[i - 1];\n\t\tfact[i] %= mod;\n\t}\n}\nint UniModal_per(int a, int b)\n{\n\tlong long int res = 1;\n\twhile (b) {\n\t\tif (b % 2)\n\t\t\tres = res * a;\n\t\tres %= mod;\n\t\ta = a * a;\n\t\ta %= mod;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\nvoid countPermutations(int n)\n{\n\tCalculate_factorial();\n\tint uni_modal = UniModal_per(2, n - 1);\n\tint nonuni_modal = fact[n] - uni_modal;\n\tcout << uni_modal << \" \" << nonuni_modal;\n\treturn;\n}", "6071": "int findWays(int N)\n{\n\tif (N == 0) {\n\t\treturn 1;\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= 6; i++) {\n\t\tif (N - i >= 0) {\n\t\t\tcnt = cnt\n\t\t\t\t+ findWays(N - i);\n\t\t}\n\t}\n\treturn cnt;\n}", "6072": "int findWays(int N, int dp[])\n{\n\tif (N == 0) {\n\t\treturn 1;\n\t}\n\tif (dp[N] != -1) {\n\t\treturn dp[N];\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= 6; i++) {\n\t\tif (N - i >= 0) {\n\t\t\tcnt = cnt\n\t\t\t\t+ findWays(N - i, dp);\n\t\t}\n\t}\n\treturn dp[N] = cnt;\n}", "6073": "void findWays(int N)\n{\n\tint dp[N + 1];\n\tdp[0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[i] = 0;\n\t\tfor (int j = 1; j <= 6; j++) {\n\t\t\tif (i - j >= 0) {\n\t\t\t\tdp[i] = dp[i] + dp[i - j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[N];\n}", "6082": "int checkEqualSumUtil(int arr[], int N, int sm1, int sm2, int sm3, int j)\n{ \n if (j == N)\n {\n\tif (sm1 == sm2 && sm2 == sm3)\n\treturn 1;\n\telse\n\treturn 0;\n }\n else\n {\n\tint l = checkEqualSumUtil(arr, N, sm1 + arr[j], sm2, sm3, j + 1);\n\tint m = checkEqualSumUtil(arr, N, sm1, sm2 + arr[j], sm3, j + 1);\n\tint r = checkEqualSumUtil(arr, N, sm1, sm2, sm3 + arr[j], j + 1);\n\treturn max(max(l, m), r);\n }\n}\nvoid checkEqualSum(int arr[], int N)\n{\n int sum1, sum2, sum3;\n sum1 = sum2 = sum3 = 0;\n if (checkEqualSumUtil(arr, N, sum1, sum2, sum3, 0)== 1)\n {\n\tcout << \"Yes\";\n }\n else\n {\n\tcout << \"No\";\n }\n}", "6083": "int checkEqualSumUtil(int arr[], int N, int sm1, int sm2, int sm3, int j)\n{\n\tstring s = to_string(sm1)\n\t\t\t+ \"_\" + to_string(sm2)\n\t\t\t+ to_string(j);\n\tif (j == N) {\n\t\tif (sm1 == sm2 && sm2 == sm3)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tif (dp.find(s) != dp.end())\n\t\treturn dp[s];\n\telse {\n\t\tint l = checkEqualSumUtil( arr, N, sm1 + arr[j], sm2, sm3, j + 1);\n\t\tint m = checkEqualSumUtil( arr, N, sm1, sm2 + arr[j], sm3, j + 1);\n\t\tint r = checkEqualSumUtil( arr, N, sm1, sm2, sm3 + arr[j], j + 1);\n\t\treturn dp[s] = max(max(l, m), r);\n\t}\n}\nvoid checkEqualSum(int arr[], int N)\n{\n\tint sum1, sum2, sum3;\n\tsum1 = sum2 = sum3 = 0;\n\tif (checkEqualSumUtil( arr, N, sum1, sum2, sum3, 0) == 1) {\n\t\tcout << \"Yes\";\n\t}\n\telse {\n\t\tcout << \"No\";\n\t}\n}", "6113": "void SieveOfEratosthenes()\n{\n\tmemset(prime, true, sizeof(prime));\n\tfor (int p = 2; p * p <= MAX; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (int i = p * p; i <= MAX; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n}\nint getMid(int s, int e)\n{\n\treturn s + (e - s) / 2;\n}\nint getSumUtil(int* st, int ss, int se, int qs, int qe, int si)\n{\n\tif (qs <= ss && qe >= se)\n\t\treturn st[si];\n\tif (se < qs ss > qe)\n\t\treturn 0;\n\tint mid = getMid(ss, se);\n\treturn getSumUtil(st, ss, mid, qs, qe, 2 * si + 1)\n\t\t+ getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2);\n}\nvoid updateValueUtil(int* st, int ss, int se, int i, int diff, int si)\n{\n\tif (i < ss i > se)\n\t\treturn;\n\tst[si] = st[si] + diff;\n\tif (se != ss) {\n\t\tint mid = getMid(ss, se);\n\t\tupdateValueUtil(st, ss, mid, i, diff, 2 * si + 1);\n\t\tupdateValueUtil(st, mid + 1, se, i, diff, 2 * si + 2);\n\t}\n}\nvoid updateValue(int arr[], int* st, int n, int i, int new_val)\n{\n\tif (i < 0 i > n - 1) {\n\t\tcout << \"-1\";\n\t\treturn;\n\t}\n\tint diff = new_val - arr[i];\n\tint prev_val = arr[i];\n\tarr[i] = new_val;\n\tif (prime[new_val] prime[prev_val]) {\n\t\tif (!prime[prev_val])\n\t\t\tupdateValueUtil(st, 0, n - 1, i, new_val, 0);\n\t\telse if (!prime[new_val])\n\t\t\tupdateValueUtil(st, 0, n - 1, i, -prev_val, 0);\n\t\telse\n\t\t\tupdateValueUtil(st, 0, n - 1, i, diff, 0);\n\t}\n}\nint getSum(int* st, int n, int qs, int qe)\n{\n\tif (qs < 0 qe > n - 1 qs > qe) {\n\t\tcout << \"-1\";\n\t\treturn -1;\n\t}\n\treturn getSumUtil(st, 0, n - 1, qs, qe, 0);\n}\nint constructSTUtil(int arr[], int ss, int se, int* st, int si)\n{\n\tif (ss == se) {\n\t\tif (prime[arr[ss]])\n\t\t\tst[si] = arr[ss];\n\t\telse\n\t\t\tst[si] = 0;\n\t\treturn st[si];\n\t}\n\tint mid = getMid(ss, se);\n\tst[si]\n\t\t= constructSTUtil(arr, ss, mid, st, si * 2 + 1)\n\t\t+ constructSTUtil(arr, mid + 1, se, st, si * 2 + 2);\n\treturn st[si];\n}\nint* constructST(int arr[], int n)\n{\n\tint x = (int)(ceil(log2(n)));\n\tint max_size = 2 * (int)pow(2, x) - 1;\n\tint* st = new int[max_size];\n\tconstructSTUtil(arr, 0, n - 1, st, 0);\n\treturn st;\n}", "6138": "void precompute(int nextpos[], int arr[], int N)\n{\n\tnextpos[N - 1] = N;\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tif (arr[i] == arr[i + 1])\n\t\t\tnextpos[i] = nextpos[i + 1];\n\t\telse\n\t\t\tnextpos[i] = i + 1;\n\t}\n}\nvoid findIndex(int query[][3], int arr[], int N, int Q)\n{\n\tint nextpos[N];\n\tprecompute(nextpos, arr, N);\n\tfor (int i = 0; i < Q; i++) {\n\t\tint l, r, x;\n\t\tl = query[i][0];\n\t\tr = query[i][1];\n\t\tx = query[i][2];\n\t\tint ans = -1;\n\t\tif (arr[l] != x)\n\t\t\tans = l;\n\t\telse {\n\t\t\tint d = nextpos[l];\n\t\t\tif (d <= r)\n\t\t\t\tans = d;\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n}", "6151": "long long countWays(string s, string t, int k)\n{\n\tint n = s.size();\n\tint a = 0, b = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring p = s.substr(i, n - i)\n\t\t\t\t+ s.substr(0, i);\n\t\tif (p == t)\n\t\t\ta++;\n\t\telse\n\t\t\tb++;\n\t}\n\tvector<long long> dp1(k + 1), dp2(k + 1);\n\tif (s == t) {\n\t\tdp1[0] = 1;\n\t\tdp2[0] = 0;\n\t}\n\telse {\n\t\tdp1[0] = 0;\n\t\tdp2[0] = 1;\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tdp1[i]\n\t\t\t= ((dp1[i - 1] * (a - 1)) % mod\n\t\t\t+ (dp2[i - 1] * a) % mod)\n\t\t\t% mod;\n\t\tdp2[i]\n\t\t\t= ((dp1[i - 1] * (b)) % mod\n\t\t\t+ (dp2[i - 1] * (b - 1)) % mod)\n\t\t\t% mod;\n\t}\n\treturn dp1[k];\n}", "6169": "void insert(int idx, string& s, TrieNode* root)\n{\n\tTrieNode* temp = root;\n\tfor (int i = idx; i < s.length(); i++) {\n\t\tif (temp->child[s[i] - 'a'] == NULL)\n\t\t\ttemp->child[s[i] - 'a'] = new TrieNode;\n\t\ttemp = temp->child[s[i] - 'a'];\n\t}\n}\nint minCuts(string S1, string S2)\n{\n\tint n1 = S1.length();\n\tint n2 = S2.length();\n\tTrieNode* root = new TrieNode;\n\tfor (int i = 0; i < n2; i++) {\n\t\tinsert(i, S2, root);\n\t}\n\tvector<int> dp(n1 + 1, INF);\n\tdp[0] = 0;\n\tfor (int i = 0; i < n1; i++) {\n\t\tTrieNode* temp = root;\n\t\tfor (int j = i + 1; j <= n1; j++) {\n\t\t\tif (temp->child[S1[j - 1] - 'a'] == NULL)\n\t\t\t\tbreak;\n\t\t\tdp[j] = min(dp[j], dp[i] + 1);\n\t\t\ttemp = temp->child[S1[j - 1] - 'a'];\n\t\t}\n\t}\n\tif (dp[n1] >= INF)\n\t\treturn -1;\n\telse\n\t\treturn dp[n1];\n}", "6174": "int minOperation(int k)\n{\n\tvector<int> dp(k + 1, 0);\n\tfor (int i = 1; i <= k; i++) {\n\t\tdp[i] = dp[i - 1] + 1;\n\t\tif (i % 2 == 0) {\n\t\t\tdp[i]\n\t\t\t\t= min(dp[i], dp[i / 2] + 1);\n\t\t}\n\t}\n\treturn dp[k];\n}", "6181": "int longestSubseq(string s, int length)\n{\n\tint ones[length + 1], zeroes[length + 1];\n\tmemset(ones, 0, sizeof(ones));\n\tmemset(zeroes, 0, sizeof(zeroes));\n\tfor (int i = 0; i < length; i++) {\n\t\tif (s[i] == '1') {\n\t\t\tones[i + 1] = ones[i] + 1;\n\t\t\tzeroes[i + 1] = zeroes[i];\n\t\t}\n\t\telse {\n\t\t\tzeroes[i + 1] = zeroes[i] + 1;\n\t\t\tones[i + 1] = ones[i];\n\t\t}\n\t}\n\tint answer = INT_MIN;\n\tint x = 0;\n\tfor (int i = 0; i <= length; i++) {\n\t\tfor (int j = i; j <= length; j++) {\n\t\t\tx += ones[i];\n\t\t\tx += (zeroes[j] - zeroes[i]);\n\t\t\tx += (ones[length] - ones[j]);\n\t\t\tanswer = max(answer, x);\n\t\t\tx = 0;\n\t\t}\n\t}\n\tcout << answer << endl;\n}", "6209": "void largestSquare(int matrix[][MAX], int R, int C, int q_i[], int q_j[], int K, int Q){\n\tfor (int q = 0; q < Q; q++) {\n\t\tint i = q_i[q];\n\t\tint j = q_j[q];\n\t\tint min_dist = min(min(i, j),\n\t\tmin(R - i - 1, C - j - 1));\n\t\tint ans = -1;\n\t\tfor (int k = 0; k <= min_dist; k++) {\n\t\t\tint count = 0;\n\t\t\tfor (int row = i - k; row <= i + k; row++)\n\t\t\t\tfor (int col = j - k; col <= j + k; col++)\n\t\t\t\t\tcount += matrix[row][col];\n\t\t\tif (count > K)\n\t\t\t\tbreak;\n\t\t\tans = 2 * k + 1;\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n}", "6210": "void largestSquare(int matrix[][MAX], int R, int C, int q_i[], int q_j[], int K, int Q){\n\tint countDP[R][C];\n\tmemset(countDP, 0, sizeof(countDP));\n\tcountDP[0][0] = matrix[0][0];\n\tfor (int i = 1; i < R; i++)\n\t\tcountDP[i][0] = countDP[i - 1][0] + \n\t\t\t\t\t\t\tmatrix[i][0];\n\tfor (int j = 1; j < C; j++)\n\t\tcountDP[0][j] = countDP[0][j - 1] +\n\t\t\t\t\t\t\tmatrix[0][j];\n\tfor (int i = 1; i < R; i++)\n\t\tfor (int j = 1; j < C; j++)\n\t\t\tcountDP[i][j] = matrix[i][j] +\n\t\t\t\t\tcountDP[i - 1][j] +\n\t\t\t\t\tcountDP[i][j - 1] -\n\t\t\t\t\tcountDP[i - 1][j - 1];\n\tfor (int q = 0; q < Q; q++) {\n\t\tint i = q_i[q];\n\t\tint j = q_j[q];\n\t\tint min_dist = min(min(i, j), \n\t\tmin(R - i - 1, C - j - 1));\n\t\tint ans = -1;\n\t\tfor (int k = 0; k <= min_dist; k++) {\n\t\t\tint x1 = i - k, x2 = i + k;\n\t\t\tint y1 = j - k, y2 = j + k;\n\t\t\tint count = countDP[x2][y2];\n\t\t\tif (x1 > 0)\n\t\t\t\tcount -= countDP[x1 - 1][y2];\n\t\t\tif (y1 > 0)\n\t\t\t\tcount -= countDP[x2][y1 - 1];\n\t\t\tif (x1 > 0 && y1 > 0)\n\t\t\t\tcount += countDP[x1 - 1][y1 - 1];\n\t\t\tif (count > K)\n\t\t\t\tbreak;\n\t\t\tans = 2 * k + 1;\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n}", "6211": "void largestSquare(int matrix[][MAX], int R, int C, int q_i[], int q_j[], int K, int Q){\n\tint countDP[R][C];\n\tmemset(countDP, 0, sizeof(countDP));\n\tcountDP[0][0] = matrix[0][0];\n\tfor (int i = 1; i < R; i++)\n\t\tcountDP[i][0] = countDP[i - 1][0] +\n\t\t\t\t\t\t\tmatrix[i][0];\n\tfor (int j = 1; j < C; j++)\n\t\tcountDP[0][j] = countDP[0][j - 1] +\n\t\t\t\t\t\t\tmatrix[0][j];\n\tfor (int i = 1; i < R; i++)\n\t\tfor (int j = 1; j < C; j++)\n\t\t\tcountDP[i][j] = matrix[i][j] +\n\t\t\t\t\tcountDP[i - 1][j] +\n\t\t\t\t\tcountDP[i][j - 1] -\n\t\t\t\tcountDP[i - 1][j - 1];\n\tfor (int q = 0; q < Q; q++) {\n\t\tint i = q_i[q];\n\t\tint j = q_j[q];\n\t\tint min_dist = min(min(i, j),\n\t\tmin(R - i - 1, C - j - 1));\n\t\tint ans = -1, l = 0, u = min_dist;\n\t\twhile (l <= u) {\n\t\t\tint mid = (l + u) / 2;\n\t\t\tint x1 = i - mid, x2 = i + mid;\n\t\t\tint y1 = j - mid, y2 = j + mid;\n\t\t\tint count = countDP[x2][y2];\n\t\t\tif (x1 > 0)\n\t\t\t\tcount -= countDP[x1 - 1][y2];\n\t\t\tif (y1 > 0)\n\t\t\t\tcount -= countDP[x2][y1 - 1];\n\t\t\tif (x1 > 0 && y1 > 0)\n\t\t\t\tcount += countDP[x1 - 1][y1 - 1];\n\t\t\tif (count <= K) {\n\t\t\t\tans = 2 * mid + 1;\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tu = mid - 1;\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n}", "6241": "long count_special(long n)\n{\n\tlong fib[n + 1];\n\tfib[0] = 1;\n\tfib[1] = 2;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfib[i] = (fib[i - 1] % mod + fib[i - 2] % mod) % mod;\n\t}\n\treturn fib[n];\n}", "6273": "int maxSum(int p0, int p1, int a[], int pos, int n)\n{\n\tif (pos == n) {\n\t\tif (p0 == p1)\n\t\t\treturn p0;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tint ans = maxSum(p0, p1, a, pos + 1, n);\n\tans = max(ans, maxSum(p0 + a[pos], p1, a, pos + 1, n));\n\tans = max(ans, maxSum(p0, p1 + a[pos], a, pos + 1, n));\n\treturn ans;\n}", "6274": "int maxSum(int a[], int n)\n{\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += a[i];\n\tint limit = 2 * sum + 1;\n\tint dp[n + 1][limit];\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tfor (int j = 0; j < limit; j++)\n\t\t\tdp[i][j] = INT_MIN;\n\t}\n\tdp[0][sum] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < limit; j++) {\n\t\t\tif ((j - a[i - 1]) >= 0 && dp[i - 1][j - a[i - 1]] != INT_MIN)\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j - a[i - 1]] + a[i - 1]);\n\t\t\tif ((j + a[i - 1]) < limit && dp[i - 1][j + a[i - 1]] != INT_MIN)\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j + a[i - 1]]);\n\t\t\tif (dp[i - 1][j] != INT_MIN)\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j]);\n\t\t}\n\t}\n\treturn dp[n][sum];\n}", "6281": "int calculate(int pos, int prev, string s, vector<int>* index)\n{\n\tif (pos == s.length())\n\t\treturn 1;\n\tif (dp[pos][prev] != -1)\n\t\treturn dp[pos][prev];\n\tint c = s[pos] - 'a';\n\tint answer = 0;\n\tfor (int i = 0; i < index.size(); i++) {\n\t\tif (index[i] > prev) {\n\t\t\tanswer = (answer % mod + calculate(pos + 1, index[i], s, index) % mod) % mod;\n\t\t}\n\t}\n\treturn dp[pos][prev] = answer;\n}\nint countWays(vector<string>& a, string s)\n{\n\tint n = a.size();\n\tvector<int> index[26];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < a[i].length(); j++) {\n\t\t\tindex[a[i][j] - 'a'].push_back(j + 1);\n\t\t}\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\treturn calculate(0, 0, s, index);\n}", "6289": "void computeFibonacci()\n{\n\tfib[0] = 1;\n\tfib[1] = 1;\n\tfor (int i = 2; i < 100005; i++) {\n\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t}\n}\nint countString(string str)\n{\n\tint ans = 1;\n\tint cnt = 1;\n\tfor (int i = 1; str[i]; i++) {\n\t\tif (str[i] == str[i - 1]) {\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tans = ans * fib[cnt];\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tans = ans * fib[cnt];\n\treturn ans;\n}", "6298": "void printGolombSequence(int N)\n{\n\tint arr[MAX];\n\tint cnt = 0;\n\tarr[0] = 0;\n\tarr[1] = 1;\n\tmap<int, int> M;\n\tM[2] = 2;\n\tfor (int i = 2; i <= N; i++) {\n\t\tif (cnt == 0) {\n\t\t\tarr[i] = 1 + arr[i - 1];\n\t\t\tcnt = M[arr[i]];\n\t\t\tcnt--;\n\t\t}\n\t\telse {\n\t\t\tarr[i] = arr[i - 1];\n\t\t\tcnt--;\n\t\t}\n\t\tM[i] = arr[i];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tcout << arr[i] << ' ';\n\t}\n}", "6299": "int number_of_ways(int n)\n{\n\tint includes_3[n + 1] = {};\n\tint not_includes_3[n + 1] = {};\n\tincludes_3[3] = 1;\n\tnot_includes_3[1] = 1;\n\tnot_includes_3[2] = 2;\n\tnot_includes_3[3] = 3;\n\tfor (int i = 4; i <= n; i++) {\n\t\tincludes_3[i]\n\t\t\t= includes_3[i - 1] + includes_3[i - 2] + not_includes_3[i - 3];\n\t\tnot_includes_3[i]\n\t\t\t= not_includes_3[i - 1] + not_includes_3[i - 2];\n\t}\n\treturn includes_3[n];\n}", "6301": "int generateDivisors(int n)\n{\n\tfor (int i = 1; i <= sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (n / i == i) {\n\t\t\t\tdivisors[i]++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdivisors[i]++;\n\t\t\t\tdivisors[n / i]++;\n\t\t\t}\n\t\t}\n\t}\n}\nint findMaxMultiples(int* arr, int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = max(divisors[arr[i]], ans);\n\t\tgenerateDivisors(arr[i]);\n\t}\n\treturn ans;\n}", "6335": "int countNum(int idx, int sum, int tight, vector<int> num, int len, int k)\n{\n\tif (len == idx) {\n\t\tif (sum == 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tif (dp[idx][sum][tight] != -1)\n\t\treturn dp[idx][sum][tight];\n\tint res = 0, limit;\n\tif (tight == 0) {\n\t\tlimit = num[idx];\n\t}\n\telse {\n\t\tlimit = 9;\n\t}\n\tfor (int i = 0; i <= limit; i++) {\n\t\tint new_tight = tight;\n\t\tif (tight == 0 && i < limit)\n\t\t\tnew_tight = 1;\n\t\tres += countNum(idx + 1,\n\t\t\t\t\t\t(sum + i) % k, new_tight, num, len, k);\n\t\tres %= MOD;\n\t}\n\tif (res < 0)\n\t\tres += MOD;\n\treturn dp[idx][sum][tight] = res;\n}\nvector<int> process(string s)\n{\n\tvector<int> num;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tnum.push_back(s[i] - '0');\n\t}\n\treturn num;\n}", "6346": "int MinCost(int arr[], int n)\n{\n\tint dp[n + 5][n + 5], sum[n + 5][n + 5];\n\tmemset(sum, 0, sizeof(0));\n\tfor (int i = 0; i < n; i++) {\n\t\tint k = arr[i];\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tif (i == j)\n\t\t\t\tsum[i][j] = k;\n\t\t\telse {\n\t\t\t\tk += arr[j];\n\t\t\t\tsum[i][j] = k;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tdp[i][j] = INT_MAX;\n\t\t\tif (i == j)\n\t\t\t\tdp[i][j] = 0;\n\t\t\telse {\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}", "6364": "int f(int i, int state, int A[], int dp[][3], int N)\n{\n\tif (i >= N)\n\t\treturn 0;\n\telse if (dp[i][state] != -1) {\n\t\treturn dp[i][state];\n\t}\n\telse {\n\t\tif (i == N - 1)\n\t\t\tdp[i][state] = 1;\n\t\telse if (state == 1 && A[i] > A[i + 1])\n\t\t\tdp[i][state] = 1;\n\t\telse if (state == 2 && A[i] < A[i + 1])\n\t\t\tdp[i][state] = 1;\n\t\telse if (state == 1 && A[i] <= A[i + 1])\n\t\t\tdp[i][state] = 1 + f(i + 1, 2, A, dp, N);\n\t\telse if (state == 2 && A[i] >= A[i + 1])\n\t\t\tdp[i][state] = 1 + f(i + 1, 1, A, dp, N);\n\t\treturn dp[i][state];\n\t}\n}\nint maxLenSeq(int A[], int N)\n{\n\tint i, tmp, y, ans;\n\tint dp[1000][3];\n\tmemset(dp, -1, sizeof dp);\n\tfor (i = 0; i < N; i++) {\n\t\ttmp = f(i, 1, A, dp, N);\n\t\ttmp = f(i, 2, A, dp, N);\n\t}\n\tans = -1;\n\tfor (i = 0; i < N; i++) {\n\t\ty = dp[i][1];\n\t\tif (i + y >= N)\n\t\t\tans = max(ans, dp[i][1] + 1);\n\t\telse if (y % 2 == 0) {\n\t\t\tans = max(ans, dp[i][1] + 1 + dp[i + y][2]);\n\t\t}\n\t\telse if (y % 2 == 1) {\n\t\t\tans = max(ans, dp[i][1] + 1 + dp[i + y][1]);\n\t\t}\n\t}\n\treturn ans;\n}", "6380": "int ways(int i, int arr[], int n)\n{\n\tif (i == n - 1)\n\t\treturn 1;\n\tint sum = 0;\n\tfor (int j = 1; j + i < n && j <= arr[i]; j++) {\n\t\tsum += (ways(i + j, arr, n))\n\t\t\t% mod;\n\t\tsum %= mod;\n\t}\n\treturn sum % mod;\n}", "6381": "int ways(int arr[], int n)\n{\n\tint dp[n + 1];\n\tdp[n - 1] = 1;\n\tfor (int i = n - 2; i >= 0; i--) {\n\t\tdp[i] = 0;\n\t\tfor (int j = 1; ((j + i) < n && j <= arr[i]); j++) {\n\t\t\tdp[i] += dp[i + j];\n\t\t\tdp[i] %= mod;\n\t\t}\n\t}\n\treturn dp[0] % mod;\n}", "6386": "pair<int, int> countSum(int arr[], int n)\n{\n\tint result = 0;\n\tint count_odd, count_even;\n\tcount_odd = 0;\n\tcount_even = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (arr[i - 1] % 2 == 0) {\n\t\t\tcount_even = count_even + count_even + 1;\n\t\t\tcount_odd = count_odd + count_odd;\n\t\t}\n\t\telse {\n\t\t\tint temp = count_even;\n\t\t\tcount_even = count_even + count_odd;\n\t\t\tcount_odd = count_odd + temp + 1;\n\t\t}\n\t}\n\treturn { count_even, count_odd };\n}", "6395": "int MaxGCD(int a[], int n)\n{\n\tint Prefix[n + 2];\n\tint Suffix[n + 2];\n\tPrefix[1] = a[0];\n\tfor (int i = 2; i <= n; i += 1) {\n\t\tPrefix[i] = __gcd(Prefix[i - 1], a[i - 1]);\n\t}\n\tSuffix[n] = a[n - 1];\n\tfor (int i = n - 1; i >= 1; i -= 1) {\n\t\tSuffix[i] = __gcd(Suffix[i + 1], a[i - 1]);\n\t}\n\tint ans = max(Suffix[2], Prefix[n - 1]);\n\tfor (int i = 2; i < n; i += 1) {\n\t\tans = max(ans, __gcd(Prefix[i - 1], Suffix[i + 1]));\n\t}\n\treturn ans;\n}", "6396": "vector<int> numToVec(int N)\n{\n\tvector<int> digit;\n\twhile (N != 0) {\n\t\tdigit.push_back(N % 10);\n\t\tN = N / 10;\n\t}\n\tif (digit.size() == 0)\n\t\tdigit.push_back(0);\n\treverse(digit.begin(), digit.end());\n\treturn digit;\n}\nint solve(vector<int>& A, int B, int C)\n{\n\tvector<int> digit;\n\tint d, d2;\n\tdigit = numToVec(C);\n\td = A.size();\n\tif (B > digit.size() d == 0)\n\t\treturn 0;\n\telse if (B < digit.size()) {\n\t\tif (A[0] == 0 && B != 1)\n\t\t\treturn (d - 1) * pow(d, B - 1);\n\t\telse\n\t\t\treturn pow(d, B);\n\t}\n\telse {\n\t\tint dp[B + 1] = { 0 };\n\t\tint lower[MAX + 1] = { 0 };\n\t\tfor (int i = 0; i < d; i++)\n\t\t\tlower[A[i] + 1] = 1;\n\t\tfor (int i = 1; i <= MAX; i++)\n\t\t\tlower[i] = lower[i - 1] + lower[i];\n\t\tbool flag = true;\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= B; i++) {\n\t\t\td2 = lower[digit[i - 1]];\n\t\t\tdp[i] = dp[i - 1] * d;\n\t\t\tif (i == 1 && A[0] == 0 && B != 1)\n\t\t\t\td2 = d2 - 1;\n\t\t\tif (flag)\n\t\t\t\tdp[i] += d2;\n\t\t\tflag = (flag & (lower[digit[i - 1] + 1] == lower[digit[i - 1]] + 1));\n\t\t}\n\t\treturn dp[B];\n\t}\n}", "6442": "int countWays(int i, int j, int x, int arr[][n])\n{\n\tif (i == n j == n)\n\t\treturn 0;\n\tx = (x & arr[i][j]);\n\tif (x == 0)\n\t\treturn 0;\n\tif (i == n - 1 && j == n - 1)\n\t\treturn 1;\n\tif (v[i][j][x])\n\t\treturn dp[i][j][x];\n\tv[i][j][x] = 1;\n\tdp[i][j][x] = countWays(i + 1, j, x, arr)\n\t\t\t\t+ countWays(i, j + 1, x, arr);\n\treturn dp[i][j][x];\n}", "6454": "void pre_process(bool dp[N][N], string s)\n{\n\tint n = s.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tdp[i][j] = false;\n\t}\n\tfor (int j = 1; j <= n; j++) {\n\t\tfor (int i = 0; i <= n - j; i++) {\n\t\t\tif (j <= 2) {\n\t\t\t\tif (s[i] == s[i + j - 1])\n\t\t\t\t\tdp[i][i + j - 1] = true;\n\t\t\t}\n\t\t\telse if (s[i] == s[i + j - 1])\n\t\t\t\tdp[i][i + j - 1] = dp[i + 1][i + j - 2];\n\t\t}\n\t}\n}\nint countPairs(string s)\n{\n\tbool dp[N][N];\n\tpre_process(dp, s);\n\tint n = s.length();\n\tint left[n];\n\tmemset(left, 0, sizeof left);\n\tint right[n];\n\tmemset(right, 0, sizeof right);\n\tleft[0] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tif (dp[j][i] == 1)\n\t\t\t\tleft[i]++;\n\t\t}\n\t}\n\tright[n - 1] = 1;\n\tfor (int i = n - 2; i >= 0; i--) {\n\t\tright[i] = right[i + 1];\n\t\tfor (int j = n - 1; j >= i; j--) {\n\t\t\tif (dp[i][j] == 1)\n\t\t\t\tright[i]++;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n - 1; i++)\n\t\tans += left[i] * right[i + 1];\n\treturn ans;\n}", "6469": "int FindMaximumSum(int ind, int kon, int a[], int b[], int c[], int n, int dp[][N])\n{\n\tif (ind == n)\n\t\treturn 0;\n\tif (dp[ind][kon] != -1)\n\t\treturn dp[ind][kon];\n\tint ans = -1e9 + 5;\n\tif (kon == 0) {\n\t\tans = max(ans, b[ind] + FindMaximumSum(ind + 1, 1, a, b, c, n, dp));\n\t\tans = max(ans, c[ind] + FindMaximumSum(ind + 1, 2, a, b, c, n, dp));\n\t}\n\telse if (kon == 1) {\n\t\tans = max(ans, a[ind] + FindMaximumSum(ind + 1, 0, a, b, c, n, dp));\n\t\tans = max(ans, c[ind] + FindMaximumSum(ind + 1, 2, a, b, c, n, dp));\n\t}\n\telse if (kon == 2) {\n\t\tans = max(ans, a[ind] + FindMaximumSum(ind + 1, 1, a, b, c, n, dp));\n\t\tans = max(ans, b[ind] + FindMaximumSum(ind + 1, 0, a, b, c, n, dp));\n\t}\n\treturn dp[ind][kon] = ans;\n}", "6471": "int noOfBinaryStrings(int N, int k)\n{\n\tint dp[100002];\n\tfor (int i = 1; i <= k - 1; i++) {\n\t\tdp[i] = 1;\n\t}\n\tdp[k] = 2;\n\tfor (int i = k + 1; i <= N; i++) {\n\t\tdp[i] = (dp[i - 1] + dp[i - k]) % mod;\n\t}\n\treturn dp[N];\n}", "6478": "int findWaysToPair(int p)\n{\n\tint dp[p + 1];\n\tdp[1] = 1;\n\tdp[2] = 2;\n\tfor (int i = 3; i <= p; i++) {\n\t\tdp[i] = dp[i - 1] + (i - 1) * dp[i - 2];\n\t}\n\treturn dp[p];\n}", "6480": "int findSubarraySum(int ind, int flips, int n, int a[], int k)\n{\n\tif (flips > k)\n\t\treturn -1e9;\n\tif (ind == n)\n\t\treturn 0;\n\tif (dp[ind][flips] != -1)\n\t\treturn dp[ind][flips];\n\tint ans = 0;\n\tans = max(\n\t\t0,\n\t\ta[ind] + findSubarraySum(ind + 1, flips, n, a, k));\n\tans = max(ans, -a[ind]\n\t\t\t\t\t+ findSubarraySum(ind + 1, flips + 1, n, a, k));\n\treturn dp[ind][flips] = ans;\n}\nint findMaxSubarraySum(int a[], int n, int k)\n{\n\tmemset(dp, -1, sizeof(dp));\n\tint ans = -1e9;\n\tfor (int i = 0; i < n; i++)\n\t\tans = max(ans, findSubarraySum(i, 0, n, a, k));\n\tif (ans == 0 && k == 0)\n\t\treturn *max_element(a, a + n);\n\treturn ans;\n}", "6486": "int maxWeight(int* arr, int n, int w1_r, int w2_r, int i)\n{\n\tif (i == n)\n\t\treturn 0;\n\tif (dp[i][w1_r][w2_r] != -1)\n\t\treturn dp[i][w1_r][w2_r];\n\tint fill_w1 = 0, fill_w2 = 0, fill_none = 0;\n\tif (w1_r >= arr[i])\n\t\tfill_w1 = arr[i] +\n\t\tmaxWeight(arr, n, w1_r - arr[i], w2_r, i + 1);\n\tif (w2_r >= arr[i])\n\t\tfill_w2 = arr[i] +\n\t\tmaxWeight(arr, n, w1_r, w2_r - arr[i], i + 1);\n\tfill_none = maxWeight(arr, n, w1_r, w2_r, i + 1);\n\tdp[i][w1_r][w2_r] = max(fill_none, max(fill_w1, fill_w2));\n\treturn dp[i][w1_r][w2_r];\n}", "6488": "void findPrefixCount(int p_arr[][n], bool set_bit[][n])\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = n - 1; j >= 0; j--) {\n\t\t\tif (!set_bit[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (j != n - 1)\n\t\t\t\tp_arr[i][j] += p_arr[i][j + 1];\n\t\t\tp_arr[i][j] += (int)set_bit[i][j];\n\t\t}\n\t}\n}\nint matrixAllOne(bool set_bit[][n])\n{\n\tint p_arr[n][n] = { 0 };\n\tfindPrefixCount(p_arr, set_bit);\n\tint ans = 0;\n\tfor (int j = 0; j < n; j++) {\n\t\tint i = n - 1;\n\t\tstack<pair<int, int> > q;\n\t\tint to_sum = 0;\n\t\twhile (i >= 0) {\n\t\t\tint c = 0;\n\t\t\twhile (q.size() != 0 and q.top().first > p_arr[i][j]) {\n\t\t\t\tto_sum -= (q.top().second + 1) * (q.top().first - p_arr[i][j]);\n\t\t\t\tc += q.top().second + 1;\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\tto_sum += p_arr[i][j];\n\t\t\tans += to_sum;\n\t\t\tq.push({ p_arr[i][j], c });\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ans;\n}\nint sumAndMatrix(int arr[][n])\n{\n\tint sum = 0;\n\tint mul = 1;\n\tfor (int i = 0; i < 30; i++) {\n\t\tbool set_bit[n][n];\n\t\tfor (int R = 0; R < n; R++)\n\t\t\tfor (int C = 0; C < n; C++)\n\t\t\t\tset_bit[R][C] = ((arr[R][C] & (1 << i)) != 0);\n\t\tsum += (mul * matrixAllOne(set_bit));\n\t\tmul *= 2;\n\t}\n\treturn sum;\n}", "6525": "int solve(int dp[][2], int wt, int K, int M, int used)\n{\n\tif (wt < 0)\n\t\treturn 0;\n\tif (wt == 0) {\n\t\tif (used)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tif (dp[wt][used] != -1)\n\t\treturn dp[wt][used];\n\tint ans = 0;\n\tfor (int i = 1; i <= K; i++) {\n\t\tif (i >= M)\n\t\t\tans += solve(dp, wt - i, K, M, used 1);\n\t\telse\n\t\t\tans += solve(dp, wt - i, K, M, used);\n\t}\n\treturn dp[wt][used] = ans;\n}", "6531": "long long sumOddFibonacci(int n)\n{\n\tlong long Sum[n + 1];\n\tSum[0] = 0;\n\tSum[1] = 1;\n\tSum[2] = 2;\n\tSum[3] = 5;\n\tSum[4] = 10;\n\tSum[5] = 23;\n\tfor (int i = 6; i <= n; i++) {\n\t\tSum[i] = ((Sum[i - 1] + (4 * Sum[i - 2]) % mod -\n\t\t\t\t(4 * Sum[i - 3]) % mod + mod) % mod +\n\t\t\t\t(Sum[i - 4] - Sum[i - 5] + mod) % mod) % mod;\n\t}\n\treturn Sum[n];\n}", "6536": "int CountWays(int n)\n{\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n == 1) {\n\t\treturn 1;\n\t}\n\tif (n == 2) {\n\t\treturn 1 + 1;\n\t}\n\treturn CountWays(n - 1) + CountWays(n - 3);\n}", "6537": "int CountWays(int n)\n{\n\tint noOfWays[n + 3];\n\tnoOfWays[0] = 1;\n\tnoOfWays[1] = 1;\n\tnoOfWays[2] = 1 + 1;\n\tfor (int i=3; i<n+1; i++) {\n\tnoOfWays[i] = noOfWays[i-1] + noOfWays[i-3];\n\t}\n\treturn noOfWays[n];\n}", "6538": "int CountWays(int n)\n{\n\tint noOfWays[3];\n\tnoOfWays[0] = 1;\n\tnoOfWays[1] = 1;\n\tnoOfWays[2] = 1 + 1;\n\tfor (int i=3; i<n+1; i++) {\n\tnoOfWays[i] =\n\t\tnoOfWays[3-1]\n\t\t+ noOfWays[3-3];\n\tnoOfWays[0] = noOfWays[1];\n\tnoOfWays[1] = noOfWays[2];\n\tnoOfWays[2] = noOfWays[i];\n\t}\n\treturn noOfWays[n];\n}", "6550": "long long fun(int marks[],int n)\n{\n\tlong long dp[n], temp;\n\tfill(dp, dp + n, 1);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tif (marks[i] > marks[i + 1])\n\t\t{\n\t\t\ttemp = i;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif ((marks[temp] > marks[temp + 1]) && temp >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (dp[temp] > dp[temp + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp -= 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[temp] = dp[temp + 1] + 1;\n\t\t\t\t\t\ttemp -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\t\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if( marks[i] < marks[i + 1])\n\t\t\tdp[i + 1] = dp[i] + 1;\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < n; i++)\n\tsum += dp[i];\n\treturn sum;\n}", "6553": "void sieve(int prime[])\n{\n\tfor (int i = 2; i * i <= MAX; i++) {\n\t\tif (prime[i] == 0) {\n\t\t\tfor (int j = i * i; j <= MAX; j += i)\n\t\t\t\tprime[j] = 1;\n\t\t}\n\t}\n}\nvoid dfs(int i, int j, int k, int* q, int n, int m, int mappedMatrix[][MAX], int mark[][MAX], pair<int, int> ans[])\n{\n\tif (mappedMatrix[i][j] == 0 || i > n\n\t\t\t\t\t\t|| j > m || mark[i][j] || (*q))\n\t\treturn;\n\tmark[i][j] = 1;\n\tans[k] = make_pair(i, j);\n\tif (i == n && j == m) {\n\t\t(*q) = k;\n\t\treturn;\n\t}\n\tdfs(i + 1, j + 1, k + 1, q, n, m, mappedMatrix, mark, ans);\n\tdfs(i + 1, j, k + 1, q, n, m, mappedMatrix, mark, ans);\n\tdfs(i, j + 1, k + 1, q, n, m, mappedMatrix, mark, ans);\n}\nvoid lexicographicalPath(int n, int m, int mappedMatrix[][MAX])\n{\n\tint q = 0;\n\tpair<int, int> ans[MAX];\n\tint mark[MAX][MAX];\n\tdfs(1, 1, 1, &q, n, m, mappedMatrix, mark, ans);\n\tfor (int i = 1; i <= q; i++)\n\t\tcout << ans[i].first << \" \" << ans[i].second << \"\\n\";\n}\nvoid countPrimePath(int mappedMatrix[][MAX], int n, int m)\n{\n\tint dp[MAX][MAX] = { 0 };\n\tdp[1][1] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (i == 1 && j == 1)\n\t\t\t\tcontinue;\n\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]);\n\t\t\tif (mappedMatrix[i][j] == 0)\n\t\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tcout << dp[n][m] << \"\\n\";\n}\nvoid preprocessMatrix(int mappedMatrix[][MAX], int a[][MAX], int n, int m)\n{\n\tint prime[MAX];\n\tsieve(prime);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (prime[a[i][j]] == 0)\n\t\t\t\tmappedMatrix[i + 1][j + 1] = 1;\n\t\t\telse\n\t\t\t\tmappedMatrix[i + 1][j + 1] = 0;\n\t\t}\n\t}\n}", "6554": "long long partitions(int n)\n{\n\tvector<long long> p(n + 1, 0);\n\tp[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint k = 1;\n\t\twhile ((k * (3 * k - 1)) / 2 <= i) {\n\t\t\tp[i] += (k % 2 ? 1 : -1) * p[i - (k * (3 * k - 1)) / 2];\n\t\t\tif (k > 0)\n\t\t\t\tk *= -1;\n\t\t\telse\n\t\t\t\tk = 1 - k;\n\t\t}\n\t}\n\treturn p[n];\n}", "6586": "vector<int> factors(int n)\n{\n\tvector<int> v;\n\tv.push_back(1);\n\tfor (int i = 2; i <= sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tv.push_back(i);\n\t\t\tif (n / i != i) {\n\t\t\t\tv.push_back(n / i);\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\nbool checkAbundant(int n)\n{\n\tvector<int> v;\n\tint sum = 0;\n\tv = factors(n);\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tsum += v[i];\n\t}\n\tif (sum > n)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nbool checkSemiPerfect(int n)\n{\n\tvector<int> v;\n\tv = factors(n);\n\tsort(v.begin(), v.end());\n\tint r = v.size();\n\tbool subset[r + 1][n + 1];\n\tfor (int i = 0; i <= r; i++)\n\t\tsubset[i][0] = true;\n\tfor (int i = 1; i <= n; i++)\n\t\tsubset[0][i] = false;\n\tfor (int i = 1; i <= r; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (j < v[i - 1])\n\t\t\t\tsubset[i][j] = subset[i - 1][j];\n\t\t\telse {\n\t\t\t\tsubset[i][j] = subset[i - 1][j] ||\n\t\t\t\t\t\t\tsubset[i - 1][j - v[i - 1]];\n\t\t\t}\n\t\t}\n\t}\n\tif ((subset[r][n]) == 0)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nbool checkweird(int n)\n{\n\tif (checkAbundant(n) == true &&\n\t\tcheckSemiPerfect(n) == false)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "6589": "int solve(int N, int K)\n{\n\tint combo[N + 1] = { 0 };\n\tcombo[0] = 1;\n\tfor (int i = 1; i <= K; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tif (j >= i) {\n\t\t\t\tcombo[j] += combo[j - i];\n\t\t\t}\n\t\t}\n\t}\n\treturn combo[N];\n}", "6679": "int maxSubArraySumRepeated(int a[], int n, int k)\n{\n\tint max_so_far = INT_MIN, max_ending_here = 0;\n\tfor (int i = 0; i < n*k; i++)\n\t{\n\t\tmax_ending_here = max_ending_here + a[i%n];\n\t\tif (max_so_far < max_ending_here)\n\t\t\tmax_so_far = max_ending_here;\n\t\tif (max_ending_here < 0)\n\t\t\tmax_ending_here = 0;\n\t}\n\treturn max_so_far;\n}", "6712": "int longOddEvenIncSeq(int arr[], int n)\n{\n\tint lioes[n];\n\tint maxLen = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tlioes[i] = 1;\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (arr[i] > arr[j] &&\n\t\t\t(arr[i] + arr[j]) % 2 != 0 && lioes[i] < lioes[j] + 1)\n\t\t\t\tlioes[i] = lioes[j] + 1;\n\tfor (int i = 0; i < n; i++)\n\t\tif (maxLen < lioes[i])\n\t\t\tmaxLen = lioes[i];\n\treturn maxLen;\n}", "6725": "int isSubsetSum(int set[], int n, int sum)\n\t{\n\t\tbool subset[sum + 1][n + 1];\n\t\tint count[sum + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t{\n\t\t\tsubset[0][i] = true;\n\t\t\tcount[0][i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= sum; i++)\n\t\t{\n\t\t\tsubset[i][0] = false;\n\t\t\tcount[i][0] = -1;\n\t\t}\n\t\tfor (int i = 1; i <= sum; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t{\n\t\t\t\tsubset[i][j] = subset[i][j - 1];\n\t\t\t\tcount[i][j] = count[i][j - 1];\n\t\t\t\tif (i >= set[j - 1])\n\t\t\t\t{\n\t\t\t\t\tsubset[i][j] = subset[i][j] ||\n\t\t\t\t\t\t\t\tsubset[i - set[j - 1]][j - 1];\n\t\t\t\t\tif (subset[i][j])\n\t\t\t\t\t\tcount[i][j] = max(count[i][j - 1], count[i - set[j - 1]][j - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count[sum][n];\n\t}", "6749": "int LIP(int dp[][MAX], int mat[][MAX], int n, int m, int x, int y)\n{\n\tif (dp[x][y] < 0) {\n\t\tint result = 0;\n\t\tif (x == n - 1 && y == m - 1)\n\t\t\treturn dp[x][y] = 1;\n\t\tif (x == n - 1 y == m - 1)\n\t\t\tresult = 1;\n\t\tif (mat[x][y] < mat[x + 1][y])\n\t\t\tresult = 1 + LIP(dp, mat, n, m, x + 1, y);\n\t\tif (mat[x][y] < mat[x][y + 1])\n\t\t\tresult = max(result, 1 + LIP(dp, mat, n, m, x, y + 1));\n\t\tdp[x][y] = result;\n\t}\n\treturn dp[x][y];\n}\nint wrapper(int mat[][MAX], int n, int m)\n{\n\tint dp[MAX][MAX];\n\tmemset(dp, -1, sizeof dp);\n\treturn LIP(dp, mat, n, m, 0, 0);\n}", "6787": "int computeLIS(int circBuff[], int start, int end, int n)\n{\n\tint LIS[end-start];\n\tfor (int i = start; i < end; i++)\n\t\tLIS[i] = 1;\n\tfor (int i = start + 1; i < end; i++)\n\t\tfor (int j = start; j < i; j++ )\n\t\t\tif (circBuff[i] > circBuff[j] && LIS[i] < LIS[j] + 1)\n\t\t\t\tLIS[i] = LIS[j] + 1;\n\tint res = INT_MIN;\n\tfor (int i = start; i < end; i++)\n\t\tres = max(res, LIS[i]);\n\treturn res;\n}\nint LICS(int arr[], int n)\n{\n\tint circBuff[2 * n];\n\tfor (int i = 0; i<n; i++)\n\t\tcircBuff[i] = arr[i];\n\tfor (int i = n; i < 2*n; i++)\n\t\tcircBuff[i] = arr[i-n];\n\tint res = INT_MIN;\n\tfor (int i=0; i<n; i++)\n\t\tres = max(computeLIS(circBuff, i, i + n, n), res);\n\treturn res;\n}", "6791": "int countPaths(int n, int m)\n{\n\tif (n==0 m==0)\n\t\treturn 1;\n\treturn (countPaths(n-1, m) + countPaths(n, m-1));\n}", "6792": "int countPaths(int n, int m)\n{\n\tint dp[n+1][m+1];\n\tfor (int i=0; i<=n; i++)\n\tdp[i][0] = 1;\n\tfor (int i=0; i<=m; i++)\n\tdp[0][i] = 1;\n\tfor (int i=1; i<=n; i++)\n\tfor (int j=1; j<=m; j++)\n\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\treturn dp[n][m];\n}", "6793": "int binomialCoeff(int n, int k) \n{ \n\tint C[k+1]; \n\tmemset(C, 0, sizeof(C)); \n\tC[0] = 1;\n\tfor (int i = 1; i <= n; i++) \n\t{\n\t\tfor (int j = min(i, k); j > 0; j--) \n\t\t\tC[j] = C[j] + C[j-1]; \n\t} \n\treturn C[k]; \n}", "6848": "int getMaxGold(int gold[][MAX], int m, int n)\n{\n\tint goldTable[m][n];\n\tmemset(goldTable, 0, sizeof(goldTable));\n\tfor (int col=n-1; col>=0; col--)\n\t{\n\t\tfor (int row=0; row<m; row++)\n\t\t{\n\t\t\tint right = (col==n-1)? 0: goldTable[row][col+1];\n\t\t\tint right_up = (row==0 col==n-1)? 0:\n\t\t\t\t\t\t\tgoldTable[row-1][col+1];\n\t\t\tint right_down = (row==m-1 col==n-1)? 0:\n\t\t\t\t\t\t\tgoldTable[row+1][col+1];\n\t\t\tgoldTable[row][col] = gold[row][col] +\n\t\t\t\t\t\t\tmax(right, max(right_up, right_down));\n\t\t}\n\t}\n\tint res = goldTable[0][0];\n\tfor (int i=1; i<m; i++)\n\t\tres = max(res, goldTable[i][0]);\n\treturn res;\n}", "6885": "bool isOperator(char op)\n{\n\treturn (op == '+' op == '*');\n}\nvoid printMinAndMaxValueOfExp(string exp)\n{\n\tvector<int> num;\n\tvector<char> opr;\n\tstring tmp = \"\";\n\tfor (int i = 0; i < exp.length(); i++)\n\t{\n\t\tif (isOperator(exp[i]))\n\t\t{\n\t\t\topr.push_back(exp[i]);\n\t\t\tnum.push_back(atoi(tmp.c_str()));\n\t\t\ttmp = \"\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp += exp[i];\n\t\t}\n\t}\n\tnum.push_back(atoi(tmp.c_str()));\n\tint len = num.size();\n\tint minVal[len][len];\n\tint maxVal[len][len];\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tfor (int j = 0; j < len; j++)\n\t\t{\n\t\t\tminVal[i][j] = INT_MAX;\n\t\t\tmaxVal[i][j] = 0;\n\t\t\tif (i == j)\n\t\t\t\tminVal[i][j] = maxVal[i][j] = num[i];\n\t\t}\n\t}\n\tfor (int L = 2; L <= len; L++)\n\t{\n\t\tfor (int i = 0; i < len - L + 1; i++)\n\t\t{\n\t\t\tint j = i + L - 1;\n\t\t\tfor (int k = i; k < j; k++)\n\t\t\t{\n\t\t\t\tint minTmp = 0, maxTmp = 0;\n\t\t\t\tif(opr[k] == '+')\n\t\t\t\t{\n\t\t\t\t\tminTmp = minVal[i][k] + minVal[k + 1][j];\n\t\t\t\t\tmaxTmp = maxVal[i][k] + maxVal[k + 1][j];\n\t\t\t\t}\n\t\t\t\telse if(opr[k] == '*')\n\t\t\t\t{\n\t\t\t\t\tminTmp = minVal[i][k] * minVal[k + 1][j];\n\t\t\t\t\tmaxTmp = maxVal[i][k] * maxVal[k + 1][j];\n\t\t\t\t}\n\t\t\t\tif (minTmp < minVal[i][j])\n\t\t\t\t\tminVal[i][j] = minTmp;\n\t\t\t\tif (maxTmp > maxVal[i][j])\n\t\t\t\t\tmaxVal[i][j] = maxTmp;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Minimum value : \" << minVal[0][len - 1]\n\t\t<< \", Maximum value : \" << maxVal[0][len - 1];\n}", "6907": "int lcs(string str1, string str2, int len1, int len2, int i, int j)\n{\n\tint &ret = dp[i][j];\n\tif (i==len1 j==len2)\n\t\treturn ret = 0;\n\tif (ret != -1)\n\t\treturn ret;\n\tret = 0;\n\tif (str1[i] == str2[j])\n\t\tret = 1 + lcs(str1, str2, len1, len2, i+1, j+1);\n\telse\n\t\tret = max(lcs(str1, str2, len1, len2, i+1, j),\n\t\t\t\tlcs(str1, str2, len1, len2, i, j+1));\n\treturn ret;\n}\nvoid printAll(string str1, string str2, int len1, int len2, char data[], int indx1, int indx2, int currlcs)\n{\n\tif (currlcs == lcslen)\n\t{\n\t\tdata[currlcs] = '\\0';\n\t\tputs(data);\n\t\treturn;\n\t}\n\tif (indx1==len1 indx2==len2)\n\t\treturn;\n\tfor (char ch='a'; ch<='z'; ch++)\n\t{\n\t\tbool done = false;\n\t\tfor (int i=indx1; i<len1; i++)\n\t\t{\n\t\t\tif (ch==str1[i])\n\t\t\t{\n\t\t\tfor (int j=indx2; j<len2; j++)\n\t\t\t{\n\t\t\t\tif (ch==str2[j] && dp[i][j] == lcslen-currlcs)\n\t\t\t\t{\n\t\t\t\tdata[currlcs] = ch;\n\t\t\t\tprintAll(str1, str2, len1, len2, data, i+1, j+1, currlcs+1);\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\nvoid prinlAllLCSSorted(string str1, string str2)\n{\n\tint len1 = str1.length(), len2 = str2.length();\n\tmemset(dp, -1, sizeof(dp));\n\tlcslen = lcs(str1, str2, len1, len2, 0, 0);\n\tchar data[MAX];\n\tprintAll(str1, str2, len1, len2, data, 0, 0, 0);\n}", "6933": "int minAdjustmentCost(int A[], int n, int target)\n{\n\tint dp[n][M + 1];\n\tfor (int j = 0; j <= M; j++)\n\t\tdp[0][j] = abs(j - A[0]);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = 0; j <= M; j++)\n\t\t{\n\t\tdp[i][j] = INT_MAX;\n\t\tfor (int k = max(j-target,0); k <= min(M,j+target); k++)\n\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(A[i] - j));\n\t\t}\n\t} \n\tint res = INT_MAX;\n\tfor (int j = 0; j <= M; j++)\n\t\tres = min(res, dp[n - 1][j]);\n\treturn res;\n}", "6944": "int LCIS(int arr1[], int n, int arr2[], int m)\n{\n\tint table[m];\n\tfor (int j=0; j<m; j++)\n\t\ttable[j] = 0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tint current = 0;\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tif (arr1[i] == arr2[j])\n\t\t\t\tif (current + 1 > table[j])\n\t\t\t\t\ttable[j] = current + 1;\n\t\t\tif (arr1[i] > arr2[j])\n\t\t\t\tif (table[j] > current)\n\t\t\t\t\tcurrent = table[j];\n\t\t}\n\t}\n\tint result = 0;\n\tfor (int i=0; i<m; i++)\n\t\tif (table[i] > result)\n\t\tresult = table[i];\n\treturn result;\n}", "7051": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n int val[n+1];\n val[0] = 0;\n int i, j;\n for (i = 1; i<=n; i++)\n {\n\tint max_val = INT_MIN;\n\tfor (j = 0; j < i; j++)\n\t\tmax_val = max(max_val, price[j] + val[i-j-1]);\n\tval[i] = max_val;\n }\n return val[n];\n}", "7052": "int un_kp(int price[], int length[], int Max_len, int n)\n{\n\tif (n == 0 Max_len == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (length[n - 1] <= Max_len)\n\t{\n\t\tt[n][Max_len]\n\t\t\t= max(price[n - 1]\n\t\t\t\t\t+ un_kp(price, length, Max_len - length[n - 1], n),\n\t\t\t\tun_kp(price, length, Max_len, n - 1));\n\t}\n\telse\n\t{\n\t\tt[n][Max_len]\n\t\t\t= un_kp(price, length, Max_len, n - 1);\n\t}\n\treturn t[n][Max_len];\n}", "7068": "int MatrixChainOrder(int p[], int i, int j)\n{\n\tif (i == j)\n\t\treturn 0;\n\tint k;\n\tint min = INT_MAX;\n\tint count;\n\tfor (k = i; k < j; k++)\n\t{\n\t\tcount = MatrixChainOrder(p, i, k)\n\t\t\t\t+ MatrixChainOrder(p, k + 1, j)\n\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\tif (count < min)\n\t\t\tmin = count;\n\t}\n\treturn min;\n}", "7069": "int matrixChainMemoised(int* p, int i, int j)\n{\n\tif (i == j)\n\t{\n\t\treturn 0;\n\t}\n\tif (dp[i][j] != -1)\n\t{\n\t\treturn dp[i][j];\n\t}\n\tdp[i][j] = INT_MAX;\n\tfor (int k = i; k < j; k++)\n\t{\n\t\tdp[i][j] = min(\n\t\t\tdp[i][j], matrixChainMemoised(p, i, k)\n\t\t\t\t\t+ matrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n\t}\n\treturn dp[i][j];\n}\nint MatrixChainOrder(int* p, int n)\n{\n\tint i = 1, j = n - 1;\n\treturn matrixChainMemoised(p, i, j);\n}", "7071": "int count(int S[], int m, int n)\n{\n\tif (n == 0)\n\t\treturn 1;\n\tif (n < 0)\n\t\treturn 0;\n\tif (m <= 0 && n >= 1)\n\t\treturn 0;\n\treturn count(S, m - 1, n) +\n\t\tcount(S, m, n - S[m - 1]);\n}", "7074": "int coinchange(vector<int>& a, int v, int n, vector<vector<int> >& dp)\n{\n\tif (v == 0)\n\t\treturn dp[n][v] = 1;\n\tif (n == 0)\n\t\treturn 0;\n\tif (dp[n][v] != -1)\n\t\treturn dp[n][v];\n\tif (a[n - 1] <= v) {\n\t\treturn dp[n][v] = coinchange(a, v - a[n - 1], n, dp)\n\t\t\t\t\t\t+ coinchange(a, v, n - 1, dp);\n\t}\n\t\treturn dp[n][v] = coinchange(a, v, n - 1, dp);\n}", "7119": "int totalCombination(int L, int R)\n{\n\tint count = 0;\n\tint K = R - L;\n\tif (K < L)\n\t\treturn 0;\n\tint ans = K - L;\n\tcount = ((ans + 1) * (ans + 2)) / 2;\n\treturn count;\n}", "7135": "void printArrays(int n)\n{\n\tvector<int> A, B;\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tif (i % 2 == 0)\n\t\t\tA.push_back(i);\n\t\telse\n\t\t\tB.push_back(i);\n\t}\n\tcout << \"{ \";\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << A[i];\n\t\tif (i != n - 1)\n\t\t\tcout << \", \";\n\t}\n\tcout << \" }\\n\";\n\tcout << \"{ \";\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << B[i];\n\t\tif (i != n - 1)\n\t\t\tcout << \", \";\n\t}\n\tcout << \" }\";\n}", "7139": "void flipBitsOfAandB(int A, int B)\n{\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((A & (1 << i)) && (B & (1 << i))) {\n\t\t\tA = A ^ (1 << i);\n\t\t\tB = B ^ (1 << i);\n\t\t}\n\t}\n\tcout << A << \" \" << B;\n}", "7140": "void flipBitsOfAandB(int A, int B)\n{\n\tA = A ^ (A & B);\n\tB = B ^ (A & B);\n\tcout << A << \" \" << B;\n}", "7167": "int TotalHammingDistance(int n)\n{\n\tint i = 1, sum = 0;\n\twhile (n / i > 0) {\n\t\tsum = sum + n / i;\n\t\ti = i * 2;\n\t}\n\treturn sum;\n}", "7176": "void solve(long long n)\n{\n\tlong long s = 0;\n\tfor (int l = 1; l <= n;) {\n\t\tint r = n / floor(n / l);\n\t\tint x = (((r % m) * ((r + 1) % m)) / 2)\n\t\t\t\t% m;\n\t\tint y = (((l % m) * ((l - 1) % m)) / 2)\n\t\t\t\t% m;\n\t\tint p = ((n / l) % m);\n\t\ts = (s + (((x - y) % m) * p) % m + m)\n\t\t\t% m;\n\t\ts %= m;\n\t\tl = r + 1;\n\t}\n\tcout << (s + m) % m;\n}", "7187": "int min_time_to_cut(int N)\n{\n\tif (N == 0)\n\t\treturn 0;\n\treturn ceil(log2(N));\n}", "7203": "int findDistinctSums(int n)\n{\n\tset<int> s;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i; j <= n; j++) {\n\t\t\ts.insert(i + j);\n\t\t}\n\t}\n\treturn s.size();\n}", "7204": "int findDistinctSums(int N)\n{\n\treturn (2 * N - 1);\n}", "7234": "int printPattern( int i, int j, int n)\n{\n\tif (j >= n) {\n\t\treturn 0;\n\t}\n\tif (i >= n) {\n\t\treturn 1;\n\t}\n\tif (j == i j == n - 1 - i) {\n\t\tif (i == n - 1 - j) {\n\t\t\tcout << \"/\";\n\t\t}\n\t\telse {\n\t\t\tcout << \"\\\\\";\n\t\t}\n\t}\n\telse {\n\t\tcout << \"*\";\n\t}\n\tif (printPattern(i, j + 1, n) == 1) {\n\t\treturn 1;\n\t}\n\tcout << endl;\n\treturn printPattern(i + 1, 0, n);\n}", "7248": "vector<int> zArray(vector<int> arr)\n{\n\tint n = arr.size();\n\tvector<int> z(n);\n\tint r = 0, l = 0;\n\tfor (int k = 1; k < n; k++) {\n\t\tif (k > r) {\n\t\t\tr = l = k;\n\t\t\twhile (r < n && arr[r] == arr[r - l])\n\t\t\t\tr++;\n\t\t\tz[k] = r - l;\n\t\t\tr--;\n\t\t}\n\t\telse {\n\t\t\tint k1 = k - l;\n\t\t\tif (z[k1] < r - k + 1)\n\t\t\t\tz[k] = z[k1];\n\t\t\telse {\n\t\t\t\tl = k;\n\t\t\t\twhile (r < n && arr[r] == arr[r - l])\n\t\t\t\t\tr++;\n\t\t\t\tz[k] = r - l;\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nvector<int> mergeArray(vector<int> A, vector<int> B)\n{\n\tint n = A.size();\n\tint m = B.size();\n\tvector<int> z;\n\tvector<int> c(n + m + 1);\n\tfor (int i = 0; i < m; i++)\n\t\tc[i] = B[i];\n\tc[m] = INT_MAX;\n\tfor (int i = 0; i < n; i++)\n\t\tc[m + i + 1] = A[i];\n\tz = zArray(c);\n\treturn z;\n}\nvoid findZArray(vector<int>A,vector<int>B, int n)\n{\n\tint flag = 0;\n\tvector<int> z;\n\tz = mergeArray(A, B);\n\tfor (int i = 0; i < z.size(); i++) {\n\t\tif (z[i] == n) {\n\t\t\tcout << (i - n - 1) << \" \";\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\tcout << (\"Not Found\");\n\t}\n}", "7276": "int getCount(string a, string b)\n{\n\tif(b.length() % a.length() != 0)\n\t\treturn -1;\n\tint count = b.length() /a.length();\n\tstring str = \"\";\n\tfor(int i = 0; i < count; i++)\n\t{\n\t\tstr = str + a;\n\t}\n\tif(str == b)\n\t\treturn count;\n\treturn -1;\n}", "7287": "void printSpiral(int size)\n{\n\tint row = 0, col = 0;\n\tint boundary = size - 1;\n\tint sizeLeft = size - 1;\n\tint flag = 1;\n\tchar move = 'r';\n\tint matrix[size][size] = {0};\n\tfor (int i = 1; i < size * size + 1; i++)\n\t{\n\t\tmatrix[row][col] = i;\n\t\tswitch (move)\n\t\t{\n\t\t\tcase 'r':\n\t\t\t\tcol += 1;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcol -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\trow -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\trow += 1;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == boundary)\n\t\t{\n\t\t\tboundary += sizeLeft;\n\t\t\tif (flag != 2)\n\t\t\t{\n\t\t\t\tflag = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tsizeLeft -= 1;\n\t\t\t}\n\t\t\tswitch (move)\n\t\t\t{\n\t\t\t\tcase 'r':\n\t\t\t\t\tmove = 'd';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tmove = 'l';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\tmove = 'u';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tmove = 'r';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (row = 0; row < size; row++)\n\t{\n\t\tfor (col = 0; col < size; col++)\n\t\t{\n\t\t\tint n = matrix[row][col];\n\t\t\tif(n < 10)\n\t\t\t\tcout << n << \" \";\n\t\t\telse\n\t\t\t\tcout << n << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}", "7298": "bool check(string S1, string S2)\n{\n\tint n1 = S1.size();\n\tint n2 = S2.size();\n\tunordered_map<int, int> mp;\n\tfor (int i = 0; i < n1; i++) {\n\t\tmp[S1[i]]++;\n\t}\n\tfor (int i = 0; i < n2; i++) {\n\t\tif (mp[S2[i]]) {\n\t\t\tmp[S2[i]]--;\n\t\t}\n\t\telse if (mp[S2[i] - 1] && mp[S2[i] - 2]) {\n\t\t\tmp[S2[i] - 1]--;\n\t\t\tmp[S2[i] - 2]--;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n return true;\n}", "7309": "int countPattern(string str)\n{\n\tint len = str.size();\n\tbool oneSeen = 0;\n\tfor (int i = 0; i < len ; i++)\n\t{\n\t\tif (str[i] == '1' && oneSeen == 1)\n\t\t\tif (str[i - 1] == '0')\n\t\t\t\tcount++;\n\t\tif (str[i] == '1' && oneSeen == 0)\n\t\t{\n\t\t\toneSeen = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[i] != '0' && str[i] != '1')\n\t\t\toneSeen = 0;\n\t}\n\treturn count;\n}", "7336": "int countSubstrings(string& str)\n{\n\tint freq[3] = { 0 };\n\tint count = 0;\n\tint i = 0;\n\tfor (int j = 0; j < str.length(); j++) {\n\t\tfreq[str[j] - '0']++;\n\t\twhile (freq[0] > 0 && freq[1] > 0 && freq[2] > 0) {\n\t\t\tfreq[str[i++] - '0']--;\n\t\t}\n\t\tcount += i;\n\t}\n\treturn count;\n}", "7347": "int minFlips(string str)\n{\n\tint count = 0;\n\tif (str.size() <= 2) {\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < str.size() - 2;) {\n\t\tif (str[i] == str[i + 1] && str[i + 2] == str[i + 1]) {\n\t\t\ti = i + 3;\n\t\t\tcount++;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn count;\n}", "7382": "string checkIfPossible(int N, string arr[], string T)\n{\n\tint freqS[256] = {0};\n\tint freqT[256] = {0};\n\tfor (char ch : T) {\n\t\tfreqT[ch - 'a']++;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (char ch : arr[i]) {\n\t\t\tfreqS[ch - 'a']++;\n\t\t}\n\t}\n\tfor (int i = 0; i < 256; i++) {\n\t\tif (freqT[i] == 0 && freqS[i] != 0) {\n\t\t\treturn \"No\";\n\t\t}\n\t\telse if (freqS[i] == 0 && freqT[i] != 0) {\n\t\t\treturn \"No\";\n\t\t}\n\t\telse if (freqT[i] != 0\n\t\t\t\t&& freqS[i]\n\t\t\t\t\t\t!= (freqT[i] * N)) {\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\treturn \"Yes\";\n}", "7390": "string convertToHex(int num)\n{\n\tstring temp = \"\";\n\twhile (num != 0) {\n\t\tint rem = num % 16;\n\t\tchar c;\n\t\tif (rem < 10) {\n\t\t\tc = rem + 48;\n\t\t}\n\t\telse {\n\t\t\tc = rem + 87;\n\t\t}\n\t\ttemp += c;\n\t\tnum = num / 16;\n\t}\n\treturn temp;\n}\nstring encryptString(string S, int N)\n{\n\tstring ans = \"\";\n\tfor (int i = 0; i < N; i++) {\n\t\tchar ch = S[i];\n\t\tint count = 0;\n\t\tstring hex;\n\t\twhile (i < N && S[i] == ch) {\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}\n\t\ti--;\n\t\thex = convertToHex(count);\n\t\tans += ch;\n\t\tans += hex;\n\t}\n\treverse(ans.begin(), ans.end());\n\treturn ans;\n}", "7401": "int groupsOfOnes(string S, int N)\n{\n\tint count = 0;\n\tstack<int> st;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (S[i] == '1')\n\t\t\tst.push(1);\n\t\telse {\n\t\t\tif (!st.empty()) {\n\t\t\t\tcount++;\n\t\t\t\twhile (!st.empty()) {\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!st.empty())\n\t\tcount++;\n\treturn count;\n}", "7412": "void generatePalindrome(string S)\n{\n\tunordered_map<char, int> Hash;\n\tfor (auto ch : S) {\n\t\tHash[ch]++;\n\t}\n\tset<string> st;\n\tfor (char i = 'a'; i <= 'z'; i++) {\n\t\tif (Hash[i] == 2) {\n\t\t\tfor (char j = 'a'; j <= 'z'; j++) {\n\t\t\t\tstring s = \"\";\n\t\t\t\tif (Hash[j] && i != j) {\n\t\t\t\t\ts += i;\n\t\t\t\t\ts += j;\n\t\t\t\t\ts += i;\n\t\t\t\t\tst.insert(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Hash[i] >= 3) {\n\t\t\tfor (char j = 'a'; j <= 'z'; j++) {\n\t\t\t\tstring s = \"\";\n\t\t\t\tif (Hash[j]) {\n\t\t\t\t\ts += i;\n\t\t\t\t\ts += j;\n\t\t\t\t\ts += i;\n\t\t\t\t\tst.insert(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto ans : st) {\n\t\tcout << ans << \"\\n\";\n\t}\n}", "7423": "void countOccurrences(string S, string X, string Y)\n{\n\tint count = 0;\n\tint N = S.length(), A = X.length();\n\tint B = Y.length();\n\tfor (int i = 0; i < N; i++) {\n\t\tif (S.substr(i, B) == Y)\n\t\t\tcount++;\n\t\tif (S.substr(i, A) == X)\n\t\t\tcout << count << \" \";\n\t}\n}", "7487": "void findWinner(string a, int n)\n{\n\tvector<int> v;\n\tint c = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == '0') {\n\t\t\tc++;\n\t\t}\n\t\telse {\n\t\t\tif (c != 0)\n\t\t\t\tv.push_back(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif (c != 0)\n\t\tv.push_back(c);\n\tif (v.size() == 0) {\n\t\tcout << \"Player B\";\n\t\treturn;\n\t}\n\tif (v.size() == 1) {\n\t\tif (v[0] & 1)\n\t\t\tcout << \"Player A\";\n\t\telse\n\t\t\tcout << \"Player B\";\n\t\treturn;\n\t}\n\tint first = INT_MIN;\n\tint second = INT_MIN;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (a[i] > first) {\n\t\t\tsecond = first;\n\t\t\tfirst = a[i];\n\t\t}\n\t\telse if (a[i] > second && a[i] != first)\n\t\t\tsecond = a[i];\n\t}\n\tif ((first & 1)\n\t\t&& (first + 1) / 2 > second)\n\t\tcout << \"Player A\";\n\telse\n\t\tcout << \"Player B\";\n}", "7507": "void DFA(string str, int N)\n{\n\tif (N <= 1) {\n\t\tcout << \"No\";\n\t\treturn;\n\t}\n\tint count = 0;\n\tif (str[0] == 'C') {\n\t\tcount++;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tif (str[i] == 'A' str[i] == 'B')\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\tcout << \"No\";\n\t\treturn;\n\t}\n\tif (count == N)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}", "7542": "void minMaxDigits(string str, int N)\n{\n\tint arr[N];\n\tfor (int i = 0; i < N; i++)\n\t\tarr[i] = (str[i] - '0') % 3;\n\tint zero = 0, one = 0, two = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] == 0)\n\t\t\tzero++;\n\t\tif (arr[i] == 1)\n\t\t\tone++;\n\t\tif (arr[i] == 2)\n\t\t\ttwo++;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tsum = (sum + arr[i]) % 3;\n\t}\n\tif (sum == 0) {\n\t\tcout << 0 << ' ';\n\t}\n\tif (sum == 1) {\n\t\tif (one && N > 1)\n\t\t\tcout << 1 << ' ';\n\t\telse if (two > 1 && N > 2)\n\t\t\tcout << 2 << ' ';\n\t\telse\n\t\t\tcout << -1 << ' ';\n\t}\n\tif (sum == 2) {\n\t\tif (two && N > 1)\n\t\t\tcout << 1 << ' ';\n\t\telse if (one > 1 && N > 2)\n\t\t\tcout << 2 << ' ';\n\t\telse\n\t\t\tcout << -1 << ' ';\n\t}\n\tif (zero > 0)\n\t\tcout << N - 1 << ' ';\n\telse if (one > 0 && two > 0)\n\t\tcout << N - 2 << ' ';\n\telse if (one > 2 two > 2)\n\t\tcout << N - 3 << ' ';\n\telse\n\t\tcout << -1 << ' ';\n}", "7548": "int findMinimumChanges(int N, int K, string S)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < (K + 1) / 2; i++) {\n\t\tmap<char, int> mp;\n\t\tfor (int j = i; j < N; j += K) {\n\t\t\tmp[S[j]]++;\n\t\t}\n\t\tfor (int j = N - i - 1; j >= 0; j -= K) {\n\t\t\tif (K & 1 and i == K / 2)\n\t\t\t\tbreak;\n\t\t\tmp[S[j]]++;\n\t\t}\n\t\tint curr_max = INT_MIN;\n\t\tfor (auto p : mp)\n\t\t\tcurr_max = max(curr_max, p.second);\n\t\tif (K & 1 and i == K / 2)\n\t\t\tans += (N / K - curr_max);\n\t\telse\n\t\t\tans += (N / K * 2 - curr_max);\n\t}\n\treturn ans;\n}", "7564": "int longComPre(string arr[], int N)\n{\n\tint freq[N][256];\n\tfor (let String of DistString) {\n\tfor (int i = 0; i < N; i++) {\n\t\tint M = arr[i].length();\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tfreq[i][arr[i][j]]++;\n\t\t}\n\t}\n\tint maxLen = 0;\n\tfor (int j = 0; j < 256; j++) {\n\t\tint minRowVal = INT_MAX;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tminRowVal = min(minRowVal, freq[i][j]);\n\t\t}\n\t\tmaxLen += minRowVal;\n\t}\n\treturn maxLen;\n}", "7587": "unsigned long int binomialCoeff(unsigned long int n, unsigned long int k)\n{\n\tunsigned long int res = 1;\n\tif (k > n - k)\n\t\tk = n - k;\n\tfor (int i = 0; i < k; ++i) {\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}\nunsigned long int countOfString(int N)\n{\n\tunsigned long int Stotal = pow(2, N);\n\tunsigned long int Sequal = 0;\n\tif (N % 2 == 0)\n\t\tSequal = binomialCoeff(N, N / 2);\n\tunsigned long int S1 = (Stotal - Sequal) / 2;\n\treturn S1;\n}", "7593": "string removeCharRecursive(string str, char X)\n{\n\tif (str.length() == 0) {\n\t\treturn \"\";\n\t}\n\tif (str[0] == X) {\n\t\treturn removeCharRecursive(str.substr(1), X);\n\t}\n\treturn str[0]\n\t\t+ removeCharRecursive(str.substr(1), X);\n}", "7594": "string checkString(string s, int K)\n{\n\tint n = s.length();\n\tunordered_map<char, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tmp[s[i]] = i;\n\t}\n\tint cnt = 0, f = 0;\n\tunordered_set<int> st;\n\tfor (int i = 0; i < n; i++) {\n\t\tst.insert(s[i]);\n\t\tif (st.size() > K) {\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (mp[s[i]] == i)\n\t\t\tst.erase(s[i]);\n\t}\n\treturn (f == 1 ? \"Yes\" : \"No\");\n}", "7609": "bool isValid(char a1, char a2, string str, int flag)\n{\n\tchar v1, v2;\n\tif (flag == 0) {\n\t\tv1 = str[4];\n\t\tv2 = str[3];\n\t}\n\telse {\n\t\tv1 = str[1];\n\t\tv2 = str[0];\n\t}\n\tif (v1 != a1 && v1 != '?')\n\t\treturn false;\n\tif (v2 != a2 && v2 != '?')\n\t\treturn false;\n\treturn true;\n}\nbool inRange(int hh, int mm, int L, int R)\n{\n\tint a = abs(hh - mm);\n\tif (a < L a > R)\n\t\treturn false;\n\treturn true;\n}\nvoid displayTime(int hh, int mm)\n{\n\tif (hh > 10)\n\t\tcout << hh << \":\";\n\telse if (hh < 10)\n\t\tcout << \"0\" << hh << \":\";\n\tif (mm > 10)\n\t\tcout << mm << endl;\n\telse if (mm < 10)\n\t\tcout << \"0\" << mm << endl;\n}\nvoid maximumTimeWithDifferenceInRange( string str, int L, int R)\n{\n\tint i, j;\n\tint h1, h2, m1, m2;\n\tfor (i = 23; i >= 0; i--) {\n\t\th1 = i % 10;\n\t\th2 = i / 10;\n\t\tif (!isValid(h1 + '0', h2 + '0', str, 1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 59; j >= 0; j--) {\n\t\t\tm1 = j % 10;\n\t\t\tm2 = j / 10;\n\t\t\tif (!isValid(m1 + '0', m2 + '0', str, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (inRange(i, j, L, R)) {\n\t\t\t\tdisplayTime(i, j);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (inRange(i, j, L, R))\n\t\tdisplayTime(i, j);\n\telse\n\t\tcout << \"-1\" << endl;\n}", "7622": "bool check(string s, int n)\n{\n\tstack<char> st;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!st.empty() && st.top() == s[i])\n\t\t\tst.pop();\n\t\telse\n\t\t\tst.push(s[i]);\n\t}\n\tif (st.empty()) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "7646": "bool can_Construct(string S, int K)\n{\n\tmap<int, int> m;\n\tint i = 0, j = 0, p = 0;\n\tif (S.length() == K) {\n\t\treturn true;\n\t}\n\tmap<int, int>::iterator h;\n\tfor (i = 0; i < S.length(); i++) {\n\t\tm[S[i]] = m[S[i]] + 1;\n\t}\n\tif (K > S.length()) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfor (h = m.begin(); h != m.end(); h++) {\n\t\t\tif (m[h->first] % 2 != 0) {\n\t\t\t\tp = p + 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (K < p) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "7688": "void findNumOfValidWords(vector<string>& w, vector<string>& p)\n{\n\tunordered_map<int, int> m;\n\tvector<int> res;\n\tfor (string& s : w) {\n\t\tint val = 0;\n\t\tfor (char c : s) {\n\t\t\tval = val | (1 << (c - 'a'));\n\t\t}\n\t\tm[val]++;\n\t}\n\tfor (string& s : p) {\n\t\tint val = 0;\n\t\tfor (char c : s) {\n\t\t\tval = val | (1 << (c - 'a'));\n\t\t}\n\t\tint temp = val;\n\t\tint first = s[0] - 'a';\n\t\tint count = 0;\n\t\twhile (temp != 0) {\n\t\t\tif (((temp >> first) & 1) == 1) {\n\t\t\t\tif (m.find(temp) != m.end()) {\n\t\t\t\t\tcount += m[temp];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp = (temp - 1) & val;\n\t\t}\n\t\tres.push_back(count);\n\t}\n\tfor (auto& it : res) {\n\t\tcout << it << '\\n';\n\t}\n}", "7693": "void flip(string& s)\n{\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (s[i] == '0') {\n\t\t\twhile (s[i] == '0') {\n\t\t\t\ts[i] = '1';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "7694": "void distinct(string S[], int M, int n)\n{\n\tint count = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tset<char> set1;\n\t\tfor(int j = 0; j < S[i].length(); j++)\n\t\t{\n\t\t\tif (set1.find(S[i][j]) == set1.end())\n\t\t\t\tset1.insert(S[i][j]);\n\t\t}\n\t\tint c = set1.size();\n\t\tif (c <= M)\n\t\t\tcount += 1;\n\t}\n\tcout << (count);\n}", "7734": "string removeOddFrequencyCharacters(string s)\n{\n\tunordered_map<char, int> m;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tm[s[i]]++;\n\t}\n\tstring new_string = \"\";\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (m[s[i]] & 1)\n\t\t\tcontinue;\n\t\tnew_string += s[i];\n\t}\n\treturn new_string;\n}", "7735": "string removeChars(char arr[], int k)\n{\n\tint hash[MAX_CHAR] = { 0 };\n\tint n = strlen(arr);\n\tfor (int i = 0; i < n; ++i)\n\t\thash[arr[i] - 'a']++;\n\tstring ans = \"\";\n\tint index = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (hash[arr[i] - 'a'] != k) {\n\t\t\tans += arr[i];\n\t\t}\n\t}\n\treturn ans;\n}", "7753": "int productAtKthLevel(string tree, int k, int& i, int level){\n\tif (tree[i++] == '(') {\n\t\tif (tree[i] == ')')\n\t\t\treturn 1;\n\t\tint product = 1;\n\t\tif (level == k)\n\t\t\tproduct = tree[i] - '0';\n\t\tint leftproduct = productAtKthLevel( tree, k, ++i, level + 1);\n\t\tint rightproduct = productAtKthLevel( tree, k, ++i, level + 1);\n\t\t++i;\n\t\treturn product * leftproduct *\n\t\t\t\t\trightproduct;\n\t}\n}", "7758": "void findMostOccurringChar(vector<string> str)\n{\n\tint hash[26] = { 0 };\n\tfor (int i = 0; i < str.size(); i++) {\n\t\tfor (int j = 0; j < str[i].length(); j++) {\n\t\t\thash[str[i][j]]++;\n\t\t}\n\t}\n\tint max = 0;\n\tfor (int i = 0; i < 26; i++) {\n\t\tmax = hash[i] > hash[max] ? i : max;\n\t}\n\tcout << (char)(max + 97) << endl;\n}", "7788": "void sub_segments(string str, int n)\n{\n\tint l = str.length();\n\tfor (int x = 0; x < l; x += n)\n\t{\n\t\tstring newlist = str.substr(x, n);\n\t\tlist<char> arr;\n\t\tlist<char>::iterator it;\n\t\tfor(auto y:newlist)\n\t\t{\n\t\t\tit = find(arr.begin(), arr.end(), y);\n\t\t\tif(it == arr.end())\n\t\t\t\tarr.push_back(y);\n\t\t}\n\t\tfor(auto y:arr)\n\t\t\tcout << y;\n\t\tcout << endl;\n\t}\n}", "7816": "bool isPalindrome(float num)\n{\n\tstringstream ss;\n\tss << num;\n\tstring s;\n\tss >> s;\n\tint low = 0;\n\tint high = s.size() - 1;\n\twhile (low < high)\n\t{\n\t\tif (s[low] != s[high])\n\t\t\treturn false;\n\t\tlow++;\n\t\thigh--;\n\t}\n\treturn true;\n}", "7819": "int maxSubStr(string str1, int len1, string str2, int len2)\n{\n\tif (len1 > len2)\n\t\treturn 0;\n\tint freq1[MAX] = { 0 };\n\tfor (int i = 0; i < len1; i++)\n\t\tfreq1[str1[i] - 'a']++;\n\tint freq2[MAX] = { 0 };\n\tfor (int i = 0; i < len2; i++)\n\t\tfreq2[str2[i] - 'a']++;\n\tint minPoss = INT_MAX;\n\tfor (int i = 0; i < MAX; i++) {\n\t\tif (freq1[i] == 0)\n\t\t\tcontinue;\n\t\tif (freq1[i] > freq2[i])\n\t\t\treturn 0;\n\t\tminPoss = min(minPoss, freq2[i] / freq1[i]);\n\t}\n\treturn minPoss;\n}", "7820": "int cntWays(string str, int n)\n{\n\tint x = n + 1;\n\tint ways = x * x * (x * x - 1) / 12;\n\treturn ways;\n}", "7828": "void findSubStr(string str, int cnt, int start)\n{\n\tif (start == str.length()) {\n\t\tminCnt = min(cnt, minCnt);\n\t}\n\tfor (int len = 1; len <= (str.length() - start); len++) {\n\t\tstring subStr = str.substr(start, len);\n\t\tif (uSet.find(subStr) != uSet.end()) {\n\t\t\tfindSubStr(str, cnt + 1, start + len);\n\t\t}\n\t}\n}\nvoid findMinSubStr(string arr[], int n, string str)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tuSet.insert(arr[i]);\n\tfindSubStr(str, 0, 0);\n}", "7851": "int countSubStr(string s, int n)\n{\n\tint c1 = 0, c2 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s.substr(i, 5) == \"geeks\")\n\t\t\tc1++;\n\t\tif (s.substr(i, 3) == \"for\")\n\t\t\tc2 = c2 + c1;\n\t}\n\treturn c2;\n}", "7861": "void findWord(string c, int n)\n{\n\tint co = 0, i;\n\tstring s(n, ' ');\n\tfor (i = 0; i < n; i++) {\n\t\tif (i < n / 2)\n\t\t\tco++;\n\t\telse\n\t\t\tco = n - i;\n\t\tif (c[i] + co <= 122)\n\t\t\ts[i] = (char)((int)c[i] + co);\n\t\telse\n\t\t\ts[i] = (char)((int)c[i] + co - 26);\n\t}\n\tcout << s;\n}", "7864": "", "7868": "string encryptStr(string str, int n, int x)\n{\n\tx = x % MAX;\n\tint freq[MAX] = {0};\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfreq[str[i] - 'a']++;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (freq[str[i] - 'a'] % 2 == 0)\n\t\t{\n\t\t\tint pos = (str[i] - 'a' + x) % MAX;\n\t\t\tstr[i] = (char)(pos + 'a');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint pos = (str[i] - 'a' - x);\n\t\t\tif (pos < 0)\n\t\t\t{\n\t\t\t\tpos += MAX;\n\t\t\t}\n\t\t\tstr[i] = (char)(pos + 'a');\n\t\t}\n\t}\n\treturn str;\n}", "7889": "void getOrgString(string s)\n{\n\tcout << s[0];\n\tint i = 1;\n\twhile (i < s.length()) {\n\t\tif (s[i] >= 'A' && s[i] <= 'Z')\n\t\t\tcout << \" \" << (char)tolower(s[i]);\n\t\telse\n\t\t\tcout << s[i];\n\t\ti++;\n\t}\n}", "7892": "int isPossible(string str)\n{\n\tunordered_map<char, int> freq;\n\tint max_freq = 0;\n\tfor (int j = 0; j < (str.length()); j++) {\n\t\tfreq[str[j]]++;\n\t\tif (freq[str[j]] > max_freq)\n\t\t\tmax_freq = freq[str[j]];\n\t}\n\tif (max_freq <= (str.length() - max_freq + 1))\n\t\treturn true;\n\treturn false;\n}", "7899": "void printUncommon(string str1, string str2)\n{\n\tint a1 = 0, a2 = 0;\n\tfor (int i = 0; i < str1.length(); i++) {\n\t\tint ch = int(str1[i]) - 'a';\n\t\ta1 = a1 | (1 << ch);\n\t}\n\tfor (int i = 0; i < str2.length(); i++) {\n\t\tint ch = int(str2[i]) - 'a';\n\t\ta2 = a2 | (1 << ch);\n\t}\n\tint ans = a1 ^ a2;\n\tint i = 0;\n\twhile (i < 26) {\n\t\tif (ans % 2 == 1) {\n\t\t\tcout << char('a' + i);\n\t\t}\n\t\tans = ans / 2;\n\t\ti++;\n\t}\n}", "7900": "bool isPalin(int i, int j, int k, int l, int p, int q, string s)\n{\n\tint start = i, end = q;\n\twhile (start < end) {\n\t\tif (s[start] != s[end])\n\t\t\treturn false;\n\t\tstart++;\n\t\tif (start == j + 1)\n\t\t\tstart = k;\n\t\tend--;\n\t\tif (end == p - 1)\n\t\t\tend = l;\n\t}\n\treturn true;\n}\nint countSubStr(string s)\n{\n\tint count = 0;\n\tint n = s.size();\n\tfor (int i = 0; i < n - 2; i++) {\n\t\tfor (int j = i; j < n - 2; j++) {\n\t\t\tfor (int k = j + 1; k < n - 1; k++) {\n\t\t\t\tfor (int l = k; l < n - 1; l++) {\n\t\t\t\t\tfor (int p = l + 1; p < n; p++) {\n\t\t\t\t\t\tfor (int q = p; q < n; q++) {\n\t\t\t\t\t\t\tif (isPalin(i, j, k, l, p, q, s)) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "7938": "void equalIgnoreCaseUtil(string str1, string str2)\n{\n\tbool res = equalIgnoreCase(str1, str2);\n\tif (res == true)\n\t\tcout << \"Same\" << endl;\n\telse\n\t\tcout << \"Not Same\" << endl;\n}", "7939": "bool equalIgnoreCase(string str1, string str2)\n{\n\tint i = 0;\n\ttransform(str1.begin(), str1.end(), str1.begin(), ::toupper);\n\ttransform(str2.begin(), str2.end(), str2.begin(), ::toupper);\n\tint x = str1.compare(str2);\n\tif (x != 0)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nvoid equalIgnoreCaseUtil(string str1, string str2)\n{\n\tbool res = equalIgnoreCase(str1, str2);\n\tif (res == true)\n\t\tcout << \"Same\" << endl;\n\telse\n\t\tcout << \"Not Same\" << endl;\n}", "7940": "bool equalIgnoreCase(string str1, string str2)\n{\n\tint i = 0;\n\ttransform(str1.begin(), str1.end(), str1.begin(), ::tolower);\n\ttransform(str2.begin(), str2.end(), str2.begin(), ::tolower);\n\tint x = str1.compare(str2);\n\tif (x != 0)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nvoid equalIgnoreCaseUtil(string str1, string str2)\n{\n\tbool res = equalIgnoreCase(str1, str2);\n\tif (res == true)\n\t\tcout << \"Same\" << endl;\n\telse\n\t\tcout << \"Not Same\" << endl;\n}", "7966": "int countMinReversals(string expr)\n{\n\tint len = expr.length();\n\tif (len % 2)\n\t\treturn -1;\n\tint ans = 0;\n\tint i;\n\tint open = 0;\n\tint close = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (expr[i] == '{')\n\t\t\topen++;\n\t\telse {\n\t\t\tif (!open)\n\t\t\t\tclose++;\n\t\t\telse\n\t\t\t\topen--;\n\t\t}\n\t}\n\tans = (close / 2) + (open / 2);\n\tclose %= 2;\n\topen %= 2;\n\tif (close)\n\t\tans += 2;\n\treturn ans;\n}", "7977": "int totalPairs(string s1, string s2)\n{\n\tint a1 = 0, b1 = 0;\n\tfor (int i = 0; i < s1.length(); i++) {\n\t\tif (int(s1[i]) % 2 != 0)\n\t\t\ta1++;\n\t\telse\n\t\t\tb1++;\n\t}\n\tint a2 = 0, b2 = 0;\n\tfor (int i = 0; i < s2.length(); i++) {\n\t\tif (int(s2[i]) % 2 != 0)\n\t\t\ta2++;\n\t\telse\n\t\t\tb2++;\n\t}\n\treturn ((a1 * a2) + (b1 * b2));\n}", "7978": "string replaceConsonants(string str)\n{\n\tstring res = \"\";\n\tint i = 0, count = 0;\n\twhile (i < str.length()) {\n\t\tif (str[i] != 'a' && str[i] != 'e' && str[i] != 'i' && str[i] != 'o' && str[i] != 'u') {\n\t\t\ti++;\n\t\t\tcount++;\n\t\t}\n\t\telse {\n\t\t\tif (count > 0)\n\t\t\t\tres += to_string(count);\n\t\t\tres += str[i];\n\t\t\ti++;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (count > 0)\n\t\tres += to_string(count);\n\treturn res;\n}", "7979": "int prefixOccurrences(string str)\n{\n\tchar c = str[0];\n\tint countc = 0;\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tif (str[i] == c)\n\t\t\tcountc++;\n\t}\n\treturn countc;\n}", "7989": "int minOperations(string s, string t, int n)\n{\n\tint ct0 = 0, ct1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == t[i])\n\t\t\tcontinue;\n\t\tif (s[i] == '0')\n\t\t\tct0++;\n\t\telse\n\t\t\tct1++;\n\t}\n\treturn max(ct0, ct1);\n}", "7991": "string maxValue(string a, string b)\n{\n\tsort(b.begin(), b.end());\n\tint n = a.length();\n\tint m = b.length();\n\tint j = m - 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (j < 0)\n\t\t\tbreak;\n\t\tif (b[j] > a[i]) {\n\t\t\ta[i] = b[j];\n\t\t\tj--;\n\t\t}\n\t}\n\treturn a;\n}", "8004": "string decryptString(string str, int n)\n{\n\tint i = 0, jump = 1;\n\tstring decryptedStr = \"\";\n\twhile (i < n) {\n\t\tdecryptedStr += str[i];\n\t\ti += jump;\n\t\tjump++;\n\t}\n\treturn decryptedStr;\n}", "8015": "void steps(string str, int n)\n{\n\tbool flag;\n\tint x = 0;\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tif (x == 0)\n\t\t\tflag = true;\n\t\tif (x == n - 1)\n\t\t\tflag = false;\n\t\tfor (int j = 0; j < x; j++)\n\t\t\tcout << \"*\";\n\t\tcout << str[i] << \"\\n\";\n\t\tif (flag == true)\n\t\t\tx++;\n\t\telse\n\t\t\tx--;\n\t}\n}", "8054": "char bitToBeFlipped(string s)\n{\n\tchar last = s[s.length() - 1];\n\tchar first = s[0];\n\tif (last == first) {\n\t\tif (last == '0') {\n\t\t\treturn '1';\n\t\t}\n\t\telse {\n\t\t\treturn '0';\n\t\t}\n\t}\n\telse if (last != first) {\n\t\treturn last;\n\t}\n}", "8061": "void SieveOfEratosthenes(bool prime[], int p_size)\n{\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (int p = 2; p * p <= p_size; p++) {\n\t\tif (prime[p]) {\n\t\t\tfor (int i = p * 2; i <= p_size; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n}\nvoid sumProdOfPrimeFreq(string s)\n{\n\tbool prime[s.length() + 1];\n\tmemset(prime, true, sizeof(prime));\n\tSieveOfEratosthenes(prime, s.length() + 1);\n\tint i, j;\n\tunordered_map<char, int> m;\n\tfor (i = 0; i < s.length(); i++)\n\t\tm[s[i]]++;\n\tint sum = 0, product = 1;\n\tfor (auto it = m.begin(); it != m.end(); it++) {\n\t\tif (prime[it->second]) {\n\t\t\tsum += it->second;\n\t\t\tproduct *= it->second;\n\t\t}\n\t}\n\tcout << \"Sum = \" << sum;\n\tcout << \"\\nProduct = \" << product;\n}", "8078": "int countChar(string str, char x)\n{\n\tint count = 0, n = 10;\n\tfor (int i = 0; i < str.size(); i++)\n\t\tif (str[i] == x)\n\t\t\tcount++;\n\tint repetitions = n / str.size();\n\tcount = count * repetitions;\n\tfor (int i = 0; i < n % str.size(); i++) {\n\t\tif (str[i] == x)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "8085": "bool multipleOrFactor(string s1, string s2)\n{\n\tmap<char, int> m1, m2;\n\tfor (int i = 0; i < s1.length(); i++)\n\t\tm1[s1[i]]++;\n\tfor (int i = 0; i < s2.length(); i++)\n\t\tm2[s2[i]]++;\n\tmap<char, int>::iterator it;\n\tfor (it = m1.begin(); it != m1.end(); it++) {\n\t\tif (m2.find((*it).first) == m2.end())\n\t\t\tcontinue;\n\t\tif (m2[(*it).first] % (*it).second == 0\n\t\t\t|| (*it).second % m2[(*it).first] == 0)\n\t\t\tcontinue;\n\t\telse\n\t\t\treturn false;\n\t}\n}", "8099": "bool checkIfUnequal(int n, int q)\n{\n\tstring s1 = to_string(n);\n\tint a[26] = { 0 };\n\tfor (int i = 0; i < s1.size(); i++)\n\t\ta[s1[i] - '0']++;\n\tint prod = n * q;\n\tstring s2 = to_string(prod);\n\tfor (int i = 0; i < s2.size(); i++)\n\t{\n\t\tif (a[s2[i] - '0'])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint countInRange(int l, int r, int q)\n{\n\tint count = 0;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (checkIfUnequal(i, q))\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "8110": "bool is_possible(string s)\n{\n\tint l = s.length();\n\tint one = 0, zero = 0;\n\tfor (int i = 0; i < l; i++) {\n\t\tif (s[i] == '0')\n\t\t\tzero++;\n\t\telse\n\t\t\tone++;\n\t}\n\tif (l % 2 == 0)\n\t\treturn (one == zero);\n\telse\n\t\treturn (abs(one - zero) == 1);\n}", "8128": "void solve(string s)\n{\n\tunordered_map<char, int> m;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tm[s[i]]++;\n\t}\n\tstring new_string = \"\";\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tif (m[s[i]] % 2 == 0)\n\t\t\tcontinue;\n\t\tnew_string += s[i];\n\t}\n\tcout << new_string << endl;\n}", "8167": "void countFreq(int arr[], int n)\n{\n\tvector<int> visited(n, false);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (visited[i] == true)\n\t\t\tcontinue;\n\t\tint count = 1;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (arr[i] == arr[j]) {\n\t\t\t\tvisited[j] = true;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << arr[i] << \" \" << count << endl;\n\t}\n}", "8168": "void countFreq(int arr[], int n, int limit)\n{\n\tvector<int> count(limit+1, 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcount[arr[i]]++;\n\tfor (int i = 0; i <= limit; i++)\n\tif (count[i] > 0)\n\t\tcout << i << \" \" << count[i] << endl;\n}", "8169": "void countFreq(string str)\n{\n\tvector<int> count(limit+1, 0);\n\tfor (int i = 0; i < str.length(); i++)\n\t\tcount[str[i]]++;\n\tfor (int i = 0; i <= limit; i++)\n\tif (count[i] > 0)\n\t\tcout << (char)i << \" \" << count[i] << endl;\n}", "8184": "void countEvenOdd(int arr[], int n, int K)\n{\n\tint even = 0, odd = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = __builtin_popcount(arr[i]);\n\t\tif (x % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\t\todd++;\n\t}\n\tint y;\n\ty = __builtin_popcount(K);\n\tif (y & 1) {\n\t\tcout << \"Even = \" << odd\n\t\t\t<< \", Odd = \" << even;\n\t}\n\telse {\n\t\tcout << \"Even = \" << even\n\t\t\t<< \", Odd = \" << odd;\n\t}\n}", "8213": "bool check(string s, int m)\n{\n\tint l = s.length();\n\tint c1 = 0;\n\tint c2 = 0;\n\tfor (int i = 0; i < l; i++) {\n\t\tif (s[i] == '0') {\n\t\t\tc2 = 0;\n\t\t\tc1++;\n\t\t}\n\t\telse {\n\t\t\tc1 = 0;\n\t\t\tc2++;\n\t\t}\n\t\tif (c1 == m c2 == m)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "8241": "bool isDivisible(char str[], int k)\n{\n\tint n = strlen(str);\n\tint c = 0;\n\tfor (int i = 0; i < k; i++) \n\t\tif (str[n - i - 1] == '0')\t\t\n\t\t\tc++;\n\treturn (c == k);\n}", "8281": "int productAtKthLevel(string tree, int k)\n{\n\tint level = -1;\n\tint n = tree.length();\n\tfor (int i = 0; i < n; i++) {\n\t\tif (tree[i] == '(')\n\t\t\tlevel++;\n\t\telse if (tree[i] == ')')\n\t\t\tlevel--;\n\t\telse {\n\t\t\tif (level == k)\n\t\t\t\tproduct *= (tree[i] - '0');\n\t\t}\n\t}\n\treturn product;\n}", "8296": "bool isPalindrome(string str) {\n int i = 0, j = str.size() - 1;\n while (i < j)\n\tif (str[i++] != str[j--])\n\treturn false;\n return true;\n}\nstring removePalinWords(string str) {\n string final_str = \"\", word = \"\";\n str = str + \" \";\n int n = str.size();\n for (int i = 0; i < n; i++) {\n\tif (str[i] != ' ')\n\tword = word + str[i];\n\telse {\n\tif (!(isPalindrome(word)))\n\t\tfinal_str += word + \" \";\n\tword = \"\";\n\t}\n }\n return final_str;\n}", "8301": "int findSubSequence(string s, int num)\n{ \n\tint res = 0;\n\tint i = 0;\n\twhile (num) {\n\t\tif (num & 1)\n\t\t\tres += s[i] - '0';\n\t\ti++;\n\t\tnum = num >> 1;\n\t}\n\treturn res;\n}\nint combinedSum(string s)\n{\n\tint n = s.length();\n\tint c_sum = 0;\n\tint range = (1 << n) - 1;\n\tfor (int i = 0; i <= range; i++)\n\t\tc_sum += findSubSequence(s, i);\n\treturn c_sum;\n}", "8304": "void findSubsequence(string str, int k)\n{\n\tint a[MAX_CHAR] = { 0 };\n\tfor (int i = 0; i < str.size(); i++)\n\t\ta[str[i] - 'a']++; \n\tfor (int i = 0; i < l; i++)\n\t\tif (a[str[i] - 'a'] >= k)\n\t\t\tcout << str[i]; \n}", "8310": "void findDuplciates(string a[], int n, int m)\n{\n\tbool isPresent[n][m];\n\tmemset(isPresent, 0, sizeof(isPresent));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (a[i][j] == a[k][j] && i != k) {\n\t\t\t\t\tisPresent[i][j] = true;\n\t\t\t\t\tisPresent[k][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (a[i][j] == a[i][k] && j != k) {\n\t\t\t\t\tisPresent[i][j] = true;\n\t\t\t\t\tisPresent[i][k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tif (!isPresent[i][j])\n\t\t\t\tprintf(\"%c\", a[i][j]);\n}", "8315": "string convert(string str)\n{\n\tstring w = \"\", z = \"\";\n\ttransform(str.begin(), str.end(),\n\t\t\tstr.begin(), ::toupper);\n\tstr += \" \";\n\tfor(int i = 0; i < str.length(); i++)\n\t{\n\tchar ch = str[i];\n\tif (ch != ' ')\n\t{\n\t\tw = w + ch;\n\t}\n\telse\n\t{\n\t\tz = z + char(tolower(w[0])) +\n\t\t\t\t\t\tw.substr(1) + \" \";\n\t\tw = \"\";\n\t}\n\t}\n\treturn z;\n}", "8316": "string convert(string s)\n{\n\tint n = s.length();\n\ts[0] = tolower(s[0]);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (s[i] == ' ' && i < n)\n\t\t{\n\t\t\ts[i + 1] = tolower(s[i + 1]);\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\ts[i] = toupper(s[i]);\n\t}\n\treturn s;\n}", "8317": "string change_case(string a)\n{\n\tint l = a.length();\n\tfor(int i = 0 ; i < l ; i++)\n\t{\n\t\tif(a[i] >= 'a' && a[i] <= 'z')\n\t\t\ta[i] = (char)(65 +\n\t\t\t\t(int)(a[i] - 'a'));\n\t\telse if(a[i] >= 'A' && a[i] <= 'Z')\n\t\t\ta[i] = (char)(97 +\n\t\t\t\t(int)(a[i] - 'A'));\n\t}\n\treturn a;\n}\nstring delete_vowels(string a)\n{\n\tstring temp = \"\";\n\tint l = a.length();\n\tfor(int i = 0 ; i < l ; i++)\n\t{\n\t\tif(a[i] != 'a' && a[i] != 'e' && a[i] != 'i' && a[i] != 'o' && a[i] != 'u' && a[i] != 'A' && a[i] != 'E' && a[i] != 'O' && a[i] != 'U'&& a[i] != 'I')\n\t\t\ttemp += a[i];\n\t}\n\treturn temp;\n}\nstring insert_hash(string a)\n{\n\tstring temp = \"\";\n\tint l = a.length();\n\tfor(int i = 0 ; i < l ; i++)\n\t{\n\t\tif((a[i] >= 'a' && a[i] <= 'z') ||\n\t\t(a[i] >= 'A' && a[i] <= 'Z'))\n\t\t\ttemp = temp + '#' + a[i];\n\t\telse\n\t\t\ttemp = temp + a[i];\n\t}\n\treturn temp;\n}\nvoid transformSting(string a)\n{\n\tstring b = delete_vowels(a);\n\tstring c = change_case(b);\n\tstring d = insert_hash(c);\n\tcout << d;\n}", "8366": "bool isVowel(char c)\n{\n\treturn (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');\n}\nstring encryptString(string s, int n, int k)\n{\n\tint countVowels = 0;\n\tint countConsonants = 0;\n\tstring ans = \"\";\n\tfor (int l = 0; l <= n - k; l++) {\n\t\tcountVowels = 0;\n\t\tcountConsonants = 0;\n\t\tfor (int r = l; r <= l + k - 1; r++) {\n\t\t\tif (isVowel(s[r]) == true)\n\t\t\t\tcountVowels++;\n\t\t\telse\n\t\t\t\tcountConsonants++;\n\t\t}\n\t\tans += to_string(countVowels * countConsonants);\n\t}\n\treturn ans;\n}", "8367": "bool isVowel(char c)\n{\n\treturn (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');\n}\nstring encryptString(string s, int n, int k)\n{\n\tint cv[n], cc[n];\n\tif (isVowel(s[0]))\n\t\tcv[0] = 1;\n\telse\n\t\tcc[0] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tcv[i] = cv[i - 1] + isVowel(s[i]);\n\t\tcc[i] = cc[i - 1] + !isVowel(s[i]);\n\t}\n\tstring ans = \"\";\n\tint prod = 0;\n\tprod = cc[k - 1] * cv[k - 1];\n\tans += to_string(prod);\n\tfor (int i = k; i < s.length(); i++) {\n\t\tprod = (cc[i] - cc[i - k]) * (cv[i] - cv[i - k]);\n\t\tans += to_string(prod);\n\t}\n\treturn ans;\n}", "8374": "int countOccurrences(char *str, string word)\n{\n\tchar *p;\n\tvector<string> a;\n\tp = strtok(str, \" \");\n\twhile (p != NULL)\n\t{\n\t\ta.push_back(p);\n\t\tp = strtok(NULL, \" \");\n\t}\n\tint c = 0;\n\tfor (int i = 0; i < a.size(); i++)\n\t\tif (word == a[i])\n\t\t\tc++;\n\treturn c;\n}", "8396": "bool isValidISBN(string& isbn)\n{\n\tint n = isbn.length();\n\tif (n != 10)\n\t\treturn false;\n\tint sum = 0;\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tint digit = isbn[i] - '0';\n\t\tif (0 > digit 9 < digit)\n\t\t\treturn false;\n\t\tsum += (digit * (10 - i));\n\t}\n\tchar last = isbn[9];\n\tif (last != 'X' && (last < '0' last > '9'))\n\t\treturn false;\n\tsum += ((last == 'X') ? 10 :\n\t\t\t\t(last - '0'));\n\treturn (sum % 11 == 0);\n}", "8460": "bool canFormPalindrome(string str)\n{\n\tint count[NO_OF_CHARS] = { 0 };\n\tfor (int i = 0; str[i]; i++)\n\t\tcount[str[i]]++;\n\tint odd = 0;\n\tfor (int i = 0; i < NO_OF_CHARS; i++) {\n\t\tif (count[i] & 1)\n\t\t\todd++;\n\t\tif (odd > 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "8490": "void permute(string input)\n{\n\tint n = input.length();\n\tint max = 1 << n;\n\t\ttransform(input.begin(), input.end(), input.begin(), ::tolower);\n\tfor (int i = 0; i < max; i++) {\n\t\tstring combination = input;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (((i >> j) & 1) == 1)\n\t\t\t\tcombination[j] = toupper(input.at(j));\t\n\t\tcout << combination << \" \";\n\t}\n}", "8501": "bool isNumber(string s)\n{\n\tfor (int i = 0; i < s.length(); i++)\n\t\tif (isdigit(s[i]) == false)\n\t\t\treturn false;\n\treturn true;\n}", "8506": "void printString(string str, char ch, int count)\n{\n\tint occ = 0, i;\n\tif (count == 0) {\n\t\tcout << str;\n\t\treturn;\n\t}\n\tfor (i = 0; i < str.length(); i++) {\n\t\tif (str[i] == ch)\n\t\t\tocc++;\n\t\tif (occ == count)\n\t\t\tbreak;\n\t}\n\tif (i < str.length() - 1)\n\t\tcout << str.substr(i + 1, str.length() - (i + 1));\n\telse\n\t\tcout << \"Empty string\";\n}", "8527": "bool isVowel(char c)\n{\n\treturn (c=='a' c=='A' c=='e' c=='E' c=='i' c=='I' c=='o' c=='O' c=='u' c=='U');\n}\nstring reverseVowel(string str)\n{\n\tint j=0;\n\tstring vowel;\n\tfor (int i=0; str[i]!='\\0'; i++)\n\t\tif (isVowel(str[i]))\n\t\t\tvowel[j++] = str[i];\n\tfor (int i=0; str[i]!='\\0'; i++)\n\t\tif (isVowel(str[i]))\n\t\t\tstr[i] = vowel[--j] ;\n\treturn str;\n}", "8528": "bool isVowel(char c)\n{\n\treturn (c=='a' c=='A' c=='e' c=='E' c=='i' c=='I' c=='o' c=='O' c=='u' c=='U');\n}\nstring reverseVowel(string str)\n{\n\tint i = 0;\n\tint j = str.length()-1;\n\twhile (i < j)\n\t{\n\t\tif (!isVowel(str[i]))\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isVowel(str[j]))\n\t\t{\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\t\tswap(str[i], str[j]);\n\t\ti++;\n\t\tj--;\n\t}\n\treturn str;\n}", "8538": "string firstLetterWord(string str)\n{\n\tstring result = \"\";\n\tbool v = true;\n\tfor (int i=0; i<str.length(); i++)\n\t{\n\t\tif (str[i] == ' ')\n\t\t\tv = true;\n\t\telse if (str[i] != ' ' && v == true)\n\t\t{\n\t\t\tresult.push_back(str[i]);\n\t\t\tv = false;\n\t\t}\n\t}\n\treturn result;\n}", "8539": "string processWords(char *input)\n{\n\tchar *p;\n\tvector<string> s;\n\tp = strtok(input, \" \");\n\twhile (p != NULL)\n\t{\n\t\ts.push_back(p);\n\t\tp = strtok(NULL, \" \");\n\t}\n\tstring charBuffer;\n\tfor (string values : s)\n\t\tcharBuffer += values[0];\n\treturn charBuffer;\n}", "8577": "char largest_alphabet(char a[], int n)\n{\n\tchar max = 'A';\n\tfor (int i=0; i<n; i++) \n\t\tif (a[i] > max)\n\t\t\tmax = a[i]; \n\treturn max;\n}\nchar smallest_alphabet(char a[], int n)\n{\n\tchar min = 'z';\n\tfor (int i=0; i<n-1; i++) \n\t\tif (a[i] < min)\n\t\t\tmin = a[i]; \n\treturn min;\n}", "8615": "string maximumPalinUsingKChanges(string str, int k)\n{\n\tstring palin = str;\n\tint l = 0;\n\tint r = str.length() - 1;\n\twhile (l < r) {\n\t\tif (str[l] != str[r]) {\n\t\t\tpalin[l] = palin[r] =\n\t\t\t\tmax(str[l], str[r]);\n\t\t\tk--;\n\t\t}\n\t\tl++;\n\t\tr--;\n\t}\n\tif (k < 0)\n\t\treturn \"Not possible\";\n\tl = 0;\n\tr = str.length() - 1;\n\twhile (l <= r) {\n\t\tif (l == r) {\n\t\t\tif (k > 0)\n\t\t\t\tpalin[l] = '9';\n\t\t}\n\t\tif (palin[l] < '9') {\n\t\t\tif (k >= 2 && palin[l] == str[l] && palin[r] == str[r]) {\n\t\t\t\tk -= 2;\n\t\t\t\tpalin[l] = palin[r] = '9';\n\t\t\t}\n\t\t\telse if (k >= 1\n\t\t\t\t\t&& (palin[l] != str[l] palin[r] != str[r])) {\n\t\t\t\tk--;\n\t\t\t\tpalin[l] = palin[r] = '9';\n\t\t\t}\n\t\t}\n\t\tl++;\n\t\tr--;\n\t}\n\treturn palin;\n}", "8636": "void generateAllStringsUtil(int K, char str[], int n)\n{\n\tif (n == K)\n\t{\n\t\tstr[n] = '\\0' ;\n\t\tcout << str << \" \";\n\t\treturn ;\n\t}\n\tif (str[n-1] == '1')\n\t{\n\t\tstr[n] = '0';\n\t\tgenerateAllStringsUtil (K , str , n+1);\n\t}\n\tif (str[n-1] == '0')\n\t{\n\t\tstr[n] = '0';\n\t\tgenerateAllStringsUtil(K, str, n+1);\n\t\tstr[n] = '1';\n\t\tgenerateAllStringsUtil(K, str, n+1) ;\n\t}\n}\nvoid generateAllStrings(int K )\n{\n\tif (K <= 0)\n\t\treturn ;\n\tchar str[K];\n\tstr[0] = '0' ;\n\tgenerateAllStringsUtil ( K , str , 1 ) ;\n\tstr[0] = '1' ;\n\tgenerateAllStringsUtil ( K , str , 1 );\n}", "8702": "int countTriplets(vector<int>& A)\n{\n\tint cnt = 0;\n\tunordered_map<int, int> tuples;\n\tfor (auto a : A)\n\t\tfor (auto b : A)\n\t\t\t++tuples[a & b];\n\tfor (auto a : A)\n\t\tfor (auto t : tuples)\n\t\t\tif ((t.first & a) == 0)\n\t\t\t\tcnt += t.second;\n\treturn cnt;\n}", "8705": "bool isPalindrome(const char *str)\n{\n\tint l = 0;\n\tint h = strlen(str) - 1;\n\twhile (h > l)\n\t\tif (str[l++] != str[h--])\n\t\t\treturn false;\n\treturn true;\n}\nint minRemovals(const char *str)\n{\n if (str[0] == '')\n\treturn 0;\n if (isPalindrome(str))\n\treturn 1;\n return 2;\n}", "8786": "void reverseWords(char* s)\n{\n char* word_begin = NULL;\n char* temp = s;\n while (*temp)\n {\n\tif ((word_begin == NULL) &&\n\t\t(*temp != ' '))\n\t{\n\tword_begin = temp;\n\t}\n\tif (word_begin && ((*(temp + 1) == ' ') ||\n\t\t\t\t\t(*(temp + 1) == '\\0')))\n\t{\n\treverse(word_begin, temp);\n\tword_begin = NULL;\n\t}\n\ttemp++;\n } \n reverse(s, temp - 1);\n}", "8787": "", "8788": "string RevString(string s[], int l)\n{\n\tif (l % 2 == 0)\n\t{\n\t\tint j = l / 2;\n\t\twhile (j <= l - 1)\n\t\t{\n\t\t\tstring temp;\n\t\t\ttemp = s[l - j - 1];\n\t\t\ts[l - j - 1] = s[j];\n\t\t\ts[j] = temp;\n\t\t\tj += 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint j = (l / 2) + 1;\n\t\twhile (j <= l - 1)\n\t\t{\n\t\t\tstring temp;\n\t\t\ttemp = s[l - j - 1];\n\t\t\ts[l - j - 1] = s[j];\n\t\t\ts[j] = temp;\n\t\t\tj += 1;\n\t\t}\n\t}\n\tstring S = s[0];\n\tfor(int i = 1; i < 9; i++)\n\t{\n\t\tS = S + \" \" + s[i];\n\t}\n\treturn S;\n}", "8795": "void reverse(string str)\n{\n\tif(str.size() == 0)\n\t{\n\t\treturn;\n\t}\n\treverse(str.substr(1));\n\tcout << str[0];\n}", "8823": "double getProbability(int balls[], int M)\n{\n\tfactorial(10);\n\tbox2 = M;\n\tint K = 0;\n\tfor(int i = 0; i < M; i++)\n\t\tK += balls[i];\n\tif (K % 2 == 1)\n\t\treturn 0;\n\tlong all = comb(K, K / 2);\n\tlong validPermutation = validPermutations(K / 2, balls, 0, 0, M);\n\treturn (double)validPermutation / all;\n}\nlong validPermutations(int n, int balls[], int usedBalls, int i, int M)\n{\n\tif (usedBalls == n)\n\t{\n\t\treturn box1 == box2 ? 1 : 0;\n\t}\n\tif (i >= M)\n\t\treturn 0;\n\tlong res = validPermutations(n, balls, usedBalls, i + 1, M);\n\tbox1++;\n\tfor(int j = 1; j <= balls[i]; j++)\n\t{\n\t\tif (j == balls[i])\n\t\t\tbox2--;\n\t\tlong combinations = comb(balls[i], j);\n\t\tres += combinations * validPermutations(n, balls, usedBalls + j, i + 1, M);\n\t}\n\tbox1--;\n\tbox2++;\n\treturn res;\n}\nvoid factorial(int N)\n{\n\tfact[0] = 1;\n\tfor(int i = 1; i <= N; i++)\n\t\tfact[i] = fact[i - 1] * i;\n}\nlong comb(int n, int r)\n{\n\tlong res = fact[n] / fact[r];\n\tres /= fact[n - r];\n\treturn res;\n}", "8840": "void parity(vector<int> even, vector<int> odd, vector<int> v, int i, int& min)\n{\n\tif (i == v.size()\n\t\t|| even.size() == 0\n\t\t\t&& odd.size() == 0) {\n\t\tint count = 0;\n\t\tfor (int j = 0; j < v.size() - 1; j++) {\n\t\t\tif (v[j] % 2 != v[j + 1] % 2)\n\t\t\t\tcount++;\n\t\t}\n\t\tif (count < min)\n\t\t\tmin = count;\n\t\treturn;\n\t}\n\tif (v[i] != -1)\n\t\tparity(even, odd, v, i + 1, min);\n\telse {\n\t\tif (even.size() != 0) {\n\t\t\tint x = even.back();\n\t\t\teven.pop_back();\n\t\t\tv[i] = x;\n\t\t\tparity(even, odd, v, i + 1, min);\n\t\t\teven.push_back(x);\n\t\t}\n\t\tif (odd.size() != 0) {\n\t\t\tint x = odd.back();\n\t\t\todd.pop_back();\n\t\t\tv[i] = x;\n\t\t\tparity(even, odd, v, i + 1, min);\n\t\t\todd.push_back(x);\n\t\t}\n\t}\n}\nvoid minDiffParity(vector<int> v, int n)\n{\n\tvector<int> even;\n\tvector<int> odd;\n\tunordered_map<int, int> m;\n\tfor (int i = 1; i <= n; i++)\n\t\tm[i] = 1;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] != -1)\n\t\t\tm.erase(v[i]);\n\t}\n\tfor (auto i : m) {\n\t\tif (i.first % 2 == 0)\n\t\t\teven.push_back(i.first);\n\t\telse\n\t\t\todd.push_back(i.first);\n\t}\n\tint min = 1000;\n\tparity(even, odd, v, 0, min);\n\tcout << min << endl;\n}", "8855": "void dfs(int u, int count)\n{\n\tvisited[u] = true;\n\tint temp = 0;\n\tfor (int i = 0; i < adjacent[u].size(); i++) {\n\t\tif (!visited[adjacent[u][i]]) {\n\t\t\ttemp++;\n\t\t\tdfs(adjacent[u][i], count + 1);\n\t\t}\n\t}\n\tif (temp == 0) {\n\t\tif (maxi < count) {\n\t\t\tmaxi = count;\n\t\t\tstartnode = u;\n\t\t}\n\t}\n}\nvoid dfs1(int u, int count)\n{\n\tvisited[u] = true;\n\tint temp = 0;\n\tfor (int i = 0; i < adjacent[u].size(); i++) {\n\t\tif (!visited[adjacent[u][i]]) {\n\t\t\ttemp++;\n\t\t\tparent[adjacent[u][i]] = u;\n\t\t\tdfs1(adjacent[u][i], count + 1);\n\t\t}\n\t}\n\tif (temp == 0) {\n\t\tif (maxi < count) {\n\t\t\tmaxi = count;\n\t\t\tendnode = u;\n\t\t}\n\t}\n}\nvoid dfs2(int u, int count)\n{\n\tvisited[u] = true;\n\tint temp = 0;\n\tfor (int i = 0; i < adjacent[u].size(); i++) {\n\t\tif (!visited[adjacent[u][i]] && !vis[adjacent[u][i]]) {\n\t\t\ttemp++;\n\t\t\tdfs2(adjacent[u][i], count + 1);\n\t\t}\n\t}\n\tif (temp == 0) {\n\t\tif (maxi < count) {\n\t\t\tmaxi = count;\n\t\t\tthirdnode = u;\n\t\t}\n\t}\n}\nvoid findNodes()\n{\n\tdfs(1, 0);\n\tfor (int i = 0; i <= N; i++)\n\t\tvisited[i] = false;\n\tmaxi = -1;\n\tdfs1(startnode, 0);\n\tfor (int i = 0; i <= N; i++)\n\t\tvisited[i] = false;\n\tint x = endnode;\n\tvis[startnode] = true;\n\twhile (x != startnode) {\n\t\tvis[x] = true;\n\t\tx = parent[x];\n\t}\n\tmaxi = -1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (vis[i])\n\t\t\tdfs2(i, 0);\n\t}\n}", "8858": "void dfs(int i, int j, vector<vector<int> >& grid, vector<vector<bool> >& vis, int& ans, int z, int z_count)\n{\n\tint n = grid.size(), m = grid[0].size();\n\tvis[i][j] = 1;\n\tif (grid[i][j] == 0)\n\t\tz++;\n\tif (grid[i][j] == 2) {\n\t\tif (z == z_count)\n\t\t\tans++;\n\t\tvis[i][j] = 0;\n\t\treturn;\n\t}\n\tif (i >= 1 && !vis[i - 1][j] && grid[i - 1][j] != -1)\n\t\tdfs(i - 1, j, grid, vis, ans, z, z_count);\n\tif (i < n - 1 && !vis[i + 1][j] && grid[i + 1][j] != -1)\n\t\tdfs(i + 1, j, grid, vis, ans, z, z_count);\n\tif (j >= 1 && !vis[i][j - 1] && grid[i][j - 1] != -1)\n\t\tdfs(i, j - 1, grid, vis, ans, z, z_count);\n\tif (j < m - 1 && !vis[i][j + 1] && grid[i][j + 1] != -1)\n\t\tdfs(i, j + 1, grid, vis, ans, z, z_count);\n\tvis[i][j] = 0;\n}\nint uniquePaths(vector<vector<int> >& grid)\n{\n\tint n = grid.size(), m = grid[0].size();\n\tint ans = 0;\n\tvector<vector<bool> > vis(n, vector<bool>(m, 0));\n\tint x, y;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (grid[i][j] == 0)\n\t\t\t\tz_count++;\n\t\t\telse if (grid[i][j] == 1) {\n\t\t\t\tx = i, y = j;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(x, y, grid, vis, ans, 0, z_count);\n\treturn ans;\n}", "8907": "int numPairs(int a[], int n)\n{\n\tint ans, i, index;\n\tans = 0;\n\tfor (i = 0; i < n; i++)\n\t\ta[i] = abs(a[i]);\n\tsort(a, a + n);\n\tfor (i = 0; i < n; i++) {\n\t\tindex = upper_bound( a, a + n, 2 * a[i])\n\t\t\t\t- a;\n\t\tans += index - i - 1;\n\t}\n\treturn ans;\n}", "8939": "int power(int x, unsigned int y, int p)\n{\n\tint res = 1;\n\tx = x % p;\n\twhile (y > 0) {\n\t\tif (y & 1)\n\t\t\tres = (res * x) % p;\n\t\ty = y >> 1;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nint findModuloByM(int X, int N, int M)\n{\n\tif (N < 6) {\n\t\tstring temp(N, (char)(48 + X));\n\t\tint res = stoi(temp) % M;\n\t\treturn res;\n\t}\n\tif (N % 2 == 0) {\n\t\tint half = findModuloByM(X, N / 2, M) % M;\n\t\tint res = (half * power(10, N / 2, M) + half)\n\t\t\t\t% M;\n\t\treturn res;\n\t}\n\telse {\n\t\tint half = findModuloByM(X, N / 2, M) % M;\n\t\tint res = (half * power(10, N / 2 + 1, M) + half * 10 + X)\n\t\t\t\t% M;\n\t\treturn res;\n\t}\n}", "9007": "bool check(circle C[])\n{\n\tdouble C1C2\n\t\t= sqrt((C[1].x - C[0].x)\n\t\t\t\t* (C[1].x - C[0].x)\n\t\t\t+ (C[1].y - C[0].y)\n\t\t\t\t\t* (C[1].y - C[0].y));\n\tbool flag = 0;\n\tif (C1C2 < (C[0].r + C[1].r)) {\n\t\tif ((C[0].x + C[1].x)\n\t\t\t\t== 2 * C[2].x\n\t\t\t&& (C[0].y + C[1].y) == 2 * C[2].y) {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\treturn flag;\n}\nbool IsFairTriplet(circle c[])\n{\n\tbool f = false;\n\tf |= check(c);\n\tfor (int i = 0; i < 2; i++) {\n\t\tswap(c[0], c[2]);\n\t\tf |= check(c);\n\t}\n\treturn f;\n}", "9009": "double eccHyperbola(double A, double B)\n{\n\tdouble r = (double)B * B / A * A;\n\tr += 1;\n\treturn sqrt(r);\n}", "9012": "float calculateArea(float A, float B, float C, float D)\n{\n\tfloat S = (A + B + C + D) / 2;\n\tfloat area = sqrt((S - A) * (S - B)\n\t\t\t\t\t* (S - C) * (S - D));\n\treturn area;\n}", "9015": "void triangleArea(int a, int b)\n{\n\tdouble ratio = (double)b / a;\n\tcout << ratio;\n}", "9021": "float distance(int m, int n, int p, int q)\n{\n\treturn sqrt(pow(n - m, 2)\n\t\t\t\t+ pow(q - p, 2) * 1.0);\n}\nvoid Excenters(int x1, int y1, int x2, int y2, int x3, int y3)\n{\n\tfloat a = distance(x2, x3, y2, y3);\n\tfloat b = distance(x3, x1, y3, y1);\n\tfloat c = distance(x1, x2, y1, y2);\n\tvector<pair<float, float> > excenter(4);\n\texcenter[1].first\n\t\t= (-(a * x1) + (b * x2) + (c * x3))\n\t\t/ (-a + b + c);\n\texcenter[1].second\n\t\t= (-(a * y1) + (b * y2) + (c * y3))\n\t\t/ (-a + b + c);\n\texcenter[2].first\n\t\t= ((a * x1) - (b * x2) + (c * x3))\n\t\t/ (a - b + c);\n\texcenter[2].second\n\t\t= ((a * y1) - (b * y2) + (c * y3))\n\t\t/ (a - b + c);\n\texcenter[3].first\n\t\t= ((a * x1) + (b * x2) - (c * x3))\n\t\t/ (a + b - c);\n\texcenter[3].second\n\t\t= ((a * y1) + (b * y2) - (c * y3))\n\t\t/ (a + b - c);\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcout << excenter[i].first << \" \"\n\t\t\t<< excenter[i].second\n\t\t\t<< endl;\n\t}\n}", "9035": "void findHeight(float p1, float p2, float b, float c)\n{\n\tfloat a = max(p1, p2) - min(p1, p2);\n\tfloat s = (a + b + c) / 2;\n\tfloat area = sqrt(s * (s - a)\n\t\t\t\t\t* (s - b) * (s - c));\n\tfloat height = (area * 2) / a;\n\tcout << \"Height is: \" << height;\n}", "9070": "int areaOfSquare(int S)\n{\n\tint area = S * S;\n\treturn area;\n}", "9079": "int maxPointOfIntersection(int x, int y)\n{\n\tint k = y * (y - 1) / 2;\n\tk = k + x * (2 * y + x - 1);\n\treturn k;\n}", "9113": "int Icositetragonal_num(int n)\n{\n\treturn (22 * n * n - 20 * n) / 2;\n}", "9114": "int Icosihenagonal_num(int n)\n{\n\treturn (19 * n * n - 17 * n) / 2;\n}", "9119": "double area_of_circle(int m, int n)\n{\n\tint square_of_radius = ( m * n ) / 4;\n\tdouble area = ( 3.141 * square_of_radius );\n\treturn area;\n}", "9129": "double area(int R) {\n\tdouble base = 1.732 * R;\n\tdouble height = (1.5) * R;\n\tdouble area = 0.5 * base * height;\n\treturn area;\n}", "9130": "float circlearea(float R)\n{\n\tif (R < 0)\n\t\treturn -1;\n\tfloat a = 3.14 * R * R / 4;\n\treturn a;\n}", "9137": "int countPairs(int* P, int* Q, int N, int M)\n{\n\tint A[2] = { 0 }, B[2] = { 0 };\n\tfor (int i = 0; i < N; i++)\n\t\tA[P[i] % 2]++;\n\tfor (int i = 0; i < M; i++)\n\t\tB[Q[i] % 2]++;\n\treturn (A[0] * B[0] + A[1] * B[1]);\n}", "9142": "pair<double, double> find_Centroid(vector<pair<double, double> >& v)\n{\n\tpair<double, double> ans = { 0, 0 };\n\tint n = v.size();\n\tdouble signedArea = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tdouble x0 = v[i].first, y0 = v[i].second;\n\t\tdouble x1 = v[(i + 1) % n].first, y1 = \n\t\t\t\t\t\t\tv[(i + 1) % n].second;\n\t\tdouble A = (x0 * y1) - (x1 * y0);\n\t\tsignedArea += A;\n\t\tans.first += (x0 + x1) * A;\n\t\tans.second += (y0 + y1) * A;\n\t}\n\tsignedArea *= 0.5;\n\tans.first = (ans.first) / (6 * signedArea);\n\tans.second = (ans.second) / (6 * signedArea);\n\treturn ans;\n}", "9147": "int countIntersections(int n)\n{\n\treturn n * (n - 1) / 2;\n}", "9169": "void newvol(double x)\n{\n\tcout << \"percentage increase in the\"\n\t\t<< \" volume of the sphere is \"\n\t\t<< pow(x, 3) / 10000 + 3 * x\n\t\t\t\t+ (3 * pow(x, 2)) / 100\n\t\t<< \"%\" << endl;\n}", "9177": "double areaOfTriangle(float d)\n{\n\tfloat c = 1.618 * d;\n\tfloat s = (d + c + c) / 2;\n\tdouble area = sqrt(s * (s - c) *\n\t\t\t\t\t\t(s - c) * (s - d));\n\treturn 5 * area;\n}\ndouble areaOfRegPentagon(float d)\n{\n\tdouble cal = 4 * tan(PI / 5);\n\tdouble area = (5 * d * d) / cal;\n\treturn area;\n}\ndouble areaOfPentagram(float d)\n{\n\treturn areaOfRegPentagon(d) +\n\t\t\t\t\t\t\tareaOfTriangle(d);\n}", "9181": "void anglequichord(int z)\n{\n\tcout << \"The angle is \" << z\n\t\t<< \" degrees\" << endl;\n}", "9187": "void circle(int x1, int y1, int x2, int y2, int r1, int r2)\n{\n\tint distSq = sqrt(((x1 - x2)\n\t\t\t\t\t* (x1 - x2))\n\t\t\t\t\t+ ((y1 - y2)\n\t\t\t\t\t\t* (y1 - y2)));\n\tif (distSq + r2 == r1)\n\t\tcout << \"The smaller circle lies completely\"\n\t\t\t<< \" inside the bigger circle with \"\n\t\t\t<< \"touching each other \"\n\t\t\t<< \"at a point of circumference. \"\n\t\t\t<< endl;\n\telse if (distSq + r2 < r1)\n\t\tcout << \"The smaller circle lies completely\"\n\t\t\t<< \" inside the bigger circle without\"\n\t\t\t<< \" touching each other \"\n\t\t\t<< \"at a point of circumference. \"\n\t\t\t<< endl;\n\telse\n\t\tcout << \"The smaller does not lies inside\"\n\t\t\t<< \" the bigger circle completely.\"\n\t\t\t<< endl;\n}", "9195": "void lengtang(double r1, double r2, double d)\n{\n\tcout << \"The length of the direct\"\n\t\t<<\" common tangent is \"\n\t\t<< sqrt(pow(d, 2) - pow((r1 - r2), 2))\n\t\t<< endl;\n}", "9196": "void rad(double d, double h)\n{\n\tcout << \"The radius of the circle is \"\n\t\t<< ((d * d) / (8 * h) + h / 2)\n\t\t<< endl;\n}", "9197": "void shortdis(double r, double d)\n{\n\tcout << \"The shortest distance \"\n\t\t<< \"from the chord to centre \"\n\t\t<< sqrt((r * r) - ((d * d) / 4))\n\t\t<< endl;\n}", "9200": "void lengtang(double r1, double r2, double d)\n{\n\tcout << \"The length of the direct\"\n\t\t<<\" common tangent is \"\n\t\t<< sqrt(pow(d, 2) - pow((r1 - r2), 2))\n\t\t<< endl;\n}", "9201": "void length_of_chord(double r, double x)\n{\n\tcout << \"The length of the chord\"\n\t\t<< \" of the circle is \"\n\t\t<< 2 * r * sin(x * (3.14 / 180))\n\t\t<< endl;\n}", "9232": "float square(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat x = 0.464 * a;\n\treturn x;\n}", "9238": "float polyapothem(float n, float a)\n{\n\tif (a < 0 && n < 0)\n\t\treturn -1;\n\treturn a / (2 * tan((180 / n) * 3.14159 / 180));\n}", "9240": "float polyarea(float n, float r)\n{\n\tif (r < 0 && n < 0)\n\t\treturn -1;\n\tfloat A = ((r * r * n) * sin((360 / n) * 3.14159 / 180)) / 2;\n\treturn A;\n}", "9241": "float polyarea(float n, float a)\n{\n\tif (a < 0 && n < 0)\n\t\treturn -1;\n\tfloat A = (a * a * n) / (4 * tan((180 / n) * 3.14159 / 180));\n\treturn A;\n}", "9247": "float hexDiagonal(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat d = 1.73 * a;\n\treturn d;\n}", "9250": "float calculateSide(float n, float r)\n{\n\tfloat theta, theta_in_radians;\n\ttheta = 360 / n;\n\ttheta_in_radians = theta * 3.14 / 180;\n\treturn 2 * r * sin(theta_in_radians / 2);\n}", "9257": "float cyl(float r, float R, float h)\n{\n\tif (h < 0 && r < 0 && R < 0)\n\t\treturn -1;\n\tfloat r1 = r;\n\tfloat h1 = h;\n\tfloat V = 3.14 * pow(r1, 2) * h1;\n\treturn V;\n}", "9258": "float findVolume(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat r = a / 2;\n\tfloat h = a;\n\tfloat V = 3.14 * pow(r, 2) * h;\n\treturn V;\n}", "9290": "float Perimeter(float s, int n)\n{\n\tfloat perimeter = 1;\n\tperimeter = n * s;\n\treturn perimeter;\n}", "9291": "float area(float r)\n{\n\treturn (0.5)*(3.14)*(r * r);\n}\nfloat perimeter(float r)\n{\n\treturn (3.14)*(r);\n}", "9302": "", "9305": "float rhombusarea(float l, float b)\n{\n\tif (l < 0 b < 0)\n\t\treturn -1;\n\treturn (l * b) / 2;\n}", "9318": "float area(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat area = sqrt(a) / 6;\n\treturn area;\n}", "9329": "double longestRodInCuboid(int length, int breadth, int height)\n{\n\tdouble result;\n\tint temp;\n\ttemp = length * length + breadth * breadth\n\t\t+ height * height;\n\tresult = sqrt(temp);\n\treturn result;\n}", "9346": "void is_partition_possible(int n, int x[], int y[], int w[])\n{\n\tmap<int, int> weight_at_x;\n\tint max_x = -2e3, min_x = 2e3;\n\tfor (int i = 0; i < n; i++) {\n\t\tint new_x = x[i] - y[i];\n\t\tmax_x = max(max_x, new_x);\n\t\tmin_x = min(min_x, new_x);\n\t\tweight_at_x[new_x] += w[i];\n\t}\n\tvector<int> sum_till;\n\tsum_till.push_back(0);\n\tfor (int x = min_x; x <= max_x; x++) {\n\t\tsum_till.push_back(sum_till.back() + weight_at_x[x]);\n\t}\n\tint total_sum = sum_till.back();\n\tint partition_possible = false;\n\tfor (int i = 1; i < sum_till.size(); i++) {\n\t\tif (sum_till[i] == total_sum - sum_till[i])\n\t\t\tpartition_possible = true;\n\t\tif (sum_till[i - 1] == total_sum - sum_till[i])\n\t\t\tpartition_possible = true;\n\t}\n\tprintf(partition_possible ? \"YES\\n\" : \"NO\\n\");\n}", "9348": "bool LiesInsieRectangle(int a, int b, int x, int y)\n{\n\tif (x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0)\n\t\treturn true;\n\treturn false;\n}", "9358": "bool FindPoint(int x1, int y1, int x2, int y2, int x, int y)\n{\n\tif (x > x1 and x < x2 and y > y1 and y < y2)\n\t\treturn true;\n\treturn false;\n}", "9359": "void distance(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2)\n{\n\tfloat x1, y1, z1, d;\n\tif (a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2)\n\t{\n\t\tx1 = y1 = 0;\n\t\tz1 = -d1 / c1;\n\t\td = fabs(( c2 * z1 + d2)) /\n\t\t(sqrt(a2 * a2 + b2 * b2 + c2 * c2));\n\t\tcout << \"Perpendicular distance is \"\n\t\t\t<< d << endl;\n\t}\n\telse\n\t\tcout << \"Planes are not parallel\";\n\treturn;\n}", "9362": "void shortest_distance(float x1, float y1, float z1, float a, float b, float c, float d)\n{\n\td = fabs((a * x1 + b * y1 + c * z1 + d));\n\tfloat e = sqrt(a * a + b * b + c * c);\n\tcout << \"Perpendicular distance is \"\n\t\t<< (d / e);\n\t\treturn;\n}", "9369": "float findVolume(float l, float b, float h)\n{\n\tfloat volume = (l * b * h) / 2;\n\treturn volume;\n}", "9405": "double findPCSlope(double m)\n{\n\treturn -1.0 / m;\n}", "9423": "bool isRectangle(int a, int b, int c, int d)\n{\n\tif (a == b == c == d)\n\t\treturn true;\n\telse if (a == b && c == d)\n\t\treturn true;\n\telse if (a == d && c == b)\n\t\treturn true;\n\telse if (a == c && d == b)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "9430": "float area_of_segment(float radius, float angle)\n{\n\tfloat area_of_sector = pi *\n\t\t\t\t\t\t(radius * radius)\n\t\t\t\t\t\t*(angle / 360);\n\tfloat area_of_triangle = (float)1 / 2 *\n\t\t\t\t\t\t\t(radius * radius) *\n\t\t\t\t\t\t\tsin((angle * pi) / 180);\n\treturn area_of_sector - area_of_triangle;\n}", "9432": "void midpoint(int x1, int x2, int y1, int y2)\n{\n\tcout << (float)(x1+x2)/2 <<\n\t\t\t\" , \"<< (float)(y1+y2)/2 ;\n}", "9445": "int maxvolume(int s)\n{\n\tint maxvalue = 0;\n\tfor (int i = 1; i <= s - 2; i++) {\n\t\tfor (int j = 1; j <= s - 1; j++) {\n\t\t\tint k = s - i - j;\n\t\t\tmaxvalue = max(maxvalue, i * j * k);\n\t\t}\n\t}\n\treturn maxvalue;\n}", "9446": "int maxvolume(int s)\n{\n\tint length = s / 3;\n\ts -= length;\n\tint breadth = s / 2;\n\tint height = s - breadth;\n\treturn length * breadth * height;\n}", "9452": "float volumeTriangular(int a, int b, int h)\n{\n\tfloat vol = (0.1666) * a *\n\t\t\t\t\tb * h;\n\treturn vol;\n}\nfloat volumeSquare(int b, int h)\n{\n\tfloat vol = (0.33) * b *\n\t\t\t\t\tb * h;\n\treturn vol;\n}\nfloat volumePentagonal(int a, int b, int h)\n{\n\tfloat vol = (0.83) * a * b * h;\n\treturn vol;\n}\nfloat volumeHexagonal(int a, int b, int h)\n{\n\tfloat vol = a * b * h;\n\treturn vol;\n}", "9457": "double Area(int b1, int b2, int h)\n{\n\treturn ((b1 + b2) / 2) * h;\n}", "9458": "double hexagonArea(double s)\n{\n\treturn ((3 * sqrt(3) *\n\t\t\t(s * s)) / 2);\t\n}", "9467": "double arcLength(double diameter, double angle)\n{\n\tdouble pi = 22.0 / 7.0;\n\tdouble arc;\n\tif (angle >= 360)\n\t{\n\t\tcout<< \"Angle cannot\",\n\t\t\t\" be formed\";\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tarc = (pi * diameter) *\n\t\t\t(angle / 360.0);\n\t\treturn arc;\n\t}\n}", "9468": "void SectorArea(double radius,double angle)\n{\n\tif(angle >= 360)\n\t\tcout<<\"Angle not possible\";\n\telse\n\t{\n\t\tdouble sector = ((22 * radius * radius) / 7)\n\t\t\t\t\t* (angle / 360);\n\t\tcout<<sector;\n\t}\n}", "9476": "int maxSquare(int b, int m)\n{\n\treturn (b / m - 1) * (b / m) / 2;\n}", "9478": "void checkCollision(int a, int b, int c, int x, int y, int radius)\n{\n\tint dist = (abs(a * x + b * y + c)) /\n\t\t\t\t\tsqrt(a * a + b * b);\n\tif (radius == dist)\n\t\tcout << \"Touch\" << endl;\n\telse if (radius > dist)\n\t\tcout << \"Intersect\" << endl;\n\telse\n\t\tcout << \"Outside\" << endl;\n}", "9493": "void lineFromPoints(pdd P, pdd Q, double &a, double &b, double &c)\n{\n\ta = Q.second - P.second;\n\tb = P.first - Q.first;\n\tc = a*(P.first)+ b*(P.second);\n}\nvoid perpendicularBisectorFromLine(pdd P, pdd Q, double &a, double &b, double &c)\n{\n\tpdd mid_point = make_pair((P.first + Q.first)/2,\n\t\t\t\t\t\t\t(P.second + Q.second)/2);\n\tc = -b*(mid_point.first) + a*(mid_point.second);\n\tdouble temp = a;\n\ta = -b;\n\tb = temp;\n}\npdd lineLineIntersection(double a1, double b1, double c1, double a2, double b2, double c2)\n{\n\tdouble determinant = a1*b2 - a2*b1;\n\tif (determinant == 0)\n\t{\n\t\treturn make_pair(FLT_MAX, FLT_MAX);\n\t}\n\telse\n\t{\n\t\tdouble x = (b2*c1 - b1*c2)/determinant;\n\t\tdouble y = (a1*c2 - a2*c1)/determinant;\n\t\treturn make_pair(x, y);\n\t}\n}\nvoid findCircumCenter(pdd P, pdd Q, pdd R)\n{\n\tdouble a, b, c;\n\tlineFromPoints(P, Q, a, b, c);\n\tdouble e, f, g;\n\tlineFromPoints(Q, R, e, f, g);\n\tperpendicularBisectorFromLine(P, Q, a, b, c);\n\tperpendicularBisectorFromLine(Q, R, e, f, g);\n\tpdd circumcenter =\n\t\tlineLineIntersection(a, b, c, e, f, g);\n\tif (circumcenter.first == FLT_MAX && circumcenter.second == FLT_MAX)\n\t{\n\t\tcout << \"The two perpendicular bisectors \"\n\t\t\t\t\"found come parallel\" << endl;\n\t\tcout << \"Thus, the given points do not form \"\n\t\t\t\t\"a triangle and are collinear\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"The circumcenter of the triangle PQR is: \";\n\t\tcout << \"(\" << circumcenter.first << \", \" << circumcenter.second << \")\" << endl;\n\t}\n}", "9496": "int numberOfDiagonals(int n)\n{\n\treturn n * (n - 3) / 2;\n}", "9505": "void findRightAngle(int A, int H)\n{\n\tlong D = pow(H, 4) - 16 * A * A;\n\tif (D >= 0)\n\t{\n\t\tlong root1 = (H * H + sqrt(D)) / 2;\n\t\tlong root2 = (H * H - sqrt(D)) / 2;\n\t\tlong a = sqrt(root1);\n\t\tlong b = sqrt(root2);\n\t\tif (b >= a)\n\t\tcout << a << \" \" << b << \" \" << H;\n\t\telse\n\t\tcout << b << \" \" << a << \" \" << H;\n\t}\n\telse\n\t\tcout << \"-1\";\n}", "9507": "int numberOfSquares(int base)\n{\n base = (base - 2);\n base = floor(base / 2);\n return base * (base + 1)/2;\n}", "9528": "double polygonArea(double X[], double Y[], int n)\n{\n\tdouble area = 0.0;\n\tint j = n - 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tarea += (X[j] + X[i]) * (Y[j] - Y[i]);\n\t}\n\treturn abs(area / 2.0);\n}", "9567": "int chk(int n)\n{\n\tvector<int> v;\n\twhile (n != 0) {\n\t\tv.push_back(n % 2);\n\t\tn = n / 2;\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] == 1) {\n\t\t\treturn pow(2, i);\n\t\t}\n\t}\n\treturn 0;\n}\nvoid sumOfLSB(int arr[], int N)\n{\n\tvector<int> lsb_arr;\n\tfor (int i = 0; i < N; i++) {\n\t\tlsb_arr.push_back(chk(arr[i]));\n\t}\n\tsort(lsb_arr.begin(), lsb_arr.end(), greater<int>());\n\tint ans = 0;\n\tfor (int i = 0; i < N - 1; i += 2) {\n\t\tans += (lsb_arr[i + 1]);\n\t}\n\tcout << (ans);\n}", "9574": "int countSubsequences(vector<int> arr)\n{\n\tint odd = 0;\n\tfor (int x : arr) {\n\t\tif (x & 1)\n\t\t\todd++;\n\t}\n\treturn (1 << odd) - 1;\n}", "9608": "void performQuery(vector<int> arr, vector<vector<int>> Q)\n\t{\n\t\tfor (int i = 0; i < Q.size(); i++) {\n\t\t\tint or1 = 0;\n\t\t\tint x = Q[i][0];\n\t\t\tarr[x - 1] = Q[i][1];\n\t\t\tfor (int j = 0; j < arr.size(); j++) {\n\t\t\t\tor1 = or1 | arr[j];\n\t\t\t}\n\t\t\tcout<<or1<<\" \";\n\t\t}\n\t}", "9638": "int smallest(int k, int d)\n{\n\tint cnt = 1;\n\tint m = d % k;\n\tvector<int> v(k, 0);\n\tv[m] = 1;\n\twhile (1) {\n\t\tif (m == 0)\n\t\t\treturn cnt;\n\t\tm = (((m * (10 % k)) % k) + (d % k)) % k;\n\t\tif (v[m] == 1)\n\t\t\treturn -1;\n\t\tv[m] = 1;\n\t\tcnt++;\n\t}\n\treturn -1;\n}", "9639": "int getPairsCount(int arr[], int n)\n{\n\tint count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = arr[i] - (i % arr[i]); j < n; j += arr[i]) {\n\t\t\tif (i < j\n\t\t\t\t&& abs(arr[i] - arr[j])\n\t\t\t\t\t>= min(arr[i], arr[j])) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "9673": "void check(int N)\n{\n\tint twos = 0, fives = 0;\n\twhile (N % 2 == 0) {\n\t\tN /= 2;\n\t\ttwos++;\n\t}\n\twhile (N % 5 == 0) {\n\t\tN /= 5;\n\t\tfives++;\n\t}\n\tif (N == 1 && twos <= fives) {\n\t\tcout << 2 * fives - twos;\n\t}\n\telse {\n\t\tcout << -1;\n\t}\n}", "9685": "void rangeSum(int arr[], int N, int L, int R)\n{\n\tint sum = 0;\n\tfor (int i = L - 1; i < R; i++) {\n\t\tsum += arr[i % N];\n\t}\n\tcout << sum;\n}", "9686": "void rangeSum(int arr[], int N, int L, int R)\n{\n\tint prefix[N + 1];\n\tprefix[0] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tprefix[i] = prefix[i - 1]\n\t\t\t\t\t+ arr[i - 1];\n\t}\n\tint leftsum\n\t\t= ((L - 1) / N) * prefix[N]\n\t\t+ prefix[(L - 1) % N];\n\tint rightsum = (R / N) * prefix[N]\n\t\t\t\t+ prefix[R % N];\n\tcout << rightsum - leftsum;\n}", "9702": "int ExpoFactorial(int N)\n{\n\tint res = 1;\n\tint mod = 1000000007;\n\tfor (int i = 2; i < N + 1; i++)\n\t\tres = (int)pow(i, res) % mod;\n\treturn res;\n}", "9704": "int maxSubArraySumRepeated(int arr[], int N, int K)\n{\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tsum += arr[i];\n\tint curr = arr[0];\n\tint ans = arr[0];\n\tif (K == 1) {\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tcurr = max(arr[i], curr + arr[i]);\n\t\t\tans = max(ans, curr);\n\t\t}\n\t\treturn ans;\n\t}\n\tvector<int> V;\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tV.push_back(arr[i % N]);\n\t}\n\tint maxSuf = V[0];\n\tint maxPref = V[2 * N - 1];\n\tcurr = V[0];\n\tfor (int i = 1; i < 2 * N; i++) {\n\t\tcurr += V[i];\n\t\tmaxPref = max(maxPref, curr);\n\t}\n\tcurr = V[2 * N - 1];\n\tfor (int i = 2 * N - 2; i >= 0; i--) {\n\t\tcurr += V[i];\n\t\tmaxSuf = max(maxSuf, curr);\n\t}\n\tcurr = V[0];\n\tfor (int i = 1; i < 2 * N; i++) {\n\t\tcurr = max(V[i], curr + V[i]);\n\t\tans = max(ans, curr);\n\t}\n\tif (sum > 0) {\n\t\tint temp = 1LL * sum * (K - 2);\n\t\tans = max(ans, max(temp + maxPref, temp + maxSuf));\n\t}\n\treturn ans;\n}", "9707": "int factorial(int n)\n{\n\tif (n == 0)\n\t\treturn 1;\n\treturn n * factorial(n - 1);\n}\nlong long numOfNecklace(int N)\n{\n\tlong long ans = factorial(N)\n\t\t\t\t\t/ (factorial(N / 2) * factorial(N / 2));\n\tans = ans * factorial(N / 2 - 1);\n\tans = ans * factorial(N / 2 - 1);\n\tans /= 2;\n\treturn ans;\n}", "9726": "int gcd(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\nvoid countPairs(int* arr, int N)\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tint count = 0;\n\t\tfor (int x = 1; x <= arr[i]; x++) {\n\t\t\tfor (int y = x; y <= arr[i]; y++) {\n\t\t\t\tif (gcd(x, y) > 1)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << count << \" \";\n\t}\n}", "9727": "void preCalculate(vector<int>& phi, vector<int>& ans)\n{\n\tphi[0] = 0;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAX; i++)\n\t\tphi[i] = i;\n\tfor (int i = 2; i <= MAX; i++) {\n\t\tif (phi[i] == i) {\n\t\t\tfor (int j = i; j <= MAX; j += i)\n\t\t\t\tphi[j] -= (phi[j] / i);\n\t\t}\n\t}\n\tfor (int i = 1; i <= MAX; i++)\n\t\tans[i] = ans[i - 1] + (i - phi[i]);\n}\nvoid countPairs(int* arr, int N)\n{\n\tvector<int> phi(1e5, 0);\n\tvector<int> ans(1e5, 0);\n\tpreCalculate(phi, ans);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcout << ans[arr[i]] << \" \";\n\t}\n}", "9735": "void countSubarray(int arr[], int n)\n{\n\tint count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tint mxSubarray = 0;\n\t\t\tint mxOther = 0;\n\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\tmxSubarray = max(mxSubarray, arr[k]);\n\t\t\t}\n\t\t\tfor (int k = 0; k < i; k++) {\n\t\t\t\tmxOther = max( mxOther, arr[k]);\n\t\t\t}\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\tmxOther = max( mxOther, arr[k]);\n\t\t\t}\n\t\t\tif (mxSubarray > (2 * mxOther))\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tcout << count;\n}", "9736": "void countSubarray(int arr[], int n)\n{\n\tint count = 0, L = 0, R = 0;\n\tint mx = *max_element(arr, arr + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] * 2 > mx) {\n\t\t\tL = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (arr[i] * 2 > mx) {\n\t\t\tR = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << (L + 1) * (n - R);\n}", "9738": "bool isPrime(int X)\n{\n\tfor (int i = 2; i * i <= X; i++)\n\t\t\treturn false;\n\treturn true;\n}\nvoid printPrimes(int A[], int N)\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = A[i] - 1;; j--) {\n\t\t\tif (isPrime(j)) {\n\t\t\t\tcout << j << \" \";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = A[i] + 1;; j++) {\n\t\t\tif (isPrime(j)) {\n\t\t\t\tcout << j << \" \";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}", "9759": "unordered_map<int, int> PrimeFactor(int N)\n{\n\tunordered_map<int, int> primef;\n\twhile (N % 2 == 0)\n\t{\n\t\tif (primef.count(2))\n\t\t{\n\t\t\tprimef[2] += 1;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tprimef[2] = 1;\n\t\t}\n\t\tN /= 2;\n\t}\n\tfor(int i = 3; i <= sqrt(N); i++) \n\t{\n\t\twhile (N % i == 0) \n\t\t{\n\t\t\tif (primef.count(i)) \n\t\t\t{\n\t\t\t\tprimef[i] += 1;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tprimef[i] = 1;\n\t\t\t}\n\t\t\tN /= 2;\n\t\t}\n\t}\n\tif (N > 2)\n\t{\n\t\tprimef[N] = 1;\n\t}\n\treturn primef;\n}\nint CountToMakeEqual(int X, int Y)\n{\n\tint gcdofXY = __gcd(X, Y);\n\tint newX = Y / gcdofXY;\n\tint newY = X / gcdofXY;\n\tunordered_map<int, int> primeX;\n\tunordered_map<int, int> primeY;\n\tprimeX = PrimeFactor(newX);\n\tprimeY = PrimeFactor(newY);\n\tint ans = 0;\n\tfor(auto c : primeX) \n\t{\n\t\tif (X % c.first != 0) \n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tans += primeX[c.first];\n\t}\n\tfor(auto c : primeY) \n\t{\n\t\tif (Y % c.first != 0)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tans += primeY[c.first];\n\t}\n\treturn ans;\n}", "9777": "string isDivisibleByDivisor(int S, int D)\n{\n\tS %= D;\n\tunordered_set<int> hashMap;\n\thashMap.insert(S);\n\tfor (int i = 0; i <= D; i++) {\n\t\tS += (S % D);\n\t\tS %= D;\n\t\tif (hashMap.find(S)\n\t\t\t!= hashMap.end()) {\n\t\t\tif (S == 0) {\n\t\t\t\treturn \"Yes\";\n\t\t\t}\n\t\t\treturn \"No\";\n\t\t}\n\t\telse\n\t\t\thashMap.insert(S);\n\t}\n\treturn \"Yes\";\n}", "9787": "int KthSmallest(int A[], int B[], int N, int K)\n{\n\tint M = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tM = max(A[i], M);\n\t}\n\tint freq[M + 1] = { 0 };\n\tfor (int i = 0; i < N; i++) {\n\t\tfreq[A[i]] += B[i];\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i <= M; i++) {\n\t\tsum += freq[i];\n\t\tif (sum >= K) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "9804": "void findbitwiseOR(int* a, int n)\n{\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint curr_sub_array = a[i];\n\t\tres = res | curr_sub_array;\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tcurr_sub_array = curr_sub_array\n\t\t\t\t\t\t\t& a[j];\n\t\t\tres = res | curr_sub_array;\n\t\t}\n\t}\n\tcout << res;\n}", "9805": "void findbitwiseOR(int* a, int n)\n{\n\tint res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres = res | a[i];\n\tcout << res;\n}", "9818": "void check(int n)\n{\n\tint sumOfDigit = 0;\n\tint prodOfDigit = 1;\n\twhile (n > 0) {\n\t\tint rem;\n\t\trem = n % 10;\n\t\tsumOfDigit += rem;\n\t\tprodOfDigit *= rem;\n\t\tn /= 10;\n\t}\n\tif (sumOfDigit > prodOfDigit)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}", "9824": "void evenOddBitwiseXOR(int N)\n{\n\tcout << \"Even: \" << 0 << \" \";\n\tfor (int i = 4; i <= N; i = i + 4) {\n\t\tcout << i << \" \";\n\t}\n\tcout << \"\\n\";\n\tcout << \"Odd: \" << 1 << \" \";\n\tfor (int i = 4; i <= N; i = i + 4) {\n\t\tcout << i - 1 << \" \";\n\t}\n\tif (N % 4 == 2)\n\t\tcout << N + 1;\n\telse if (N % 4 == 3)\n\t\tcout << N;\n}", "9829": "void findPermutation(vector<int>& arr)\n{\n\tint N = arr.size();\n\tint i = N - 2;\n\twhile (i >= 0 && arr[i] <= arr[i + 1])\n\t\ti--;\n\tif (i == -1) {\n\t\tcout << \"-1\";\n\t\treturn;\n\t}\n\tint j = N - 1;\n\twhile (j > i && arr[j] >= arr[i])\n\t\tj--;\n\twhile (j > i && arr[j] == arr[j - 1]) {\n\t\tj--;\n\t}\n\tswap(arr[i], arr[j]);\n\tfor (auto& it : arr) {\n\t\tcout << it << ' ';\n\t}\n}", "9849": "void sieveOfEratosthenes(int N, int s[])\n{\n\tvector<bool> prime(N + 1, false);\n\tfor (int i = 2; i <= N; i += 2)\n\t\ts[i] = 2;\n\tfor (int i = 3; i <= N; i += 2) {\n\t\tif (prime[i] == false) {\n\t\t\ts[i] = i;\n\t\t\tfor (int j = i; j * i <= N; j += 2) {\n\t\t\t\tif (!prime[i * j]) {\n\t\t\t\t\tprime[i * j] = true;\n\t\t\t\t\ts[i * j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid findDifference(int N)\n{\n\tint s[N + 1];\n\tsieveOfEratosthenes(N, s);\n\tint total = 1, odd = 1, even = 0;\n\tint curr = s[N];\n\tint cnt = 1;\n\twhile (N > 1) {\n\t\tN /= s[N];\n\t\tif (curr == s[N]) {\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (curr == 2) {\n\t\t\ttotal = total * (cnt + 1);\n\t\t}\n\t\telse {\n\t\t\ttotal = total * (cnt + 1);\n\t\t\todd = odd * (cnt + 1);\n\t\t}\n\t\tcurr = s[N];\n\t\tcnt = 1;\n\t}\n\teven = total - odd;\n\tcout << abs(even - odd);\n}", "9877": "void findMedian(int Mean, int Mode)\n{\n\tdouble Median = (2 * Mean + Mode) / 3.0;\n\tcout << Median;\n}", "9889": "float vectorMagnitude(int x, int y, int z)\n{\n\tint sum = x * x + y * y + z * z;\n\treturn sqrt(sum);\n}", "9905": "int minimumSteps(int x, int y)\n{\n\tint cnt = 0;\n\twhile (x != 0 && y != 0) {\n\t\tif (x > y) {\n\t\t\tcnt += x / y;\n\t\t\tx %= y;\n\t\t}\n\t\telse {\n\t\t\tcnt += y / x;\n\t\t\ty %= x;\n\t\t}\n\t}\n\tcnt--;\n\tif (x > 1 y > 1)\n\t\tcnt = -1;\n\tcout << cnt;\n}", "9915": "bool check(vector<int> Adj[], int Src, int N, bool visited[])\n{\n\tint color[N] = { 0 };\n\tvisited[Src] = true;\n\tqueue<int> q;\n\tq.push(Src);\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tint Col = color[u];\n\t\tfor (int x : Adj[u]) {\n\t\t\tif (visited[x] == true && color[x] == Col) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (visited[x] == false) {\n\t\t\t\tvisited[x] = true;\n\t\t\t\tq.push(x);\n\t\t\t\tcolor[x] = 1 - Col;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nvoid addEdge(vector<int> Adj[], int u, int v)\n{\n\tAdj[u].push_back(v);\n\tAdj[v].push_back(u);\n}\nvoid isPossible(struct Node Arr[], int N)\n{\n\tvector<int> Adj[N];\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (Arr[i].R < Arr[j].L Arr[i].L > Arr[j].R) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (Arr[i].V == Arr[j].V) {\n\t\t\t\t\taddEdge(Adj, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool visited[N] = { false };\n\tfor (int i = 0; i < N; i++) {\n\t\tif (visited[i] == false\n\t\t\t&& Adj[i].size() > 0) {\n\t\t\tif (check(Adj, i, N, visited) == false) {\n\t\t\t\tcout << \"No\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Yes\";\n}", "9935": "void checkCommonDivisor(int arr[], int N, int X)\n{\n\tint G = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tG = __gcd(G, arr[i]);\n\t}\n\tint copy_G = G;\n\tfor (int divisor = 2; divisor <= X; divisor++) {\n\t\twhile (G % divisor == 0) {\n\t\t\tG = G / divisor;\n\t\t}\n\t}\n\tif (G <= X) {\n\t\tcout << \"Yes\\n\";\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcout << arr[i] / copy_G << \" \";\n\t\tcout << endl;\n\t}\n\telse\n\t\tcout << \"No\";\n}", "9948": "long multiplyByMersenne(long N, long M)\n{\n\tlong x = log2(M + 1);\n\treturn ((N << x) - N);\n}", "9958": "int perfectSquare(int num)\n{\n\tint sr = sqrt(num);\n\tint a = sr * sr;\n\tint b = (sr + 1) * (sr + 1);\n\tif ((num - a) < (b - num)) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\nint powerOfTwo(int num)\n{\n\tint lg = log2(num);\n\tint p = pow(2, lg);\n\treturn p;\n}\nvoid uniqueElement(int arr[], int N)\n{\n\tbool ans = true;\n\tunordered_map<int, int> freq;\n\tfor (int i = 0; i < N; i++) {\n\t\tfreq[arr[i]]++;\n\t}\n\tfor (auto el : freq) {\n\t\tif (el.second == 1) {\n\t\t\tans = false;\n\t\t\tint ps = perfectSquare(el.first);\n\t\t\tcout << powerOfTwo(ps) << ' ';\n\t\t}\n\t}\n\tif (ans)\n\t\tcout << \"-1\";\n}", "9963": "void partitionArray(int *a, int n)\n{\n int *Min = new int[n];\n int Mini = INT_MAX;\n for (int i = n - 1; i >= 0; i--) {\n\tMini = min(Mini, a[i]);\n\tMin[i] = Mini;\n }\n int Maxi = INT_MIN;\n int ind = -1;\n for (int i = 0; i < n - 1; i++) {\n\tMaxi = max(Maxi, a[i]);\n\tif (Maxi < Min[i + 1]) {\n\tind = i;\n\tbreak;\n\t}\n }\n if (ind != -1) {\n\tfor (int i = 0; i <= ind; i++)\n\tcout << a[i] << \" \";\n\tcout << endl;\n\tfor (int i = ind + 1; i < n; i++)\n\tcout << a[i] << \" \";\n }\n else\n\tcout << \"Impossible\";\n}", "9971": "int countPrimeFactors(int n)\n{\n\tint count = 0;\n\twhile (n % 2 == 0) {\n\t\tn = n / 2;\n\t\tcount++;\n\t}\n\tfor (int i = 3; i <= sqrt(n); i = i + 2) {\n\t\twhile (n % i == 0) {\n\t\t\tn = n / i;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (n > 2)\n\t\tcount++;\n\treturn (count);\n}\nint findSum(int n)\n{\n\tint sum = 0;\n\tfor (int i = 1, num = 2; i <= n; num++) {\n\t\tif (countPrimeFactors(num) == 2) {\n\t\t\tsum += num;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn sum;\n}\nvoid check(int n, int k)\n{\n\tint s = findSum(k - 1);\n\tif (s >= n)\n\t\tcout << \"No\";\n\telse\n\t\tcout << \"Yes\";\n}", "9979": "long long int gcd(long long int a, long long int b)\n{\n\twhile (b > 0) {\n\t\tlong long int rem = a % b;\n\t\ta = b;\n\t\tb = rem;\n\t}\n\treturn a;\n}\nint countNumberOfWays(long long int n)\n{\n\tif (n == 1)\n\t\treturn -1;\n\tlong long int g = 0;\n\tint power = 0;\n\twhile (n % 2 == 0) {\n\t\tpower++;\n\t\tn /= 2;\n\t}\n\tg = gcd(g, power);\n\tfor (int i = 3; i <= sqrt(n); i += 2) {\n\t\tpower = 0;\n\t\twhile (n % i == 0) {\n\t\t\tpower++;\n\t\t\tn /= i;\n\t\t}\n\t\tg = gcd(g, power);\n\t}\n\tif (n > 2)\n\t\tg = gcd(g, 1);\n\tint ways = 1;\n\tpower = 0;\n\twhile (g % 2 == 0) {\n\t\tg /= 2;\n\t\tpower++;\n\t}\n\tways *= (power + 1);\n\tfor (int i = 3; i <= sqrt(g); i += 2) {\n\t\tpower = 0;\n\t\twhile (g % i == 0) {\n\t\t\tpower++;\n\t\t\tg /= i;\n\t\t}\n\t\tways *= (power + 1);\n\t}\n\tif (g > 2)\n\t\tways *= 2;\n\treturn ways;\n}", "9989": "void printSpiral(int size)\n{\n\tint row = 0, col = 0;\n\tint boundary = size - 1;\n\tint sizeLeft = size - 1;\n\tint flag = 1;\n\tchar move = 'r';\n\tint matrix[size][size] = {0};\n\tfor (int i = 1; i < size * size + 1; i++)\n\t{\n\t\tmatrix[row][col] = i;\n\t\tswitch (move)\n\t\t{\n\t\t\tcase 'r':\n\t\t\t\tcol += 1;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcol -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\trow -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\trow += 1;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == boundary)\n\t\t{\n\t\t\tboundary += sizeLeft;\n\t\t\tif (flag != 2)\n\t\t\t{\n\t\t\t\tflag = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tsizeLeft -= 1;\n\t\t\t}\n\t\t\tswitch (move)\n\t\t\t{\n\t\t\t\tcase 'r':\n\t\t\t\t\tmove = 'd';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tmove = 'l';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\tmove = 'u';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tmove = 'r';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (row = 0; row < size; row++)\n\t{\n\t\tfor (col = 0; col < size; col++)\n\t\t{\n\t\t\tint n = matrix[row][col];\n\t\t\tif(n < 10)\n\t\t\t\tcout << n << \" \";\n\t\t\telse\n\t\t\t\tcout << n << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}", "10030": "bool isPossible(int target[], int n)\n{\n int max = 0;\n int index = 0;\n for (int i = 0; i < n; i++) {\n\tif (max < target[i]) {\n\tmax = target[i];\n\tindex = i;\n\t}\n }\n if (max == 1)\n\treturn true;\n for (int i = 0; i < n; i++) {\n\tif (i != index) {\n\tmax -= target[i];\n\tif (max <= 0)\n\t\treturn false;\n\t}\n }\n target[index] = max;\n return isPossible(target,n);\n}", "10041": "int convertToASCII(int N)\n{\n\tstring num = to_string(N);\n\tfor (char ch : num) {\n\t\tcout << ch << \" (\"\n\t\t\t<< (int)ch << \")\\n\";\n\t}\n}", "10049": "void productExceptSelf(int arr[], int N)\n{\n\tint product = 1;\n\tint z = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i])\n\t\t\tproduct *= arr[i];\n\t\tz += (arr[i] == 0);\n\t}\n\tint a = abs(product), b;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (z == 1) {\n\t\t\tif (arr[i])\n\t\t\t\tarr[i] = 0;\n\t\t\telse\n\t\t\t\tarr[i] = product;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (z > 1) {\n\t\t\tarr[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint b = abs(arr[i]);\n\t\tint curr = round(exp(log(a) - log(b)));\n\t\tif (arr[i] < 0 && product < 0)\n\t\t\tarr[i] = curr;\n\t\telse if (arr[i] > 0 && product > 0)\n\t\t\tarr[i] = curr;\n\t\telse\n\t\t\tarr[i] = -1 * curr;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}", "10054": "int singleDigitSubarrayCount(int arr[], int N)\n{\n\tint res = 0;\n\tint count = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] <= 9) {\n\t\t\tcount++;\n\t\t\tres += count;\n\t\t}\n\t\telse {\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tcout << res;\n}", "10057": "bool isPossible(int N)\n{\n\treturn ((N & (N - 1)) && N);\n}\nvoid countElements(int N)\n{\n\tint count = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (isPossible(i))\n\t\t\tcount++;\n\t}\n\tcout << count;\n}", "10058": "void countElements(int N)\n{\n\tint Cur_Ele = 1;\n\tint Count = 0;\n\twhile (Cur_Ele <= N) {\n\t\tCount++;\n\t\tCur_Ele = Cur_Ele * 2;\n\t}\n\tcout << N - Count;\n}", "10062": "int minSum(int A[], int N)\n{\n\tmap<int, int> mp;\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tsum += A[i];\n\t\tmp[A[i]]++;\n\t}\n\tint minSum = INT_MAX;\n\tfor (auto it : mp) {\n\t\tminSum = min(\n\t\t\tminSum, sum - (it.first * it.second));\n\t}\n\treturn minSum;\n}", "10063": "void maxAdjacent(int* arr, int N)\n{\n\tvector<int> res;\n\tfor (int i = 1; i < N - 1; i++) {\n\t\tint prev = arr[0];\n\t\tint maxi = INT_MIN;\n\t\tfor (int j = 1; j < N; j++) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tmaxi = max(maxi, abs(arr[j] - prev));\n\t\t\tprev = arr[j];\n\t\t}\n\t\tres.push_back(maxi);\n\t}\n\tfor (auto x : res)\n\t\tcout << x << \" \";\n\tcout << endl;\n}", "10064": "void maxAdjacent(int* arr, int N)\n{\n\tvector<int> res;\n\tint arr_max = INT_MIN;\n\tfor (int i = 1; i < N; i++) {\n\t\tarr_max = max(arr_max,\n\t\t\t\t\tabs(arr[i - 1] - arr[i]));\n\t}\n\tfor (int i = 1; i < N - 1; i++) {\n\t\tint curr_max = abs(arr[i - 1] - arr[i + 1]);\n\t\tint ans = max(curr_max, arr_max);\n\t\tres.push_back(ans);\n\t}\n\tfor (auto x : res)\n\t\tcout << x << \" \";\n\tcout << endl;\n}", "10071": "int minimumIncrement(int arr[], int N)\n{\n\tif (N % 2 != 0) {\n\t\tcout << \"-1\";\n\t\texit(0);\n\t}\n\tint cntEven = 0;\n\tint cntOdd = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] % 2 == 0) {\n\t\t\tcntEven += 1;\n\t\t}\n\t}\n\tcntOdd = N - cntEven;\n\treturn abs(cntEven - cntOdd) / 2;\n}", "10076": "int findSize(int N)\n{\n\tif (N == 0)\n\t\treturn 1;\n\tif (N == 1)\n\t\treturn 1;\n\tint Size = 2 * findSize(N / 2) + 1;\n\treturn Size;\n}\nint CountOnes(int N, int L, int R)\n{\n\tif (L > R) {\n\t\treturn 0;\n\t}\n\tif (N <= 1) {\n\t\treturn N;\n\t}\n\tint ret = 0;\n\tint M = N / 2;\n\tint Siz_M = findSize(M);\n\tif (L <= Siz_M) {\n\t\tret += CountOnes(\n\t\t\tN / 2, L, min(Siz_M, R));\n\t}\n\tif (L <= Siz_M + 1 && Siz_M + 1 <= R) {\n\t\tret += N % 2;\n\t}\n\tif (Siz_M + 1 < R) {\n\t\tret += CountOnes(N / 2,\n\t\t\t\t\t\tmax(1, L - Siz_M - 1), R - Siz_M - 1);\n\t}\n\treturn ret;\n}", "10114": "void cntWaysConsArray(int A[], int N)\n{\n\tint total = 1;\n\tint oddArray = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\ttotal = total * 3;\n\t\tif (A[i] % 2 == 0) {\n\t\t\toddArray *= 2;\n\t\t}\n\t}\n\tcout << total - oddArray << \"\\n\";\n}", "10120": "int countNumberHavingKthBitSet(int N, int K)\n{\n\tint numbers_rightmost_setbit_K;\n\tfor (int i = 1; i <= K; i++) {\n\t\tint numbers_rightmost_bit_i = (N + 1) / 2;\n\t\tN -= numbers_rightmost_bit_i;\n\t\tif (i == K) {\n\t\t\tnumbers_rightmost_setbit_K\n\t\t\t\t= numbers_rightmost_bit_i;\n\t\t}\n\t}\n\tcout << numbers_rightmost_setbit_K;\n}", "10123": "int countSetBits(int N)\n{\n\tint count = 0;\n\twhile (N) {\n\t\tN = N & (N - 1);\n\t\tcount++;\n\t}\n\treturn count;\n}", "10124": "void minMoves(int arr[], int N)\n{\n\tint odd_element_cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] % 2 != 0) {\n\t\t\todd_element_cnt++;\n\t\t}\n\t}\n\tint moves = (odd_element_cnt) / 2;\n\tif (odd_element_cnt % 2 != 0)\n\t\tmoves += 2;\n\tcout << moves;\n}", "10145": "void minimumSubsetDifference(int N)\n{\n\tint blockOfSize8 = N / 8;\n\tstring str = \"ABBABAAB\";\n\tint subsetDifference = 0;\n\tstring partition = \"\";\n\twhile (blockOfSize8--) {\n\t\tpartition += str;\n\t}\n\tvector<int> A, B;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (partition[i] == 'A') {\n\t\t\tA.push_back((i + 1) * (i + 1));\n\t\t}\n\t\telse {\n\t\t\tB.push_back((i + 1) * (i + 1));\n\t\t}\n\t}\n\tcout << subsetDifference << \"\\n\";\n\tfor (int i = 0; i < A.size(); i++)\n\t\tcout << A[i] << \" \";\n\tcout << \"\\n\";\n\tfor (int i = 0; i < B.size(); i++)\n\t\tcout << B[i] << \" \";\n}", "10155": "void findTheGreatestX(int P, int Q)\n{\n\tmap<int, int> divisiors;\n\tfor (int i = 2; i * i <= Q; i++) {\n\t\twhile (Q % i == 0 and Q > 1) {\n\t\t\tQ /= i;\n\t\t\tdivisiors[i]++;\n\t\t}\n\t}\n\tif (Q > 1)\n\t\tdivisiors[Q]++;\n\tint ans = 0;\n\tfor (auto i : divisiors) {\n\t\tint frequency = i.second;\n\t\tint temp = P;\n\t\tint cur = 0;\n\t\twhile (temp % i.first == 0) {\n\t\t\ttemp /= i.first;\n\t\t\tcur++;\n\t\t}\n\t\tif (cur < frequency) {\n\t\t\tans = P;\n\t\t\tbreak;\n\t\t}\n\t\ttemp = P;\n\t\tfor (int j = cur; j >= frequency; j--) {\n\t\t\ttemp /= i.first;\n\t\t}\n\t\tans = max(temp, ans);\n\t}\n\tcout << ans;\n}", "10174": "string checkRearrangements( vector<vector<int> > mat, int N, int M)\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 1; j < M; j++) {\n\t\t\tif (mat[i][0] != mat[i][j]) {\n\t\t\t\treturn \"Yes\";\n\t\t\t}\n\t\t}\n\t}\n\treturn \"No\";\n}\nstring nonZeroXor(vector<vector<int> > mat, int N, int M)\n{\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tres = res ^ mat[i][0];\n\t}\n\tif (res != 0)\n\t\treturn \"Yes\";\n\telse\n\t\treturn checkRearrangements(mat, N, M);\n}", "10186": "void findPrimeNos(int L, int R, unordered_map<int, int>& M)\n{\n\tfor (int i = L; i <= R; i++) {\n\t\tM[i]++;\n\t}\n\tif (M.find(1) != M.end()) {\n\t\tM.erase(1);\n\t}\n\tfor (int i = 2; i <= sqrt(R); i++) {\n\t\tint multiple = 2;\n\t\twhile ((i * multiple) <= R) {\n\t\t\tif (M.find(i * multiple)\n\t\t\t\t!= M.end()) {\n\t\t\t\tM.erase(i * multiple);\n\t\t\t}\n\t\t\tmultiple++;\n\t\t}\n\t}\n}\nvoid getPrimePairs(int L, int R, int K)\n{\n\tunordered_map<int, int> M;\n\tfindPrimeNos(L, R, M);\n\tfor (auto& it : M) {\n\t\tif (M.find(it.first + K)\n\t\t\t!= M.end()) {\n\t\t\tcout << \"(\" << it.first << \", \" << it.first + K << \") \";\n\t\t}\n\t}\n}", "10212": "int functionMax(int arr[], int n)\n{\n\tvector<int> setBit[32];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < size_int; j++) {\n\t\t\tif (arr[i] & (1 << j))\n\t\t\t\tsetBit[j].push_back(i);\n\t\t}\n\t}\n\tfor (int i = size_int; i >= 0; i--) {\n\t\tif (setBit[i].size() == 1) {\n\t\t\tswap(arr[0], arr[setBit[i][0]]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint maxAnd = arr[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tmaxAnd = maxAnd & (~arr[i]);\n\t}\n\treturn maxAnd;\n}", "10228": "bool prime(int n)\n{\n\tif (n == 1)\n\t\treturn false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvoid minDivisior(int n)\n{\n\tif (prime(n)) {\n\t\tcout << 1 << \" \" << n - 1;\n\t}\n\telse {\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tcout << n / i << \" \"\n\t\t\t\t\t<< n / i * (i - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "10233": "int gcd(int a, int b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b % a, a);\n}\nint lcm(int a, int b)\n{\n\treturn (a * b) / gcd(a, b);\n}\nvoid findLCM(vector<int>& arr)\n{\n\tint nth_lcm = arr[0];\n\tfor (int i = 1; i < arr.size(); i++)\n\t\tnth_lcm = lcm(nth_lcm, arr[i]);\n\tLandau = max(Landau, nth_lcm);\n}\nvoid findWays(vector<int>& arr, int i, int n)\n{\n\tif (n == 0)\n\t\tfindLCM(arr);\n\tfor (int j = i; j <= n; j++) {\n\t\tarr.push_back(j);\n\t\tfindWays(arr, j, n - j);\n\t\tarr.pop_back();\n\t}\n}\nvoid Landau_function(int n)\n{\n\tvector<int> arr;\n\tfindWays(arr, 1, n);\n\tcout << Landau;\n}", "10237": "int nCr(int n, int r)\n{\n\tint res = 1;\n\tif (r > n - r)\n\t\tr = n - r;\n\tfor (int i = 0; i < r; ++i) {\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}\nint solve(int n, int m, int k)\n{\n\tint sum = 0;\n\tfor (int i = 0; i <= k; i++)\n\t\tsum += nCr(n, i)\n\t\t\t* nCr(m, k - i);\n\treturn sum;\n}", "10238": "int nCr(int n, int r)\n{\n\tint res = 1;\n\tif (r > n - r)\n\t\tr = n - r;\n\tfor (int i = 0; i < r; ++i) {\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}", "10267": "int powerOptimised(int a, int n)\n{\n\tint ans = 1;\n\twhile (n > 0) {\n\t\tint last_bit = (n & 1);\n\t\tif (last_bit) {\n\t\t\tans = ans * a;\n\t\t}\n\t\ta = a * a;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}", "10269": "int findMaximumGcd(int n)\n{\n\tint max_gcd = 1;\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (i > max_gcd)\n\t\t\t\tmax_gcd = i;\n\t\t\tif ((n / i != i)\n\t\t\t\t&& (n / i != n)\n\t\t\t\t&& ((n / i) > max_gcd))\n\t\t\t\tmax_gcd = n / i;\n\t\t}\n\t}\n\treturn max_gcd;\n}", "10309": "void sieve()\n{\n\tv[1] = 1;\n\tfor (long long int i = 2; i < x; i++)\n\t\tv[i] = i;\n\tfor (long long int i = 4; i < x; i += 2)\n\t\tv[i] = 2;\n\tfor (long long int i = 3; i * i < x; i++) {\n\t\tif (v[i] == i) {\n\t\t\tfor (long long int j = i * i; j < x; j += i) {\n\t\t\t\tif (v[j] == j) {\n\t\t\t\t\tv[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nlong long int prime_factors(long long n)\n{\n\tset<long long int> s;\n\twhile (n != 1) {\n\t\ts.insert(v[n]);\n\t\tn = n / v[n];\n\t}\n\treturn s.size();\n}\nvoid distinctPrimes(long long int m, long long int k)\n{\n\tvector<long long int> result;\n\tfor (long long int i = 14; i < m + k; i++) {\n\t\tlong long count\n\t\t\t= prime_factors(i);\n\t\tif (count == k) {\n\t\t\tresult.push_back(i);\n\t\t}\n\t}\n\tlong long int p = result.size();\n\tfor (long long int index = 0; index < p - 1; index++) {\n\t\tlong long element = result[index];\n\t\tlong long count = 1, z = index;\n\t\twhile (z < p - 1 && count <= k && result[z] + 1 == result[z + 1]) {\n\t\t\tcount++;\n\t\t\tz++;\n\t\t}\n\t\tif (count >= k)\n\t\t\tcout << element << ' ';\n\t}\n}", "10325": "void print_product(int a, int b, int c, int d)\n{\n\tint prod1 = a * c;\n\tint prod2 = b * d;\n\tint prod3 = (a + b) * (c + d);\n\tint real = prod1 - prod2;\n\tint imag = prod3 - (prod1 + prod2);\n\tcout << real << \" + \" << imag << \"i\";\n}", "10330": "int reverse(int num)\n{\n\tint rev_num = 0;\n\twhile(num > 0)\n\t{\n\t\trev_num = rev_num*10 + num%10;\n\t\tnum = num/10;\n\t}\n\treturn rev_num;\n}\nint properDivSum(int num)\n{\n\tint result = 0;\n\tfor (int i=2; i<=sqrt(num); i++)\n\t{\n\t\tif (num%i==0)\n\t\t{\n\t\t\tif (i==(num/i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + num/i);\n\t\t}\n\t}\n\treturn (result + 1);\n}\nbool isTcefrep(int n)\n{\n\treturn properDivSum(n) == reverse(n);\n}", "10335": "bool isInsolite(int n)\n{\n\tint N = n;\n\tint sum = 0;\n\tint product = 1;\n\twhile (n != 0) {\n\t\tint r = n % 10;\n\t\tsum = sum + r * r;\n\t\tproduct = product * r * r;\n\t\tn = n / 10;\n\t}\n\treturn (N % sum == 0)\n\t\t&& (N % product == 0);\n}", "10337": "int sigma(int n)\n{\n\tif (n == 1)\n\t\treturn 1;\n\tint result = 0;\n\tfor (int i = 2; i <= sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (i == (n / i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + n / i);\n\t\t}\n\t}\n\treturn (result + n + 1);\n}\nbool isSuperabundant(int N)\n{\n\tfor (float i = 1; i < N; i++) {\n\t\tfloat x = sigma(i) / i;\n\t\tfloat y = sigma(N) / (N * 1.0);\n\t\tif (x > y)\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "10345": "int isDNum(int n)\n{\n\tif (n < 4)\n\t\treturn false;\n\tint numerator, hcf;\n\tfor (int k = 2; k <= n; k++)\n\t{\n\t\tnumerator = pow(k, n - 2) - k;\n\t\thcf = __gcd(n, k);\n\t}\n\tif (hcf == 1 && (numerator % n) != 0)\n\t\treturn false;\n\treturn true;\n}", "10367": "bool isPrime(int n)\n{\n\tif (n == 1)\n\t\treturn true;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0\n\t\t\t|| n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nvoid checkExpression(int n)\n{\n\tif (isPrime(n))\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}", "10377": "int Sum(int N)\n{\n\tint SumOfPrimeDivisors[N + 1] = { 0 };\n\tfor (int i = 2; i <= N; ++i) {\n\t\tif (!SumOfPrimeDivisors[i]) {\n\t\t\tfor (int j = i; j <= N; j += i) {\n\t\t\t\tSumOfPrimeDivisors[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\treturn SumOfPrimeDivisors[N];\n}\nbool RuthAaronNumber(int n)\n{\n\tif (Sum(n) == Sum(n + 1))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "10394": "void Is_possible(long long int N)\n{\n\tint C = 0;\n\tint D = 0;\n\twhile (N % 10 == 0)\n\t{\n\t\tN = N / 10;\n\t\tC += 1;\n\t}\n\tif(pow(2, (int)log2(N)) == N)\n\t{\n\t\tD = (int)log2(N);\n\t\tif (C >= D)\n\t\t\tcout << \"YES\";\n\t\telse\n\t\t\tcout << \"NO\";\n\t}\n\telse\n\t\tcout << \"NO\";\n}", "10406": "int maxAdjacentDifference(int N, int K)\n{\n\tif (N == 1) {\n\t\treturn 0;\n\t}\n\tif (N == 2) {\n\t\treturn K;\n\t}\n\treturn 2 * K;\n}", "10408": "int linearSum(int n)\n{\n\treturn (n * (n + 1) / 2) % mod;\n}\nint rangeSum(int b, int a)\n{\n\treturn (linearSum(b) -\n\t\t\tlinearSum(a)) % mod;\n}\nint totalSum(int n)\n{\n\tint result = 0;\n\tint i = 1;\n\twhile(true)\n\t{\n\t\tresult += rangeSum(n / i, n / (i + 1)) *\n\t\t\t\t\t\t(i % mod) % mod;\n\t\tresult %= mod;\n\t\tif (i == n)\n\t\t\tbreak;\n\t\ti = n / (n / (i + 1));\n\t}\n\treturn result;\n}", "10423": "bool isDouble(int num)\n{\n\tstring s = to_string(num);\n\tint l = s.length();\n\tif(s[0] == s[1])\n\treturn false;\n\tif(l % 2 == 1)\n\t{\n\t\ts = s + s[1];\n\t\tl++;\n\t}\n\tstring s1 = s.substr(0, l/2);\n\tstring s2 = s.substr(l/2);\n\treturn s1 == s2;\n}\nbool isNontrivialUndulant(int N)\n{ \n\treturn N > 100 && isDouble(N);\n}", "10434": "void findNthTerm(int n)\n{\n\tcout << n * n - n + 1 << endl;\n}", "10438": "int rev(int num)\n{\n\tint rev_num = 0;\n\twhile (num > 0) {\n\t\trev_num = rev_num * 10\n\t\t\t\t+ num % 10;\n\t\tnum = num / 10;\n\t}\n\treturn rev_num;\n}\nint divSum(int num)\n{\n\tint result = 0;\n\tfor (int i = 2; i <= sqrt(num); i++) {\n\t\tif (num % i == 0) {\n\t\t\tif (i == (num / i))\n\t\t\t\tresult += rev(i);\n\t\t\telse\n\t\t\t\tresult += (rev(i)\n\t\t\t\t\t\t+ rev(num / i));\n\t\t}\n\t}\n\treturn (result + 1);\n}\nbool isAntiPerfect(int n)\n{\n\treturn divSum(n) == n;\n}", "10445": "void printSeries(int n, int a, int b, int c)\n{\n\tint d;\n\tif (n == 1) {\n\t\tcout << a << \" \";\n\t\treturn;\n\t}\n\tif (n == 2) {\n\t\tcout << a << \" \" << b << \" \";\n\t\treturn;\n\t}\n\tcout << a << \" \" << b\n\t\t<< \" \" << c << \" \";\n\tfor (int i = 4; i <= n; i++) {\n\t\td = a + b + c;\n\t\tcout << d << \" \";\n\t\ta = b;\n\t\tb = c;\n\t\tc = d;\n\t}\n}", "10452": "bool checkArray(int n, int k, int arr[])\n{\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] & 1)\n\t\t\tcnt += 1;\n\t}\n\tif (cnt >= k && cnt % 2 == k % 2)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "10462": "int func(int arr[], int n)\n{\n\tdouble ans = 0;\n\tint maxx = 0;\n\tdouble freq[100005] = { 0 };\n\tint temp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttemp = arr[i];\n\t\tfreq[temp]++;\n\t\tmaxx = max(maxx, temp);\n\t}\n\tfor (int i = 1; i <= maxx; i++) {\n\t\tfreq[i] += freq[i - 1];\n\t}\n\tfor (int i = 1; i <= maxx; i++) {\n\t\tif (freq[i]) {\n\t\t\ti = (double)i;\n\t\t\tdouble j;\n\t\t\tll value = 0;\n\t\t\tdouble cur = ceil(0.5 * i) - 1.0;\n\t\t\tfor (j = 1.5;; j++) {\n\t\t\t\tint val = min(maxx, (int)(ceil(i * j) - 1.0));\n\t\t\t\tint times = (freq[i] - freq[i - 1]), con = j - 0.5;\n\t\t\t\tans += times * con * (freq[(int)val] - freq[(int)cur]);\n\t\t\t\tcur = val;\n\t\t\t\tif (val == maxx)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn (ll)ans;\n}", "10474": "int EnneacontahexagonNum(int n)\n{\n\treturn (94 * n * n - 92 * n) / 2;\n}", "10475": "int MegagonNum(int n)\n{\n\treturn (999998 * n * n - 999996 * n) / 2;\n}", "10492": "void insert_element(int a[], int n)\n{\n\tint Xor = 0;\n\tint Sum = 0;\n\tfor(int i = 0; i < n; i++)\n\t{ \n\t\tXor ^= a[i];\n\t\tSum += a[i];\n\t}\n\tif(Sum == 2 * Xor)\n\t{\n\t\tcout << \"0\" << endl;\n\t\treturn;\n\t}\n\tif(Xor == 0)\n\t{\n\t\tcout << \"1\" << endl;\n\t\tcout << Sum << endl;\n\t\treturn;\n\t}\n\tint num1 = Sum + Xor;\n\tint num2 = Xor;\n\tcout << \"2\";\n\tcout << num1 << \" \"\n\t\t<< num2 << endl; \n}", "10502": "void checkSolution(int a, int b, int c)\n{\n\tif (a == c)\n\t\tcout << \"Yes\";\n\telse\n\t\tcout << \"No\";\n}", "10539": "int productPairs(int arr[], int n)\n{\n\tint product = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tproduct *= (arr[i] % mod * arr[j] % mod)\n\t\t\t\t\t% mod;\n\t\t\tproduct = product % mod;\n\t\t}\n\t}\n\treturn product % mod;\n}", "10540": "int power(int x, unsigned int y)\n{\n\tint p = 1000000007;\n\tint res = 1;\n\tx = x % p;\n\twhile (y > 0) {\n\t\tif (y & 1)\n\t\t\tres = (res * x) % p;\n\t\ty = y >> 1;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nll productPairs(ll arr[], ll n)\n{\n\tll product = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tproduct\n\t\t\t= (product\n\t\t\t% mod\n\t\t\t* (int)power(\n\t\t\t\t\tarr[i], (2 * n)) % mod)\n\t\t\t% mod;\n\t}\n\treturn product % mod;\n}", "10546": "void constructArray(int N)\n{\n\tint arr[N];\n\tfor (int i = 1; i <= N; i++) {\n\t\tarr[i - 1] = i;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << arr[i] << \", \";\n\t}\n}", "10568": "bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (int i = 2; i < n; i++)\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nint countSubsequences(int arr[], int n)\n{\n\tint totalSubsequence = pow(2, n) - 1;\n\tint countPrime = 0, countOnes = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] == 1)\n\t\t\tcountOnes++;\n\t\telse if (isPrime(arr[i]))\n\t\t\tcountPrime++;\n\t}\n\tint compositeSubsequence;\n\tint onesSequence = pow(2, countOnes) - 1;\n\tcompositeSubsequence\n\t\t= totalSubsequence - countPrime\n\t\t- onesSequence\n\t\t- onesSequence * countPrime;\n\treturn compositeSubsequence;\n}", "10569": "int nCr(int n, int r)\n{\n\treturn fact(n)\n\t\t/ (fact(r)\n\t\t\t* fact(n - r));\n}\nint fact(int n)\n{\n\tint res = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tres = res * i;\n\treturn res;\n}\nint sumSubsequences( int arr[], int n, int k)\n{\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tsum += arr[i];\n\t}\n\tint kLengthSubSequence;\n\tkLengthSubSequence = nCr(n, k);\n\tint ans\n\t\t= sum\n\t\t* ((k * kLengthSubSequence) / n);\n\treturn ans;\n}", "10573": "vector<int> getFactorization(int x)\n{\n\tint count = 0;\n\tvector<int> v;\n\twhile (x % 2 == 0) {\n\t\tcount++;\n\t\tx = x / 2;\n\t}\n\tif (count != 0)\n\t\tv.push_back(count);\n\tfor (int i = 3; i <= sqrt(x); i += 2) {\n\t\tcount = 0;\n\t\twhile (x % i == 0) {\n\t\t\tcount++;\n\t\t\tx /= i;\n\t\t}\n\t\tif (count != 0)\n\t\t\tv.push_back(count);\n\t}\n\tif (x > 1) {\n\t\tv.push_back(1);\n\t}\n\treturn v;\n}\nint nonPrimeDivisors(int N)\n{\n\tvector<int> v = getFactorization(N);\n\tint ret = 1;\n\tfor (int i = 0; i < v.size(); i++)\n\t\tret = ret * (v[i] + 1);\n\tret = ret - v.size();\n\treturn ret;\n}", "10653": "void checksum(int n, int k)\n{\n\tfloat first_term = ((2 * n) / k\n\t\t\t\t\t\t+ (1 - k))\n\t\t\t\t\t/ 2.0;\n\tif (first_term - int(first_term) == 0) {\n\t\tfor (int i = first_term; i <= first_term + k - 1; i++) {\n\t\t\tcout << i << \" \";\n\t\t}\n\t}\n\telse\n\t\tcout << \"-1\";\n}", "10668": "void sumEvenNumbers(int N, int K)\n{\n\tint check = N - 2 * (K - 1);\n\tif (check > 0 && check % 2 == 0) {\n\t\tfor (int i = 0; i < K - 1; i++) {\n\t\t\tcout << \"2 \";\n\t\t}\n\t\tcout << check;\n\t}\n\telse {\n\t\tcout << \"-1\";\n\t}\n}", "10677": "bool isPerfectSquare(long double x)\n{\n\tlong double sr = sqrt(x);\n\treturn((sr - floor(sr)) == 0);\n}\nvoid checkSunnyNumber(int N)\n{\n\tif (isPerfectSquare(N + 1)) {\n\t\tcout << \"Yes\\n\";\n\t}\n\telse {\n\t\tcout << \"No\\n\";\n\t}\n}", "10694": "vector<int> calculateWays(int N)\n{\n\tint x = 0;\n\tvector<int> v;\n\tfor (int i = 0; i < N; i++)\n\t\tv.push_back(0);\n\tfor (int i = 0; i <= N / 2; i++) {\n\t\tif (N % 2 == 0 && i == N / 2)\n\t\t\tbreak;\n\t\tx = N * (i + 1) - (i + 1) * i;\n\t\tv[i] = x;\n\t\tv[N - i - 1] = x;\n\t}\n\treturn v;\n}\nvoid printArray(vector<int> v)\n{\n\tfor (int i = 0; i < v.size(); i++)\n\t\tcout << v[i] << \" \";\n}", "10703": "int sumOfDigits(int n)\n{\n\tint sum = 0;\n\twhile (n > 0) {\n\t\tsum += n % 10;\n\t\tn /= 10;\n\t}\n\treturn sum;\n}\nint smallestNum(int X, int Y)\n{\n\tint res = -1;\n\tfor (int i = X; i < MAXN; i++) {\n\t\tint sum_of_digit = sumOfDigits(i);\n\t\tif (sum_of_digit % Y == 0) {\n\t\t\tres = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}", "10706": "int countValues(int n)\n{\n\tint answer = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint k = n;\n\t\twhile (k >= i) {\n\t\t\tif (k % i == 0)\n\t\t\t\tk /= i;\n\t\t\telse\n\t\t\t\tk -= i;\n\t\t}\n\t\tif (k == 1)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "10707": "int countValues(int N)\n{\n\tvector<int> div;\n\tfor (int i = 2; i * i <= N; i++) {\n\t\tif (N % i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\tif (N != i * i) {\n\t\t\t\tdiv.push_back(N / i);\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tfor (int i = 1; i * i <= N - 1; i++) {\n\t\tif ((N - 1) % i == 0) {\n\t\t\tif (i * i == N - 1)\n\t\t\t\tanswer++;\n\t\t\telse\n\t\t\t\tanswer += 2;\n\t\t}\n\t}\n\tfor (auto d : div) {\n\t\tint K = N;\n\t\twhile (K % d == 0)\n\t\t\tK /= d;\n\t\tif ((K - 1) % d == 0)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "10719": "void findMaxPrimeDivisor(int n){\n\tint max_possible_prime = 0;\n\twhile (n % 2 == 0) {\n\t\tmax_possible_prime++;\n\t\tn = n / 2;\n\t}\n\tfor (int i = 3; i * i <= n; i = i + 2) {\n\t\twhile (n % i == 0) {\n\t\t\tmax_possible_prime++;\n\t\t\tn = n / i;\n\t\t}\n\t}\n\tif (n > 2) {\n\t\tmax_possible_prime++;\n\t}\n\tcout << max_possible_prime << \"\\n\";\n}", "10721": "void printKNumbers(int N, int K)\n{\n\tfor (int i = 0; i < K - 1; i++)\n\t\tcout << 1 << \" \";\n\tcout << (N - K + 1);\n}", "10751": "int CountWays(int n)\n{\n\tint ans = (n - 1) / 2;\n\treturn ans;\n}", "10753": "void Solve(int arr[], int size, int n)\n{\n\tvector<int> v(n + 1);\n\tfor (int i = 0; i < size; i++)\n\t\tv[arr[i]]++;\n\tint max1 = (max_element(v.begin(), v.end())\n\t\t\t\t\t\t\t\t\t- v.begin());\n\tint diff1 = n + 1 - count(v.begin(), v.end(), 0);\n\tint max_size = max(min(v[max1] - 1, diff1),\n\t\t\t\t\t\t\tmin(v[max1], diff1 - 1));\n\tcout << \"Maximum size is :\" << max_size << \"\\n\";\n\tcout << \"The First Array Is : \\n\";\n\tfor (int i = 0; i < max_size; i++) {\n\t\tcout << max1 << \" \";\n\t\tv[max1] -= 1;\n\t}\n\tcout << \"\\n\";\n\tcout << \"The Second Array Is : \\n\";\n\tfor (int i = 0; i < (n + 1); i++) {\n\t\tif (v[i] > 0) {\n\t\t\tcout << i << \" \";\n\t\t\tmax_size--;\n\t\t}\n\t\tif (max_size < 1)\n\t\t\tbreak;\n\t}\n\tcout << \"\\n\";\n}", "10768": "int power(int x, int y, int p)\n{\n\tint res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif (y & 1)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nint modInverse(int n, int p)\n{\n\treturn power(n, p - 2, p);\n}\nint nCrModPFermat(int n, int r, int p)\n{\n\tif (r == 0)\n\t\treturn 1;\n\tif (n < r)\n\t\treturn 0;\n\tint fac[n + 1];\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = fac[i - 1] * i % p;\n\treturn (fac[n] * modInverse(fac[r], p) % p\n\t\t\t* modInverse(fac[n - r], p) % p) % p;\n}\nint SumOfXor(int a[], int n)\n{\n\tint mod = 10037;\n\tint answer = 0;\n\tfor (int k = 0; k < 32; k++)\n\t{\n\t\tint x = 0, y = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] & (1 << k))\n\t\t\t\tx++;\n\t\t\telse\n\t\t\t\ty++;\n\t\t}\n\t\tanswer += ((1 << k) % mod *\n\t\t\t\t(nCrModPFermat(x, 3, mod)\n\t\t\t\t\t+ x * nCrModPFermat(y, 2, mod)) % mod) % mod;\n\t}\n\treturn answer;\n}", "10801": "int NthSmallest(int K)\n{\n\tqueue<int> Q;\n\tint x;\n\tfor (int i = 1; i < 10; i++)\n\t\tQ.push(i);\n\tfor (int i = 1; i <= K; i++) {\n\t\tx = Q.front();\n\t\tQ.pop();\n\t\tif (x % 10 != 0) {\n\t\t\tQ.push(x * 10 + x % 10 - 1);\n\t\t}\n\t\tQ.push(x * 10 + x % 10);\n\t\tif (x % 10 != 9) {\n\t\t\tQ.push(x * 10 + x % 10 + 1);\n\t\t}\n\t}\n\treturn x;\n}", "10812": "float round(float var,int digit)\n{\n float value = (int)(var *\n\t\t\t\tpow(10, digit) + .5);\n return (float)value /\n\t\tpow(10, digit);\n}\nint probability(int N)\n{\n int a = 2;\n int b = 3;\n if (N == 1)\n {\n\treturn a;\n }\n else if(N == 2)\n {\n\treturn b;\n }\n else\n {\n\tfor(int i = 3; i <= N; i++)\n\t{\n\tint c = a + b;\n\ta = b;\n\tb = c;\n\t}\n\treturn b;\n }\n}\nfloat operations(int N)\n {\n int x = probability(N);\n int y = pow(2, N);\n return round((float)x /\n\t\t\t(float)y, 2);\n}", "10874": "bool isPerfectCube(int x)\n{\n\tlong double cr = round(cbrt(x));\n\treturn (cr * cr * cr == x);\n}\nvoid checkCube(int a, int b)\n{\n\tstring s1 = to_string(a);\n\tstring s2 = to_string(b);\n\tint c = stoi(s1 + s2);\n\tif (isPerfectCube(c)) {\n\t\tcout << \"Yes\";\n\t}\n\telse {\n\t\tcout << \"No\";\n\t}\n}", "10885": "int largest_sum(int arr[], int n)\n{\n\tint maximum = -1;\n\tmap<int, int> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tm[arr[i]]++;\n\t}\n\tfor (auto j : m) {\n\t\tif (j.second > 1) {\n\t\t\tm[2 * j.first]\n\t\t\t\t= m[2 * j.first]\n\t\t\t\t+ j.second / 2;\n\t\t\tif (2 * j.first > maximum)\n\t\t\t\tmaximum = 2 * j.first;\n\t\t}\n\t}\n\treturn maximum;\n}", "10897": "void canBeReduced(int x, int y)\n{\n\tint maxi = max(x, y);\n\tint mini = min(x, y);\n\tif (((x + y) % 3) == 0 && maxi <= 2*mini)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}", "10921": "void isPrime(int N)\n{\n\tbool isPrime = true;\n\tint arr[8] = { 7, 11, 13, 17,\n\t\t\t\t19, 23, 29, 31 };\n\tif (N < 2) {\n\t\tisPrime = false;\n\t}\n\tif (N % 2 == 0 N % 3 == 0 N % 5 == 0) {\n\t\tisPrime = false;\n\t}\n\tfor (int i = 0; i < sqrt(N); i += 30) {\n\t\tfor (int c : arr) {\n\t\t\tif (c > sqrt(N)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (N % (c + i) == 0) {\n\t\t\t\t\tisPrime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isPrime)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (isPrime)\n\t\tcout << \"Prime Number\";\n\telse\n\t\tcout << \"Not a Prime Number\";\n}", "10932": "void printPairs(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcout << \"(\" << arr[i] << \", \" << arr[j] << \")\"\n\t\t\t\t<< \", \";\n\t\t}\n\t}\n}", "10935": "long long power(int p)\n{\n\tlong long res = 1;\n\tfor (int i = 1; i <= p; ++i) {\n\t\tres *= 2;\n\t\tres %= mod;\n\t}\n\treturn res % mod;\n}\nlong long subset_cube_sum(vector<int>& A)\n{\n\tint n = (int)A.size();\n\tlong long ans = 0;\n\tfor (int i : A) {\n\t\tans += (1LL * i * i * i) % mod;\n\t\tans %= mod;\n\t}\n\treturn (1LL * ans * power(n - 1))\n\t\t% mod;\n}", "10936": "int nearest(int n)\n{\n\tint prevSquare = sqrt(n);\n\tint nextSquare = prevSquare + 1;\n\tprevSquare = prevSquare * prevSquare;\n\tnextSquare = nextSquare * nextSquare;\n\tint ans\n\t\t= (n - prevSquare) < (nextSquare - n)\n\t\t\t? (prevSquare - n)\n\t\t\t: (nextSquare - n);\n\treturn ans;\n}", "10937": "int nearest(int n)\n{\n\tint prevCube = cbrt(n);\n\tint nextCube = prevCube + 1;\n\tprevCube = prevCube * prevCube * prevCube;\n\tnextCube = nextCube * nextCube * nextCube;\n\tint ans\n\t\t= (n - prevCube) < (nextCube - n)\n\t\t\t? (prevCube - n)\n\t\t\t: (nextCube - n);\n\treturn ans;\n}", "10951": "void printValueOfPi(int N)\n{\n\tdouble pi = 2 * acos(0.0);\n\tprintf(\"%.*lf\\n\", N, pi);\n}", "10952": "int powOfPositive(int n)\n{\n\tint pos = floor(log2(n));\n\treturn pow(2, pos);\n}\nint powOfNegative(int n)\n{\n\tint pos = ceil(log2(n));\n\treturn (-1 * pow(2, pos));\n}\nvoid highestPowerOf2(int n)\n{\n\tif (n > 0) {\n\t\tcout << powOfPositive(n);\n\t}\n\telse {\n\t\tn = -n;\n\t\tcout << powOfNegative(n);\n\t}\n}", "10960": "int noOfCards(int n)\n{\n\treturn n * (3 * n + 1) / 2;\n}", "10974": "string smallestPoss(string s, int n)\n{\n\tstring ans = \"\";\n\tint arr[10] = { 0 };\n\tfor (int i = 0; i < n; i++) {\n\t\tarr[s[i] - 48]++;\n\t}\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 0; j < arr[i]; j++)\n\t\t\tans = ans + to_string(i);\n\t}\n\treturn ans;\n}", "11014": "int Count_subarray(int arr[], int n)\n{\n\tint subarray_sum, remaining_sum, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tsubarray_sum = 0;\n\t\t\tremaining_sum = 0;\n\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\tsubarray_sum += arr[k];\n\t\t\t}\n\t\t\tfor (int l = 0; l < i; l++) {\n\t\t\t\tremaining_sum += arr[l];\n\t\t\t}\n\t\t\tfor (int l = j + 1; l < n; l++) {\n\t\t\t\tremaining_sum += arr[l];\n\t\t\t}\n\t\t\tif (subarray_sum > remaining_sum) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "11015": "int Count_subarray(int arr[], int n)\n{\n\tint total_sum = 0, subarray_sum,\n\t\tremaining_sum, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\ttotal_sum += arr[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tsubarray_sum = 0;\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tsubarray_sum += arr[j];\n\t\t\tremaining_sum = total_sum - subarray_sum;\n\t\t\tif (subarray_sum > remaining_sum) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "11045": "void decBinary(int arr[], int n)\n{\n\tint k = log2(n);\n\twhile (n > 0) {\n\t\tarr[k--] = n % 2;\n\t\tn /= 2;\n\t}\n}\nint binaryDec(int arr[], int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans += arr[i] << (n - i - 1);\n\treturn ans;\n}\nint getNum(int n, int k)\n{\n\tint l = log2(n) + 1;\n\tint a[l] = { 0 };\n\tdecBinary(a, n);\n\tif (k > l)\n\t\treturn n;\n\ta[k - 1] = (a[k - 1] == 0) ? 1 : 0;\n\treturn binaryDec(a, l);\n}", "11051": "void find_composite_nos(int n)\n{\n\tcout << 9 * n << \" \" << 8 * n;\n}", "11052": "int maxXOR(int* arr, int n)\n{\n\tint xorArr = 0;\n\tfor (int i = 0; i < n; i++)\n\t\txorArr ^= arr[i];\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans = max(ans, (xorArr ^ arr[i]));\n\treturn ans;\n}", "11060": "bool digitDividesK(int num, int k)\n{\n\twhile (num) {\n\t\tint d = num % 10;\n\t\tif (d != 0 and k % d == 0)\n\t\t\treturn true;\n\t\tnum = num / 10;\n\t}\n\treturn false;\n}\nint findCount(int l, int r, int k)\n{\n\tint count = 0;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (digitDividesK(i, k))\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "11088": "bool isFactorial(int n)\n{\n for (int i = 1;; i++) {\n\tif (n % i == 0) {\n\tn /= i;\n\t}\n\telse {\n\tbreak;\n\t}\n }\n if (n == 1) {\n\treturn true;\n }\n else {\n\treturn false;\n }\n}", "11094": "int lcm(int a, int b)\n{\n\tint GCD = __gcd(a, b);\n\treturn (a * b) / GCD;\n}\nint MinLCM(int a[], int n)\n{\n\tint Prefix[n + 2];\n\tint Suffix[n + 2];\n\tPrefix[1] = a[0];\n\tfor (int i = 2; i <= n; i += 1) {\n\t\tPrefix[i] = lcm(Prefix[i - 1], a[i - 1]);\n\t}\n\tSuffix[n] = a[n - 1];\n\tfor (int i = n - 1; i >= 1; i -= 1) {\n\t\tSuffix[i] = lcm(Suffix[i + 1], a[i - 1]);\n\t}\n\tint ans = min(Suffix[2], Prefix[n - 1]);\n\tfor (int i = 2; i < n; i += 1) {\n\t\tans = min(ans, lcm(Prefix[i - 1], Suffix[i + 1]));\n\t}\n\treturn ans;\n}", "11102": "int diameter(int n)\n{\n\tint L, H, templen;\n\tL = 1;\n\tH = 0;\n\tif (n == 1) {\n\t\treturn 1;\n\t}\n\tif (n == 2) {\n\t\treturn 2;\n\t}\n\tif (n == 3) {\n\t\treturn 3;\n\t}\n\twhile (L * 2 <= n) {\n\t\tL *= 2;\n\t\tH++;\n\t}\n\tif (n >= L * 2 - 1)\n\t\treturn 2 * H + 1;\n\telse if (n >= L + (L / 2) - 1)\n\t\treturn 2 * H;\n\treturn 2 * H - 1;\n}", "11139": "int count(int n)\n{\n\treturn n * (3 * n - 1) / 2;\n}", "11180": "int findMinValue(int arr[], int n)\n{\n\tlong sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += arr[i];\n\treturn ((sum / n) + 1);\n}", "11182": "int modFact(int n, int m)\n{\n\tint result = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tresult = (result * i) % MOD;\n\treturn result;\n}", "11194": "void preCompute()\n{\n\tfact[0] = 1;\n\tresult[0] = 1;\n\tfor (int i = 1; i <= MAX; i++) {\n\t\tfact[i] = ((fact[i - 1] % MOD) * i) % MOD;\n\t\tresult[i] = ((result[i - 1] % MOD) * (fact[i] % MOD)) % MOD;\n\t}\n}\nvoid performQueries(int q[], int n)\n{\n\tpreCompute();\n\tfor (int i = 0; i < n; i++)\n\t\tcout << result[q[i]] << \"\\n\";\n}", "11196": "int gcd(int a, int b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b % a, a);\n}\nlong divTermCount(long a, long b, long c, long num)\n{\n\treturn ((num / a) + (num / b) + (num / c)\n\t\t\t- (num / ((a * b) / gcd(a, b)))\n\t\t\t- (num / ((c * b) / gcd(c, b)))\n\t\t\t- (num / ((a * c) / gcd(a, c)))\n\t\t\t+ (num / ((((a*b)/gcd(a, b))* c) / gcd(((a*b)/gcd(a, b)), c))));\n}\nint findNthTerm(int a, int b, int c, long n)\n{\n\tlong low = 1, high = LONG_MAX, mid;\n\twhile (low < high) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (divTermCount(a, b, c, mid) < n)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\treturn low;\n}", "11199": "double calculate_angle(int n, int i, int j, int k)\n{\n\tint x, y;\n\tif (i < j)\n\t\tx = j - i;\n\telse\n\t\tx = j + n - i;\n\tif (j < k)\n\t\ty = k - j;\n\telse\n\t\ty = k + n - j;\n\tdouble ang1 = (180 * x) / n;\n\tdouble ang2 = (180 * y) / n;\n\tdouble ans = 180 - ang1 - ang2;\n\treturn ans;\n}", "11204": "long long power(int p)\n{\n\tlong long res = 1;\n\tfor (int i = 1; i <= p; ++i) {\n\t\tres *= 2;\n\t\tres %= mod;\n\t}\n\treturn res % mod;\n}\nlong long subset_square_sum(vector<int>& A)\n{\n\tint n = (int)A.size();\n\tlong long ans = 0;\n\tfor (int i : A) {\n\t\tans += (1LL * i * i) % mod;\n\t\tans %= mod;\n\t}\n\treturn (1LL * ans * power(n - 1)) % mod;\n}", "11217": "void least_prime_factor()\n{\n\tfor (int i = 2; i < N; i++)\n\t\tif (!lpf[i])\n\t\t\tfor (int j = i; j < N; j += i)\n\t\t\t\tif (!lpf[j])\n\t\t\t\t\tlpf[j] = i;\n}\nvoid Mobius()\n{\n\tfor (int i = 1; i < N; i++) {\n\t\tif (i == 1)\n\t\t\tmobius[i] = 1;\n\t\telse {\n\t\t\tif (lpf[i / lpf[i]] == lpf[i])\n\t\t\t\tmobius[i] = 0;\n\t\t\telse\n\t\t\t\tmobius[i] = -1 * mobius[i / lpf[i]];\n\t\t}\n\t}\n}\nint gcd_pairs(int a[], int n)\n{\n\tint maxi = 0;\n\tint fre[N] = { 0 };\n\tfor (int i = 0; i < n; i++) {\n\t\tfre[a[i]]++;\n\t\tmaxi = max(a[i], maxi);\n\t}\n\tleast_prime_factor();\n\tMobius();\n\tint ans = 0;\n\tfor (int i = 1; i <= maxi; i++) {\n\t\tif (!mobius[i])\n\t\t\tcontinue;\n\t\tint temp = 0;\n\t\tfor (int j = i; j <= maxi; j += i)\n\t\t\ttemp += fre[j];\n\t\tans += temp * (temp - 1) / 2 * mobius[i];\n\t}\n\treturn ans;\n}", "11253": "void compareVal(int x, int y)\n{\n\tlong double a = y * log(x);\n\tlong double b = x * log(y);\n\tif (a > b)\n\t\tcout << x << \"^\" << y << \" > \"\n\t\t\t<< y << \"^\" << x;\n\telse if (a < b)\n\t\tcout << x << \"^\" << y << \" < \"\n\t\t\t<< y << \"^\" << x;\n\telse if (a == b)\n\t\tcout << x << \"^\" << y << \" = \"\n\t\t\t<< y << \"^\" << x;\n}", "11283": "void compareValues(int a, int b, int c, int d)\n{\n\tdouble log1 = log10(a);\n\tdouble num1 = log1 * b;\n\tdouble log2 = log10(c);\n\tdouble num2 = log2 * d;\n\tif (num1 > num2)\n\t\tcout << a << \"^\" << b;\n\telse\n\t\tcout << c << \"^\" << d;\n}", "11294": "void ZigZag(int n)\n{\n\tlong long fact[n + 1], zig[n + 1] = { 0 };\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfact[i] = fact[i - 1] * i;\n\tzig[0] = 1;\n\tzig[1] = 1;\n\tcout << \"zig zag numbers: \";\n\tcout << zig[0] << \" \" << zig[1] << \" \";\n\tfor (int i = 2; i < n; i++)\n\t{\n\t\tlong long sum = 0;\n\t\tfor (int k = 0; k <= i - 1; k++)\n\t\t{\n\t\t\tsum += (fact[i - 1]/(fact[i - 1 - k]*fact[k]))\n\t\t\t\t\t\t\t\t*zig[k] * zig[i - 1 - k];\n\t\t}\n\t\tzig[i] = sum / 2;\n\t\tcout << sum / 2 << \" \";\n\t}\n}", "11302": "int find_count(vector<int> ele)\n{\n\tint count = 0;\n\tfor (int i = 0; i < ele.size(); i++) {\n\t\tvector<int> p;\n\t\tint c = 0;\n\t\tfor (int j = ele.size() - 1;\n\t\t\tj >= (ele.size() - 1 - i) && j >= 0; j--)\n\t\t\tp.push_back(ele[j]);\n\t\tint j = ele.size() - 1, k = 0;\n\t\twhile (j >= 0) {\n\t\t\tif (ele[j] != p[k])\n\t\t\t\tbreak;\n\t\t\tj--;\n\t\t\tk++;\n\t\t\tif (k == p.size()) {\n\t\t\t\tc++;\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tcount = max(count, c);\n\t}\n\treturn count;\n}\nvoid solve(int n)\n{\n\tint count = 1;\n\tvector<int> ele;\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << count << \", \";\n\t\tele.push_back(count);\n\t\tcount = find_count(ele);\n\t}\n}", "11306": "vector<int> addPrimes()\n{\n\tint n = MAX;\n\tbool prime[n + 1];\n\tmemset(prime, true, sizeof(prime));\n\tfor (int p = 2; p * p <= n; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tvector<int> ans;\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tans.push_back(p);\n\treturn ans;\n}\nbool is_prime(int n)\n{\n\treturn (n == 3 n == 5 n == 7);\n}\nint find_Sum(int n)\n{\n\tint sum = 0;\n\tvector<int> v = addPrimes();\n\tfor (int i = 0; i < v.size() and n; i++)\n\t{\n\t\tint flag = 1;\n\t\tint a = v[i];\n\t\twhile (a != 0)\n\t\t{\n\t\t\tint d = a % 10;\n\t\t\ta = a / 10;\n\t\t\tif (is_prime(d)) {\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag==1)\n\t\t{\n\t\t\tn--;\n\t\t\tsum = sum + v[i];\n\t\t}\n\t}\n\treturn sum;\n}", "11315": "int Wedderburn(int n)\n{\n\tif (n <= 2)\n\t\treturn store[n];\n\telse if (n % 2 == 0)\n\t{\n\t\tint x = n / 2, ans = 0;\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\tans += store[i] * store[n - i];\n\t\t}\n\t\tans += (store[x] * (store[x] + 1)) / 2;\n\t\tstore[n] = ans;\n\t\treturn ans;\n\t}\n\telse\n\t{\n\t\tint x = (n + 1) / 2, ans = 0;\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\tans += store[i] * store[n - i];\n\t\t}\n\t\tstore[n] = ans;\n\t\treturn ans;\n\t}\n}\nvoid Wedderburn_Etherington(int n)\n{\n\tstore[0] = 0;\n\tstore[1] = 1;\n\tstore[2] = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << Wedderburn(i);\n\t\tif(i!=n-1)\n\t\t\tcout << \", \";\n\t}\n}", "11331": "int Max_sum(int a[], int n)\n{\n\tint pos = 0, neg = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(a[i] > 0)\n\t\t\tpos = 1;\n\t\telse if(a[i] < 0)\n\t\t\tneg = 1;\n\t\tif(pos == 1 and neg == 1)\n\t\t\tbreak;\n\t}\n\tint sum = 0;\n\tif(pos==1 and neg==1)\n\t{\n\t\tfor(int i=0; i < n ; i++)\n\t\t\tsum += abs(a[i]);\n\t}\n\telse if(pos == 1)\n\t{\n\t\tint mini = a[0];\n\t\tsum = a[0];\n\t\tfor(int i=1; i < n; i++)\n\t\t{\n\t\t\tmini = min(mini, a[i]);\n\t\t\tsum += a[i];\n\t\t} \n\t\tsum -= 2*mini;\n\t} \n\telse if(neg == 1)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t\ta[i] = abs(a[i]);\n\t\tint mini = a[0];\n\t\tsum = a[0];\n\t\tfor(int i=1; i < n; i++)\n\t\t{\n\t\t\tmini = min(mini, a[i]);\n\t\t\tsum += a[i];\n\t\t} \n\t\tsum -= 2*mini;\n\t}\n\treturn sum;\n}", "11342": "void decimalToBinary(int n)\n{\n\tif (n == 0) {\n\t\tcout << \"0\";\n\t\treturn;\n\t}\n\tdecimalToBinary(n / 2);\n\tcout << n % 2;\n}", "11343": "void MinimumValue(int x, int y)\n{\n\tif (x > y)\n\t\tswap(x, y);\n\tint a = 1;\n\tint b = x - 1;\n\tint c = y - b;\n\tcout << a << \" \" << b << \" \" << c;\n}", "11370": "bool canConvert(int a, int b)\n{\n\twhile (b > a) {\n\t\tif (b % 10 == 1) {\n\t\t\tb /= 10;\n\t\t\tcontinue;\n\t\t}\n\t\tif (b % 2 == 0) {\n\t\t\tb /= 2;\n\t\t\tcontinue;\n\t\t}\n\t\treturn false;\n\t}\n\tif (b == a)\n\t\treturn true;\n\treturn false;\n}", "11387": "int count(int N)\n{\n\tint a = 0;\n\ta = (N * (N + 1)) / 2;\n\treturn a;\n}", "11404": "int numberOfDays(int a, int b, int n)\n{\n\tint Days = b * (n + a) / (a + b);\n\treturn Days;\n}", "11418": "int getAverage(int x, int y)\n{\n\tint avg = (x & y) + ((x ^ y) >> 1);\n\treturn avg;\n}", "11435": "int primeCount(int arr[], int n)\n{\n\tint max_val = *max_element(arr, arr + n);\n\tvector<bool> prime(max_val + 1, true);\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (int p = 2; p * p <= max_val; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (int i = p * 2; i <= max_val; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tint count = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (prime[arr[i]])\n\t\t\tcount++;\n\treturn count;\n}\nvoid getPrefixArray(int arr[], int n, int pre[])\n{\n\tpre[0] = arr[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tpre[i] = pre[i - 1] + arr[i];\n\t}\n}", "11510": "int smallestIndex(int a[], int n)\n{\n\tint right1 = 0, right0 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == 1)\n\t\t\tright1 = i;\n\t\telse\n\t\t\tright0 = i;\n\t}\n\treturn min(right1, right0);\n}", "11523": "int freqPairs(int arr[], int n)\n{\n\tint max = *(std::max_element(arr, arr + n));\n\tint freq[max + 1] = { 0 };\n\tint count = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfreq[arr[i]]++;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 2 * arr[i]; j <= max; j += arr[i]) {\n\t\t\tif (freq[j] >= 1)\n\t\t\t\tcount += freq[j];\n\t\t}\n\t\tif (freq[arr[i]] > 1) {\n\t\t\tcount += freq[arr[i]] - 1;\n\t\t\tfreq[arr[i]]--;\n\t\t}\n\t}\n\treturn count;\n}", "11533": "int countSquares(int r, int c, int m)\n{\n\tint squares = 0;\n\tfor (int i = 1; i <= 8; i++) {\n\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\tif (max(abs(i - r), abs(j - c)) <= m)\n\t\t\t\tsquares++;\n\t\t}\n\t}\n\treturn squares;\n}", "11549": "void Loss(int SP, int P)\n{\n\tfloat loss = 0;\n\tloss = (2 * P * P * SP) / float(100 * 100 - P * P);\n\tcout << \"Loss = \" << loss;\n}", "11611": "void sieve()\n{\n\tspf[1] = 1;\n\tfor (int i = 2; i < MAXN; i++)\n\t\tspf[i] = i;\n\tfor (int i = 4; i < MAXN; i += 2)\n\t\tspf[i] = 2;\n\tfor (int i = 3; i * i < MAXN; i++) {\n\t\tif (spf[i] == i) {\n\t\t\tfor (int j = i * i; j < MAXN; j += i)\n\t\t\t\tif (spf[j] == j)\n\t\t\t\t\tspf[j] = i;\n\t\t}\n\t}\n}\nvoid getFactorization(int x)\n{\n\tint temp;\n\twhile (x != 1) {\n\t\ttemp = spf[x];\n\t\tif (x % temp == 0) {\n\t\t\thash1[spf[x]]++;\n\t\t\tx = x / spf[x];\n\t\t}\n\t\twhile (x % temp == 0)\n\t\t\tx = x / temp;\n\t}\n}\nbool check(int x)\n{\n\tint temp;\n\twhile (x != 1) {\n\t\ttemp = spf[x];\n\t\tif (x % temp == 0 && hash1[temp] > 1)\n\t\t\treturn false;\n\t\twhile (x % temp == 0)\n\t\t\tx = x / temp;\n\t}\n\treturn true;\n}\nbool hasValidNum(int arr[], int n)\n{\n\tsieve();\n\tfor (int i = 0; i < n; i++)\n\t\tgetFactorization(arr[i]);\n\tfor (int i = 0; i < n; i++)\n\t\tif (check(arr[i]))\n\t\t\treturn true;\n\treturn false;\n}", "11613": "int countQuadruples(int a[], int n)\n{\n\tunordered_map<int, int> mpp;\n\tfor (int i = 0; i < n; i++)\n\t\tmpp[a[i]]++;\n\tint count = 0;\n\tfor (int j = 0; j < n; j++) {\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tif (j == k)\n\t\t\t\tcontinue;\n\t\t\tmpp[a[j]]--;\n\t\t\tmpp[a[k]]--;\n\t\t\tint first = a[j] - (a[k] - a[j]);\n\t\t\tint fourth = (a[k] * a[k]) / a[j];\n\t\t\tif ((a[k] * a[k]) % a[j] == 0) {\n\t\t\t\tif (a[j] != a[k])\n\t\t\t\t\tcount += mpp[first] * mpp[fourth];\n\t\t\t\telse\n\t\t\t\t\tcount += mpp[first] * (mpp[fourth] - 1);\n\t\t\t}\n\t\t\tmpp[a[j]]++;\n\t\t\tmpp[a[k]]++;\n\t\t}\n\t}\n\treturn count;\n}", "11626": "int countNumbers(int L, int R, int K)\n{\n\tif (K == 9)\n\t\tK = 0;\n\tint totalnumbers = R - L + 1;\n\tint factor9 = totalnumbers / 9;\n\tint rem = totalnumbers % 9;\n\tint ans = factor9;\n\tfor (int i = R; i > R - rem; i--) {\n\t\tint rem1 = i % 9;\n\t\tif (rem1 == K)\n\t\t\tans++;\n\t}\n\treturn ans;\n}", "11627": "int countWays(int N)\n{\n\tint E = (N * (N - 1)) / 2;\n\tif (N == 1)\n\t\treturn 0;\n\treturn pow(2, E - 1);\n}", "11628": "int EvenSum(vector<int>& A, int index, int value)\n{\n\tA[index] = A[index] + value;\n\tint sum = 0;\n\tfor (int i = 0; i < A.size(); i++)\n\t\tif (A[i] % 2 == 0)\n\t\t\tsum = sum + A[i];\n\treturn sum;\n}\nvoid BalanceArray(vector<int>& A, vector<vector<int> >& Q)\n{\n\tvector<int> ANS;\n\tint i, sum;\n\tfor (i = 0; i < Q.size(); i++) {\n\t\tint index = Q[i][0];\n\t\tint value = Q[i][1];\n\t\tsum = EvenSum(A, index, value);\n\t\tANS.push_back(sum);\n\t}\n\tfor (i = 0; i < ANS.size(); i++)\n\t\tcout << ANS[i] << \" \";\n}", "11629": "void BalanceArray(vector<int>& A, vector<vector<int> >& Q)\n{\n\tvector<int> ANS;\n\tint i, sum = 0;\n\tfor (i = 0; i < A.size(); i++)\n\t\tif (A[i] % 2 == 0)\n\t\t\tsum = sum + A[i];\n\tfor (i = 0; i < Q.size(); i++) {\n\t\tint index = Q[i][0];\n\t\tint value = Q[i][1];\n\t\tif (A[index] % 2 == 0)\n\t\t\tsum = sum - A[index];\n\t\tA[index] = A[index] + value;\n\t\tif (A[index] % 2 == 0)\n\t\t\tsum = sum + A[index];\n\t\tANS.push_back(sum);\n\t}\n\tfor (i = 0; i < ANS.size(); i++)\n\t\tcout << ANS[i] << \" \";\n}", "11658": "int Cycles(int N)\n{\n\tint fact = 1, result = 0;\n\tresult = N - 1;\n\tint i = result;\n\twhile (i > 0) {\n\t\tfact = fact * i;\n\t\ti--;\n\t}\n\treturn fact / 2;\n}", "11667": "int findAndSum(int arr[], int n)\n{\n\tint sum = 0;\n\tint mul = 1;\n\tfor (int i = 0; i < 30; i++) {\n\t\tbool count_on = 0;\n\t\tint l = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((arr[j] & (1 << i)) > 0)\n\t\t\t\tif (count_on)\n\t\t\t\t\tl++;\n\t\t\t\telse {\n\t\t\t\t\tcount_on = 1;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\telse if (count_on) {\n\t\t\t\tsum += ((mul * l * (l + 1)) / 2);\n\t\t\t\tcount_on = 0;\n\t\t\t\tl = 0;\n\t\t\t}\n\t\t}\n\t\tif (count_on) {\n\t\t\tsum += ((mul * l * (l + 1)) / 2);\n\t\t\tcount_on = 0;\n\t\t\tl = 0;\n\t\t}\n\t\tmul *= 2;\n\t}\n\treturn sum;\n}", "11677": "void initialize()\n{\n\tl[0][0] = 1;\n\tfor (int i = 1; i < 1001; i++) {\n\t\tl[i][0] = 1;\n\t\tfor (int j = 1; j < i + 1; j++) {\n\t\t\tl[i][j] = (l[i - 1][j - 1] + l[i - 1][j]);\n\t\t}\n\t}\n}\nint nCr(int n, int r)\n{\n\treturn l[n][r];\n}", "11687": "int minValue(int n, int x, int y)\n{\n\tfloat val = (y * n) / 100;\n\tif (x >= val)\n\t\treturn 0;\n\telse\n\t\treturn (ceil(val) - x);\n}", "11707": "bool digitWell(int n, int m, int k)\n{\n\tint cnt = 0;\n\twhile (n > 0) {\n\t\tif (n % 10 == m)\n\t\t\t++cnt;\n\t\tn /= 10;\n\t}\n\treturn cnt == k;\n}\nint findInt(int n, int m, int k)\n{\n\tint i = n + 1;\n\twhile (true) {\n\t\tif (digitWell(i, m, k))\n\t\t\treturn i;\n\t\ti++;\n\t}\n}", "11709": "int minAbsDiff(int n)\n{\n\tint mod = n % 4;\n\tif (mod == 0 mod == 3)\n\t\treturn 0;\n\treturn 1;\n}", "11722": "int countOdd(int arr[], int n)\n{\n\tint odd = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] % 2 == 1)\n\t\t\todd++;\n\t}\n\treturn odd;\n}\nint countValidPairs(int arr[], int n)\n{\n\tint odd = countOdd(arr, n);\n\treturn (odd * (odd - 1)) / 2;\n}", "11748": "ll gcd(ll a, ll b)\n{\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\nll lcmOfArray(int arr[], int n)\n{\n\tif (n < 1)\n\t\treturn 0;\n\tll lcm = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\treturn lcm;\n}\nint minPerfectCube(int arr[], int n)\n{\n\tll minPerfectCube;\n\tll lcm = lcmOfArray(arr, n);\n\tminPerfectCube = (long long)lcm;\n\tint cnt = 0;\n\twhile (lcm > 1 && lcm % 2 == 0) {\n\t\tcnt++;\n\t\tlcm /= 2;\n\t}\n\tif (cnt % 3 == 2)\n\t\tminPerfectCube *= 2;\n\telse if (cnt % 3 == 1)\n\t\tminPerfectCube *= 4;\n\tint i = 3;\n\twhile (lcm > 1) {\n\t\tcnt = 0;\n\t\twhile (lcm % i == 0) {\n\t\t\tcnt++;\n\t\t\tlcm /= i;\n\t\t}\n\t\tif (cnt % 3 == 1)\n\t\t\tminPerfectCube *= i * i;\n\t\telse if (cnt % 3 == 2)\n\t\t\tminPerfectCube *= i;\n\t\ti += 2;\n\t}\n\treturn minPerfectCube;\n}", "11772": "bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nstatic bool isStrongPrime(int n)\n{\n\tif (!isPrime(n) n == 2)\n\t\treturn false;\n\tint previous_prime = n - 1;\n\tint next_prime = n + 1;\n\twhile (!isPrime(next_prime))\n\t\tnext_prime++;\n\twhile (!isPrime(previous_prime))\n\t\tprevious_prime--;\n\tint mean = (previous_prime + next_prime) / 2;\n\tif (n > mean)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "11774": "bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nbool isFactorialPrime(long n)\n{\n\tif (!isPrime(n))\n\t\treturn false;\n\tlong fact = 1;\n\tint i = 1;\n\twhile (fact <= n + 1) {\n\t\tfact = fact * i;\n\t\tif (n + 1 == fact n - 1 == fact)\n\t\t\treturn true;\n\t\ti++;\n\t}\n\treturn false;\n}", "11815": "int countDigitsToBeRemoved(int N, int K)\n{\n\tstring s = to_string(N);\n\tint res = 0;\n\tint f_zero = 0;\n\tfor (int i = s.size() - 1; i >= 0; i--) {\n\t\tif (K == 0)\n\t\t\treturn res;\n\t\tif (s[i] == '0') {\n\t\t\tf_zero = 1;\n\t\t\tK--;\n\t\t}\n\t\telse\n\t\t\tres++;\n\t}\n\tif (!K)\n\t\treturn res;\n\telse if (f_zero)\n\t\treturn s.size() - 1;\n\treturn -1;\n}", "11906": "float getSum(int a, int n)\n{\n\tfloat sum = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tsum += (i / pow(a, i));\n\t}\n\treturn sum;\n}", "11948": "bool check(int s)\n{\n\tint freq[10] = {0},r;\n\twhile(s != 0)\n\t{\n\t\tr = s % 10;\n\t\ts = int(s / 10);\n\t\tfreq[r] += 1;\n\t}\n\tint xor__ = 0;\n\tfor (int i=0;i<10;i++)\n\t{\n\txor__ = xor__ ^ freq[i];\n\tif(xor__ == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n\t}\n}", "11998": "int largestPrimeFactor(int n)\n{\n\tint max = -1;\n\twhile (n % 2 == 0) {\n\t\tmax = 2;\n\t}\n\tfor (int i = 3; i <= sqrt(n); i += 2) {\n\t\twhile (n % i == 0) {\n\t\t\tmax = i;\n\t\t\tn = n / i;\n\t\t}\n\t}\n\tif (n > 2)\n\t\tmax = n;\n\treturn max;\n}\nbool checkUnusual(int n)\n{\n\tint factor = largestPrimeFactor(n);\n\tif (factor > sqrt(n)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "12002": "int Nth_Term(int n)\n{\n\treturn (2 * pow(n, 3) - 3 *\n\t\t\t\tpow(n, 2) + n + 6) / 6;\n}", "12035": "void isHalfReducible(int arr[], int n, int m)\n{\n\tint frequencyHash[m + 1];\n\tint i;\n\tmemset(frequencyHash, 0, sizeof(frequencyHash));\n\tfor (i = 0; i < n; i++) {\n\t\tfrequencyHash[arr[i] % (m + 1)]++;\n\t}\n\tfor (i = 0; i <= m; i++) {\n\t\tif (frequencyHash[i] >= n / 2)\n\t\t\tbreak;\n\t}\n\tif (i <= m)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}", "12037": "void generateDivisors(int n)\n{\n\tfor (int i = 1; i <= sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (n / i == i)\n\t\t\t\tarr.push_back(i);\n\t\t\t{\n\t\t\t\tarr.push_back(i);\n\t\t\t\tarr.push_back(n / i);\n\t\t\t}\n\t\t}\n\t}\n}\ndouble harmonicMean(int n)\n{\n\tgenerateDivisors(n);\n\tdouble sum = 0.0;\n\tint len = arr.size();\n\tfor (int i = 0; i < len; i++)\n\t\tsum = sum + double(n / arr[i]);\n\tsum = double(sum / n);\n\treturn double(arr.size() / sum);\n}\nbool isOreNumber(int n)\n{\n\tdouble mean = harmonicMean(n);\n\tif (mean - int(mean) == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "12058": "", "12070": "void printLines(int n, int k)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << k * (6 * i + 1) << \" \"\n\t\t\t<< k * (6 * i + 2) << \" \"\n\t\t\t<< k * (6 * i + 3) << \" \"\n\t\t\t<< k * (6 * i + 5) << endl;\n\t}\n}", "12076": "void SieveOfEratosthenes()\n{\n\tbool prime[MAX];\n\tmemset(prime, true, sizeof(prime));\n\tfor (int p = 2; p * p < MAX; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (int i = p * 2; i < MAX; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor (int p = 2; p < MAX; p++)\n\t\tif (prime[p])\n\t\t\tarr.push_back(p);\n}\nbool isEuclid(long n)\n{\n\tlong long product = 1;\n\tint i = 0;\n\twhile (product < n) {\n\t\tproduct = product * arr[i];\n\t\tif (product + 1 == n)\n\t\t\treturn true;\n\t\ti++;\n\t}\n\treturn false;\n}", "12077": "void SieveOfEratosthenes()\n{\n\tbool prime[MAX];\n\tmemset(prime, true, sizeof(prime));\n\tfor (int p = 2; p * p < MAX; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (int i = p * 2; i < MAX; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tlong long int product = 1;\n\tfor (int p = 2; p < MAX; p++) {\n\t\tif (prime[p]) {\n\t\t\tproduct = product * p;\n\t\t\ts.insert(product + 1);\n\t\t}\n\t}\n}\nbool isEuclid(long n)\n{\n\tif (s.find(n) != s.end())\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "12078": "bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6) {\n\t\tif (n % i == 0 || n % (i + 2) == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool isPowerOfTwo(int n)\n{\n\treturn (n && !(n & (n - 1)));\n}", "12117": "float area(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat area = pow((a * sqrt(3)) / (sqrt(2)), 2);\n\treturn area;\n}", "12147": "int nthTerm(int n)\n{\n\treturn 3 * pow(n, 2) - 4 * n + 2;\n}", "12157": "int calculateSum(int n)\n{\n\treturn n * (n + 1) / 2\n\t\t+ pow((n * (n + 1) / 2), 2);\n}", "12170": "string findNthNo(int n)\n{\n\tstring res = \"\";\n\twhile (n >= 1) {\n\t\tif (n & 1) {\n\t\t\tres = res + \"3\";\n\t\t\tn = (n - 1) / 2;\n\t\t}\n\t\telse {\n\t\t\tres = res + \"5\";\n\t\t\tn = (n - 2) / 2;\n\t\t}\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}", "12180": "int printNthElement(int n)\n{\n\tint arr[n + 1];\n\tarr[1] = 3;\n\tarr[2] = 5;\n\tfor (int i = 3; i <= n; i++) {\n\t\tif (i % 2 != 0)\n\t\t\tarr[i] = arr[i / 2] * 10 + 3;\n\t\telse\n\t\t\tarr[i] = arr[(i / 2) - 1] * 10 + 5;\n\t}\n\treturn arr[n];\n}", "12185": "bool arePermutations(int a[], int b[], int n, int m)\n{\n\tint sum1 = 0, sum2 = 0, mul1 = 1, mul2 = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tsum1 += a[i];\n\t\tmul1 *= a[i];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tsum2 += b[i];\n\t\tmul2 *= b[i];\n\t}\n\treturn ((sum1 == sum2) && (mul1 == mul2));\n}", "12191": "int nextPerfectCube(int N)\n{\n\tint nextN = floor(cbrt(N)) + 1;\n\treturn nextN * nextN * nextN;\n}", "12192": "int nthTerm(int N)\n{\n\treturn (N * ((N / 2) + ((N % 2) * 2) + N));\n}", "12225": "int Race(int B, int C)\n{\n\tint result = 0;\n\tresult = ((C * 100) / B);\n\treturn 100 - result;\n}", "12228": "int calculateSum(int n)\n{\n\treturn (pow(2, n + 1) + n - 2);\n}", "12239": "float Time(float arr[], int n, int Emptypipe)\n{\n\tfloat fill = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfill += 1 / arr[i];\n\tfill = fill - (1 / (float)Emptypipe);\n\treturn 1 / fill;\n}", "12261": "int isPrime(int n)\n{\n\tint i, c = 0;\n\tfor (i = 1; i < n / 2; i++) {\n\t\tif (n % i == 0)\n\t\t\tc++;\n\t}\n\tif (c == 1)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\nvoid findMinNum(int arr[], int n)\n{\n\tint first = 0, last = 0, num, rev, i;\n\tint hash[10] = { 0 };\n\tfor (int i = 0; i < n; i++) {\n\t\thash[arr[i]]++;\n\t}\n\tcout << \"Minimum number: \";\n\tfor (int i = 0; i <= 9; i++) {\n\t\tfor (int j = 0; j < hash[i]; j++)\n\t\t\tcout << i;\n\t}\n\tcout << endl;\n\tfor (i = 0; i <= 9; i++) {\n\t\tif (hash[i] != 0) {\n\t\t\tfirst = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 9; i >= 0; i--) {\n\t\tif (hash[i] != 0) {\n\t\t\tlast = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnum = first * 10 + last;\n\trev = last * 10 + first;\n\tcout << \"Prime combinations: \";\n\tif (isPrime(num) && isPrime(rev))\n\t\tcout << num << \" \" << rev;\n\telse if (isPrime(num))\n\t\tcout << num;\n\telse if (isPrime(rev))\n\t\tcout << rev;\n\telse\n\t\tcout << \"No combinations exist\";\n}", "12264": "int check(int n)\n{\n\tint sum = 0;\n\twhile (n != 0) {\n\t\tsum += n % 10;\n\t\tn = n / 10;\n\t}\n\tif (sum % 7 == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "12314": "bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nint SumOfPrimeDivisors(int n)\n{\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (isPrime(i))\n\t\t\t\tsum += i;\n\t\t}\n\t}\n\treturn sum;\n}", "12315": "int Sum(int N)\n{\n\tint SumOfPrimeDivisors[N+1] = { 0 };\n\tfor (int i = 2; i <= N; ++i) {\n\t\tif (!SumOfPrimeDivisors[i]) {\n\t\t\tfor (int j = i; j <= N; j += i) {\n\t\t\t\tSumOfPrimeDivisors[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\treturn SumOfPrimeDivisors[N];\n}", "12316": "bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nint SumOfPrimeDivisors(int n)\n{\n\tint sum = 0;\n\tint root_n = (int)sqrt(n);\n\tfor (int i = 1; i <= root_n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (i == n / i && isPrime(i)) {\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (isPrime(i)) {\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (isPrime(n / i)) {\n\t\t\t\t\tsum += (n / i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "12333": "int findNthNonSquare(int n)\n{\n\tlong double x = (long double)n;\n\tlong double ans = x + floor(0.5 + sqrt(x));\n\treturn (int)ans;\n}", "12340": "ll power(ll x, ll y, ll p)\n{\n\tx = x % p;\n\twhile (y > 0) {\n\t\tif (y & 1)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}", "12422": "string find_Square_369(string num)\n{\n\tchar a, b, c, d;\n\tif (num[0] == '3')\n\t\ta = '1', b = '0', c = '8', d = '9';\n\telse if (num[0] == '6')\n\t\ta = '4', b = '3', c = '5', d = '6';\n\telse\n\t\ta = '9', b = '8', c = '0', d = '1';\n\tstring result = \"\";\n\tint size = num.size();\n\tfor (int i = 1; i < num.size(); i++)\n\t\tresult += a;\n\tresult += b;\n\tfor (int i = 1; i < num.size(); i++)\n\t\tresult += c;\n\tresult += d;\n\treturn result;\n}", "12429": "", "12430": "", "12439": "int findpos(string n)\n{\n\tint pos = 0;\n\tfor (int i = 0; n[i] != '\\0'; i++) {\n\t\tswitch (n[i]) {\n\t\tcase '2':\n\t\t\tpos = pos * 4 + 1;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tpos = pos * 4 + 2;\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tpos = pos * 4 + 3;\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tpos = pos * 4 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn pos;\n}", "12462": "int fact(int n)\n{\n\tif (n == 0 n == 1) \n\t\treturn 1 ;\n\tint ans = 1; \n\tfor (int i = 1 ; i <= n; i++) \n\t\tans = ans * i ;\n\treturn ans ;\n}\nint nCr(int n, int r)\n{\n\tint Nr = n , Dr = 1 , ans = 1;\n\tfor (int i = 1 ; i <= r ; i++ ) {\n\t\tans = ( ans * Nr ) / ( Dr ) ;\n\t\tNr-- ;\n\t\tDr++ ;\n\t}\n\treturn ans ;\n}\nint solve ( int n )\n{\n\tint N = 2*n - 2 ;\n\tint R = n - 1 ; \n\treturn nCr (N, R) * fact(n - 1) ;\n}", "12485": "int gcd(int a, int b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b % a, a);\n}\nbool coprime(int a, int b)\n{\n\treturn (gcd(a, b) == 1);\n}\nvoid possibleTripletInRange(int L, int R)\n{\n\tbool flag = false;\n\tint possibleA, possibleB, possibleC;\n\tfor (int a = L; a <= R; a++) {\n\t\tfor (int b = a + 1; b <= R; b++) {\n\t\t\tfor (int c = b + 1; c <= R; c++) {\n\t\t\t\tif (coprime(a, b) && coprime(b, c) && !coprime(a, c)) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tpossibleA = a;\n\t\t\t\t\tpossibleB = b;\n\t\t\t\t\tpossibleC = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == true) {\n\t\tcout << \"(\" << possibleA << \", \" << possibleB << \", \" << possibleC << \")\"\n\t\t\t<< \" is one such possible triplet between \"\n\t\t\t<< L << \" and \" << R << \"\\n\";\n\t}\n\telse {\n\t\tcout << \"No Such Triplet exists between \"\n\t\t\t<< L << \" and \" << R << \"\\n\";\n\t}\n}", "12486": "void possibleTripletInRange(int L, int R)\n{\n\tbool flag = false;\n\tint possibleA, possibleB, possibleC;\n\tint numbersInRange = (R - L + 1);\n\tif (numbersInRange < 3) {\n\t\tflag = false;\n\t}\n\telse if (numbersInRange > 3) {\n\t\tflag = true;\n\t\tif (L % 2) {\n\t\t\tL++;\n\t\t}\n\t\tpossibleA = L;\n\t\tpossibleB = L + 1;\n\t\tpossibleC = L + 2;\n\t}\n\telse {\n\t\tif (!(L % 2)) {\n\t\t\tflag = true;\n\t\t\tpossibleA = L;\n\t\t\tpossibleB = L + 1;\n\t\t\tpossibleC = L + 2;\n\t\t}\n\t\telse {\n\t\t\tflag = false;\n\t\t}\n\t}\n\tif (flag == true) {\n\t\tcout << \"(\" << possibleA << \", \" << possibleB << \", \" << possibleC << \")\"\n\t\t\t<< \" is one such possible triplet between \"\n\t\t\t<< L << \" and \" << R << \"\\n\";\n\t}\n\telse {\n\t\tcout << \"No Such Triplet exists between \"\n\t\t\t<< L << \" and \" << R << \"\\n\";\n\t}\n}", "12496": "bool possibleToReach(int a, int b)\n{\n\tint c = cbrt(a * b);\n\tint re1 = a / c;\n\tint re2 = b / c;\n\tif ((re1 * re1 * re2 == a) && (re2 * re2 * re1 == b))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "12520": "bool isUndulating(string n)\n{\n\tif (n.length() <= 2)\n\treturn false;\n\tfor (int i = 2; i < n.length(); i++)\n\t\tif (n[i - 2] != n[i])\n\t\tfalse;\n\treturn true;\n}", "12523": "void pythagoreanTriplet(int n)\n{\n\tfor (int i = 1; i <= n / 3; i++)\n\t{\n\t\tfor (int j = i + 1; j <= n / 2; j++)\n\t\t{\n\t\t\tint k = n - i - j;\n\t\t\tif (i * i + j * j == k * k)\n\t\t\t{\n\t\t\t\tcout << i << \", \"\n\t\t\t\t\t<< j << \", \"\n\t\t\t\t\t<< k;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No Triplet\";\n}", "12532": "int factorial(int n)\n{\n\tint f = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tf *= i;\t\n\treturn f;\n}\nvoid series(int A, int X, int n)\n{\t\n\tint nFact = factorial(n);\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tint niFact = factorial(n - i);\n\t\tint iFact = factorial(i);\n\t\tint aPow = pow(A, n - i);\n\t\tint xPow = pow(X, i);\n\t\tcout << (nFact * aPow * xPow) /\n\t\t\t\t(niFact * iFact) << \" \";\n\t}\n}", "12533": "void series(int A, int X, int n)\n{\n\tint term = pow(A, n);\n\tcout << term << \" \";\n\tfor (int i = 1; i <= n; i++) {\n\t\tterm = term * X * (n - i + 1)/(i * A);\n\t\tcout << term << \" \";\n\t}\n}", "12547": "int seiresSum(int n, int a[])\n{\n\tint res = 0;\n\tfor (int i = 0; i < 2 * n; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tres += a[i] * a[i];\n\t\telse\n\t\t\tres -= a[i] * a[i];\n\t}\n\treturn res;\n}", "12548": "int seiresSum(int n, int a[])\n{\n\treturn n * (a[0] * a[0] - a[2 * n - 1] * a[2 * n - 1]) / (2 * n - 1);\n}", "12550": "int checkdigit(int n, int k)\n{\n\twhile (n)\n\t{\n\t\tint rem = n % 10;\n\t\tif (rem == k)\n\t\t\treturn 1;\n\t\tn = n / 10;\n\t}\n\treturn 0;\n}\nint findNthNumber(int n, int k)\n{\n\tfor (int i = k + 1, count = 1; count < n; i++)\n\t{\n\t\tif (checkdigit(i, k) || (i % k == 0))\n\t\t\tcount++;\n\t\tif (count == n)\n\t\treturn i;\n\t}\n\treturn -1;\n}", "12561": "int power(int n, int r)\n{\t\t\n\tint count = 0;\n\tfor (int i = r; (n / i) >= 1; i = i * r) \n\t\tcount += n / i;\n\treturn count;\n}", "12564": "long long digitNumber(long long n) {\n if (n == 0)\n\treturn 1;\n if (n == 1)\n\treturn 9;\n if (n % 2) {\n\tlong long temp = digitNumber((n - 1) / 2) % mod;\n\treturn (9 * (temp * temp) % mod) % mod;\n } else {\n\tlong long temp = digitNumber(n / 2) % mod;\n\treturn (temp * temp) % mod;\n }\n}\nint countExcluding(int n, int d)\n{\n if (d == 0)\n\treturn (9 * digitNumber(n - 1)) % mod;\n else\n\treturn (8 * digitNumber(n - 1)) % mod;\n}", "12587": "int Div_by_8(int n)\n{\n\treturn (((n >> 3) << 3) == n);\n}", "12603": "int avg_of_odd_num(int n)\n{\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += (2 * i + 1);\n\treturn sum / n;\n}", "12604": "int avg_of_odd_num(int n)\n{\n\treturn n;\n}", "12615": "void fib(int f[], int N)\n{\n\tf[1] = 1;\n\tf[2] = 1;\n\tfor (int i = 3; i <= N; i++)\n\t\tf[i] = f[i - 1] + f[i - 2];\n}\nvoid fiboTriangle(int n)\n{\n\tint N = n * (n + 1) / 2;\n\tint f[N + 1];\n\tfib(f, N);\n\tint fiboNum = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tcout << f[fiboNum++] << \" \";\n\t\tcout << endl;\n\t}\n}", "12638": "int averageEven(int n)\n{\n\tif (n % 2 != 0) {\n\t\tprintf(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\tint sum = 0, count = 0;\n\twhile (n >= 2) {\n\t\tcount++;\n\t\tsum += n;\n\t\tn = n - 2;\n\t}\n\treturn sum / count;\n}", "12639": "int averageEven(int n)\n{\n\tif (n % 2 != 0) {\n\t\tcout<<\"Invalid Input\";\n\t\treturn -1;\n\t}\n\treturn (n + 2) / 2;\n}", "12645": "int averageOdd(int n)\n{\n\tif (n % 2 == 0) {\n\t\tprintf(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\tint sum = 0, count = 0;\n\twhile (n >= 1) {\n\t\tcount++;\n\t\tsum += n;\n\t\tn = n - 2;\n\t}\n\treturn sum / count;\n}", "12686": "int lcm(int a, int b)\n{\n\treturn (a * b) / (__gcd(a, b));\n}\nRational maxRational(Rational first, Rational sec)\n{\n\tint k = lcm(first.deno, sec.deno);\n\tint nume1 = first.nume;\n\tint nume2 = sec.nume;\n\tnume1 *= k / (first.deno);\n\tnume2 *= k / (sec.deno);\n\treturn (nume2 < nume1)? first : sec;\n}", "12714": "int TrinomialValue(int n, int k)\n{\n\tif (n == 0 && k == 0)\n\t\treturn 1;\n\tif(k < -n k > n)\n\t\treturn 0;\n\treturn TrinomialValue (n - 1, k - 1)\n\t\t+ TrinomialValue (n - 1, k)\n\t\t+ TrinomialValue (n - 1, k + 1);\n}\nvoid printTrinomial(int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = -i; j <= 0; j++)\n\t\t\tcout << TrinomialValue(i, j) << \" \";\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tcout << TrinomialValue(i, j) << \" \";\n\t\tcout << endl;\n\t}\n}", "12716": "int Series(int n)\n{\n\tint i;\n\tint sums = 0;\n\tfor (i = 1; i <= n; i++)\n\t\tsums += (i * i);\n\treturn sums;\n}", "12745": "bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (int i = 2; i < n; i++)\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nbool isEmirp(int n)\n{\n\tif (isPrime(n) == false)\n\t\treturn false;\n\tint rev = 0;\n\twhile (n != 0) {\n\t\tint d = n % 10;\n\t\trev = rev * 10 + d;\n\t\tn /= 10;\n\t}\n\treturn isPrime(rev);\n}", "12747": "int sumOfLargePrimeFactor(int n)\n{\n\tint prime[n+1], sum = 0;\n\tmemset(prime, 0, sizeof(prime));\n\tint max = n / 2;\n\tfor (int p=2; p<=max; p++)\n\t{\n\t\tif (prime[p] == 0)\n\t\t{\n\t\t\tfor (int i=p*2; i<=n; i += p)\n\t\t\t\tprime[i] = p;\n\t\t}\n\t}\n\tfor (int p=2; p<=n; p++)\n\t{\n\t\tif (prime[p])\n\t\t\tsum += prime[p];\n\t\telse\n\t\t\tsum += p;\n\t}\n\treturn sum;\t\n}", "12750": "int gcd(int a, int b)\n{\n\tif (a == 0 b == 0)\n\t\treturn 0;\n\tif (a == b)\n\t\treturn a;\n\tif (a > b)\n\t\treturn gcd(a - b, b);\n\treturn gcd(a, b - a);\n}\nint cpFact(int x, int y)\n{\n\twhile (gcd(x, y) != 1) {\n\t\tx = x / gcd(x, y);\n\t}\n\treturn x;\n}", "12764": "int counLastDigitK(int low, int high, int k)\n{\n\tint count = 0;\n\tfor (int i = low; i <= high; i++)\n\t\tif (i % 10 == k)\n\t\t\tcount++; \n\treturn count;\n}", "12765": "int countLastDigitK(long long low, long long high, long long K)\n{\n long long mlow = 10 * ceil(low/10.0);\n long long mhigh = 10 * floor(high/10.0);\n int count = (mhigh - mlow)/10;\n if (high % 10 >= K)\n\tcount++;\n if (low % 10 <=K && (low%10))\n\tcount++;\n return count;\n}", "12794": "double Convert(double radian)\n{\n\tdouble pi = 3.14159;\n\treturn(radian * (180 / pi));\n}", "12799": "int sn(int n, int an)\n{\n\treturn (n * (1 + an)) / 2;\n}\nint trace(int n, int m)\n{\n\tint an = 1 + (n - 1) * (m + 1);\n\tint rowmajorSum = sn(n, an);\n\tan = 1 + (n - 1) * (n + 1);\n\tint colmajorSum = sn(n, an);\n\treturn rowmajorSum + colmajorSum;\n}", "12810": "float avgOfFirstN(int n)\n{\n\treturn (float)(1 + n)/2;\n}", "12842": "int sum(int L, int R)\n{\n\tint p = R / 6;\n\tint q = (L - 1) / 6;\n\tint sumR = 3 * (p * (p + 1));\n\tint sumL = (q * (q + 1)) * 3;\n\treturn sumR - sumL;\n}", "12844": "void max_area(int n, int m, int k)\n{\n\tif (k > (n + m - 2))\n\t\tcout << \"Not possible\" << endl;\n\telse {\n\t\tint result;\n\t\tif (k < max(m, n) - 1) {\n\t\t\tresult = max(m * (n / (k + 1)), n * (m / (k + 1)));\n\t\t}\n\t\telse {\n\t\t\tresult = max(m / (k - n + 2), n / (k - m + 2));\n\t\t}\n\t\tcout << result << endl;\n\t}\n}", "12855": "string prevNum(string str)\n{\n\tint len = str.length();\n\tint index = -1;\n\tfor (int i = len - 2; i >= 0; i--) {\n\t\tif (str[i] > str[i+1])\n\t\t{\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint smallGreatDgt = -1;\n\tfor (int i = len - 1; i > index; i--) {\n\t\tif (str[i] < str[index]) {\n\t\t\tif (smallGreatDgt == -1)\n\t\t\t\tsmallGreatDgt = i;\n\t\t\telse if (str[i] >= str[smallGreatDgt])\n\t\t\t\tsmallGreatDgt = i;\n\t\t}\n\t}\n\tif (index == -1)\n\t\treturn \"-1\";\n\tif (smallGreatDgt != -1)\n\t{\n\t\tswap(str[index], str[smallGreatDgt]);\n\t\treturn str;\n\t}\n\treturn \"-1\";\n}", "12891": "int calculate_sum(int a, int N)\n{\n\tint m = N / a;\n\tint sum = m * (m + 1) / 2;\n\tint ans = a * sum;\n\treturn ans;\n}", "12895": "int horner(int poly[], int n, int x)\n{\n\tfor (int i=1; i<n; i++)\n\t\tresult = result*x + poly[i];\n\treturn result;\n}\nint findSign(int poly[], int n, int x)\n{\n int result = horner(poly, n, x);\n if (result > 0)\n\treturn 1;\n else if (result < 0)\n\treturn -1;\n return 0;\n}", "12906": "bool ispowerof2 ( cpp_int num )\n{\n\tif ( ( num & ( num - 1 ) ) == 0 )\n\t\treturn 1;\n\treturn 0; \n}", "12970": "int counDivisors(int X)\n{\n\tint count = 0;\n\tfor (int i = 1; i <= X; ++i) {\n\t\tif (X % i == 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\nint countDivisorsMult(int arr[], int n)\n{\n\tint mul = 1;\n\tfor (int i = 0; i < n; ++i)\n\t\tmul *= arr[i];\n\treturn counDivisors(mul);\n}", "12971": "void SieveOfEratosthenes(int largest, vector<int> &prime)\n{\n\tbool isPrime[largest+1];\n\tmemset(isPrime, true, sizeof(isPrime));\n\tfor (int p = 2; p * p <= largest; p++)\n\t{\n\t\tif (isPrime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * 2; i <= largest; i += p)\n\t\t\t\tisPrime[i] = false;\n\t\t}\n\t}\n\tfor (int p = 2; p <= largest; p++)\n\t\tif (isPrime[p])\n\t\t\tprime.push_back(p);\n}\nint countDivisorsMult(int arr[], int n)\n{\n\tint largest = *max_element(arr, arr+n);\n\tvector<int> prime;\n\tSieveOfEratosthenes(largest, prime);\n\tunordered_map<int, int> mp;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < prime.size(); j++)\n\t\t{\n\t\t\twhile(arr[i] > 1 && arr[i]%prime[j] == 0)\n\t\t\t{\n\t\t\t\tarr[i] /= prime[j];\n\t\t\t\tmp[prime[j]]++;\n\t\t\t}\n\t\t}\n\t\tif (arr[i] != 1)\n\t\t\tmp[arr[i]]++;\n\t}\n\tlong long int res = 1;\n\tfor (auto it : mp)\n\tres *= (it.second + 1L);\n\treturn res;\n}", "12983": "void printTaxicab2(int N)\n{\n\tint i = 1, count = 0;\n\twhile (count < N)\n\t{\n\tint int_count = 0;\n\tfor (int j = 1; j <= pow(i, 1.0/3); j++)\n\t\tfor (int k = j + 1; k <= pow(i, 1.0/3); k++)\n\t\t\tif (j*j*j + k*k*k == i)\n\t\t\t\tint_count++;\n\tif (int_count == 2)\n\t{\n\t\tcount++;\n\t\tcout << count << \" \" << i << endl; \n\t}\n\ti++;\n\t}\n}", "12991": "bool isComposite(int n)\n{\n\tif (n <= 1) return false;\n\tif (n <= 3) return false;\n\tif (n%2 == 0 n%3 == 0) return true;\n\tfor (int i=5; i*i<=n; i=i+6)\n\t\tif (n%i == 0 || n%(i+2) == 0)\n\t\treturn true;\n\treturn false;\n}", "13022": "int area_fun(int side)\n{\nint area = side * side;\nreturn area;\n}", "13040": "long int countConsecutive(long int N)\n{\n\tlong int count = 0;\n\tfor (long int L = 1; L * (L + 1) < 2 * N; L++) {\n\t\tdouble a = (1.0 * N - (L * (L + 1)) / 2) / (L + 1);\n\t\tif (a - (int)a == 0.0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "13048": "bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (int i = 2; i < n; i++)\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nint findPrime(int n)\n{\n\tint num = n + 1;\n\twhile (num)\n\t{\n\t\tif (isPrime(num))\n\t\t\treturn num;\n\t\tnum = num + 1;\n\t}\n\treturn 0;\n}\nint minNumber(int arr[], int n)\n{\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += arr[i];\n\tif (isPrime(sum))\n\t\treturn 0;\n\tint num = findPrime(sum);\n\treturn num - sum;\n}", "13049": "void sieveOfEratostheneses()\n{\n\tmemset(isPrime, true, sizeof(isPrime));\n\tisPrime[1] = false;\n\tfor (int i = 2; i * i < MAX; i++)\n\t{\n\t\tif (isPrime[i])\n\t\t{\n\t\t\tfor (int j = 2 * i; j < MAX; j += i)\n\t\t\t\tisPrime[j] = false;\n\t\t}\n\t}\n}\nint findPrime(int n)\n{\n\tint num = n + 1;\n\twhile (num)\n\t{\n\t\tif (isPrime[num])\n\t\t\treturn num;\n\t\tnum = num + 1;\n\t}\n\treturn 0;\n}\nint minNumber(int arr[], int n)\n{\n\tsieveOfEratostheneses();\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += arr[i];\n\tif (isPrime[sum])\n\t\treturn 0;\n\tint num = findPrime(sum);\n\treturn num - sum;\n}", "13140": "int fact(int n)\n{\n\tif (n == 0)\n\t\treturn 1;\n\treturn n * fact(n - 1);\n}\nint div(int x)\n{\n\tint ans = 0;\n\tfor (int i = 1; i<= x; i++)\n\t\tif (x % i == 0)\n\t\t\tans += i;\n\treturn ans;\n}\nint sumFactDiv(int n)\n{\n\treturn div(fact(n));\n}", "13141": "void sieve(int n)\n{\n\tvector<bool> prime(n+1, true);\n\tfor (int p = 2; p*p <= n; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (int i = p*2; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tallPrimes.push_back(p);\n}\nint factorialDivisors(int n)\n{\n\tint result = 1;\n\tfor (int i = 0; i < allPrimes.size(); i++)\n\t{\n\t\tint p = allPrimes[i];\n\t\tint exp = 0;\n\t\twhile (p <= n)\n\t\t{\n\t\t\texp = exp + (n/p);\n\t\t\tp = p*allPrimes[i];\n\t\t}\n\t\tresult = result*(pow(allPrimes[i], exp+1)-1)/\n\t\t\t\t\t\t\t\t\t(allPrimes[i]-1);\n\t}\n\treturn result;\n}", "13144": "bool isAutomorphic(int N)\n{\n\tint sq = N * N;\n\twhile (N > 0) {\n\t\tif (N % 10 != sq % 10)\n\t\t\treturn false;\n\t\tN /= 10;\n\t\tsq /= 10;\n\t}\n\treturn true;\n}", "13179": "bool checkPandigital(int b, char n[])\n{\n\tif (strlen(n) < b)\n\t\treturn false;\n\tbool hash[b];\n\tmemset(hash, false, sizeof(hash));\n\tfor (int i = 0; i < strlen(n); i++)\n\t{\n\t\tif (n[i] >= '0' && n[i] <= '9')\n\t\t\thash[n[i] - '0'] = true;\n\t\telse if (n[i] - 'A' <= b - 11)\n\t\t\thash[n[i] - 'A' + 10] = true;\n\t}\n\tfor (int i = 0; i < b; i++)\n\t\tif (hash[i] == false)\n\t\t\treturn false;\n\treturn true;\n}", "13180": "int convert(int m, int n)\n{\n\tif (m == n)\n\t\treturn 0;\n\tif (m > n)\n\t\treturn m - n;\n\tif (m <= 0 && n > 0)\n\t\treturn -1;\n\tif (n % 2 == 1)\n\t\treturn 1 + convert(m, n + 1);\n\telse\n\t\treturn 1 + convert(m, n / 2);\n}", "13236": "int getDigitProduct(int x)\n{\n\tif (x < 10)\n\treturn x;\n\tif (prodDig[x] != 0)\n\treturn prodDig[x];\n\tint prod = (x % 10) * getDigitProduct(x/10);\n\treturn (prodDig[x] = prod);\n}\nvoid findSeed(int n)\n{\n\tvector<int> res;\n\tfor (int i=1; i<=n/2; i++)\n\t\tif (i*getDigitProduct(i) == n)\n\t\t\tres.push_back(i);\n\tif (res.size() == 0)\n\t{\n\t\tcout << \"NO seed exists\\n\";\n\t\treturn;\n\t}\n\tfor (int i=0; i<res.size(); i++)\n\t\tcout << res[i] << \" \";\n}", "13240": "int maxPrimefactorNum(int N)\n{\n\tint arr[N + 5];\n\tmemset(arr, 0, sizeof(arr));\n\tfor (int i = 2; i*i <= N; i++)\n\t{\n\t\tif (!arr[i])\n\t\t\tfor (int j = 2*i; j <= N; j+=i)\n\t\t\t\tarr[j]++;\n\t\tarr[i] = 1;\n\t}\n\tint maxval = 0, maxint = 1;\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tif (arr[i] > maxval)\n\t\t{\n\t\t\tmaxval = arr[i];\n\t\t\tmaxint = i;\n\t\t}\n\t}\n\treturn maxint;\n}", "13241": "int maxPrimefactorNum(int N)\n{\n\tbool arr[N + 5];\n\tmemset(arr, true, sizeof(arr));\n\tfor (int i = 3; i*i <= N; i += 2)\n\t{\n\t\tif (arr[i])\n\t\t\tfor (int j = i*i; j <= N; j+=i)\n\t\t\t\tarr[j] = false;\n\t}\n\tvector<int> prime;\n\tprime.push_back(2);\n\tfor(int i = 3; i <= N; i += 2)\n\t\tif(arr[i])\n\t\t\tprime.push_back(i);\n\tint i = 0, ans = 1;\n\twhile (ans*prime[i] <= N && i < prime.size())\n\t{\n\t\tans *= prime[i];\n\t\ti++;\n\t}\n\treturn ans;\n}", "13250": "long int SubArraySum(int arr[], int n)\n{\n\tlong int result = 0,temp=0;\n\tfor (int i=0; i <n; i++)\n\t{\n\t\ttemp=0;\n\t\tfor (int j=i; j<n; j++)\n\t\t{\n\t\t\ttemp+=arr[j];\n\t\t\tresult += temp ;\n\t\t}\n\t}\n\treturn result ;\n}", "13251": "long int SubArraySum( int arr[] , int n )\n{\n\tlong int result = 0;\n\tfor (int i=0; i<n; i++)\n\t\tresult += (arr[i] * (i+1) * (n-i));\n\treturn result ;\n}", "13288": "int highestPowerof2(int n)\n{\n\tint res = 0;\n\tfor (int i=n; i>=1; i--)\n\t{\n\t\tif ((i & (i-1)) == 0)\n\t\t{\n\t\t\tres = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}", "13290": "int highestPowerof2(int n)\n{\n int p = (int)log2(n);\n return (int)pow(2, p);\n}", "13291": "unsigned highestPowerof2(unsigned x)\n{\n\tx |= x >> 1;\n\tx |= x >> 2;\n\tx |= x >> 4;\n\tx |= x >> 8;\n\tx |= x >> 16;\n\treturn x ^ (x >> 1);\n}", "13307": "unsigned int aModM(string s, unsigned int mod)\n{\n\tunsigned int number = 0;\n\tfor (unsigned int i = 0; i < s.length(); i++)\n\t{\n\t\tnumber = (number*10 + (s[i] - '0'));\n\t\tnumber %= mod;\n\t}\n\treturn number;\n}\nunsigned int ApowBmodM(string &a, unsigned int b, unsigned int m)\n{\n\tunsigned int ans = aModM(a, m);\n\tunsigned int mul = ans;\n\tfor (unsigned int i=1; i<b; i++)\n\t\tans = (ans*mul) % m;\n\treturn ans;\n}", "13352": "int divSum(int num)\n{\n\tint result = 0;\n\tif(num == 1) \n\treturn result;\n\tfor (int i=2; i<=sqrt(num); i++)\n\t{\n\t\tif (num%i==0)\n\t\t{\n\t\t\tif (i==(num/i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + num/i);\n\t\t}\n\t}\n\treturn (result + 1);\n}", "13400": "void findPairs(int n)\n{\n\tint cubeRoot = pow(n, 1.0 / 3.0);\n\tint cube[cubeRoot + 1];\n\tfor (int i = 1; i <= cubeRoot; i++)\n\t\tcube[i] = i*i*i;\n\tint l = 1;\n\tint r = cubeRoot;\n\twhile (l < r)\n\t{\n\t\tif (cube[l] + cube[r] < n)\n\t\t\tl++;\n\t\telse if(cube[l] + cube[r] > n)\n\t\t\tr--;\n\t\telse {\n\t\t\tcout << \"(\" << l << \", \" << r << \")\" << endl;\n\t\t\tl++; r--;\n\t\t}\n\t}\n}", "13401": "void findPairs(int n)\n{\n\tint cubeRoot = pow(n, 1.0/3.0);\n\tunordered_map<int, pair<int, int> > s;\n\tfor (int x = 1; x < cubeRoot; x++)\n\t{\n\t\tfor (int y = x + 1; y <= cubeRoot; y++)\n\t\t{\n\t\t\tint sum = x*x*x + y*y*y;\n\t\t\tif (sum != n)\n\t\t\t\tcontinue;\n\t\t\tif (s.find(sum) != s.end())\n\t\t\t{\n\t\t\t\tcout << \"(\" << s[sum].first << \", \" << s[sum].second << \") and (\" << x << \", \" << y << \")\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t\ts[sum] = make_pair(x, y);\n\t\t}\n\t}\n}", "13409": "int gcd(int a, int b)\n{\n\twhile (b != 0)\n\t{\n\t\tint t = b;\n\t\tb = a % b;\n\t\ta = t;\n\t}\n\treturn a;\n}\nint findMinDiff(int a, int b, int x, int y)\n{\n\tint g = gcd(a,b);\n\tint diff = abs(x-y) % g;\n\treturn min(diff, g - diff);\n}", "13429": "void printDivisors(int n)\n{\n\tvector<int> v;\n\tfor (int i = 1; i <= sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (n / i == i)\n\t\t\t\tprintf(\"%d \", i);\n\t\t\telse {\n\t\t\t\tprintf(\"%d \", i);\n\t\t\t\tv.push_back(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = v.size() - 1; i >= 0; i--)\n\t\tprintf(\"%d \", v[i]);\n}", "13430": "void printDivisors(int n)\n{\n\tint i;\n\tfor (i = 1; i * i < n; i++) {\n\t\tif (n % i == 0)\n\t\t\tcout<<i<<\" \";\n\t}\n\tif (i - (n / i) == 1) {\n\t\ti--;\n\t}\n\tfor (; i >= 1; i--) {\n\t\tif (n % i == 0)\n\t\t\tcout<<n / i<<\" \";\n\t}\n}", "13431": "void printDivisors(int n)\n{\n\tfor (int i = 1; i <= n; i++)\n\t\tif (n % i == 0)\n\t\t\tcout <<\" \" << i;\n}", "13432": "void printDivisors(int n)\n{\n\tfor (int i=1; i<=sqrt(n); i++)\n\t{\n\t\tif (n%i == 0)\n\t\t{\n\t\t\tif (n/i == i)\n\t\t\t\tcout <<\" \"<< i;\n\t\t\t\tcout << \" \"<< i << \" \" << n/i;\n\t\t}\n\t}\n}", "13448": "double interpolate(Data f[], int xi, int n)\n{\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tdouble term = f[i].y;\n\t\tfor (int j=0;j<n;j++)\n\t\t{\n\t\t\tif (j!=i)\n\t\t\t\tterm = term*(xi - f[j].x)/double(f[i].x - f[j].x);\n\t\t}\n\t\tresult += term;\n\t}\n\treturn result;\n}", "13453": "int SieveOfAtkin(int limit)\n{\n\tif (limit > 2)\n\t\tcout << 2 << \" \";\n\tif (limit > 3)\n\t\tcout << 3 << \" \";\n\tbool sieve[limit];\n\tfor (int i = 0; i < limit; i++)\n\t\tsieve[i] = false;\n\tfor (int x = 1; x * x < limit; x++) {\n\t\tfor (int y = 1; y * y < limit; y++) {\n\t\t\tint n = (4 * x * x) + (y * y);\n\t\t\tif (n <= limit && (n % 12 == 1 n % 12 == 5))\n\t\t\t\tsieve[n] ^= true;\n\t\t\tn = (3 * x * x) + (y * y);\n\t\t\tif (n <= limit && n % 12 == 7)\n\t\t\t\tsieve[n] ^= true;\n\t\t\tn = (3 * x * x) - (y * y);\n\t\t\tif (x > y && n <= limit && n % 12 == 11)\n\t\t\t\tsieve[n] ^= true;\n\t\t}\n\t}\n\tfor (int r = 5; r * r < limit; r++) {\n\t\tif (sieve[r]) {\n\t\t\tfor (int i = r * r; i < limit; i += r * r)\n\t\t\t\tsieve[i] = false;\n\t\t}\n\t}\n\tfor (int a = 5; a < limit; a++)\n\t\tif (sieve[a])\n\t\t\tcout << a << \" \";\n}", "13454": "int SieveOfSundaram(int n)\n{\n\tint nNew = (n-1)/2;\n\tbool marked[nNew + 1];\n\tmemset(marked, false, sizeof(marked));\n\tfor (int i=1; i<=nNew; i++)\n\t\tfor (int j=i; (i + j + 2*i*j) <= nNew; j++)\n\t\t\tmarked[i + j + 2*i*j] = true;\n\tif (n > 2)\n\t\tcout << 2 << \" \";\n\tfor (int i=1; i<=nNew; i++)\n\t\tif (marked[i] == false)\n\t\t\tcout << 2*i + 1 << \" \";\n}", "13460": "int power(int x, int y, int p)\n{\n\twhile (y > 0)\n\t{\n\t\tif (y & 1)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nvoid squareRoot(int n, int p)\n{\n\tif (p % 4 != 3) {\n\t\tcout << \"Invalid Input\";\n\t\treturn;\n\t}\n\tn = n % p;\n\tint x = power(n, (p + 1) / 4, p);\n\tif ((x * x) % p == n) {\n\t\tcout << \"Square root is \" << x;\n\t\treturn;\n\t}\n\tx = p - x;\n\tif ((x * x) % p == n) {\n\t\tcout << \"Square root is \" << x;\n\t\treturn;\n\t}\n\tcout << \"Square root doesn't exist \";\n}", "13468": "int power(int x, unsigned int y, int p)\n{\n\tint res = 1;\t\n\tx = x % p; \n\twhile (y > 0)\n\t{\n\t\tif (y & 1)\n\t\t\tres = (res*x) % p;\n\t\tx = (x*x) % p;\n\t}\n\treturn res;\n}\nbool miillerTest(int d, int n)\n{\n\tint a = 2 + rand() % (n - 4);\n\tint x = power(a, d, n);\n\tif (x == 1 x == n-1)\n\treturn true;\n\twhile (d != n-1)\n\t{\n\t\tx = (x * x) % n;\n\t\td *= 2;\n\t\tif (x == 1)\treturn false;\n\t\tif (x == n-1)\treturn true;\n\t}\n\treturn false;\n}\nbool isPrime(int n, int k)\n{\n\tif (n <= 1 n == 4) return false;\n\tif (n <= 3) return true;\n\tint d = n - 1;\n\twhile (d % 2 == 0)\n\t\td /= 2;\n\tfor (int i = 0; i < k; i++)\n\t\tif (!miillerTest(d, n))\n\t\t\treturn false;\n\treturn true;\n}", "13489": "bool isInside(int circle_x, int circle_y, int rad, int x, int y)\n{\n\tif ((x - circle_x) * (x - circle_x) +\n\t\t(y - circle_y) * (y - circle_y) <= rad * rad)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "13501": "int eval(int a, char op, int b)\n{\n\tif (op=='+') return a+b;\n\tif (op=='-') return a-b;\n\tif (op == '*') return a*b;\n}\nvector<int> evaluateAll(string expr, int low, int high)\n{\n\tvector<int> res;\n\tif (low == high)\n\t{\n\t\tres.push_back(expr[low] - '0');\n\t\treturn res;\n\t}\n\tif (low == (high-2))\n\t{\n\t\tint num = eval(expr[low]-'0', expr[low+1], expr[low+2]-'0');\n\t\tres.push_back(num);\n\t\treturn res;\n\t}\n\tfor (int i=low+1; i<=high; i+=2)\n\t{\n\t\tvector<int> l = evaluateAll(expr, low, i-1);\n\t\tvector<int> r = evaluateAll(expr, i+1, high);\n\t\tfor (int s1=0; s1<l.size(); s1++)\n\t\t{\n\t\t\tfor (int s2=0; s2<r.size(); s2++)\n\t\t\t{\n\t\t\t\tint val = eval(l[s1], expr[i], r[s2]);\n\t\t\t\tres.push_back(val);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "13504": "bool isLucky(int n)\n{\n\tbool arr[10];\n\tfor (int i=0; i<10; i++)\n\t\tarr[i] = false;\n\twhile (n > 0)\n\t{\n\t\tint digit = n%10;\n\t\tif (arr[digit])\n\t\treturn false;\n\t\tarr[digit] = true;\n\t\tn = n/10;\n\t}\n\treturn true;\n}", "13535": "void printSquares(int n)\n{\n\tint square = 0, odd = 1;\n\tfor (int x = 0; x < n; x++)\n\t{\n\t\tcout << square << \" \";\n\t\tsquare = square + odd;\n\t\todd = odd + 2;\n\t}\n}", "13575": "int reversDigits(int num)\n{\n\tstatic int rev_num = 0;\n\tstatic int base_pos = 1;\n\tif (num > 0) {\n\t\treversDigits(num / 10);\n\t\trev_num += (num % 10) * base_pos;\n\t\tbase_pos *= 10;\n\t}\n\treturn rev_num;\n}", "13606": "void constructArray(int A[], int N, int K)\n{\n\tint B[N];\n\tint totalXOR = A[0] ^ K;\n\tfor (int i = 0; i < N; i++)\n\t\tB[i] = totalXOR ^ A[i];\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << B[i] << \" \";\n\t}\n}", "13633": "int RecursiveFunction(vector<int> ref, int bit)\n{\n\tif (ref.size() == 0 bit < 0)\n\t\treturn 0;\n\tvector<int> curr_on, curr_off;\n\tfor (int i = 0; i < ref.size(); i++)\n\t{\n\t\tif (((ref[i] >> bit) & 1) == 0)\n\t\t\tcurr_off.push_back(ref[i]);\n\t\telse\n\t\t\tcurr_on.push_back(ref[i]);\n\t}\n\tif (curr_off.size() == 0)\n\t\treturn RecursiveFunction(curr_on, bit - 1);\n\tif (curr_on.size() == 0)\n\t\treturn RecursiveFunction(curr_off, bit - 1);\n\treturn min(RecursiveFunction(curr_off, bit - 1),\n\t\t\tRecursiveFunction(curr_on, bit - 1))\n\t\t+ (1 << bit);\n}\nvoid PrintMinimum(int a[], int n)\n{\n\tvector<int> v;\n\tfor (int i = 0; i < n; i++)\n\t\tv.push_back(a[i]);\n\tcout << RecursiveFunction(v, 30)\n\t\t<< \"\\n\";\n}", "13660": "int extraElement(int A[], int B[], int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans ^= A[i];\n\tfor (int i = 0; i < n + 1; i++)\n\t\tans ^= B[i];\n\treturn ans;\n}", "13671": "int cntElements(int arr[], int n)\n{\n\tint cnt = 0;\n\tfor (int i = 0; i < n - 2; i++) {\n\t\tif (arr[i] == (arr[i + 1] ^ arr[i + 2])) {\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}", "13672": "int xor_triplet(int arr[], int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\tint xor1 = 0, xor2 = 0;\n\t\t\t\tfor (int x = i; x < j; x++) {\n\t\t\t\t\txor1 ^= arr[x];\n\t\t\t\t}\n\t\t\t\tfor (int x = j; x <= k; x++) {\n\t\t\t\t\txor2 ^= arr[x];\n\t\t\t\t}\n\t\t\t\tif (xor1 == xor2) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}", "13673": "void insert(TrieNode* node, int num, int index)\n{\n\tfor (int bits = lg; bits >= 0; bits--) {\n\t\tint curr_bit = (num >> bits) & 1;\n\t\tif (node->children[curr_bit] == nullptr) {\n\t\t\tnode->children[curr_bit]\n\t\t\t\t= new TrieNode();\n\t\t}\n\t\tnode = node->children[curr_bit];\n\t}\n\tnode->sum_of_indexes += index;\n\tnode->number_of_indexes++;\n}\nint query(TrieNode* node, int num, int index)\n{\n\tfor (int bits = lg; bits >= 0; bits--) {\n\t\tint curr_bit = (num >> bits) & 1;\n\t\tif (node->children[curr_bit] == nullptr) {\n\t\t\treturn 0;\n\t\t}\n\t\tnode = node->children[curr_bit];\n\t}\n\tint sz = node->number_of_indexes;\n\tint sum = node->sum_of_indexes;\n\tint ans = (sz * index) - (sum);\n\treturn ans;\n}\nint no_of_triplets(int arr[], int n)\n{\n\tint curr_xor = 0;\n\tint number_of_triplets = 0;\n\tTrieNode* root = new TrieNode();\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = arr[i];\n\t\tinsert(root, curr_xor, i);\n\t\tcurr_xor ^= x;\n\t\tnumber_of_triplets\n\t\t\t+= query(root, curr_xor, i);\n\t}\n\treturn number_of_triplets;\n}\nTrieNode()\n\t{\n\t\tthis->children[0] = nullptr;\n\t\tthis->children[1] = nullptr;\n\t\tthis->sum_of_indexes = 0;\n\t\tthis->number_of_indexes = 0;\n\t}", "13684": "long long bit_q(int i, int j)\n{\n\tlong long sum = 0ll;\n\twhile (j > 0) {\n\t\tsum += bit[j];\n\t\tj -= (j & (j * -1));\n\t}\n\ti--;\n\twhile (i > 0) {\n\t\tsum -= bit[i];\n\t\ti -= (i & (i * -1));\n\t}\n\treturn sum;\n}\nvoid bit_up(int i, long long diff)\n{\n\twhile (i <= n) {\n\t\tbit[i] += diff;\n\t\ti += i & -i;\n\t}\n}\nvoid dfs(int node)\n{\n\tIdeal_pair += bit_q(max(1, node - k),\n\t\t\t\t\t\tmin(n, node + k));\n\tbit_up(node, 1);\n\tfor (int i = 0; i < al[node].size(); i++)\n\t\tdfs(al[node][i]);\n\tbit_up(node, -1);\n}\nvoid initialise()\n{\n\tIdeal_pair = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\troot_node[i] = true;\n\t\tbit[i] = 0LL;\n\t}\n}\nvoid Add_Edge(int x, int y)\n{\n\tal[x].push_back(y);\n\troot_node[y] = false;\n}\nlong long Idealpairs()\n{\n\tint r = -1;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (root_node[i]) {\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\tdfs(r);\n\treturn Ideal_pair;\n}", "13757": "int hammingDistance(int n1, int n2)\n{\n\tint x = n1 ^ n2;\n\tint setBits = 0;\n\twhile (x > 0) {\n\t\tsetBits += x & 1;\n\t\tx >>= 1;\n\t}\n\treturn setBits;\n}", "13829": "void printSubsets(int n) {\n for (int i = 0; i <= n; i++)\n\tif ((n & i) == i)\n\tcout << i << \" \";\n}", "13830": "void printSubsets(int n) {\n for (int i = n; i > 0; i = (i - 1) & n)\n\tcout << i << \" \";\n cout << 0;\n}", "13875": "bool isDivisibleby17(int n)\n{\n\tif (n == 0 n == 17)\n\t\treturn true;\n\tif (n < 17)\n\t\treturn false;\n\treturn isDivisibleby17((int)(n >> 4) - (int)(n & 15));\n}", "13876": "long long answer(long long n)\n{\n\tlong m = 2;\n\tlong long ans = 1;\n\tlong long r = 1;\n\twhile (r < n) {\n\t\tr = (int)(pow(2, m) - 1) * (pow(2, m - 1));\n\t\tif (r < n)\n\t\t\tans = r;\n\t\tm++;\n\t}\n\treturn ans;\n}", "13897": "int setBitNumber(int n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tint msb = 0;\n\tn = n / 2;\n\twhile (n != 0) {\n\t\tn = n / 2;\n\t\tmsb++;\n\t}\n\treturn (1 << msb);\n}", "13898": "int setBitNumber(int n)\n{\n\tn |= n >> 1;\n\tn |= n >> 2;\n\tn |= n >> 4;\n\tn |= n >> 8;\n\tn |= n >> 16;\n\tn = n + 1;\n\treturn (n >> 1);\n}", "13899": "int setBitNumber(int n)\n{\n\tint k = (int)(log2(n));\n\treturn 1 << k;\n}", "13966": "int countTrailingZero(int x)\n{\n int count = 0;\n while ((x & 1) == 0)\n {\n\tx = x >> 1;\n\tcount++;\n }\n return count;\n}", "13967": "int countTrailingZero(int x)\n{\n\tstatic const int lookup[] = {32, 0, 1,\n\t26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11,\n\t0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29,\n\t10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19,\n\t18};\n\treturn lookup[(-x & x) % 37];\n}", "13987": "int maxConsecutiveOnes(int x)\n{\n\tint count = 0;\n\twhile (x!=0)\n\t{\n\t\tx = (x & (x << 1));\n\t\tcount++;\n\t}\n\treturn count;\n}", "14020": "int multiplyBySevenByEight(int n)\n{\n\treturn (n - (n >> 3));\n}", "14022": "int subtract(int x, int y)\n{\n\twhile (y != 0)\n\t{\n\t\tint borrow = (~x) & y;\n\t\tx = x ^ y;\n\t\ty = borrow << 1;\n\t}\n\treturn x;\n}", "14023": "int subtract(int x, int y)\n{\n\tif (y == 0)\n\t\treturn x;\n\treturn subtract(x ^ y, (~x & y) << 1);\n}"}, "Java": {"451": "static int minCost(int cost[][])\n\t{\n\t\tint dist[] = new int[N];\n\t\tfor (int i=0; i<N; i++)\n\t\tdist[i] = INF;\n\t\tdist[0] = 0;\n\t\tfor (int i=0; i<N; i++)\n\t\tfor (int j=i+1; j<N; j++)\n\t\t\tif (dist[j] > dist[i] + cost[i][j])\n\t\t\t\tdist[j] = dist[i] + cost[i][j];\n\t\treturn dist[N-1];\n\t}", "455": "static int numOfways(int n, int k)\n\t{\n\t\tint p = 1;\n\t\tif (k % 2 != 0)\n\t\t\tp = -1;\n\t\treturn (int)(Math.pow(n - 1, k)\n\t\t\t\t\t+ p * (n - 1)) / n;\n\t}", "496": "static int fib(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn n;\n\t\treturn fib(n - 1) + fib(n - 2);\n\t}\nstatic int findVertices (int n)\n\t{\n\t\treturn fib(n + 2);\n\t}", "617": "static Node reverse( Node head_ref)\n{\n\tNode temp = null;\n\tNode current = head_ref;\n\twhile (current != null)\n\t{\n\t\ttemp = current.prev;\n\t\tcurrent.prev = current.next;\n\t\tcurrent.next = temp;\n\t\tcurrent = current.prev;\n\t}\n\tif (temp != null)\n\t\thead_ref = temp.prev;\n\t\treturn head_ref;\n}\nstatic Node merge(Node first, Node second)\n{\n\tif (first == null)\n\t\treturn second;\n\tif (second == null)\n\t\treturn first;\n\tif (first.data < second.data)\n\t{\n\t\tfirst.next = merge(first.next, second);\n\t\tfirst.next.prev = first;\n\t\tfirst.prev = null;\n\t\treturn first;\n\t}\n\telse\n\t{\n\t\tsecond.next = merge(first, second.next);\n\t\tsecond.next.prev = second;\n\t\tsecond.prev = null;\n\t\treturn second;\n\t}\n}\nstatic Node sort(Node head)\n{\n\tif (head == null head.next == null)\n\t\treturn head;\n\tNode current = head.next;\n\twhile (current != null)\n\t{\n\t\tif (current.data < current.prev.data)\n\t\t\tbreak;\n\t\tcurrent = current.next;\n\t}\n\tif (current == null)\n\t\treturn head;\n\tcurrent.prev.next = null;\n\tcurrent.prev = null;\n\tcurrent = reverse(current);\n\treturn merge(head, current);\n}\nstatic Node push( Node head_ref, int new_data)\n{\n\tNode new_node = new Node();\n\tnew_node.data = new_data;\n\tnew_node.prev = null;\n\tnew_node.next = (head_ref);\n\tif ((head_ref) != null)\n\t\t(head_ref).prev = new_node;\n\t(head_ref) = new_node;\n\treturn head_ref;\n}\nstatic void printList( Node head)\n{\n\tif (head == null)\n\t\tSystem.out.println(\"Doubly Linked list empty\");\n\twhile (head != null)\n\t{\n\t\tSystem.out.print(head.data + \" \");\n\t\thead = head.next;\n\t}\n}", "647": "static Node newNode(char key)\n{\n\tNode temp = new Node();\n\ttemp.data = key;\n\ttemp.next = null;\n\treturn temp;\n}\nstatic void printlist(Node head)\n{\n\tif (head == null)\n\t{\n\t\tSystem.out.println(\"Empty List\");\n\t\treturn;\n\t}\n\twhile (head != null)\n\t{\n\t\tSystem.out.print(head.data +\" \");\n\t\tif (head.next != null)\n\t\tSystem.out.print(\"-> \");\n\t\thead = head.next;\n\t}\n\tSystem.out.println();\n}\nstatic boolean isVowel(char x)\n{\n\treturn (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n}\nstatic Node arrange(Node head)\n{\n\tNode newHead = head;\n\tNode latestVowel;\n\tNode curr = head;\n\tif (head == null)\n\t\treturn null;\n\tif (isVowel(head.data) == true)\n\t\tlatestVowel = head;\n\telse\n\t{\n\t\twhile (curr.next != null &&\n\t\t\t!isVowel(curr.next.data))\n\t\t\tcurr = curr.next;\n\t\tif (curr.next == null)\n\t\t\treturn head;\n\t\tlatestVowel = newHead = curr.next;\n\t\tcurr.next = curr.next.next;\n\t\tlatestVowel.next = head;\n\t}\n\twhile (curr != null && curr.next != null)\n\t{\n\t\tif (isVowel(curr.next.data) == true)\n\t\t{\n\t\t\tif (curr == latestVowel)\n\t\t\t{\n\t\t\t\tlatestVowel = curr = curr.next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNode temp = latestVowel.next;\n\t\t\t\tlatestVowel.next = curr.next;\n\t\t\t\tlatestVowel = latestVowel.next;\n\t\t\t\tcurr.next = curr.next.next;\n\t\t\t\tlatestVowel.next = temp;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurr = curr.next;\n\t\t}\n\t}\n\treturn newHead;\n}", "694": "static Node newNode(int data)\n{\n\tNode temp = new Node();\n\ttemp.data = data;\n\ttemp.right = null;\n\ttemp.left = null;\n\treturn temp;\n}\nstatic Node KthLargestUsingMorrisTraversal(Node root, int k)\n{\n\tNode curr = root;\n\tNode Klargest = null;\n\tint count = 0;\n\twhile (curr != null)\n\t{\n\t\tif (curr.right == null)\n\t\t{\n\t\t\tif (++count == k)\n\t\t\t\tKlargest = curr;\n\t\t\tcurr = curr.left;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNode succ = curr.right;\n\t\t\twhile (succ.left != null && succ.left != curr)\n\t\t\t\tsucc = succ.left;\n\t\t\tif (succ.left == null)\n\t\t\t{\n\t\t\t\tsucc.left = curr;\n\t\t\t\tcurr = curr.right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsucc.left = null;\n\t\t\t\tif (++count == k)\n\t\t\t\t\tKlargest = curr;\n\t\t\t\tcurr = curr.left;\n\t\t\t}\n\t\t}\n\t}\n\treturn Klargest;\n}", "803": "static void sortByRow(Integer mat[][], int n, boolean ascending)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ascending)\n\t\t\t\tArrays.sort(mat[i]);\n\t\t\telse\n\t\t\t\tArrays.sort(mat[i],Collections.reverseOrder());\n\t\t}\t\n\t}\nstatic void transpose(Integer mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tint temp = mat[i][j];\n\t\t\t\tmat[i][j] = mat[j][i];\n\t\t\t\tmat[j][i] = temp;\n\t\t\t}\n\t}\nstatic void sortMatRowAndColWise(Integer mat[][], int n)\n\t{\n\t\tsortByRow(mat, n, true);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n, false);\n\t\ttranspose(mat, n);\n\t}\nstatic void printMat(Integer mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(mat[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "815": "static void sortByRow(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tArrays.sort(mat[i]);\n\t}\nstatic void transpose(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\tint temp=mat[i][j];\n\t\t\t\tmat[i][j]=mat[j][i];\n\t\t\t\tmat[j][i]=temp;\n\t\t\t\t}\n\t}\nstatic void sortMatRowAndColWise(int mat[][],int n)\n\t{\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t}\nstatic void printMat(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(mat[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "818": "static void doublyEven(int n)\n\t{\n\t\tint[][] arr = new int[n][n];\n\t\tint i, j;\n\t\tfor ( i = 0; i < n; i++)\n\t\t\tfor ( j = 0; j < n; j++)\n\t\t\t\tarr[i][j] = (n*i) + j + 1;\n\t\tfor ( i = 0; i < n/4; i++)\n\t\t\tfor ( j = 0; j < n/4; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = 0; i < n/4; i++)\n\t\t\tfor ( j = 3 * (n/4); j < n; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = 3 * n/4; i < n; i++)\n\t\t\tfor ( j = 0; j < n/4; j++)\n\t\t\t\tarr[i][j] = (n*n+1) - arr[i][j];\n\t\tfor ( i = 3 * n/4; i < n; i++)\n\t\t\tfor ( j = 3 * n/4; j < n; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = n/4; i < 3 * n/4; i++)\n\t\t\tfor ( j = n/4; j < 3 * n/4; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tfor ( j = 0; j < n; j++)\n\t\t\t\tSystem.out.print(arr[i][j]+\" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "821": "static void Kroneckerproduct(int A[][], int B[][])\n\t{\n\t\tint[][] C= new int[rowa * rowb][cola * colb];\n\t\tfor (int i = 0; i < rowa; i++)\n\t\t{\n\t\t\tfor (int k = 0; k < rowb; k++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < cola; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < colb; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tC[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n\t\t\t\t\t\tSystem.out.print( C[i + l + 1][j + k + 1]+\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}", "832": "boolean isLowerTriangularMatrix(int mat[][])\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\tif (mat[i][j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "833": "public static Boolean isUpperTriangularMatrix(int mat[][])\n\t{\n\t\tfor (int i = 1; i < N ; i++)\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tif (mat[i][j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "846": "static long countSets(int a[][]) {\n\tlong res = 0;\n\tfor (int i = 0; i < n; i++) {\n\tint u = 0, v = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tif (a[i][j] == 1)\n\t\tu++;\n\t\telse\n\t\tv++;\n\t}\n\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\tint u = 0, v = 0;\n\tfor (int j = 0; j < n; j++) {\n\t\tif (a[j][i] == 1)\n\t\tu++;\n\t\telse\n\t\tv++;\n\t}\n\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t}\n\treturn res - (n * m);\n}", "861": "static void transpose(int mat[][], int tr[][], int N)\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\ttr[i][j] = mat[j][i];\n}\nstatic boolean isSymmetric(int mat[][], int N)\n{\n\tint tr[][] = new int[N][MAX];\n\ttranspose(mat, tr, N);\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != tr[i][j])\n\t\t\t\treturn false;\n\treturn true;\n}", "862": "static boolean isSymmetric(int mat[][], int N)\n{\n\tfor (int i = 0; i < N; i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != mat[j][i])\n\t\t\t\treturn false;\n\treturn true;\n}", "883": "static int findNormal(int mat[][], int n)\n{\n\tint sum = 0;\n\tfor (int i=0; i<n; i++)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tsum += mat[i][j]*mat[i][j];\n\treturn (int)Math.sqrt(sum);\n}\nstatic int findTrace(int mat[][], int n)\n{\n\tint sum = 0;\n\tfor (int i=0; i<n; i++)\n\t\tsum += mat[i][i];\n\treturn sum;\n}", "895": "static int maxDet(int n)\n{\n\treturn (2 * n * n * n);\n}\nvoid resMatrix(int n)\n{\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (i == 0 && j == 2)\n\t\t\t\tSystem.out.print(\"0 \");\n\t\t\telse if (i == 1 && j == 0)\n\t\t\t\tSystem.out.print(\"0 \");\n\t\t\telse if (i == 2 && j == 1)\n\t\t\t\tSystem.out.print(\"0 \");\n\t\t\telse\n\t\t\t\tSystem.out.print(n +\" \");\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}", "918": "static int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (M[i][j] < 0)\n\t\t\t\t\tcount += 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "919": "static int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = m - 1;\n\t\twhile (j >= 0 && i < n) {\n\t\t\tif (M[i][j] < 0) {\n\t\t\t\tcount += j + 1;\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tj -= 1;\n\t\t}\n\t\treturn count;\n\t}", "920": "static int getLastNegativeIndex(int array[], int start, int end)\n\t{\n\t\tif (start == end) {\n\t\t\treturn start;\n\t\t}\n\t\tint mid = start + (end - start) / 2;\n\t\tif (array[mid] < 0) {\n\t\t\tif (mid + 1 < array.length && array[mid + 1] >= 0) {\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\treturn getLastNegativeIndex(array, mid + 1, end);\n\t\t}\n\t\telse {\n\t\t\treturn getLastNegativeIndex(array, start, mid - 1);\n\t\t}\n\t}\nstatic int countNegative(int M[][], int n, int m)\n\t{\n\t\tint count = 0;\n\t\tint nextEnd = m - 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (M[i][0] >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextEnd = getLastNegativeIndex(M[i], 0, nextEnd);\n\t\t\tcount += nextEnd + 1;\n\t\t}\n\t\treturn count;\n\t}", "926": "static int findMaxValue(int N,int mat[][])\n\t{\n\t\tint maxValue = Integer.MIN_VALUE;\n\t\tfor (int a = 0; a < N - 1; a++)\n\t\tfor (int b = 0; b < N - 1; b++)\n\t\t\tfor (int d = a + 1; d < N; d++)\n\t\t\tfor (int e = b + 1; e < N; e++)\n\t\t\t\tif (maxValue < (mat[d][e] - mat[a][b]))\n\t\t\t\t\tmaxValue = mat[d][e] - mat[a][b];\n\t\treturn maxValue;\n\t}", "927": "static int findMaxValue(int N,int mat[][])\n\t{\n\t\tint maxValue = Integer.MIN_VALUE;\n\t\tint maxArr[][] = new int[N][N];\n\t\tmaxArr[N-1][N-1] = mat[N-1][N-1];\nint maxv = mat[N-1][N-1]; \n\t\tfor (int j = N - 2; j >= 0; j--)\n\t\t{\n\t\t\tif (mat[N-1][j] > maxv)\n\t\t\t\tmaxv = mat[N - 1][j];\n\t\t\tmaxArr[N-1][j] = maxv;\n\t\t}\nmaxv = mat[N - 1][N - 1]; \n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t{\n\t\t\tif (mat[i][N - 1] > maxv)\n\t\t\t\tmaxv = mat[i][N - 1];\n\t\t\tmaxArr[i][N - 1] = maxv;\n\t\t}\n\t\tfor (int i = N-2; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = N-2; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (maxArr[i+1][j+1] - mat[i][j] > maxValue)\n\t\t\t\t\tmaxValue = maxArr[i + 1][j + 1] - mat[i][j];\n\t\t\t\tmaxArr[i][j] = Math.max(mat[i][j],\n\t\t\t\t\t\t\t\tMath.max(maxArr[i][j + 1], maxArr[i + 1][j]) );\n\t\t\t}\n\t\t}\n\t\treturn maxValue;\n\t}", "953": "static void youngify(int mat[][], int i, int j)\n\t{\n\t\tint downVal = (i + 1 < N) ?\n\t\t\t\t\tmat[i + 1][j] : INF;\n\t\tint rightVal = (j + 1 < N) ?\n\t\t\t\t\tmat[i][j + 1] : INF;\n\t\tif (downVal == INF && rightVal == INF)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (downVal < rightVal)\n\t\t{\n\t\t\tmat[i][j] = downVal;\n\t\t\tmat[i + 1][j] = INF;\n\t\t\tyoungify(mat, i + 1, j);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmat[i][j] = rightVal;\n\t\t\tmat[i][j + 1] = INF;\n\t\t\tyoungify(mat, i, j + 1);\n\t\t}\n\t}\nstatic int extractMin(int mat[][])\n\t{\n\t\tint ret = mat[0][0];\n\t\tmat[0][0] = INF;\n\t\tyoungify(mat, 0, 0);\n\t\treturn ret;\n\t}\nstatic void printSorted(int mat[][])\n\t{\n\t\tSystem.out.println(\"Elements of matrix in sorted order n\");\n\t\tfor (int i = 0; i < N * N; i++)\n\t\t{\n\t\t\tSystem.out.print(extractMin(mat) + \" \");\n\t\t}\n\t}", "955": "static void printSumSimple(int mat[][], int k)\n\t{\n\t\tif (k > n) return;\n\t\tfor (int i = 0; i < n-k+1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n-k+1; j++)\n\t\t\t{\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int p = i; p < k+i; p++)\n\t\t\t\t\tfor (int q = j; q < k+j; q++)\n\t\t\t\t\t\tsum += mat[p][q];\n\t\t\t\tSystem.out.print(sum+ \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "956": "static void printSumTricky(int mat[][], int k) {\n\tif (k > n)\n\treturn;\n\tint stripSum[][] = new int[n][n];\n\tfor (int j = 0; j < n; j++) {\n\tint sum = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tsum += mat[i][j];\n\tstripSum[0][j] = sum;\n\tfor (int i = 1; i < n - k + 1; i++) {\n\t\tsum += (mat[i + k - 1][j] - mat[i - 1][j]);\n\t\tstripSum[i][j] = sum;\n\t}\n\t}\n\tfor (int i = 0; i < n - k + 1; i++) {\n\tint sum = 0;\n\tfor (int j = 0; j < k; j++)\n\t\tsum += stripSum[i][j];\n\tSystem.out.print(sum + \" \");\n\tfor (int j = 1; j < n - k + 1; j++) {\n\t\tsum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n\t\tSystem.out.print(sum + \" \");\n\t}\n\tSystem.out.println();\n\t}\n}", "958": "static void transpose(int A[][], int B[][])\n\t{\n\t\tint i, j;\n\t\tfor (i = 0; i < N; i++)\n\t\t\tfor (j = 0; j < M; j++)\n\t\t\t\tB[i][j] = A[j][i];\n\t}", "959": "static void transpose(int A[][])\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i+1; j < N; j++)\n\t\t\t{\n\t\t\t\tint temp = A[i][j];\n\t\t\t\tA[i][j] = A[j][i];\n\t\t\t\tA[j][i] = temp;\n\t\t\t}\n\t}", "965": "static int pathCountRec(int mat[][], int m, int n, int k) {\n\t\tif (m < 0 n < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (m == 0 && n == 0 && (k == mat[m][n])) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn pathCountRec(mat, m - 1, n, k - mat[m][n])\n\t\t\t\t+ pathCountRec(mat, m, n - 1, k - mat[m][n]);\n\t}\nstatic int pathCount(int mat[][], int k) {\n\t\treturn pathCountRec(mat, R - 1, C - 1, k);\n\t}", "966": "static int pathCountDPRecDP(int [][]mat, int m, int n, int k)\n\t{\n\t\tif (m < 0 n < 0) return 0;\n\t\tif (m==0 && n==0) return (k == mat[m][n] ? 1 : 0);\n\t\tif (dp[m][n][k] != -1) return dp[m][n][k];\n\t\tdp[m][n][k] = pathCountDPRecDP(mat, m-1, n, k-mat[m][n]) +\n\t\t\t\t\tpathCountDPRecDP(mat, m, n-1, k-mat[m][n]);\n\t\treturn dp[m][n][k];\n\t}\nstatic int pathCountDP(int [][]mat, int k)\n\t{\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++)\n\t\t\t\tfor(int l=0;l<MAX_K;l++)\n\t\t\t\tdp[i][j][l]=-1;\n\t\treturn pathCountDPRecDP(mat, R-1, C-1, k);\n\t}", "1045": "static boolean check(int A[], int N) {\n\t\tStack<Integer> S = new Stack<Integer>();\n\t\tint B_end = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!S.empty()) {\n\t\t\t\tint top = S.peek();\n\t\t\t\twhile (top == B_end + 1) {\n\t\t\t\t\tB_end = B_end + 1;\n\t\t\t\t\tS.pop();\n\t\t\t\t\tif (S.empty()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttop = S.peek();\n\t\t\t\t}\n\t\t\t\tif (S.empty()) {\n\t\t\t\t\tS.push(A[i]);\n\t\t\t\t} else {\n\t\t\t\t\ttop = S.peek();\n\t\t\t\t\tif (A[i] < top) {\n\t\t\t\t\t\tS.push(A[i]);\n} \n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tS.push(A[i]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "1064": "static int countMinReversals(String expr)\n\t{\n\t\tint len = expr.length();\n\t\tif (len%2 != 0)\n\t\treturn -1;\n\t\tStack<Character> s=new Stack<>();\n\t\tfor (int i=0; i<len; i++)\n\t\t{\n\t\t\tchar c = expr.charAt(i);\n\t\t\tif (c =='}' && !s.empty())\n\t\t\t{\n\t\t\t\tif (s.peek()=='{')\n\t\t\t\t\ts.pop();\n\t\t\t\telse\n\t\t\t\t\ts.push(c);\n\t\t\t}\n\t\t\telse\n\t\t\t\ts.push(c);\n\t\t}\n\t\tint red_len = s.size();\n\t\tint n = 0;\n\t\twhile (!s.empty() && s.peek() == '{')\n\t\t{\n\t\t\ts.pop();\n\t\t\tn++;\n\t\t}\n\t\treturn (red_len/2 + n%2);\n\t}", "1065": "static int countMinReversals(String expr)\n\t{\n\t\tint len = expr.length();\n\t\tint ans;\n\t\tif (len % 2 != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tint left_brace = 0, right_brace = 0;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tchar ch = expr.charAt(i);\n\t\t\tif (ch == '{') {\n\t\t\t\tleft_brace++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (left_brace == 0) {\n\t\t\t\t\tright_brace++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tleft_brace--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (int)(Math.ceil((0.0 + left_brace) / 2)\n\t\t\t\t\t+ Math.ceil((0.0 + right_brace) / 2));\n\t\treturn ans;\n\t}", "1072": "static void PrintMinNumberForPattern(String arr)\n\t{\n\t\tint curr_max = 0;\n\t\tint last_entry = 0;\n\t\tint j;\n\t\tfor (int i = 0; i < arr.length(); i++)\n\t\t{\n\t\t\tint noOfNextD = 0;\n\t\t\tswitch (arr.charAt(i))\n\t\t\t{\n\t\t\t\tcase 'I':\n\t\t\t\t\tj = i + 1;\n\t\t\t\t\twhile (j < arr.length() && arr.charAt(j) == 'D')\n\t\t\t\t\t{\n\t\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\t\tSystem.out.print(\" \" + ++last_entry);\n\t\t\t\t\t\tSystem.out.print(\" \" + curr_max);\n\t\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_max = curr_max + noOfNextD + 1;\n\t\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\t\tSystem.out.print(\" \" + last_entry);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < noOfNextD; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.print(\" \" + --last_entry);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = i + 1;\n\t\t\t\t\t\twhile (j < arr.length()&&arr.charAt(j) == 'D')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\t\tSystem.out.print(\" \" + curr_max + \" \" + (curr_max - 1));\n\t\t\t\t\t\tlast_entry = curr_max - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.print(\" \" + (last_entry - 1));\n\t\t\t\t\t\tlast_entry--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}", "1073": "static void printLeast(String arr)\n\t{\n\t\t\tint min_avail = 1, pos_of_I = 0;\n\t\t\tArrayList<Integer> al = new ArrayList<>();\n\t\t\tif (arr.charAt(0) == 'I')\n\t\t\t{\n\t\t\t\tal.add(1);\n\t\t\t\tal.add(2);\n\t\t\t\tmin_avail = 3;\n\t\t\t\tpos_of_I = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tal.add(2);\n\t\t\t\tal.add(1);\n\t\t\t\tmin_avail = 3;\n\t\t\t\tpos_of_I = 0;\n\t\t\t}\n\t\t\tfor (int i = 1; i < arr.length(); i++)\n\t\t\t{\n\t\t\t\tif (arr.charAt(i) == 'I')\n\t\t\t\t{\n\t\t\t\t\tal.add(min_avail);\n\t\t\t\t\tmin_avail++;\n\t\t\t\t\tpos_of_I = i + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tal.add(al.get(i));\n\t\t\t\t\tfor (int j = pos_of_I; j <= i; j++)\n\t\t\t\t\t\t\tal.set(j, al.get(j) + 1);\n\t\t\t\t\tmin_avail++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < al.size(); i++)\n\t\t\t\tSystem.out.print(al.get(i) + \" \");\n\t\t\tSystem.out.println();\n\t}", "1074": "static void PrintMinNumberForPattern(String seq) {\n\t\tString result = \"\";\n\t\tStack<Integer> stk = new Stack<Integer>();\n\t\tfor (int i = 0; i <= seq.length(); i++) {\n\t\t\tstk.push(i + 1);\n\t\t\tif (i == seq.length() || seq.charAt(i) == 'I') {\n\t\t\t\twhile (!stk.empty()) {\n\t\t\t\t\tresult += String.valueOf(stk.peek());\n\t\t\t\t\tresult += \" \";\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}", "1075": "static String getMinNumberForPattern(String seq)\n\t{\n\t\tint n = seq.length();\n\t\tif (n >= 9)\n\t\t\treturn \"-1\";\n\t\tchar result[] = new char[n + 1];\n\t\tint count = 1;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t{\n\t\t\tif (i == n || seq.charAt(i) == 'I')\n\t\t\t{\n\t\t\t\tfor (int j = i - 1; j >= -1; j--)\n\t\t\t\t{\n\t\t\t\t\tresult[j + 1] = (char) ((int) '0' + count++);\n\t\t\t\t\tif (j >= 0 && seq.charAt(j) == 'I')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new String(result);\n\t}", "1132": "public int compare(Key k1, Key k2)\n\t{\n\t\tif (k1.freq < k2.freq)\n\t\t\treturn 1;\n\t\telse if (k1.freq > k2.freq)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\nstatic void rearrangeString(String str)\n\t{\n\t\tint n = str.length();\n\t\tint[] count = new int[MAX_CHAR];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcount[str.charAt(i) - 'a']++;\n\t\tPriorityQueue<Key> pq\n\t\t\t= new PriorityQueue<>(new KeyComparator());\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tint val = c - 'a';\n\t\t\tif (count[val] > 0)\n\t\t\t\tpq.add(new Key(count[val], c));\n\t\t}\n\t\tstr = \"\";\n\t\tKey prev = new Key(-1, '#');\n\t\twhile (pq.size() != 0) {\n\t\t\tKey k = pq.peek();\n\t\t\tpq.poll();\n\t\t\tstr = str + k.ch;\n\t\t\tif (prev.freq > 0)\n\t\t\t\tpq.add(prev);\n\t\t\t(k.freq)--;\n\t\t\tprev = k;\n\t\t}\n\t\tif (n != str.length())\n\t\t\tSystem.out.println(\" Not valid String \");\n\t\telse\n\t\t\tSystem.out.println(str);\n\t}", "1252": "public static int subset(int ar[], int n)\n\t{\n\t\tint res = 0;\n\t\tArrays.sort(ar);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint count = 1;\n\t\t\tfor (; i < n - 1; i++) {\n\t\t\t\tif (ar[i] == ar[i + 1])\n\t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = Math.max(res, count);\n\t\t}\n\t\treturn res;\n\t}", "1253": "static int subset(int arr[], int n)\n{\n\tHashMap<Integer, Integer> mp = new HashMap<>();\n\tfor (int i = 0; i < n; i++)\n\t\tmp.put(arr[i],mp.get(arr[i]) == null?1:mp.get(arr[i])+1);\n\tint res = 0;\n\tfor (Map.Entry<Integer,Integer> entry : mp.entrySet())\n\tres = Math.max(res, entry.getValue());\n\treturn res;\n}", "1344": "static boolean areElementsContiguous(int arr[], int n)\n\t{\n\tArrays.sort(arr);\n\tfor (int i = 1; i < n; i++)\n\t\tif (arr[i] - arr[i-1] > 1)\n\t\t\treturn false;\n\treturn true; \n\t}", "1345": "static boolean areElementsContiguous(int arr[], int n)\n\t{\n\t\tint max = Integer.MIN_VALUE;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t\tmin = Math.min(min, arr[i]);\n\t\t}\n\t\tint m = max - min + 1;\n\t\tif (m > n)\n\t\t\treturn false;\n\t\tboolean visited[] = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) \n\t\tvisited[arr[i] - min] = true;\n\t\tfor (int i = 0; i < m; i++)\n\t\tif (visited[i] == false)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "1346": "static Boolean areElementsContiguous(int arr[], int n)\n\t{\n\t\tHashSet<Integer> us = new HashSet<Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tus.add(arr[i]);\n\t\tint count = 1;\n\t\tint curr_ele = arr[0] - 1;\n\t\twhile (us.contains(curr_ele) == true) {\n\t\t\tcount++;\n\t\t\tcurr_ele--;\n\t\t}\n\t\tcurr_ele = arr[0] + 1;\n\t\twhile (us.contains(curr_ele) == true) {\n\t\t\tcount++;\n\t\t\tcurr_ele++;\n\t\t}\n\t\treturn (count == (us.size()));\n\t}", "1366": "static void longest(int a[], int n, int k)\n{\n\tint[] freq = new int[7];\n\tint start = 0, end = 0, now = 0, l = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfreq[a[i]]++;\n\t\tif (freq[a[i]] == 1)\n\t\t\tnow++;\n\t\twhile (now > k)\n\t\t{\n\t\t\tfreq[a[l]]--;\n\t\t\tif (freq[a[l]] == 0)\n\t\t\t\tnow--;\n\t\t\tl++;\n\t\t}\n\t\tif (i - l + 1 >= end - start + 1)\n\t\t{\n\t\t\tend = i;\n\t\t\tstart = l;\n\t\t}\n\t}\n\tfor (int i = start; i <= end; i++)\n\t\tSystem.out.print(a[i]+\" \");\n}", "1390": "static void findSmallestRange(int arr[][], int n, int k)\n\t{\n\t\tint i, minval, maxval, minrange, minel = 0, maxel = 0, flag, minind;\n\t\tfor (i = 0; i <= k; i++) {\n\t\t\tptr[i] = 0;\n\t\t}\n\t\tminrange = Integer.MAX_VALUE;\n\t\twhile (true) {\n\t\t\tminind = -1;\n\t\t\tminval = Integer.MAX_VALUE;\n\t\t\tmaxval = Integer.MIN_VALUE;\n\t\t\tflag = 0;\n\t\t\tfor (i = 0; i < k; i++) {\n\t\t\t\tif (ptr[i] == n) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i][ptr[i]] < minval) {\nminind = i; \n\t\t\t\t\tminval = arr[i][ptr[i]];\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i][ptr[i]] > maxval) {\n\t\t\t\t\tmaxval = arr[i][ptr[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr[minind]++;\n\t\t\tif ((maxval - minval) < minrange) {\n\t\t\t\tminel = minval;\n\t\t\t\tmaxel = maxval;\n\t\t\t\tminrange = maxel - minel;\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"The smallest range is [%d, %d]\\n\", minel, maxel);\n\t}", "1405": "static int findLargestd(int []S, int n)\n{\n\tboolean found = false;\n\tArrays.sort(S);\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tif (i == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int l = k + 1; l < n; l++)\n\t\t\t\t{\n\t\t\t\t\tif (i == l)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l])\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\treturn S[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (found == false)\n\t\treturn Integer.MAX_VALUE;\n\treturn -1;\n}", "1406": "int getI()\n\t{\n\t\treturn i;\n\t}\nint getJ()\n\t{\n\t\treturn j;\n\t}\nstatic int findFourElements(int[] arr, int n)\n\t{\n\t\tHashMap<Integer, Indexes> map = new HashMap<>();\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tmap.put(arr[i] + arr[j], new Indexes(i, j));\n\t\t\t}\n\t\t}\n\t\tint d = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tint abs_diff = Math.abs(arr[i] - arr[j]);\n\t\t\t\tif (map.containsKey(abs_diff))\n\t\t\t\t{\n\t\t\t\t\tIndexes indexes = map.get(abs_diff);\n\t\t\t\t\tif (indexes.getI() != i && indexes.getI() != j &&\n\t\t\t\t\tindexes.getJ() != i && indexes.getJ() != j)\n\t\t\t\t\t{\n\t\t\t\t\t\td = Math.max(d, Math.max(arr[i], arr[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}", "1428": "void leftRotatebyOne(int arr[], int n)\n\t{\n\t\tint i, temp;\n\t\ttemp = arr[0];\n\t\tfor (i = 0; i < n - 1; i++)\n\t\t\tarr[i] = arr[i + 1];\n\t\tarr[n-1] = temp;\n\t}\nvoid leftRotate(int arr[], int d, int n)\n\t{\n\t\tfor (int i = 0; i < d; i++)\n\t\t\tleftRotatebyOne(arr, n);\n\t}\nvoid printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t}", "1468": "static void pushZerosToEnd(int arr[], int n)\n\t{\nint count = 0; \n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\narr[count++] = arr[i]; \n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}", "1469": "static void moveZerosToEnd(int arr[], int n) {\n\tint count = 0;\n\tint temp;\n\tfor (int i = 0; i < n; i++) {\n\tif ((arr[i] != 0)) {\n\t\ttemp = arr[count];\n\t\tarr[count] = arr[i];\n\t\tarr[i] = temp;\n\t\tcount = count + 1;\n\t}\n\t}\n}\nstatic void printArray(int arr[], int n) {\n\tfor (int i = 0; i < n; i++)\n\tSystem.out.print(arr[i] + \" \");\n}", "1473": "static void pushZerosToEnd(int arr[], int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[count++] = arr[i];\n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}\nstatic void modifyAndRearrangeArr(int arr[], int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif ((arr[i] != 0) && (arr[i] == arr[i + 1]))\n\t\t\t{\n\t\t\t\tarr[i] = 2 * arr[i];\n\t\t\t\tarr[i + 1] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpushZerosToEnd(arr, n);\n\t}\nstatic void printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}", "1474": "public static void swap(int[] A, int i, int j)\n\t{\n\t\tint temp = A[i];\n\t\tA[i] = A[j];\n\t\tA[j] = temp;\n\t}\nstatic void shiftAllZeroToLeft(int array[], int n)\n\t{\n\t\tint lastSeenNonZero = 0;\n\t\tfor (int index = 0; index < n; index++) {\n\t\t\tif (array[index] != 0) {\n\t\t\t\tswap(array, array[index], array[lastSeenNonZero]);\n\t\t\t\tlastSeenNonZero++;\n\t\t\t}\n\t\t}\n\t}", "1478": "static void printArray(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}\nstatic void RearrangePosNeg(int arr[], int n)\n\t{\n\t\tint key, j;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tkey = arr[i];\n\t\t\tif (key > 0)\n\t\t\t\tcontinue;\n\t\t\tj = i - 1;\n\t\t\twhile (j >= 0 && arr[j] > 0) {\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tj = j - 1;\n\t\t\t}\n\t\t\tarr[j + 1] = key;\n\t\t}\n\t}", "1480": "static void printArray(int A[], int size)\n\t{\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tSystem.out.print(A[i] + \" \");\n\t\tSystem.out.println(\"\");\n\t\t;\n\t}\nstatic void reverse(int arr[], int l, int r)\n\t{\n\t\tif (l < r) {\n\t\t\tarr = swap(arr, l, r);\n\t\t\treverse(arr, ++l, --r);\n\t\t}\n\t}\nstatic void merge(int arr[], int l, int m, int r)\n\t{\nint i = l; \nint j = m + 1; \n\t\twhile (i <= m && arr[i] < 0)\n\t\t\ti++;\n\t\twhile (j <= r && arr[j] < 0)\n\t\t\tj++;\n\t\treverse(arr, i, m);\n\t\treverse(arr, m + 1, j - 1);\n\t\treverse(arr, i, j - 1);\n\t}\nstatic void RearrangePosNeg(int arr[], int l, int r)\n\t{\n\t\tif (l < r) {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\tRearrangePosNeg(arr, l, m);\n\t\t\tRearrangePosNeg(arr, m + 1, r);\n\t\t\tmerge(arr, l, m, r);\n\t\t}\n\t}\nstatic int[] swap(int[] arr, int i, int j)\n\t{\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t\treturn arr;\n\t}", "1481": "public static void RearrangePosNeg(int arr[])\n\t{\n\t\tint i=0;\n\t\tint j=arr.length-1;\n\t\twhile(true)\n\t\t{\n\t\t\twhile(arr[i]<0 && i<arr.length)\n\t\t\ti++;\n\t\t\twhile(arr[j]>0 && j>=0)\n\t\t\tj--;\n\t\t\tif(i<j)\n\t\t\t{\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t}\n\t\t\telse\n\t\t\tbreak;\n\t\t}\n\t}", "1515": "static void findElements(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint count = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (arr[j] > arr[i])\n\t\t\t\tcount++;\n\t\tif (count >= 2)\n\t\tSystem.out.print(arr[i] + \" \");\n\t}\n}", "1516": "static void findElements(int arr[], int n)\n{\n\tArrays.sort(arr);\n\tfor (int i = 0; i < n - 2; i++)\n\tSystem.out.print(arr[i] + \" \");\n}", "1517": "static void findElements(int arr[], int n)\n{\n\tint first = Integer.MIN_VALUE;\n\tint second = Integer.MAX_VALUE;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > first)\n\t\t{\n\t\t\tsecond = first;\n\t\t\tfirst = arr[i];\n\t\t}\n\t\telse if (arr[i] > second)\n\t\t\tsecond = arr[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr[i] < second)\n\t\t\tSystem.out.print(arr[i] + \" \") ;\n}", "1535": "int findFirstMissing(int array[], int start, int end)\n\t{\n\t\tif (start > end)\n\t\t\treturn end + 1;\n\t\tif (start != array[start])\n\t\t\treturn start;\n\t\tint mid = (start + end) / 2;\n\t\tif (array[mid] == mid)\n\t\t\treturn findFirstMissing(array, mid+1, end);\n\t\treturn findFirstMissing(array, start, mid);\n\t}", "1536": "int findFirstMissing(int[] arr , int start , int end, int first)\n\t{\n\tif (start < end)\n\t{\n\t\tint mid = (start+end)/2;\n\t\tif (arr[mid] != mid+first)\n\t\treturn findFirstMissing(arr, start, mid , first);\n\t\telse\n\t\treturn findFirstMissing(arr, mid+1, end , first);\n\t}\n\treturn start+first;\n\t}\nint findSmallestMissinginSortedArray( int[] arr)\n\t{\n\tif(arr[0] != 0)\n\t\treturn 0;\n\tif(arr[arr.length-1] == arr.length - 1)\n\t\treturn arr.length;\n\tint first = arr[0];\n\treturn findFirstMissing(arr,0, arr.length-1,first);\n\t}", "1537": "int FindMaxSum(int arr[], int n)\n\t{\n\t\tint incl = arr[0];\n\t\tint excl = 0;\n\t\tint excl_new;\n\t\tint i;\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\texcl_new = (incl > excl) ? incl : excl;\n\t\t\tincl = excl + arr[i];\n\t\t\texcl = excl_new;\n\t\t}\n\t\treturn ((incl > excl) ? incl : excl);\n\t}", "1545": "static void buildSparseTable(int arr[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlookup[i][0] = arr[i];\n\t\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\t\tfor (int i = 0; (i + (1 << j) - 1) < n; i++) {\n\t\t\t\tif (lookup[i][j - 1] <\n\t\t\t\t\t\t\tlookup[i + (1 << (j - 1))][j - 1])\n\t\t\t\t\tlookup[i][j] = lookup[i][j - 1];\n\t\t\t\telse\n\t\t\t\t\tlookup[i][j] =\n\t\t\t\t\t\t\tlookup[i + (1 << (j - 1))][j - 1];\n\t\t\t}\n\t\t}\n\t}\nstatic int query(int L, int R)\n\t{\n\t\tint j = (int)Math.log(R - L + 1);\n\t\tif (lookup[L][j] <= lookup[R - (1 << j) + 1][j])\n\t\t\treturn lookup[L][j];\n\t\telse\n\t\t\treturn lookup[R - (1 << j) + 1][j];\n\t}", "1546": "static void buildSparseTable(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\ttable[i][0] = arr[i];\n\tfor (int j = 1; j <= n; j++)\n\t\tfor (int i = 0; i <= n - (1 << j); i++)\n\t\t\ttable[i][j] = __gcd(table[i][j - 1],\n\t\t\t\t\t\t\t\ttable[i + (1 << (j - 1))][j - 1]);\n}\nstatic int query(int L, int R)\n{\n\tint j = (int)Math.log(R - L + 1);\n\treturn __gcd(table[L][j],\n\t\t\t\ttable[R - (1 << j) + 1][j]);\n}\nstatic int __gcd(int a, int b)\n{\n\treturn b == 0 ? a : __gcd(b, a % b);\t\n}", "1590": "static int findMaxAverage(int []arr, int n, int k)\n\t{\n\t\tif (k > n)\n\t\t\treturn -1;\n\t\tint []csum = new int[n];\n\t\tcsum[0] = arr[0];\n\t\tfor (int i = 1; i < n; i++)\n\t\tcsum[i] = csum[i - 1] + arr[i];\n\t\tint max_sum = csum[k - 1],\n\t\t\t\t\tmax_end = k - 1;\n\t\tfor (int i = k; i < n; i++)\n\t\t{\n\t\t\tint curr_sum = csum[i] -\n\t\t\t\t\tcsum[i - k];\n\t\t\tif (curr_sum > max_sum)\n\t\t\t{\n\t\t\t\tmax_sum = curr_sum;\n\t\t\t\tmax_end = i;\n\t\t\t}\n\t\t}\n\t\treturn max_end - k + 1;\n\t}", "1591": "static int findMaxAverage(int arr[], int n, int k)\n\t{\n\t\tif (k > n)\n\t\t\treturn -1;\n\t\tint sum = arr[0];\n\t\tfor (int i = 1; i < k; i++)\n\t\t\tsum += arr[i];\n\t\tint max_sum = sum, max_end = k-1;\n\t\tfor (int i = k; i < n; i++)\n\t\t{\n\t\t\tsum = sum + arr[i] - arr[i-k];\n\t\t\tif (sum > max_sum)\n\t\t\t{\n\t\t\t\tmax_sum = sum;\n\t\t\t\tmax_end = i;\n\t\t\t}\n\t\t}\n\t\treturn max_end - k + 1;\n\t}", "1694": "static boolean isMajority(int arr[], int n, int x)\n\t{\n\t\tint i, last_index = 0;\n\t\tlast_index = (n%2==0)? n/2: n/2+1;\n\t\tfor (i = 0; i < last_index; i++)\n\t\t{\n\t\t\tif (arr[i] == x && arr[i+n/2] == x)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "1695": "static int _binarySearch(int arr[], int low, int high, int x)\n\t{\n\t\tif (high >= low)\n\t\t{\n\t\t\tint mid = (low + high)/2; \n\t\t\tif ( (mid == 0 x > arr[mid-1]) && (arr[mid] == x) )\n\t\t\t\treturn mid;\n\t\t\telse if (x > arr[mid])\n\t\t\t\treturn _binarySearch(arr, (mid + 1), high, x);\n\t\t\telse\n\t\t\t\treturn _binarySearch(arr, low, (mid -1), x);\n\t\t}\n\t\treturn -1;\n\t}\nstatic boolean isMajority(int arr[], int n, int x)\n\t{\n\t\tint i = _binarySearch(arr, 0, n-1, x);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\tif (((i + n/2) <= (n -1)) && arr[i + n/2] == x)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "1696": "static boolean isMajorityElement(int arr[], int n, int key)\n{\n\tif (arr[n / 2] == key)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "1730": "static void sortMat(int mat[][], int n)\n\t{\n\t\tint temp[] = new int[n * n];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\ttemp[k++] = mat[i][j];\n\t\tArrays.sort(temp);\n\t\tk = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tmat[i][j] = temp[k++];\n\t}\nstatic void printMat(int mat[][], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tSystem.out.print( mat[i][j] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "1795": "void sort(int arr[])\n\t{\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n-1; i++)\n\t\t{\n\t\t\tint min_idx = i;\n\t\t\tfor (int j = i+1; j < n; j++)\n\t\t\t\tif (arr[j] < arr[min_idx])\n\t\t\t\t\tmin_idx = j;\n\t\t\tint temp = arr[min_idx];\n\t\t\tarr[min_idx] = arr[i];\n\t\t\tarr[i] = temp;\n\t\t}\n\t}\nvoid printArray(int arr[])\n\t{\n\t\tint n = arr.length;\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}", "1797": "static void bubbleSort(int arr[], int n)\n\t{\n\t\tint i, j, temp;\n\t\tboolean swapped;\n\t\tfor (i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tswapped = false;\n\t\t\tfor (j = 0; j < n - i - 1; j++)\n\t\t\t{\n\t\t\t\tif (arr[j] > arr[j + 1])\n\t\t\t\t{\n\t\t\t\t\ttemp = arr[j];\n\t\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\t\tarr[j + 1] = temp;\n\t\t\t\t\tswapped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (swapped == false)\n\t\t\t\tbreak;\n\t\t}\n\t}\nstatic void printArray(int arr[], int size)\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < size; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}", "1813": "int findCrossOver(int arr[], int low, int high, int x)\n\t{\nif (arr[high] <= x) \n\t\t\treturn high;\nif (arr[low] > x) \n\t\t\treturn low;\n\t\tint mid = (low + high)/2; \n\t\tif (arr[mid] <= x && arr[mid+1] > x)\n\t\t\treturn mid;\n\t\tif(arr[mid] < x)\n\t\t\treturn findCrossOver(arr, mid+1, high, x);\n\t\treturn findCrossOver(arr, low, mid - 1, x);\n\t}\nvoid printKclosest(int arr[], int x, int k, int n)\n\t{\n\t\tint l = findCrossOver(arr, 0, n-1, x);\nint r = l+1; \nint count = 0; \n\t\tif (arr[l] == x) l--;\n\t\twhile (l >= 0 && r < n && count < k)\n\t\t{\n\t\t\tif (x - arr[l] < arr[r] - x)\n\t\t\t\tSystem.out.print(arr[l--]+\" \");\n\t\t\telse\n\t\t\t\tSystem.out.print(arr[r++]+\" \");\n\t\t\tcount++;\n\t\t}\n\t\twhile (count < k && l >= 0)\n\t\t{\n\t\t\tSystem.out.print(arr[l--]+\" \");\n\t\t\tcount++;\n\t\t}\n\t\twhile (count < k && r < n)\n\t\t{\n\t\t\tSystem.out.print(arr[r++]+\" \");\n\t\t\tcount++;\n\t\t}\n\t}", "1822": "void push(int val)\n\t{\n\t\tnode newnode = new node(val);\n\t\tnewnode.next = head;\n\t\thead = newnode;\n\t}\nvoid insertionSort(node headref)\n\t{\n\t\tsorted = null;\n\t\tnode current = headref;\n\t\twhile (current != null)\n\t\t{\n\t\t\tnode next = current.next;\n\t\t\tsortedInsert(current);\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = sorted;\n\t}\nvoid sortedInsert(node newnode)\n\t{\n\t\tif (sorted == null sorted.val >= newnode.val)\n\t\t{\n\t\t\tnewnode.next = sorted;\n\t\t\tsorted = newnode;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode current = sorted;\n\t\t\twhile (current.next != null && current.next.val < newnode.val)\n\t\t\t{\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\tnewnode.next = current.next;\n\t\t\tcurrent.next = newnode;\n\t\t}\n\t}\nvoid printlist(node head)\n\t{\n\t\twhile (head != null)\n\t\t{\n\t\t\tSystem.out.print(head.val + \" \");\n\t\t\thead = head.next;\n\t\t}\n\t}", "1849": "", "1852": "static int matrixChainMemoised(int[] p, int i, int j)\n {\n\tif (i == j) \n\t{\n\treturn 0;\n\t}\n\tif (dp[i][j] != -1) \n\t{\n\treturn dp[i][j];\n\t}\n\tdp[i][j] = Integer.MAX_VALUE;\n\tfor (int k = i; k < j; k++) \n\t{\n\tdp[i][j] = Math.min(\n\t\tdp[i][j], matrixChainMemoised(p, i, k)\n\t\t+ matrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n\t}\n\treturn dp[i][j];\n }\nstatic int MatrixChainOrder(int[] p, int n)\n {\n\tint i = 1, j = n - 1;\n\treturn matrixChainMemoised(p, i, j);\n }", "1853": "static int MatrixChainOrder(int p[], int n)\n\t{\n\t\tint m[][] = new int[n][n];\n\t\tint i, j, k, L, q;\n\t\tfor (i = 1; i < n; i++)\n\t\t\tm[i][i] = 0;\n\t\tfor (L = 2; L < n; L++)\n\t\t{\n\t\t\tfor (i = 1; i < n - L + 1; i++)\n\t\t\t{\n\t\t\t\tj = i + L - 1;\n\t\t\t\tif (j == n)\n\t\t\t\t\tcontinue;\n\t\t\t\tm[i][j] = Integer.MAX_VALUE;\n\t\t\t\tfor (k = i; k <= j - 1; k++)\n\t\t\t\t{\n\t\t\t\t\tq = m[i][k] + m[k + 1][j]\n\t\t\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\t\t\t\tif (q < m[i][j])\n\t\t\t\t\t\tm[i][j] = q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m[1][n - 1];\n\t}", "1869": "static int cutRod(int price[], int n)\n\t{\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tint max_val = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i<n; i++)\n\t\t\tmax_val = Math.max(max_val,\n\t\t\t\t\t\t\tprice[i] + cutRod(price, n-i-1));\n\t\treturn max_val;\n\t}", "1870": "static int cutRod(int price[],int n)\n\t{\n\t\tint val[] = new int[n+1];\n\t\tval[0] = 0;\n\t\tfor (int i = 1; i<=n; i++)\n\t\t{\n\t\t\tint max_val = Integer.MIN_VALUE;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tmax_val = Math.max(max_val, price[j] + val[i-j-1]);\n\t\t\tval[i] = max_val;\n\t\t}\n\t\treturn val[n];\n\t}", "1998": "static int multiply(int x, int y) {\n\t\tif (y == 0)\n\t\t\treturn 0;\n\t\tif (y > 0)\n\t\t\treturn (x + multiply(x, y - 1));\n\t\tif (y < 0)\n\t\t\treturn -multiply(x, -y);\n\t\treturn -1;\n\t}", "2013": "void sieveOfEratosthenes(int n)\n\t{\n\t\tboolean prime[] = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tprime[i] = true;\n\t\tfor (int p = 2; p * p <= n; p++)\n\t\t{\n\t\t\tif (prime[p] == true)\n\t\t\t{\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\tif (prime[i] == true)\n\t\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t}", "2024": "static int binomialCoeff(int n, int k)\n\t{\n\t\tint res = 1;\n\t\tif (k > n - k)\n\t\tk = n - k;\n\t\tfor (int i = 0; i < k; ++i)\n\t\t{\n\t\t\tres *= (n - i);\n\t\t\tres /= (i + 1);\n\t\t}\n\t\treturn res;\n\t}\nstatic void printPascal(int n)\n\t{\n\tfor (int line = 0; line < n; line++)\n\t{\n\t\tfor (int i = 0; i <= line; i++)\n\t\tSystem.out.print(binomialCoeff\n\t\t\t\t\t\t(line, i)+\" \");\n\t\tSystem.out.println();\n\t}\n\t}", "2025": "public static void printPascal(int n)\n{\nint[][] arr = new int[n][n];\nfor (int line = 0; line < n; line++)\n{\n\tfor (int i = 0; i <= line; i++)\n\t{\n\tif (line == i i == 0)\n\t\tarr[line][i] = 1;\nelse \n\t\tarr[line][i] = arr[line-1][i-1] + arr[line-1][i];\n\tSystem.out.print(arr[line][i]);\n\t}\n\tSystem.out.println(\"\");\n}\n}", "2026": "public static void printPascal(int n)\n{\n\tfor(int line = 1; line <= n; line++)\n\t{\nint C=1;\n\tfor(int i = 1; i <= line; i++)\n\t{\n\t\tSystem.out.print(C+\" \");\n\t\tC = C * (line - i) / i;\n\t}\n\tSystem.out.println();\n\t}\n}", "2079": "static int Add(int x, int y)\n\t{\n\t\twhile (y != 0)\n\t\t{\n\t\t\tint carry = x & y;\n\t\t\tx = x ^ y;\n\t\t\ty = carry << 1;\n\t\t}\n\t\treturn x;\n\t}", "2080": "", "2101": "static int getModulo(int n, int d)\n\t{\n\t\treturn ( n & (d-1) );\n\t}", "2114": "static int countSetBits(int n)\n\t{\n\t\tint count = 0;\n\t\twhile (n > 0) {\n\t\t\tcount += n & 1;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn count;\n\t}", "2117": "public static int countSetBits(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1 + countSetBits(n & (n - 1));\n\t}", "2118": "public static void initialize()\n\t{\n\t\tBitsSetTable256[0] = 0;\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tBitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n\t\t}\n\t}\npublic static int countSetBits(int n)\n\t{\n\t\treturn (BitsSetTable256[n & 0xff]\n\t\t\t\t+ BitsSetTable256[(n >> 8) & 0xff]\n\t\t\t\t+ BitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24]);\n\t}", "2119": "", "2120": "static int countSetBitsRec(int num)\n\t{\n\t\tint nibble = 0;\n\t\tif (0 == num)\n\t\t\treturn num_to_bits[0];\n\t\tnibble = num & 0xf;\n\t\treturn num_to_bits[nibble] + countSetBitsRec(num >> 4);\n\t}", "2121": "static int countSetBits(int N)\n {\n\tint count = 0;\n\tfor (int i = 0; i < 4 * 8; i++)\n\t{\n\tif ((N & (1 << i)) != 0)\n\t\tcount++;\n\t}\n\treturn count;\n }", "2127": "static boolean getParity(int n)\n\t{\n\t\tboolean parity = false;\n\t\twhile(n != 0)\n\t\t{\n\t\t\tparity = !parity;\n\t\t\tn = n & (n-1);\n\t\t}\n\t\treturn parity;\n\t}", "2129": "static boolean isPowerOfTwo(int n)\n{\n\tif(n==0)\n\treturn false;\nreturn (int)(Math.ceil((Math.log(n) / Math.log(2)))) ==\n\t(int)(Math.floor(((Math.log(n) / Math.log(2)))));\n}", "2130": "static boolean isPowerOfTwo(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn false;\n\t\twhile (n != 1)\n\t\t{\n\t\t\tif (n % 2 != 0)\n\t\t\t\treturn false;\n\t\t\tn = n / 2;\n\t\t}\n\t\treturn true;\n\t}", "2131": "static boolean powerOf2(int n)\n{\n if (n == 1)\n\treturn true;\n else if (n % 2 != 0 n ==0)\n\treturn false;\n return powerOf2(n / 2);\n}", "2132": "static boolean isPowerOfTwo (int x)\n\t{\n\t\treturn x!=0 && ((x&(x-1)) == 0);\n\t}", "2210": "static int maxRepeating(int arr[], int n, int k)\n\t{\n\t\tfor (int i = 0; i< n; i++)\n\t\t\tarr[(arr[i]%k)] += k;\n\t\tint max = arr[0], result = 0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] > max)\n\t\t\t{\n\t\t\t\tmax = arr[i];\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "2226": "static int fun(int x)\n\t{\n\t\tint y = (x / 4) * 4;\n\t\tint ans = 0;\n\t\tfor (int i = y; i <= x; i++)\n\t\t\tans ^= i;\n\t\treturn ans;\n\t}\nstatic int query(int x)\n\t{\n\t\tif (x == 0)\n\t\t\treturn 0;\n\t\tint k = (x + 1) / 2;\n\t\treturn ((x %= 2) != 0) ? 2 * fun(k) :\n\t\t\t\t((fun(k - 1) * 2) ^ (k & 1));\n\t}\nstatic void allQueries(int q, int l[], int r[])\n\t{\n\t\tfor (int i = 0; i < q; i++)\n\t\t\tSystem.out.println((query(r[i]) ^\n\t\t\t\t\t\t\tquery(l[i] - 1))) ;\n\t}", "2243": "static void prefixXOR(int arr[], int preXOR[], int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\twhile (arr[i] % 2 != 1)\n\t\t\t\tarr[i] /= 2;\n\t\t\tpreXOR[i] = arr[i];\n\t\t}\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tpreXOR[i] = preXOR[i - 1] ^ preXOR[i];\n\t}\nstatic int query(int preXOR[], int l, int r)\n\t{\n\t\tif (l == 0)\n\t\t\treturn preXOR[r];\n\t\telse\n\t\t\treturn preXOR[r] ^ preXOR[l - 1];\n\t}", "2258": "static int findMinSwaps(int arr[], int n)\n\t{\n\t\tint noOfZeroes[] = new int[n];\n\t\tint i, count = 0;\n\t\tnoOfZeroes[n - 1] = 1 - arr[n - 1];\n\t\tfor (i = n - 2; i >= 0; i--)\n\t\t{\n\t\t\tnoOfZeroes[i] = noOfZeroes[i + 1];\n\t\t\tif (arr[i] == 0)\n\t\t\t\tnoOfZeroes[i]++;\n\t\t}\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] == 1)\n\t\t\t\tcount += noOfZeroes[i];\n\t\t}\n\t\treturn count;\n\t}", "2259": "public static int minswaps(int arr[], int n)\n\t{\n\t\tint count = 0;\n\t\tint num_unplaced_zeros = 0;\n\t\tfor (int index = n - 1; index >= 0; index--)\n\t\t{\n\t\t\tif (arr[index] == 0)\n\t\t\t\tnum_unplaced_zeros += 1;\n\t\t\telse\n\t\t\t\tcount += num_unplaced_zeros;\n\t\t}\n\t\treturn count;\n\t}", "2281": "static boolean arraySortedOrNot(int arr[], int n)\n\t{\n\t\tif (n == 0 n == 1)\n\t\t\treturn true;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tif (arr[i - 1] > arr[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "2308": "static void printTwoOdd(int arr[], int size)\n\t{\n\tint xor2 = arr[0];\n\tint set_bit_no; \n\tint i;\n\tint n = size - 2;\n\tint x = 0, y = 0;\n\tfor(i = 1; i < size; i++)\n\t\txor2 = xor2 ^ arr[i];\n\tset_bit_no = xor2 & ~(xor2-1);\n\tfor(i = 0; i < size; i++)\n\t{\n\t\tif((arr[i] & set_bit_no)>0)\n\t\tx = x ^ arr[i];\n\t\telse\n\t\ty = y ^ arr[i];\n\t}\n\tSystem.out.println(\"The two ODD elements are \"+ x + \" & \" + y);\n\t}", "2310": "static boolean findPair(int arr[],int n)\n\t{\n\t\tint size = arr.length;\n\t\tint i = 0, j = 1;\n\t\twhile (i < size && j < size)\n\t\t{\n\t\t\tif (i != j && arr[j]-arr[i] == n)\n\t\t\t{\n\t\t\t\tSystem.out.print(\"Pair Found: \"+\n\t\t\t\t\t\t\t\t\"( \"+arr[i]+\", \"+ arr[j]+\" )\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (arr[j] - arr[i] < n)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\ti++;\n\t\t}\n\t\tSystem.out.print(\"No such pair\");\n\t\treturn false;\n\t}", "2360": "public static void printMax(int arr[], int k, int n)\n\t{\n\t\tInteger[] brr = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\tbrr[i] = arr[i];\n\t\tArrays.sort(brr, Collections.reverseOrder());\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (Arrays.binarySearch(brr, arr[i],\n\t\t\t\t\tCollections.reverseOrder()) >= 0\n\t\t\t\t&& Arrays.binarySearch(brr, arr[i],\n\t\t\t\t\tCollections.reverseOrder()) < k)\n\t\t\t\tSystem.out.print(arr[i]+ \" \");\n\t}", "2372": "static void printSmall(int arr[], int asize, int n)\n{\n\tint []copy_arr = Arrays.copyOf(arr,asize);\n\tArrays.sort(copy_arr);\n\tfor (int i = 0; i < asize; ++i)\n\t{\n\t\tif (Arrays.binarySearch(copy_arr,0,n, arr[i])>-1)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t}\n}", "2379": "static boolean checkIsAP(int arr[], int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn true;\n\t\tArrays.sort(arr);\n\t\tint d = arr[1] - arr[0];\n\t\tfor (int i = 2; i < n; i++)\n\t\t\tif (arr[i] - arr[i-1] != d)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "2382": "static int countPairs(int a[], int n)\n\t{\n\t\tint mn = Integer.MAX_VALUE;\n\t\tint mx = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmn = Math.min(mn, a[i]);\n\t\t\tmx = Math.max(mx, a[i]);\n\t\t}\n\t\tint c1 = 0;\nint c2 = 0; \n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] == mn)\n\t\t\t\tc1++;\n\t\t\tif (a[i] == mx)\n\t\t\t\tc2++;\n\t\t}\n\t\tif (mn == mx)\n\t\t\treturn n * (n - 1) / 2;\n\t\telse\n\t\t\treturn c1 * c2;\n\t}", "2437": "static Node rearrange(Node head)\n\t{\nif (head == null) \n\t\t\treturn null;\n\t\tNode prev = head, curr = head.next;\n\t\twhile (curr != null) {\n\t\t\tif (prev.data > curr.data) {\n\t\t\t\tint t = prev.data;\n\t\t\t\tprev.data = curr.data;\n\t\t\t\tcurr.data = t;\n\t\t\t}\n\t\t\tif (curr.next != null && curr.next.data > curr.data) {\n\t\t\t\tint t = curr.next.data;\n\t\t\t\tcurr.next.data = curr.data;\n\t\t\t\tcurr.data = t;\n\t\t\t}\n\t\t\tprev = curr.next;\n\t\t\tif (curr.next == null)\n\t\t\t\tbreak;\n\t\t\tcurr = curr.next.next;\n\t\t}\n\t\treturn head;\n\t}\nstatic Node push(Node head, int k)\n\t{\n\t\tNode tem = new Node();\n\t\ttem.data = k;\n\t\ttem.next = head;\n\t\thead = tem;\n\t\treturn head;\n\t}\nstatic void display(Node head)\n\t{\n\t\tNode curr = head;\n\t\twhile (curr != null) {\n\t\t\tSystem.out.printf(\"%d \", curr.data);\n\t\t\tcurr = curr.next;\n\t\t}\n\t}", "2438": "void printlist(Node head)\n\t{\n\t\twhile (head != null) {\n\t\t\tSystem.out.print(head.data + \" \");\n\t\t\tif (head.next != null) {\n\t\t\t\tSystem.out.print(\"->\");\n\t\t\t}\n\t\t\thead = head.next;\n\t\t}\n\t\tSystem.out.println();\n\t}\nvoid rearrange(Node head)\n\t{\n\t\tif (head != null) {\n\t\t\tleft = head;\n\t\t\treorderListUtil(left);\n\t\t}\n\t}\nvoid reorderListUtil(Node right)\n\t{\n\t\tif (right == null) {\n\t\t\treturn;\n\t\t}\n\t\treorderListUtil(right.next);\n\t\tif (left == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (left != right && left.next != right) {\n\t\t\tNode temp = left.next;\n\t\t\tleft.next = right;\n\t\t\tright.next = temp;\n\t\t\tleft = temp;\n\t\t}\nelse { \n\t\t\tif (left.next == right) {\nleft.next.next = null; \n\t\t\t\tleft = null;\n\t\t\t}\n\t\t\telse {\nleft.next = null; \n\t\t\t\tleft = null;\n\t\t\t}\n\t\t}\n\t}", "2464": "int getLength(Node node)\n\t{\n\t\tint size = 0;\n\t\twhile (node != null) {\n\t\t\tnode = node.next;\n\t\t\tsize++;\n\t\t}\n\t\treturn size;\n\t}\nNode paddZeros(Node sNode, int diff)\n\t{\n\t\tif (sNode == null)\n\t\t\treturn null;\n\t\tNode zHead = new Node(0);\n\t\tdiff--;\n\t\tNode temp = zHead;\n\t\twhile ((diff--) != 0) {\n\t\t\ttemp.next = new Node(0);\n\t\t\ttemp = temp.next;\n\t\t}\n\t\ttemp.next = sNode;\n\t\treturn zHead;\n\t}\nNode subtractLinkedListHelper(Node l1, Node l2)\n\t{\n\t\tif (l1 == null && l2 == null && borrow == false)\n\t\t\treturn null;\n\t\tNode previous\n\t\t\t= subtractLinkedListHelper(\n\t\t\t\t(l1 != null) ? l1.next\n\t\t\t\t\t\t\t: null,\n\t\t\t\t(l2 != null) ? l2.next : null);\n\t\tint d1 = l1.data;\n\t\tint d2 = l2.data;\n\t\tint sub = 0;\n\t\tif (borrow) {\n\t\t\td1--;\n\t\t\tborrow = false;\n\t\t}\n\t\tif (d1 < d2) {\n\t\t\tborrow = true;\n\t\t\td1 = d1 + 10;\n\t\t}\n\t\tsub = d1 - d2;\n\t\tNode current = new Node(sub);\n\t\tcurrent.next = previous;\n\t\treturn current;\n\t}\nNode subtractLinkedList(Node l1, Node l2)\n\t{\n\t\tif (l1 == null && l2 == null)\n\t\t\treturn null;\n\t\tint len1 = getLength(l1);\n\t\tint len2 = getLength(l2);\n\t\tNode lNode = null, sNode = null;\n\t\tNode temp1 = l1;\n\t\tNode temp2 = l2;\n\t\tif (len1 != len2) {\n\t\t\tlNode = len1 > len2 ? l1 : l2;\n\t\t\tsNode = len1 > len2 ? l2 : l1;\n\t\t\tsNode = paddZeros(sNode, Math.abs(len1 - len2));\n\t\t}\n\t\telse {\n\t\t\twhile (l1 != null && l2 != null) {\n\t\t\t\tif (l1.data != l2.data) {\n\t\t\t\t\tlNode = l1.data > l2.data ? temp1 : temp2;\n\t\t\t\t\tsNode = l1.data > l2.data ? temp2 : temp1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tl1 = l1.next;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t}\n\t\tborrow = false;\n\t\treturn subtractLinkedListHelper(lNode, sNode);\n\t}\nstatic void printList(Node head)\n\t{\n\t\tNode temp = head;\n\t\twhile (temp != null) {\n\t\t\tSystem.out.print(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2501": "static void insertAtMid(int x)\n\t{\n\t\tif (head == null)\n\t\t\thead = new Node(x);\n\t\telse {\n\t\t\tNode newNode = new Node(x);\n\t\t\tNode ptr = head;\n\t\t\tint len = 0;\n\t\t\twhile (ptr != null) {\n\t\t\t\tlen++;\n\t\t\t\tptr = ptr.next;\n\t\t\t}\n\t\t\tint count = ((len % 2) == 0) ? (len / 2) :\n\t\t\t\t\t\t\t\t\t\t(len + 1) / 2;\n\t\t\tptr = head;\n\t\t\twhile (count-- > 1)\n\t\t\t\tptr = ptr.next;\n\t\t\tnewNode.next = ptr.next;\n\t\t\tptr.next = newNode;\n\t\t}\n\t}\nstatic void display()\n\t{\n\t\tNode temp = head;\n\t\twhile (temp != null)\n\t\t{\n\t\t\tSystem.out.print(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2502": "static void insertAtMid(int x)\n\t{\n\t\tif (head == null)\n\t\thead = new Node(x);\n\t\telse {\n\t\t\tNode newNode = new Node(x);\n\t\t\tNode slow = head;\n\t\t\tNode fast = head.next;\n\t\t\twhile (fast != null && fast.next != null)\n\t\t\t{\n\t\t\t\tslow = slow.next;\n\t\t\t\tfast = fast.next.next;\n\t\t\t}\n\t\t\tnewNode.next = slow.next;\n\t\t\tslow.next = newNode;\n\t\t}\n\t}\nstatic void display()\n\t{\n\t\tNode temp = head;\n\t\twhile (temp != null)\n\t\t{\n\t\t\tSystem.out.print(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2518": "static Node getNode(int data)\n{\n\tNode newNode = new Node();\n\tnewNode.data = data;\n\tnewNode.prev = newNode.next = null;\n\treturn newNode;\n}\nstatic Node sortedInsert(Node head_ref, Node newNode)\n{\n\tNode current;\n\tif (head_ref == null)\n\t\thead_ref = newNode;\n\telse if ((head_ref).data >= newNode.data)\n\t{\n\t\tnewNode.next = head_ref;\n\t\tnewNode.next.prev = newNode;\n\t\thead_ref = newNode;\n\t}\n\telse\n\t{\n\t\tcurrent = head_ref;\n\t\twhile (current.next != null && current.next.data < newNode.data)\n\t\t\tcurrent = current.next;\n\t\tnewNode.next = current.next;\n\t\tif (current.next != null)\n\t\t\tnewNode.next.prev = newNode;\n\t\tcurrent.next = newNode;\n\t\tnewNode.prev = current;\n\t}\n\treturn head_ref;\n}\nstatic Node insertionSort(Node head_ref)\n{\n\tNode sorted = null;\n\tNode current = head_ref;\n\twhile (current != null)\n\t{\n\t\tNode next = current.next;\n\t\tcurrent.prev = current.next = null;\n\t\tsorted=sortedInsert(sorted, current);\n\t\tcurrent = next;\n\t}\n\thead_ref = sorted;\n\treturn head_ref;\n}\nstatic void printList(Node head)\n{\n\twhile (head != null)\n\t{\n\t\tSystem.out.print(head.data + \" \");\n\t\thead = head.next;\n\t}\n}\nstatic Node push(Node head_ref, int new_data)\n{\n\tNode new_node = new Node();\n\tnew_node.data = new_data;\n\tnew_node.next = (head_ref);\n\tnew_node.prev = null;\n\tif ((head_ref) != null)\n\t\t(head_ref).prev = new_node;\n\t(head_ref) = new_node;\n\treturn head_ref;\n}", "2575": "public static void reverse(int arr[], int s, int e)\n{\n\twhile(s < e)\n\t{\n\t\tint tem = arr[s];\n\t\tarr[s] = arr[e];\n\t\tarr[e] = tem;\n\t\ts = s + 1;\n\t\te = e - 1;\n\t}\n}\npublic static void fun(int arr[], int k)\n{\n\tint n = 4 - 1;\n\tint v = n - k;\n\tif (v >= 0)\n\t{\n\t\treverse(arr, 0, v);\n\t\treverse(arr, v + 1, n);\n\t\treverse(arr, 0, n);\n\t}\n}", "2578": "static void build(int node, int l, int r, int a[])\n{\n\tif (l == r)\n\t\tseg[node] = a[l];\n\telse\n\t{\n\t\tint mid = (l + r) / 2;\n\t\tbuild(2 * node, l, mid, a);\n\t\tbuild(2 * node + 1, mid + 1, r, a);\n\t\tseg[node] = (seg[2 * node] seg[2 * node + 1]);\n\t}\n}\nstatic int query(int node, int l, int r, int start, int end, int a[])\n{\n\tif (l > end r < start)\n\t\treturn 0;\n\tif (start <= l && r <= end)\n\t\treturn seg[node];\n\tint mid = (l + r) / 2;\n\treturn ((query(2 * node, l, mid, start, end, a)) |\n\t\t\t(query(2 * node + 1, mid + 1, r, start, end, a)));\n}\nstatic void orsum(int a[], int n, int q, int k[])\n{\n\tbuild(1, 0, n - 1, a);\n\tfor(int j = 0; j < q; j++)\n\t{\n\t\tint i = k[j] % (n / 2);\n\t\tint sec = query(1, 0, n - 1, n / 2 - i, n - i - 1, a);\n\t\tint first = (query(1, 0, n - 1, 0, n / 2 - 1 - i, a) |\n\t\t\t\t\tquery(1, 0, n - 1, n - i, n - 1, a));\n\t\tint temp = sec + first;\n\t\tSystem.out.print(temp + \"\\n\");\n\t}\n}", "2579": "static void maximumEqual(int a[], int b[], int n)\n{\n\tint store[] = new int[(int) 1e5];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tstore[b[i]] = i + 1;\n\t}\n\tint ans[] = new int[(int) 1e5];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint d = Math.abs(store[a[i]] - (i + 1));\n\t\tif (store[a[i]] < i + 1)\n\t\t{\n\t\t\td = n - d;\n\t\t}\n\t\tans[d]++;\n\t}\n\tint finalans = 0;\n\tfor (int i = 0; i < 1e5; i++)\n\t\tfinalans = Math.max(finalans, ans[i]);\n\tSystem.out.print(finalans + \"\\n\");\n}", "2583": "static void RightRotate(int a[], int n, int k)\n{\n\tk=k%n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(i<k)\n\t\t{\n\t\t\tSystem.out.print(a[n + i - k] + \" \");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(a[i - k] + \" \");\n\t\t}\n\t}\n\tSystem.out.println();\n}", "2615": "static void restoreSortedArray(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > arr[i + 1])\n\t\t{\n\t\t\treverse(arr,0,i);\n\t\t\treverse(arr , i + 1, n);\n\t\t\treverse(arr,0, n);\n\t\t}\n\t}\n}\nstatic void reverse(int[] arr, int i, int j)\n{\n\tint temp;\n\twhile(i < j)\n\t{\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t\ti++;\n\t\tj--;\n\t}\n}\nstatic void printArray(int arr[], int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t\tSystem.out.print(arr[i] + \" \");\n}", "2616": "static int findStartIndexOfArray(int arr[], int low, int high)\n\t{\n\t\tif (low > high)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tif (low == high)\n\t\t{\n\t\t\treturn low;\n\t\t}\n\t\tint mid = low + (high - low) / 2;\n\t\tif (arr[mid] > arr[mid + 1])\n\t\t{\n\t\t\treturn mid + 1;\n\t\t}\n\t\tif (arr[mid - 1] > arr[mid])\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\tif (arr[low] > arr[mid])\n\t\t{\n\t\t\treturn findStartIndexOfArray(arr, low, mid - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn findStartIndexOfArray(arr, mid + 1, high);\n\t\t}\n\t}\nstatic void restoreSortedArray(int arr[], int n)\n\t{\n\t\tif (arr[0] < arr[n - 1])\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint start = findStartIndexOfArray(arr, 0, n - 1);\n\t\tArrays.sort(arr, 0, start);\n\t\tArrays.sort(arr, start, n);\n\t\tArrays.sort(arr);\n\t}\nstatic void printArray(int arr[], int size)\n\t{\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}", "2623": "static String leftrotate(String str, int d)\n\t{\n\t\t\tString ans = str.substring(d) + str.substring(0, d);\n\t\t\treturn ans;\n\t}\nstatic String rightrotate(String str, int d)\n\t{\n\t\t\treturn leftrotate(str, str.length() - d);\n\t}", "2673": "static Node insertNode(Node start, int value)\n{\n\tif (start == null)\n\t{\n\t\tNode new_node = new Node();\n\t\tnew_node.data = value;\n\t\tnew_node.next = new_node.prev = new_node;\n\t\tstart = new_node;\n\t\treturn new_node;\n\t}\n\tNode last = (start).prev;\n\tNode new_node = new Node();\n\tnew_node.data = value;\n\tnew_node.next = start;\n\t(start).prev = new_node;\n\tnew_node.prev = last;\n\tlast.next = new_node;\n\treturn start;\n}\nstatic void displayList(Node start)\n{\n\tNode temp = start;\n\twhile (temp.next != start)\n\t{\n\t\tSystem.out.printf(\"%d \", temp.data);\n\t\ttemp = temp.next;\n\t}\n\tSystem.out.printf(\"%d \", temp.data);\n}\nstatic int searchList(Node start, int search)\n{\n\tNode temp = start;\n\tint count = 0, flag = 0, value;\n\tif(temp == null)\n\t\treturn -1;\n\telse\n\t{\n\t\twhile(temp.next != start)\n\t\t{\n\t\t\tcount++;\n\t\t\tif(temp.data == search)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tif(temp.data == search)\n\t\t{\n\t\t\tcount++;\n\t\t\tflag = 1;\n\t\t}\n\t\tif(flag == 1)\n\t\t\tSystem.out.println(\"\\n\"+search +\" found at location \"+ count);\n\t\telse\n\t\t\tSystem.out.println(\"\\n\"+search +\" not found\");\n\t}\n\treturn -1;\n}", "2675": "static Node getNode(int data)\n{\n\tNode newNode = new Node();\n\tnewNode.data = data;\n\treturn newNode;\n}\nstatic Node insertEnd(Node head, Node new_node)\n{\n\tif (head == null)\n\t{\n\t\tnew_node.next = new_node.prev = new_node;\n\t\thead = new_node;\n\t\treturn head;\n\t}\n\tNode last = (head).prev;\n\tnew_node.next = head;\n\t(head).prev = new_node;\n\tnew_node.prev = last;\n\tlast.next = new_node;\n\treturn head;\n}\nstatic Node reverse(Node head)\n{\n\tif (head==null)\n\t\treturn null;\n\tNode new_head = null;\n\tNode last = head.prev;\n\tNode curr = last, prev;\n\twhile (curr.prev != last)\n\t{\n\t\tprev = curr.prev;\n\t\tnew_head=insertEnd(new_head, curr);\n\t\tcurr = prev;\n\t}\n\tnew_head=insertEnd(new_head, curr);\n\treturn new_head;\n}\nstatic void display(Node head)\n{\n\tif (head==null)\n\t\treturn;\n\tNode temp = head;\n\tSystem.out.print( \"Forward direction: \");\n\twhile (temp.next != head)\n\t{\n\t\tSystem.out.print( temp.data + \" \");\n\t\ttemp = temp.next;\n\t}\n\t\tSystem.out.print( temp.data + \" \");\n\tNode last = head.prev;\n\ttemp = last;\n\tSystem.out.print( \"\\nBackward direction: \");\n\twhile (temp.prev != last)\n\t{\n\t\tSystem.out.print( temp.data + \" \");\n\t\ttemp = temp.prev;\n\t}\n\t\tSystem.out.print( temp.data + \" \");\n}", "2696": "static void addEdge(int u, int v)\n\t{\n\t\tadj[u].add(v);\n\t\tadj[v].add(u);\n\t}\nstatic void dfs(int cur, int prev)\n\t{\n\t\tparent[cur] = prev;\n\t\tdepth[cur] = depth[prev] + 1;\n\t\tfor (int i = 0; i < adj[cur].size(); i++)\n\t\t\tif (adj[cur].elementAt(i) != prev)\n\t\t\t\tdfs(adj[cur].elementAt(i), cur);\n\t}\nstatic void preprocess()\n\t{\n\t\tdepth[0] = -1;\n\t\tdfs(1, 0);\n\t}\nstatic int LCANaive(int u, int v)\n\t{\n\t\tif (u == v)\n\t\t\treturn u;\n\t\tif (depth[u] > depth[v])\n\t\t{\n\t\t\tint temp = u;\n\t\t\tu = v;\n\t\t\tv = temp;\n\t\t}\n\t\tv = parent[v];\n\t\treturn LCANaive(u, v);\n\t}", "2697": "static void addEdge(int u,int v)\n{\n\tadj[u].add(v);\n\tadj[v].add(u);\n}\nstatic int LCANaive(int u,int v)\n{\n\tif (u == v) return u;\n\tif (depth[u] > depth[v])\n\t{\n\t\tint t = u;\n\t\tu = v;\n\t\tv = t;\n\t}\t\n\tv = parent[v];\n\treturn LCANaive(u, v);\n}\nstatic void dfs(int cur, int prev)\n{\n\tdepth[cur] = depth[prev] + 1;\n\tparent[cur] = prev;\n\tif (depth[cur] % block_sz == 0)\n\t\tjump_parent[cur] = parent[cur];\n\telse\n\t\tjump_parent[cur] = jump_parent[prev];\n\tfor (int i = 0; i < adj[cur].size(); ++i)\n\t\tif (adj[cur].get(i) != prev)\n\t\t\tdfs(adj[cur].get(i), cur);\n}\nstatic int LCASQRT(int u, int v)\n{\n\twhile (jump_parent[u] != jump_parent[v])\n\t{\n\t\tif (depth[u] > depth[v])\n\t\t{\n\t\t\tint t = u;\n\t\t\tu = v;\n\t\t\tv = t;\n\t\t}\n\t\tv = jump_parent[v];\n\t}\n\treturn LCANaive(u, v);\n}\nstatic void preprocess(int height)\n{\n\tblock_sz = (int)Math.sqrt(height);\n\tdepth[0] = -1;\n\tdfs(1, 0);\n}", "2740": "public static int find_permutations( Vector<Integer> arr)\n{\n\tint cnt = 0;\n\tint max_ind = -1, min_ind = 10000000;\n\tint n = arr.size();\n\tHashMap<Integer,\n\t\t\tInteger> index_of = new HashMap<>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tindex_of.put(arr.get(i), i + 1);\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tmax_ind = Math.max(max_ind, index_of.get(i));\n\t\tmin_ind = Math.min(min_ind, index_of.get(i));\n\t\tif (max_ind - min_ind + 1 == i)\n\t\t\tcnt++;\n\t}\n\treturn cnt;\n}", "2753": "", "2773": "static int countOfNum( int n, int a, int b)\n\t{\n\t\tint cnt_of_a, cnt_of_b, cnt_of_ab, sum;\n\t\tcnt_of_a = n / a;\n\t\tcnt_of_b = n / b;\n\t\tsum = cnt_of_b + cnt_of_a;\n\t\tcnt_of_ab = n / (a * b);\n\t\tsum = sum - cnt_of_ab;\n\t\treturn sum;\n\t}\nstatic int sumOfNum( int n, int a, int b)\n\t{\n\t\tint i;\n\t\tint sum = 0;\n\t\tSet< Integer> ans = new HashSet<Integer>();\n\t\tfor (i = a; i <= n; i = i + a) {\n\t\t\tans.add(i);\n\t\t}\n\t\tfor (i = b; i <= n; i = i + b) {\n\t\t\tans.add(i);\n\t\t}\n\t\tfor (Integer it : ans) {\n\t\t\tsum = sum + it;\n\t\t}\n\t\treturn sum;\n\t}", "2783": "static void maximumArea(int l, int b, int x, int y)\n{\n\tint left, right, above, below;\n\tleft = x * b;\n\tright = (l - x - 1) * b;\n\tabove = l * y;\n\tbelow = (b - y - 1) * l;\n\tSystem.out.print(Math.max(Math.max(left, right),\n\t\t\t\tMath.max(above, below)));\n}", "2802": "static void precompute()\n{\n\tF[1] = 2;\n\tF[2] = 3;\n\tF[3] = 4;\n\tfor (int i = 4; i < N; i++)\n\t\tF[i] = (F[i - 1] + F[i - 2]) % MOD;\n}", "2804": "static double get(double L, double R)\n{\n\tdouble x = 1.0 / L;\n\tdouble y = 1.0 / (R + 1.0);\n\treturn (x - y);\n}", "2809": "public static int upper_bound(ArrayList<Integer> ar, int k)\n{\n\tint s = 0;\n\tint e = ar.size();\n\twhile (s != e)\n\t{\n\t\tint mid = s + e >> 1;\n\t\tif (ar.get(mid) <= k)\n\t\t{\n\t\t\ts = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te = mid;\n\t\t}\n\t}\n\tif (s == ar.size())\n\t{\n\t\treturn -1;\n\t}\n\treturn s;\n}\nstatic int consecutiveOnes(int x)\n{\n\tint p = 0;\n\twhile (x > 0)\n\t{\n\t\tif (x % 2 == 1 && p == 1)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tp = x % 2;\n\t\tx /= 2;\n\t}\n\treturn 0;\n}\nstatic void preCompute()\n{\n\tfor(int i = 0; i <= MAX; i++)\n\t{\n\t\tif (consecutiveOnes(i) == 0)\n\t\t{\n\t\t\tv.add(i);\n\t\t}\n\t}\n}\nstatic int nextValid(int n)\n{\n\tint it = upper_bound(v,n);\n\tint val = v.get(it);\n\treturn val;\n}\nstatic void performQueries(int queries[], int q)\n{\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tSystem.out.println(nextValid(queries[i]));\n\t}\n}", "2816": "static int changeToOnes(String str)\n{\n\tint i, l, ctr = 0;\n\tl = str.length();\n\tfor (i = l - 1; i >= 0; i--)\n\t{\n\t\tif (str.charAt(i) == '1')\n\t\t\tctr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn l - ctr;\n}\nstatic String removeZeroesFromFront(String str)\n{\n\tString s;\n\tint i = 0;\n\twhile (i < str.length() &&\n\t\t\tstr.charAt(i) == '0')\n\t\ti++;\n\tif (i == str.length())\n\t\ts = \"0\";\n\telse\n\t\ts = str.substring(i, str.length() - i);\n\treturn s;\n}", "2818": "static int calgcd(int a, int b)\n\t{\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn calgcd(b, a % b);\n\t}\nstatic int getCount(int [] a, int n)\n\t{\n\t\tint gcd = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tgcd = calgcd(gcd, a[i]);\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i * i <= gcd; i++)\n\t\t{\n\t\t\tif (gcd % i == 0)\n\t\t\t{\n\t\t\t\tif (i * i == gcd)\n\t\t\t\t\tcnt++;\n\t\t\t\telse\n\t\t\t\t\tcnt += 2;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}", "2827": "static int MinDeletion(int a[], int n)\n{\n\tMap<Integer,Integer> mp = new HashMap<>();\n\tfor (int i = 0 ; i < n; i++)\n\t{\n\t\tif(mp.containsKey(a[i]))\n\t\t{\n\t\t\tmp.put(a[i], mp.get(a[i])+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.put(a[i], 1);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (Map.Entry<Integer,Integer> i : mp.entrySet())\n\t{\n\t\tint x = i.getKey();\n\t\tint frequency = i.getValue();\n\t\tif (x <= frequency)\n\t\t{\n\t\t\tans += (frequency - x);\n\t\t}\n\t\telse\n\t\t\tans += frequency;\n\t}\n\treturn ans;\n}", "2831": "static int maxCountAB(String s[], int n)\n{\n\tint A = 0, B = 0, BA = 0, ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tString S = s[i];\n\t\tint L = S.length();\n\t\tfor (int j = 0; j < L - 1; j++)\n\t\t{\n\t\t\tif (S.charAt(j) == 'A' &&\n\t\t\t\t\t\tS.charAt(j + 1) == 'B')\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tif (S.charAt(0) == 'B' && S.charAt(L - 1) == 'A')\n\t\t\tBA++;\n\t\telse if (S.charAt(0) == 'B')\n\t\t\tB++;\n\t\telse if (S.charAt(L - 1) == 'A')\n\t\t\tA++;\n\t}\n\tif (BA == 0)\n\t\tans += Math.min(B, A);\n\telse if (A + B == 0)\n\t\tans += BA - 1;\n\telse\n\t\tans += BA + Math.min(B, A);\n\treturn ans;\n}", "2832": "static int MinOperations(int n, int x, int[] arr)\n{\n\tint total = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (arr[i] > x)\n\t\t{\n\t\t\tint difference = arr[i] - x;\n\t\t\ttotal = total + difference;\n\t\t\tarr[i] = x;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint LeftNeigbouringSum = arr[i] + arr[i - 1];\n\t\tif (LeftNeigbouringSum > x)\n\t\t{\n\t\t\tint current_diff = LeftNeigbouringSum - x;\n\t\t\tarr[i] = Math.max(0, arr[i] - current_diff);\n\t\t\ttotal = total + current_diff;\n\t\t}\n\t}\n\treturn total;\n}", "2847": "static void findNumbers(int arr[], int n)\n\t{\n\t\tint sumN = (n * (n + 1)) / 2;\n\t\tint sumSqN = (n * (n + 1) * (2 * n + 1)) / 6;\n\t\tint sum = 0, sumSq = 0, i;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tsum += arr[i];\n\t\t\tsumSq += Math.pow(arr[i], 2);\n\t\t}\n\t\tint B = (((sumSq - sumSqN) / (sum - sumN)) + sumN - sum) / 2;\n\t\tint A = sum - sumN + B;\n\t\tSystem.out.println(\"A = \" + A + \"\\nB = \" + B);\n\t}", "2883": "static boolean is_prefix(String temp, String str)\n\t{\n\t\tif (temp.length() < str.length())\n\t\t\treturn false;\n\t\telse {\n\t\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\t\tif (str.charAt(i) != temp.charAt(i))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\nstatic String lexicographicallyString(String[] input, int n, String str)\n\t{\n\t\tArrays.sort(input);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString temp = input[i];\n\t\t\tif (is_prefix(temp, str)) {\n\t\t\t\treturn temp;\n\t\t\t}\n\t\t}\n\t\treturn \"-1\";\n\t}", "2892": "static void Rearrange(int arr[], int K, int N)\n{\n\tint ans[] = new int[N + 1];\n\tint f = -1;\n\tfor (int i = 0; i < N; i++) {\n\t\tans[i] = -1;\n\t}\n for (int i = 0; i < arr.length; i++)\n {\n\tif (arr[i] == K)\n\t{\n\t\tK = i;\n\t\tbreak;\n\t}\n }\n\tVector<Integer> smaller = new Vector<Integer>();\n\tVector<Integer> greater = new Vector<Integer>();\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] < arr[K])\n\t\t\tsmaller.add(arr[i]);\n\t\telse if (arr[i] > arr[K])\n\t\t\tgreater.add(arr[i]);\n\t}\n\tint low = 0, high = N - 1;\n\twhile (low <= high) {\n\t\tint mid = (low + high) / 2;\n\t\tif (mid == K) {\n\t\t\tans[mid] = arr[K];\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (mid < K) {\n\t\t\tif (smaller.size() == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans[mid] = smaller.lastElement();\n\t\t\tsmaller.remove(smaller.size()-1);\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse {\n\t\t\tif (greater.size() == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans[mid] = greater.lastElement();\n\t\t\tgreater.remove(greater.size()-1);\n\t\t\thigh = mid - 1;\n\t\t}\n\t}\n\tif (f == -1) {\n\t\tSystem.out.println(-1 );\n\t\treturn;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (ans[i] == -1) {\n\t\t\tif (smaller.size()>0) {\n\t\t\t\tans[i] = smaller.lastElement();\n\t\t\t\tsmaller.remove(smaller.size()-1);\n\t\t\t}\n\t\t\telse if (greater.size()>0) {\n\t\t\t\tans[i] = greater.lastElement();\n\t\t\t\tgreater.remove(greater.size()-1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t\tSystem.out.print(ans[i] +\" \");\n\tSystem.out.println();\n}", "2923": "static void minimumK(ArrayList<Integer> arr, int M, int N)\n{\n\tint good = (int)((N * 1.0) / ((M + 1) * 1.0)) + 1;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tint K = i;\n\t\tint candies = N;\n\t\tint taken = 0;\n\t\twhile (candies > 0)\n\t\t{\n\t\t\ttaken += Math.min(K, candies);\n\t\t\tcandies -= Math.min(K, candies);\n\t\t\tfor(int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tint consume = (arr.get(j) * candies) / 100;\n\t\t\t\tcandies -= consume;\n\t\t\t}\n\t\t}\n\t\tif (taken >= good)\n\t\t{\n\t\t\tSystem.out.print(i);\n\t\t\treturn;\n\t\t}\n\t}\n}", "2924": "static boolean check(int K, int n, int m, ArrayList<Integer> arr, int good_share)\n{\n\tint candies = n, taken = 0;\n\twhile (candies > 0) {\n\t\ttaken += Math.min(K, candies);\n\t\tcandies -= Math.min(K, candies);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint consume = (arr.get(j) * candies) / 100;\n\t\t\tcandies -= consume;\n\t\t}\n\t}\n\treturn (taken >= good_share);\n}\nstatic void minimumK(ArrayList<Integer> arr, int N, int M)\n{\n\tint good_share = (int)Math.ceil((N * 1.0)\n\t\t\t\t\t\t/ ((M + 1) * 1.0));\n\tint lo = 1, hi = N;\n\twhile (lo < hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (check(mid, N, M, arr, good_share)) {\n\t\t\thi = mid;\n\t\t}\n\t\telse {\n\t\t\tlo = mid + 1;\n\t\t}\n\t}\n\tSystem.out.print(hi);\n}", "2940": "static void calcTotalTime(String path)\n{\n\tint time = 0;\n\tint x = 0, y = 0;\n\tSet<String> s = new HashSet<>();\n\tfor(int i = 0; i < path.length(); i++)\n\t{\n\t\tint p = x;\n\t\tint q = y;\n\t\tif (path.charAt(i) == 'N')\n\t\t\ty++;\n\t\telse if (path.charAt(i) == 'S')\n\t\t\ty--;\n\t\telse if (path.charAt(i) == 'E')\n\t\t\tx++;\n\t\telse if (path.charAt(i) == 'W')\n\t\t\tx--;\n\t\tString o = (p + x) + \" \" + (q + y);\n\t\tif (!s.contains(o))\n\t\t{\n\t\t\ttime += 2;\n\t\t\ts.add(o);\n\t\t}\n\t\telse\n\t\t\ttime += 1;\n\t}\n\tSystem.out.println(time);\n}", "2950": "static void calcPsquare(int N)\n\t{\n\t\tfor (int i = 1; i * i <= N; i++)\n\t\t\tpsquare.add(i * i);\n\t}\nstatic int countWays(int index, int target)\n\t{\n\t\tif (target == 0)\n\t\t\treturn 1;\n\t\tif (index < 0 target < 0)\n\t\t\treturn 0;\n\t\tint inc\n\t\t\t= countWays(index, target - psquare.get(index));\n\t\tint exc = countWays(index - 1, target);\n\t\treturn inc + exc;\n\t}", "2983": "static int findCost(int[] A, int N)\n{\n\tint totalCost = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (A[i] == 0)\n\t\t{\n\t\t\tA[i] = 1;\n\t\t\ttotalCost += i;\n\t\t}\n\t}\n\treturn totalCost;\n}", "3003": "static int countNumbers(int L, int R, int K)\n\t{\n\t\tArrayList<Integer> list\n\t\t\t= new ArrayList<>();\n\t\tfor (int i = L; i <= R; i++) {\n\t\t\tif (isPalindrome(i)) {\n\t\t\t\tlist.add(i);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tint right_index\n\t\t\t\t= search(list, list.get(i) + K - 1);\n\t\t\tif (right_index != -1)\n\t\t\t\tcount = Math.max(count, right_index - i + 1);\n\t\t}\n\t\treturn count;\n\t}\nstatic int search( ArrayList<Integer> list, int num)\n\t{\n\t\tint low = 0, high = list.size() - 1;\n\t\tint ans = -1;\n\t\twhile (low <= high) {\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tif (list.get(mid) <= num) {\n\t\t\t\tans = mid;\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\thigh = mid - 1;\n\t\t}\n\t\treturn ans;\n\t}\nstatic boolean isPalindrome(int n)\n\t{\n\t\tint rev = 0;\n\t\tint temp = n;\n\t\twhile (n > 0) {\n\t\t\trev = rev * 10 + n % 10;\n\t\t\tn /= 10;\n\t\t}\n\t\treturn rev == temp;\n\t}", "3010": "public static int peakIndex(int[] arr)\n\t{\n\t\tint N = arr.length;\n\t\tif (arr.length < 3)\n\t\t\treturn -1;\n\t\tint i = 0;\n\t\twhile (i + 1 < N) {\n\t\t\tif (arr[i + 1] < arr[i] arr[i] == arr[i + 1])\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == 0 i == N - 1)\n\t\t\treturn -1;\n\t\tint ans = i;\n\t\twhile (i < N - 1) {\n\t\t\tif (arr[i] < arr[i + 1] arr[i] == arr[i + 1])\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == N - 1)\n\t\t\treturn ans;\n\t\treturn -1;\n\t}", "3053": "static void hasArrayTwoPairs(int nums[], int n, int target)\n {\n\tArrays.sort(nums);\n\tfor (int i = 0; i < n; i++) {\n\tint x = target - nums[i];\n\tint low = 0, high = n - 1;\n\twhile (low <= high) {\n\t\tint mid = low\n\t\t+ ((high - low) / 2);\n\t\tif (nums[mid] > x) {\n\t\thigh = mid - 1;\n\t\t}\n\t\telse if (nums[mid] < x) {\n\t\tlow = mid + 1;\n\t\t}\n\t\telse {\n\t\tif (mid == i) {\n\t\t\tif ((mid - 1 >= 0) && nums[mid - 1] == x) {\n\t\t\tSystem.out.print(nums[i] + \", \");\n\t\t\tSystem.out.print( nums[mid - 1]);\n\t\t\treturn;\n\t\t\t}\n\t\t\tif ((mid + 1 < n) && nums[mid + 1] == x) {\n\t\t\tSystem.out.print( nums[i] + \", \");\n\t\t\tSystem.out.print( nums[mid + 1]);\n\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tSystem.out.print( nums[i] + \", \");\n\t\t\tSystem.out.print(nums[mid]);\n\t\t\treturn;\n\t\t}\n\t\t}\n\t}\n\t}\n\tSystem.out.print(-1);\n }", "3096": "static TreeNode newNode(int data)\n{\n\tTreeNode Node = new TreeNode();\n\tNode.data = data;\n\tNode.left = null;\n\tNode.right = null;\n\treturn (Node);\n}\nstatic pair sumofsubtree(TreeNode root)\n{\n\tpair p = new pair(1, 0);\n\tif (root.left != null)\n\t{\n\t\tpair ptemp\n\t\t\t= sumofsubtree(root.left);\n\t\tp.second += ptemp.first\n\t\t\t\t\t+ ptemp.second;\n\t\tp.first += ptemp.first;\n\t}\n\tif (root.right != null)\n\t{\n\t\tpair ptemp\n\t\t\t= sumofsubtree(root.right);\n\t\tp.second += ptemp.first\n\t\t\t\t\t+ ptemp.second;\n\t\tp.first += ptemp.first;\n\t}\n\troot.size = p.first;\n\treturn p;\n}\nstatic void distance(TreeNode root, int target, int distancesum, int n)\n{\n\tif (root.data == target)\n\t{\n\t\tsum = distancesum;\n\t}\n\tif (root.left != null)\n\t{\n\t\tint tempsum = distancesum\n\t\t\t\t\t- root.left.size\n\t\t\t\t\t+ (n - root.left.size);\n\t\tdistance(root.left, target, tempsum, n);\n\t}\n\tif (root.right != null)\n\t{\n\t\tint tempsum = distancesum\n\t\t\t\t\t- root.right.size\n\t\t\t\t\t+ (n - root.right.size);\n\t\tdistance(root.right, target, tempsum, n);\n\t}\n}", "3120": "public static int delCost(String s, int[] cost)\n {\n\tboolean visited[] = new boolean[s.length()];\n\tint ans = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t{\n\tif (visited[i])\n\t{\n\t\tcontinue;\n\t}\n\tint maxDel = 0;\n\tint totalCost = 0;\n\tvisited[i] = true;\n\tfor (int j = i; j < s.length(); j++)\n\t{\n\t\tif (s.charAt(i) == s.charAt(j))\n\t\t{\n\t\tmaxDel = Math.max(maxDel, cost[j]);\n\t\ttotalCost += cost[j];\n\t\tvisited[j] = true;\n\t\t}\n\t}\n\tans += totalCost - maxDel;\n\t}\n\treturn ans;\n }", "3121": "static int delCost(String s, int[] cost)\n {\n\tint ans = 0;\n\tHashMap<Character, Integer> forMax = new HashMap<>();\n\tHashMap<Character, Integer> forTot = new HashMap<>();\n\tfor(int i = 0; i < s.length(); i++)\n\t{\n\tif(!forMax.containsKey(s.charAt(i)))\n\t{\n\t\tforMax.put(s.charAt(i), cost[i]);\n\t}\n\telse\n\t{\n\t\tforMax.put(s.charAt(i), Math.max(cost[i], forMax.get(s.charAt(i))));\n\t}\n\tif(!forTot.containsKey(s.charAt(i)))\n\t{\n\t\tforTot.put(s.charAt(i), cost[i]);\n\t}\n\telse\n\t{\n\t\tforTot.put(s.charAt(i), forTot.get(s.charAt(i)) + cost[i]);\n\t}\n\t}\n\tfor (Map.Entry<Character, Integer> i : forMax.entrySet())\n\t{\n\tans += forTot.get(i.getKey()) - i.getValue();\n\t}\n\treturn ans;\n }", "3128": "static void findClosest(int N, int target)\n {\n\tint closest = -1;\n\tint diff = Integer.MAX_VALUE;\n\tfor (int i = 1; i <= (int)Math.sqrt(N); i++) {\n\tif (N % i == 0) {\n\t\tif (N / i == i) {\n\t\tif (Math.abs(target - i) < diff)\n\t\t{\n\t\t\tdiff = Math.abs(target - i);\n\t\t\tclosest = i;\n\t\t}\n\t\t}\n\t\telse {\n\t\tif (Math.abs(target - i) < diff)\n\t\t{\n\t\t\tdiff = Math.abs(target - i);\n\t\t\tclosest = i;\n\t\t}\n\t\tif (Math.abs(target - N / i) < diff)\n\t\t{\n\t\t\tdiff = Math.abs(target - N / i);\n\t\t\tclosest = N / i;\n\t\t}\n\t\t}\n\t}\n\t}\n\tSystem.out.println(closest);\n }", "3129": "static void computeDivisors()\n{\n\tfor (int i = 1; i <= MAX; i++)\n\t{\n\t\tfor (int j = i; j <= MAX; j += i)\n\t\t{\n\t\t\tdivisors[j].add(i);\n\t\t}\n\t}\n}\nstatic int getClosest(int val1, int val2, int target)\n{\n\tif (target - val1 >= val2 - target)\n\t\treturn val2;\n\telse\n\t\treturn val1;\n}\nstatic int findClosest(Vector<Integer> array, int n, int target)\n{\n\tInteger []arr = array.toArray(new Integer[array.size()]);\n\tif (target <= arr[0])\n\t\treturn arr[0];\n\tif (target >= arr[n - 1])\n\t\treturn arr[n - 1];\n\tint i = 0, j = n, mid = 0;\n\twhile (i < j)\n\t{\n\t\tmid = (i + j) / 2;\n\t\tif (arr[mid] == target)\n\t\t\treturn arr[mid];\n\t\tif (target < arr[mid])\n\t\t{\n\t\t\tif (mid > 0 && target > arr[mid - 1])\n\t\t\t\treturn getClosest(arr[mid - 1], arr[mid], target);\n\t\t\tj = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mid < n - 1 && target < arr[mid + 1])\n\t\t\t\treturn getClosest(arr[mid], arr[mid + 1], target);\n\t\t\ti = mid + 1;\n\t\t}\n\t}\n\treturn arr[mid];\n}\nstatic void printClosest(int N, int X)\n{\n\tcomputeDivisors();\n\tint ans\n\t\t= findClosest(divisors[N], divisors[N].size(), X);\n\tSystem.out.print(ans);\n}", "3135": "static void countTriplets(int []arr, int N)\n{\n\tVector<Integer> zero_i = new Vector<Integer>();\n\tVector<Integer> one_i = new Vector<Integer>();\n\tHashMap<Integer,\n\t\t\tInteger> mp = new HashMap<Integer,\n\t\t\t\t\t\t\t\t\tInteger>();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t\tzero_i.add(i + 1);\n\t\telse if (arr[i] == 1)\n\t\t\tone_i.add(i + 1);\n\t\telse\n\t\t\tmp.put(i + 1, 1);\n\t}\n\tint total = zero_i.size() *\n\t\t\t\tone_i.size() * mp.size();\n\tfor(int i = 0; i < zero_i.size(); i++)\n\t{\n\t\tfor(int j = 0; j < one_i.size(); j++)\n\t\t{\n\t\t\tint p = zero_i.get(i);\n\t\t\tint q = one_i.get(j);\n\t\t\tint r = 2 * p - q;\n\t\t\tif (mp.containsKey(r) && mp.get(r) > 0)\n\t\t\t\ttotal--;\n\t\t\tr = 2 * q - p;\n\t\t\tif (mp.containsKey(r) && mp.get(r) > 0)\n\t\t\t\ttotal--;\n\t\t\tr = (p + q) / 2;\n\t\t\tif (mp.containsKey(r) &&\n\t\t\t\t\tmp.get(r) > 0 &&\n\t\t\t\tMath.abs(r - p) == Math.abs(r - q))\n\t\t\t\ttotal--;\n\t\t}\n\t}\n\tSystem.out.print(total);\n}", "3138": "static int power(int A, int N)\n{\n\tint count = 0;\n\tif (A == 1)\n\t\treturn 0;\n\twhile (N > 0)\n\t{\n\t\tcount++;\n\t\tN /= A;\n\t}\n\treturn count;\n}\nstatic void Pairs(int N, int A, int B)\n{\n\tint powerA, powerB;\n\tpowerA = power(A, N);\n\tpowerB = power(B, N);\n\tint intialB = B, intialA = A;\n\tA = 1;\n\tfor(int i = 0; i <= powerA; i++)\n\t{\n\t\tB = 1;\n\t\tfor(int j = 0; j <= powerB; j++)\n\t\t{\n\t\t\tif (B == N - A)\n\t\t\t{\n\t\t\t\tSystem.out.println(i + \" \" + j);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tB *= intialB;\n\t\t}\n\t\tA *= intialA;\n\t}\n\tSystem.out.println(\"-1\");\n\treturn;\n}", "3142": "public static int findNonMultiples(int[] arr, int n, int k)\n{\n\tSet<Integer> multiples = new HashSet<Integer>();\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tif (!multiples.contains(arr[i]))\n\t\t{\n\t\t\tfor(int j = 1; j <= k / arr[i]; j++)\n\t\t\t{\n\t\t\t\tmultiples.add(arr[i] * j);\n\t\t\t}\n\t\t}\n\t}\n\treturn k - multiples.size();\n}\npublic static int countValues(int[] arr, int N, int L, int R)\n{\n\treturn findNonMultiples(arr, N, R) -\n\t\tfindNonMultiples(arr, N, L - 1);\n}", "3163": "static int maxMatch(int[] A, int[] B)\n {\n\tHashMap<Integer, Integer> Aindex = new HashMap<Integer, Integer>();\n\tHashMap<Integer, Integer> diff = new HashMap<Integer, Integer>();\n\tfor (int i = 0; i < A.length; i++)\n\t{\n\tAindex.put(A[i], i);\n\t}\n\tfor (int i = 0; i < B.length; i++)\n\t{\n\tif (i - Aindex.get(B[i]) < 0)\n\t{\n\t\tif (!diff.containsKey(A.length + i - Aindex.get(B[i])))\n\t\t{\n\t\tdiff.put(A.length + i - Aindex.get(B[i]), 1);\n\t\t} else {\n\t\tdiff.put(A.length + i - Aindex.get(B[i]), diff.get(A.length + i - Aindex.get(B[i])) + 1);\n\t\t}\n\t}\n\telse {\n\t\tif (!diff.containsKey(i - Aindex.get(B[i]))) {\n\t\tdiff.put(i - Aindex.get(B[i]), 1);\n\t\t}\n\t\telse\n\t\t{\n\t\tdiff.put(i - Aindex.get(B[i]),\n\t\t\t\tdiff.get(i - Aindex.get(B[i])) + 1);\n\t\t}\n\t}\n\t}\n\tint max = 0;\n\tfor (Map.Entry<Integer, Integer> ele : diff.entrySet())\n\t{\n\tif (ele.getValue() > max)\n\t{\n\t\tmax = ele.getValue();\n\t}\n\t}\n\treturn max;\n }", "3176": "static void checkXOR(int arr[], int N)\n{\n\tif (N % 2 == 0)\n\t{\n\t\tint xro = 0;\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\txro ^= arr[i];\n\t\t}\n\t\tif (xro != 0)\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < N - 3; i += 2)\n\t\t{\n\t\t\tSystem.out.println(i + \" \" + (i + 1) +\n\t\t\t\t\t\t\t\t\" \" + (i + 2));\n\t\t}\n\t\tfor(int i = 0; i < N - 3; i += 2)\n\t\t{\n\t\t\tSystem.out.println(i + \" \" + (i + 1) +\n\t\t\t\t\t\t\t\t\" \" + (N - 1));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i < N - 2; i += 2)\n\t\t{\n\t\t\tSystem.out.println(i + \" \" + (i + 1) +\n\t\t\t\t\t\t\t\t\" \" + (i + 2));\n\t\t}\n\t\tfor(int i = 0; i < N - 2; i += 2)\n\t\t{\n\t\t\tSystem.out.println(i + \" \" + (i + 1) +\n\t\t\t\t\t\t\t\t\" \" + (N - 1));\n\t\t}\n\t}\n}", "3179": "static int make_array_element_even(int arr[], int N)\n {\n\tint res = 0;\n\tint odd_cont_seg = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\tif (arr[i] % 2 == 1)\n\t{\n\t\todd_cont_seg++;\n\t}\n\telse\n\t{\n\t\tif (odd_cont_seg > 0)\n\t\t{\n\t\tif (odd_cont_seg % 2 == 0)\n\t\t{\n\t\t\tres += odd_cont_seg / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += (odd_cont_seg / 2) + 2;\n\t\t}\n\t\todd_cont_seg = 0;\n\t\t}\n\t}\n\t}\n\tif (odd_cont_seg > 0)\n\t{\n\tif (odd_cont_seg % 2 == 0)\n\t{\n\t\tres += odd_cont_seg / 2;\n\t}\n\telse\n\t{\n\t\tres += odd_cont_seg / 2 + 2;\n\t}\n\t}\n\treturn res;\n }", "3183": "static void minCollectingSpeed(int[] piles, int H)\n{\n\tint ans = -1;\n\tint low = 1, high;\n\thigh = Arrays.stream(piles).max().getAsInt();\n\twhile (low <= high)\n\t{\n\t\tint K = low + (high - low) / 2;\n\t\tint time = 0;\n\t\tfor(int ai : piles)\n\t\t{\n\t\t\ttime += (ai + K - 1) / K;\n\t\t}\n\t\tif (time <= H)\n\t\t{\n\t\t\tans = K;\n\t\t\thigh = K - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlow = K + 1;\n\t\t}\n\t}\n\tSystem.out.print(ans);\n}", "3198": "static int cntDisPairs(int arr[], int N, int K)\n{\n\tint cntPairs = 0;\n\tArrays.sort(arr);\n\tint i = 0;\n\tint j = N - 1;\n\twhile (i < j) {\n\t\tif (arr[i] + arr[j] == K) {\n\t\t\twhile (i < j && arr[i] == arr[i + 1]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (i < j && arr[j] == arr[j - 1]) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tcntPairs += 1;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse if (arr[i] + arr[j] < K) {\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\tj--;\n\t\t}\n\t}\n\treturn cntPairs;\n}", "3199": "static int cntDisPairs(int arr[], int N, int K)\n{\n\tint cntPairs = 0;\n\tHashMap<Integer,Integer> cntFre = new HashMap<Integer,Integer>();\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif(cntFre.containsKey(arr[i]))\n\t\t\tcntFre.put(arr[i], cntFre.get(arr[i]) + 1);\n\t\telse\n\t\t\tcntFre.put(arr[i], 1);\n\t}\n\tfor (Map.Entry<Integer,Integer> it : cntFre.entrySet())\n\t{\n\t\tint i = it.getKey();\n\t\tif (2 * i == K)\n\t\t{\n\t\t\tif (cntFre.get(i) > 1)\n\t\t\t\tcntPairs += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (cntFre.containsKey(K - i))\n\t\t\t{\n\t\t\t\tcntPairs += 1;\n\t\t\t}\n\t\t}\n\t}\n\tcntPairs = cntPairs / 2;\n\treturn cntPairs;\n}", "3229": "static Node push(Node head_ref, int new_data)\n {\n\tNode new_node = new Node();\n\tnew_node.data = new_data;\n\tnew_node.prev = null;\n\tnew_node.next = head_ref;\n\tif (head_ref != null)\n\t{\n\thead_ref.prev = new_node;\n\t}\n\thead_ref = new_node;\n\treturn head_ref;\n }\nstatic int search(Node head_ref, int x)\n {\n\tNode temp = head_ref;\n\tint pos = 0;\n\twhile (temp.data != x && temp.next != null)\n\t{\n\tpos++;\n\ttemp = temp.next;\n\t}\n\tif (temp.data != x)\n\treturn -1;\n\treturn (pos + 1);\n }", "3234": "static void longestSubsequence(int N, int Q, int arr[], int Queries[][])\n{\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tint x = Queries[i][0];\n\t\tint y = Queries[i][1];\n\t\tarr[x - 1] = y;\n\t\tint count = 1;\n\t\tfor (int j = 1; j < N; j++)\n\t\t{\n\t\t\tif (arr[j] != arr[j - 1])\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(count +\" \");\n\t}\n}", "3235": "static void longestSubsequence(int N, int Q, int arr[], int Queries[][])\n{\n\tint count = 1;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tif (arr[i] != arr[i - 1])\n\t\t{\n\t\t\tcount += 1;\n\t\t}\n\t}\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tint x = Queries[i][0];\n\t\tint y = Queries[i][1];\n\t\tif (x > 1)\n\t\t{\n\t\t\tif (arr[x - 1] != arr[x - 2])\n\t\t\t{\n\t\t\t\tcount -= 1;\n\t\t\t}\n\t\t\tif (arr[x - 2] != y)\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tif (x < N)\n\t\t{\n\t\t\tif (arr[x] != arr[x - 1])\n\t\t\t{\n\t\t\t\tcount -= 1;\n\t\t\t}\n\t\t\tif (y != arr[x])\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(count + \" \");\n\t\tarr[x - 1] = y;\n\t}\n}", "3253": "static void sum(int arr[], int n)\n{\n\tHashMap<Integer, Vector<Integer>> mp = new HashMap<>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tVector<Integer> v = new Vector<>();\n\t\tv.add(i);\n\t\tif (mp.containsKey(arr[i]))\n\t\t\tv.addAll(mp.get(arr[i]));\n\t\tmp.put(arr[i], v);\n\t}\n\tint []ans = new int[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint sum = 0;\n\t\tfor(int it : mp.get(arr[i]))\n\t\t{\n\t\t\tsum += Math.abs(it - i);\n\t\t}\n\t\tans[i] = sum;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tSystem.out.print(ans[i] + \" \");\n\t}\n\treturn;\n}", "3270": "static int[] reverse(int a[])\n{\n\tint i, n = a.length, t;\n\tfor(i = 0; i < n / 2; i++)\n\t{\n\t\tt = a[i];\n\t\ta[i] = a[n - i - 1];\n\t\ta[n - i - 1] = t;\n\t}\n\treturn a;\n}\nstatic void rearrangeArray(int A[], int B[], int N, int K)\n{\n\tArrays.sort(B);\n\tB = reverse(B);\n\tboolean flag = true;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (A[i] + B[i] > K)\n\t\t{\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!flag)\n\t{\n\t\tSystem.out.print(\"-1\" + \"\\n\");\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tSystem.out.print(B[i] + \" \");\n\t\t}\n\t}\n}", "3311": "static boolean isinRange(int[][] board)\n{\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (board[i][j] <= 0 board[i][j] > 9)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nstatic boolean isValidSudoku(int board[][])\n{\n\tif (isinRange(board) == false)\n\t{\n\t\treturn false;\n\t}\n\tboolean[] unique = new boolean[N + 1];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tArrays.fill(unique, false);\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tint Z = board[i][j];\n\t\t\tif (unique[Z])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tunique[Z] = true;\n\t\t}\n\t}\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tArrays.fill(unique, false);\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tint Z = board[j][i];\n\t\t\tif (unique[Z])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tunique[Z] = true;\n\t\t}\n\t}\n\tfor(int i = 0; i < N - 2; i += 3)\n\t{\n\t\tfor(int j = 0; j < N - 2; j += 3)\n\t\t{\n\t\t\tArrays.fill(unique, false);\n\t\t\tfor(int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tfor(int l = 0; l < 3; l++)\n\t\t\t\t{\n\t\t\t\t\tint X = i + k;\n\t\t\t\t\tint Y = j + l;\n\t\t\t\t\tint Z = board[X][Y];\n\t\t\t\t\tif (unique[Z])\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tunique[Z] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "3332": "static void conVowUpp(char[] str)\n{\n int N = str.length;\n for (int i = 0; i < N; i++)\n {\n\tif (str[i] == 'a' str[i] == 'e' str[i] == 'i' str[i] == 'o' str[i] == 'u')\n\t{\n\tchar c = Character.toUpperCase(str[i]);\n\tstr[i] = c;\n\t}\n }\n for(char c : str)\n\tSystem.out.print(c);\n}", "3337": "public static int zvalue(int[] nums)\n{\n\tint m = max_element(nums);\n\tint cnt = 0;\n\tfor(int i = 0; i <= m; i++)\n\t{\n\t\tcnt = 0;\n\t\tfor(int j = 0; j < nums.length; j++)\n\t\t{\n\t\t\tif (nums[j] >= i)\n\t\t\t\tcnt++;\n\t\t}\n\t\tif (cnt == i)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\npublic static int max_element(int[] nums)\n{\n\tint max = nums[0];\n\tfor(int i = 1; i < nums.length; i++)\n\t\tmax = Math.max(max, nums[i]);\n\treturn max;\n}", "3345": "public static boolean palindrome(int[] a, int i, int j)\n\t{\n\t\twhile(i<j)\n\t\t{\n\t\t\tif(a[i] != a[j])\n\t\t\t\treturn false;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\nstatic int findSubArray(int []arr, int k)\n\t{\n\t\tint n= arr.length;\n\t\tfor(int i=0; i<=n-k; i++){\n\t\t\tif(palindrome(arr, i, i+k-1))\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}", "3346": "static boolean helper(int mid)\n{\n\tint cnt = 0;\n\tfor(Map.Entry<Integer, Integer> i : mp.entrySet())\n\t{\n\t\tint temp = i.getValue();\n\t\twhile (temp >= mid)\n\t\t{\n\t\t\ttemp -= mid;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt >= N;\n}\nstatic int findMaximumDays(int arr[])\n{\n\tfor(int i = 0; i < P; i++)\n\t{\n\t\tif (mp.containsKey(arr[i]))\n\t\t{\n\t\t\tmp.put(arr[i], mp.get(arr[i]) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.put(arr[i], 1);\n\t\t}\n\t}\n\tint start = 0, end = P, ans = 0;\n\twhile (start <= end)\n\t{\n\t\tint mid = start +\n\t\t\t\t((end - start) / 2);\n\t\tif (mid != 0 && helper(mid))\n\t\t{\n\t\t\tans = mid;\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse if (mid == 0)\n\t\t{\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tend = mid - 1;\n\t\t}\n\t}\n\treturn ans;\n}", "3374": "static void countSubarrays(int a[], int n, int k)\n{\n\tint ans = 0;\n\tArrayList<Integer> pref = new ArrayList<>();\n\tpref.add(0);\n\tfor(int i = 0; i < n; i++)\n\t\tpref.add((a[i] + pref.get(i)) % k);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = i; j <= n; j++)\n\t\t{\n\t\t\tif ((pref.get(j) -\n\t\t\t\tpref.get(i - 1) + k) % k == j - i + 1)\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tSystem.out.println(ans);\n}", "3375": "static void countSubarrays(int a[], int n, int k)\n{\n\tHashMap<Integer, Integer> cnt = new HashMap<>();\n\tlong ans = 0;\n\tArrayList<Integer> pref = new ArrayList<>();\n\tpref.add(0);\n\tfor(int i = 0; i < n; i++)\n\t\tpref.add((a[i] + pref.get(i)) % k);\n\tcnt.put(0, 1);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint remIdx = i - k;\n\t\tif (remIdx >= 0)\n\t\t{\n\t\t\tif (cnt.containsKey((pref.get(remIdx) - remIdx % k + k) % k))\n\t\t\t\tcnt.put((pref.get(remIdx) - remIdx % k + k) % k,\n\t\t\t\tcnt.get((pref.get(remIdx) - remIdx % k + k) % k) - 1);\n\t\t\telse\n\t\t\t\tcnt.put((pref.get(remIdx) - remIdx % k + k) % k, -1);\n\t\t}\n\t\tif (cnt.containsKey((pref.get(i) - i % k + k) % k))\n\t\t\tans += cnt.get((pref.get(i) - i % k + k) % k);\n\t\tif (cnt.containsKey((pref.get(i) - i % k + k) % k))\n\t\t\tcnt.put((pref.get(i) - i % k + k) % k,\n\t\t\tcnt.get((pref.get(i) - i % k + k) % k) + 1);\n\t\telse\n\t\t\tcnt.put((pref.get(i) - i % k + k) % k, 1);\n\t}\n\tSystem.out.println(ans);\n}", "3398": "static void countRows(int[][] mat)\n\t{\n\t\tint n = mat.length;\n\t\tint m = mat[0].length;\n\t\tint count = 0;\n\t\tint totalSum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ttotalSum += mat[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint currSum = 0;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcurrSum += mat[i][j];\n\t\t\t}\n\t\t\tif (currSum > totalSum - currSum)\n\t\t\t\tcount++;\n\t\t}\n\t\tSystem.out.println(count);\n\t}", "3417": "static void isCrossed(String path)\n{\n if (path.length() == 0)\n\treturn;\n boolean ans = false;\n HashSet<Point> set =\n\t\tnew HashSet<Point>();\n int x = 0, y = 0;\n set.add(new Point(x, y));\n for (int i = 0; i < path.length(); i++)\n {\n\tif (path.charAt(i) == 'N')\n\tset.add(new Point(x, y++));\n\tif (path.charAt(i) == 'S')\n\tset.add(new Point(x, y--));\n\tif (path.charAt(i) == 'E')\n\tset.add(new Point(x++, y));\n\tif (path.charAt(i) == 'W')\n\tset.add(new Point(x--, y));\n\tif (set.contains(new Point(x, y)))\n\t{\n\tans = true;\n\tbreak;\n\t}\n }\n if (ans)\n\tSystem.out.print(\"Crossed\");\n else\n\tSystem.out.print(\"Not Crossed\");\n}", "3427": "static int maxWidth(int N, int M,ArrayList<Integer> cost, ArrayList<ArrayList<Integer> > s)\n\t{\n\t\tArrayList<ArrayList<Integer> > adj =\n\t\tnew ArrayList<ArrayList<Integer> >();\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tadj.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i = 0; i < M; i++)\n\t\t{\n\t\t\tadj.get(s.get(i).get(0)).add(s.get(i).get(1));\n\t\t}\n\t\tint result = 0;\n\t\tQueue<Integer> q = new LinkedList<>();\n\t\tq.add(0);\n\t\twhile(q.size() != 0)\n\t\t{\n\t\t\tint count = q.size();\n\t\t\tresult = Math.max(count, result);\n\t\t\twhile(count-->0)\n\t\t\t{\n\t\t\t\tint temp = q.remove();\n\t\t\t\tfor(int i = 0; i < adj.get(temp).size(); i++)\n\t\t\t\t{\n\t\t\t\t\tq.add(adj.get(temp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "3463": "static void SieveOfEratosthenes()\n{\n\tArrays.fill(isPrime, true);\n\tfor(int p = 2; p * p <= MAX; p++)\n\t{\n\t\tif (isPrime[p] == true)\n\t\t{\n\t\t\tfor(int i = p * p; i <= MAX; i += p)\n\t\t\t\tisPrime[i] = false;\n\t\t}\n\t}\n\tfor(int p = 2; p <= MAX; p++)\n\t\tif (isPrime[p])\n\t\t\tprimes.add(p);\n}\nstatic int prime_search(Vector<Integer> primes, int diff)\n{\n\tint low = 0;\n\tint high = primes.size() - 1;\n\tint res = -1;\n\twhile (low <= high)\n\t{\n\t\tint mid = (low + high) / 2;\n\t\tif (primes.get(mid) == diff)\n\t\t{\n\t\t\treturn primes.get(mid);\n\t\t}\n\t\telse if (primes.get(mid) < diff)\n\t\t{\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres = primes.get(mid);\n\t\t\thigh = mid - 1;\n\t\t}\n\t}\n\treturn res;\n}\nstatic int minCost(int arr[], int n)\n{\n\tSieveOfEratosthenes();\n\tint res = 0;\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tif (arr[i] < arr[i - 1])\n\t\t{\n\t\t\tint diff = arr[i - 1] - arr[i];\n\t\t\tint closest_prime = prime_search(primes, diff);\n\t\t\tres += closest_prime;\n\t\t\tarr[i] += closest_prime;\n\t\t}\n\t}\n\treturn res;\n}", "3464": "static String[] lexico_smallest(String s1, String s2)\n{\n\tMap<Character, Integer> M = new HashMap<>();\n\tSet<Character> S = new TreeSet<>();\n\tfor(int i = 0; i <= s1.length() - 1; ++i)\n\t{\n\t\tif (!M.containsKey(s1.charAt(i)))\n\t\t\tM.put(s1.charAt(i), 1);\n\t\telse\n\t\t\tM.replace(s1.charAt(i),\n\t\t\t\tM.get(s1.charAt(i)) + 1);\n\t\tS.add(s1.charAt(i));\n\t}\n\tfor(int i = 0; i <= s2.length() - 1; ++i)\n\t{\n\t\tif (M.containsKey(s2.charAt(i)))\n\t\t\tM.replace(s2.charAt(i),\n\t\t\t\tM.get(s2.charAt(i)) - 1);\n\t}\n\tchar c = s2.charAt(0);\n\tint index = 0;\n\tString res = \"\";\n\tIterator<Character> it = S.iterator();\n\twhile (it.hasNext())\n\t{\n\t\tchar x = it.next();\n\t\tif (x != c)\n\t\t{\n\t\t\tfor(int i = 1; i <= M.get(x); ++i)\n\t\t\t{\n\t\t\t\tres += x;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint j = 0;\n\t\t\tindex = res.length();\n\t\t\twhile (s2.charAt(j) == x)\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (s2.charAt(j) < c)\n\t\t\t{\n\t\t\t\tres += s2;\n\t\t\t\tfor(int i = 1; i <= M.get(x); ++i)\n\t\t\t\t{\n\t\t\t\t\tres += x;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i = 1; i <= M.get(x); ++i)\n\t\t\t\t{\n\t\t\t\t\tres += x;\n\t\t\t\t}\n\t\t\t\tindex += M.get(x);\n\t\t\t\tres += s2;\n\t\t\t}\n\t\t}\n\t}\n\tString pr[] = {res, index + \"\"};\n\treturn pr;\n}", "3468": "static void addEdge(Vector<Integer> v[], int x, int y)\n{\n\tv[x].add(y);\n\tv[y].add(x);\n}\nstatic void dfs(Vector<Integer> tree[], Vector<Integer> temp, int ancestor[], int u, int parent, int k)\n{\n\ttemp.add(u);\n\tfor(int i : tree[u])\n\t{\n\t\tif (i == parent)\n\t\t\tcontinue;\n\t\tdfs(tree, temp, ancestor, i, u, k);\n\t}\n\ttemp.remove(temp.size() - 1);\n\tif (temp.size() < k)\n\t{\n\t\tancestor[u] = -1;\n\t}\n\telse\n\t{\n\t\tancestor[u] = temp.get(temp.size() - k);\n\t}\n}\nstatic void KthAncestor(int N, int K, int E, int edges[][])\n{\n\t@SuppressWarnings(\"unchecked\")\n\tVector<Integer> []tree = new Vector[N + 1];\n\tfor(int i = 0; i < tree.length; i++)\n\t\ttree[i] = new Vector<Integer>();\n\tfor(int i = 0; i < E; i++)\n\t{\n\t\taddEdge(tree, edges[i][0], edges[i][1]);\n\t}\n\tVector<Integer> temp = new Vector<Integer>();\n\tint []ancestor = new int[N + 1];\n\tdfs(tree, temp, ancestor, 1, 0, K);\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tSystem.out.print(ancestor[i] + \" \");\n\t}\n}", "3471": "static void build(Vector<Integer> sum,Vector<Integer> a, int l, int r, int rt)\n\t{\n\t\tif(l == r)\n\t\t{\n\t\t\tsum.set(rt, a.get(l - 1));\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tbuild(sum, a, l, m, rt << 1);\n\t\tbuild(sum, a, m + 1, r, rt << 1 1);\n\t}\nstatic void pushDown(Vector<Integer> sum, Vector<Integer> add, int rt, int ln, int rn)\n\t{\n\t\tif(add.get(rt) != 0)\n\t\t{\n\t\t\tadd.set(rt << 1, add.get(rt));\n\t\t\tadd.set(rt << 1 | 1, add.get(rt));\n\t\t\tsum.set(rt << 1, sum.get(rt << 1) + add.get(rt) * ln);\n\t\t\tsum.set(rt << 1 | 1, sum.get(rt << 1 1) + add.get(rt) * rn);\n\t\t\tadd.set(rt, 0);\n\t\t}\n\t}\nstatic void update(Vector<Integer> sum, Vector<Integer> add,int L, int R, int C, int l, int r, int rt)\n\t{\n\t\tif(L <= l && r <= R)\n\t\t{\n\t\t\tsum.set(rt,sum.get(rt) + C * (r - l + 1));\n\t\t\tadd.set(rt,add.get(rt) + C);\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tpushDown(sum, add, rt, m - l + 1, r - m);\n\t\tif(L <= m)\n\t\t{\n\t\t\tupdate(sum, add, L, R, C, l, m, rt << 1);\n\t\t}\n\t\tif(R > m)\n\t\t{\n\t\t\tupdate(sum, add, L, R, C, m + 1, r, rt << 1 1);\n\t\t}\n\t}\nstatic int query(Vector<Integer> sum,Vector<Integer> add, int L, int R, int l,int r, int rt)\n\t{\n\t\tif (L <= l && r <= R)\n\t\t{\n\t\t\treturn sum.get(rt);\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tpushDown(sum, add, rt, m - l + 1, r - m);\n\t\tint ans = 0;\n\t\tif(L <= m)\n\t\t{\n\t\t\tans += query(sum, add, L, R, l, m, rt << 1);\n\t\t}\n\t\tif(R > m)\n\t\t{\n\t\t\tans += query(sum, add, L, R, m + 1, r,rt << 1 1);\n\t\t}\n\t\treturn ans;\n\t}\nstatic void sequenceMaintenance(int n, int q, Vector<Integer> a, Vector<Integer> b,int m)\n\t{\n\t\tCollections.sort(a);\n\t\tVector<Integer> sum = new Vector<Integer>();\n\t\tVector<Integer> ad = new Vector<Integer>();\n\t\tVector<Integer> ans = new Vector<Integer>();\n\t\tfor(int i = 0; i < (n << 2); i++)\n\t\t{\n\t\t\tsum.add(0);\n\t\t\tad.add(0);\n\t\t}\n\t\tbuild(sum, a, 1, n, 1);\n\t\tfor(int i = 0; i < q; i++)\n\t\t{\n\t\t\tint l = 1, r = n, pos = -1;\n\t\t\twhile(l <= r)\n\t\t\t{\n\t\t\t\tm = (l + r) >> 1;\n\t\t\t\tif(query(sum, ad, m, m, 1, n, 1) >= b.get(i))\n\t\t\t\t{\n\t\t\t\t\tr = m - 1;\n\t\t\t\t\tpos = m;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tl = m + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos == -1)\n\t\t\t{\n\t\t\t\tans.add(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans.add(n - pos + 1);\n\t\t\t\tupdate(sum, ad, pos, n, -m, 1, n, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < ans.size(); i++)\n\t\t{\n\t\t\tSystem.out.print(ans.get(i) + \" \");\n\t\t}\n\t}", "3487": "static int count(String s)\n\t{\n\t\tint cnt = 0;\n\t\tfor (char c : s.toCharArray()) {\n\t\t\tcnt += c == '0' ? 1 : 0;\n\t\t}\n\t\tif (cnt % 3 != 0)\n\t\t\treturn 0;\n\t\tint res = 0, k = cnt / 3, sum = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tsum += s.charAt(i) == '0' ? 1 : 0;\n\t\t\tif (sum == 2 * k && map.containsKey(k)\n\t\t\t\t&& i < s.length() - 1 && i > 0) {\n\t\t\t\tres += map.get(k);\n\t\t\t}\n\t\t\tmap.put(sum,\n\t\t\t\t\tmap.getOrDefault(sum, 0) + 1);\n\t\t}\n\t\treturn res;\n\t}", "3488": "static int splitstring(String s)\n{\n\tint n = s.length();\n\tint zeros = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tif (s.charAt(i) == '0')\n\t\t\tzeros++;\n\tif (zeros % 3 != 0)\n\t\treturn 0;\n\tif (zeros == 0)\n\t\treturn ((n - 1) * (n - 2)) / 2;\n\tint zerosInEachSubstring = zeros / 3;\n\tint waysOfFirstCut = 0;\n\tint waysOfSecondCut = 0;\n\tint count = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (s.charAt(i) == '0')\n\t\t\tcount++;\n\t\tif (count == zerosInEachSubstring)\n\t\t\twaysOfFirstCut++;\n\t\telse if (count == 2 * zerosInEachSubstring)\n\t\t\twaysOfSecondCut++;\n\t}\n\treturn waysOfFirstCut * waysOfSecondCut;\n}", "3495": "static boolean check(String s, int k)\n{\n int n = s.length();\n for (int i = 0; i < k; i++)\n {\n\tfor (int j = i; j < n; j += k)\n\t{\n\tif (s.charAt(i) != s.charAt(j))\n\t\treturn false;\n\t}\n }\n int c = 0;\n for (int i = 0; i < k; i++)\n {\n\tif (s.charAt(i) == '0')\n\tc++;\n\telse\n\tc--;\n }\n if (c == 0)\n\treturn true;\n else\n\treturn false;\n}", "3503": "static void addEdge(int a, int b)\n{\n tree[a].add(b);\n tree[b].add(a);\n}\nstatic void dfs(int x)\n{\n vis[x] = true;\n subtreeSize[x] = 1;\n for (int i : tree[x])\n {\n\tif (!vis[i])\n\t{\n\tdfs(i);\n\tsubtreeSize[x] += subtreeSize[i];\n\t}\n }\n}\nstatic void countPairs(int a, int b)\n{\n int sub = Math.min(subtreeSize[a], subtreeSize[b]);\n System.out.print(sub * (n - sub) + \"\\n\");\n}", "3516": "static int revNum(int N)\n{\n\tint x = 0;\n\twhile (N != 0)\n\t{\n\t\tx = x * 10 + N % 10;\n\t\tN = N / 10;\n\t}\n\treturn x;\n}\nstatic int ctNonPalin(int arr[], int N)\n{\n\tint Res = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tint x = revNum(arr[i]);\n\t\tif (x == arr[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(arr[i] % 10 == x % 10)\n\t\t\t\tRes += 1;\n\t\t}\n\t}\n\treturn Res;\n}", "3520": "static boolean isSame(String str, int n)\n{\n\tHashMap<Integer,\n\t\t\tInteger> mp = new HashMap<Integer,\n\t\t\t\t\t\t\t\t\tInteger>();\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tif(mp.containsKey(str.charAt(i) - 'a'))\n\t\t{\n\t\t\tmp.put(str.charAt(i) - 'a',\n\t\t\t\tmp.get(str.charAt(i) - 'a') + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.put(str.charAt(i) - 'a', 1);\n\t\t}\n\t}\n\tfor (Map.Entry<Integer, Integer> it : mp.entrySet())\n\t{\n\t\tif ((it.getValue()) >= n)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "3531": "static boolean canTransform(String str1, String str2)\n\t{\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tfor (char c : str1.toCharArray())\n\t\t{\n\t\t\tif (c != 'C')\n\t\t\t{\n\t\t\t\ts1 += c;\n\t\t\t}\n\t\t}\n\t\tfor (char c : str2.toCharArray())\n\t\t{\n\t\t\tif (c != 'C')\n\t\t\t{\n\t\t\t\ts2 += c;\n\t\t\t}\n\t\t}\n\t\tif (!s1.equals(s2))\n\t\t\treturn false;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint n = str1.length();\n\t\twhile (i < n && j < n)\n\t\t{\n\t\t\tif (str1.charAt(i) == 'C')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (str2.charAt(j) == 'C')\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((str1.charAt(i) == 'A' && i < j) ||\n\t\t\t\t\t(str1.charAt(i) == 'B' && i > j))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "3540": "static double func(double a, double b, double c, double x)\n{\n\treturn a * x * x + b * x + c;\n}\nstatic double findRoot(double a, double b, double c, double low, double high)\n{\n\tdouble x = -1;\n\twhile (Math.abs(high - low) > eps)\n\t{\n\t\tx = (low + high) / 2;\n\t\tif (func(a, b, c, low) *\n\t\t\tfunc(a, b, c, x) <= 0)\n\t\t{\n\t\t\thigh = x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlow = x;\n\t\t}\n\t}\n\treturn x;\n}\nstatic void solve(double a, double b, double c, double A, double B)\n{\n\tif (func(a, b, c, A) * func(a, b, c, B) > 0)\n\t{\n\t\tSystem.out.println(\"No solution\");\n\t}\n\telse\n\t{\n\t\tSystem.out.format(\"%.4f\", findRoot( a, b, c, A, B));\n\t}\n}", "3550": "static int __gcd(int a, int b) \n{ \n\treturn b == 0? a:__gcd(b, a % b);\t\n}\nstatic boolean hasCoprimePair(int []arr, int n)\n{\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif ((__gcd(arr[i], arr[j])) == 1)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "3555": "static int findPermutation(Set<Integer>arr, int N)\n{\n\tint pos = arr.size() + 1;\n\tif (pos > N)\n\t\treturn 1;\n\tint res = 0;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tif (! arr.contains(i))\n\t\t{\n\t\t\tif (i % pos == 0 pos % i == 0)\n\t\t\t{\n\t\t\t\tarr.add(i);\n\t\t\t\tres += findPermutation(arr, N);\n\t\t\t\tarr.remove(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "3562": "static void solve(int arr[], int n, int X, int Y)\n{\n\tint diff = Y - X;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] != 1)\n\t\t{\n\t\t\tdiff = diff % (arr[i] - 1);\n\t\t}\n\t}\n\tif (diff == 0)\n\t\tSystem.out.print( \"Yes\");\n\telse\n\t\tSystem.out.print(\"No\");\n}", "3564": "static int Numberofways(int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int a = 1; a < n; a++) {\n\t\t\tfor (int b = 0; b < n; b++) {\n\t\t\t\tint c = n - (a + b);\n\t\t\t\tif (a + b > c && a + c > b && b + c > a) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn count;\n}", "3567": "static int maxsubStringLength(char[] S, int N)\n{\n\tint arr[] = new int[N];\n\tfor(int i = 0; i < N; i++)\n\tif (S[i] == 'a' S[i] == 'e' S[i] == 'i' S[i] == 'o' S[i] == 'u')\n\t\tarr[i] = 1;\n\telse\n\t\tarr[i] = -1;\n\tint maxLen = 0;\n\tint curr_sum = 0;\n\tHashMap<Integer, Integer> hash = new HashMap<>();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tcurr_sum += arr[i];\n\t\tif (curr_sum == 0)\n\t\t\tmaxLen = Math.max(maxLen, i + 1);\n\t\tif (hash.containsKey(curr_sum))\n\t\t\tmaxLen = Math.max(maxLen,\n\t\t\t\t\t\t\ti - hash.get(curr_sum));\n\t\telse\n\t\t\thash.put(curr_sum, i);\n\t}\n\treturn maxLen;\n}", "3584": "public static int findMaximumSum(int[] a, int n)\n\t{\n\t\tint prev_smaller[] = findPrevious(a, n);\n\t\tint next_smaller[] = findNext(a, n);\n\t\tint max_value = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmax_value\n\t\t\t\t= Math.max(max_value,\n\t\t\t\t\t\ta[i] * (next_smaller[i] - prev_smaller[i] - 1));\n\t\t}\n\t\treturn max_value;\n\t}\npublic static int[] findPrevious(int[] a, int n)\n\t{\n\t\tint ps[] = new int[n];\n\t\tps[0] = -1;\n\t\tStack<Integer> stack = new Stack<>();\n\t\tstack.push(0);\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\twhile (stack.size() > 0\n\t\t\t\t&& a[stack.peek()] >= a[i])\n\t\t\t\tstack.pop();\n\t\t\tps[i] = stack.size() > 0 ? stack.peek() : -1;\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn ps;\n\t}\npublic static int[] findNext(int[] a, int n)\n\t{\n\t\tint ns[] = new int[n];\n\t\tns[n - 1] = n;\n\t\tStack<Integer> stack = new Stack<>();\n\t\tstack.push(n - 1);\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\twhile (stack.size() > 0\n\t\t\t\t&& a[stack.peek()] >= a[i])\n\t\t\t\tstack.pop();\n\t\t\tns[i] = stack.size() > 0 ? stack.peek()\n\t\t\t\t\t\t\t\t\t: a.length;\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn ns;\n\t}", "3601": "static boolean possible(long mid, int[] a)\n{\n\tlong n = a.length;\n\tlong total = (n * (n - 1)) / 2;\n\tlong need = (total + 1) / 2;\n\tlong count = 0;\n\tlong start = 0, end = 1;\n\twhile (end < n)\n\t{\n\t\tif (a[(int)end] - a[(int)start] <= mid)\n\t\t{\n\t\t\tend++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount += (end - start - 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\tif (end == n && start < end &&\n\t\ta[(int)end - 1] - a[(int)start] <= mid)\n\t{\n\t\tlong t = end - start - 1;\n\t\tcount += (t * (t + 1) / 2);\n\t}\n\tif (count >= need)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nstatic long findMedian(int[] a)\n{\n\tlong n = a.length;\n\tlong low = 0, high = a[(int)n - 1] - a[0];\n\twhile (low <= high)\n\t{\n\t\tlong mid = (low + high) / 2;\n\t\tif (possible(mid, a))\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\treturn high + 1;\n}", "3605": "static void FindMinimumDistance()\n{\n\tQueue<pair> q = new LinkedList<>();\n\tq.add(new pair(x, y));\n\tmat[x][y] = 0;\n\twhile (!q.isEmpty())\n\t{\n\t\tx = q.peek().first;\n\t\ty = q.peek().second;\n\t\tq.remove();\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint a = x + dx[i];\n\t\t\tint b = y + dy[i];\n\t\t\tif (a < 0 a >= r b >= c b < 0)\n\t\t\t\tcontinue;\n\t\t\tif (mat[a][b] == 0)\n\t\t\t{\n\t\t\t\tmat[a][b] = mat[x][y] + 1;\n\t\t\t\tq.add(new pair(a, b));\n\t\t\t}\n\t\t}\n\t}\n}", "3629": "static void addEdge(int u, int v)\n{\n\tadj[u].add(v);\n\tadj[v].add(u);\n}\nstatic void dfs1(int cur, int par)\n{\n\tfor(int u : adj[cur])\n\t{\n\t\tif (u != par)\n\t\t{\n\t\t\tdfs1(u, cur);\n\t\t\theight[cur] = Math.max(height[cur], height[u]);\n\t\t}\n\t}\n\theight[cur] += 1;\n}\nstatic void dfs2(int cur, int par)\n{\n\tint max1 = 0;\n\tint max2 = 0;\n\tfor(int u : adj[cur])\n\t{\n\t\tif (u != par)\n\t\t{\n\t\t\tif (height[u] >= max1)\n\t\t\t{\n\t\t\t\tmax2 = max1;\n\t\t\t\tmax1 = height[u];\n\t\t\t}\n\t\t\telse if (height[u] > max2)\n\t\t\t{\n\t\t\t\tmax2 = height[u];\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor(int u : adj[cur])\n\t{\n\t\tif (u != par)\n\t\t{\n\t\t\tsum = ((max1 == height[u]) ? max2 : max1);\n\t\t\tif (max1 == height[u])\n\t\t\t\tdist[u] = 1 + Math.max(1 + max2, dist[cur]);\n\t\t\telse\n\t\t\t\tdist[u] = 1 + Math.max(1 + max1, dist[cur]);\n\t\t\tdfs2(u, cur);\n\t\t}\n\t}\n}", "3644": "static void countPairs(int N, int[] arr)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (i == arr[arr[i] - 1] - 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count / 2);\n\t}", "3664": "public static int minOperations(String S, int K)\n{\n\tint ans = 0;\n\tfor(int i = 0; i < K; i++)\n\t{\n\t\tint zero = 0, one = 0;\n\t\tfor(int j = i; j < S.length(); j += K)\n\t\t{\n\t\t\tif (S.charAt(j) == '0')\n\t\t\t\tzero++;\n\t\t\telse\n\t\t\t\tone++;\n\t\t}\n\t\tans += Math.min(zero, one);\n\t}\n\treturn ans;\n}", "3678": "static void UniversalSubset(List<String> A, List<String> B)\n{\n\tint n1 = A.size();\n\tint n2 = B.size();\n\tList<String> res = new ArrayList<>();\n\tint[][] A_fre = new int[n1][26];\n\tfor(int i = 0; i < n1; i++)\n\t{\n\t\tfor(int j = 0; j < 26; j++)\n\t\t\tA_fre[i][j] = 0;\n\t}\n\tfor(int i = 0; i < n1; i++)\n\t{\n\t\tfor(int j = 0; j < A.get(i).length(); j++)\n\t\t{\n\t\t\tA_fre[i][A.get(i).charAt(j) - 'a']++;\n\t\t}\n\t}\n\tint[] B_fre = new int[26];\n\tfor(int i = 0; i < n2; i++)\n\t{\n\t\tint[] arr = new int[26] ;\n\t\tfor(int j = 0; j < B.get(i).length(); j++)\n\t\t{\n\t\t\tarr[B.get(i).charAt(j) - 'a']++;\n\t\t\tB_fre[B.get(i).charAt(j) - 'a'] = Math.max(\n\t\t\tB_fre[B.get(i).charAt(j) - 'a'],\n\t\t\tarr[B.get(i).charAt(j) - 'a']);\n\t\t}\n\t}\n\tfor(int i = 0; i < n1; i++)\n\t{\n\t\tint flag = 0;\n\t\tfor(int j = 0; j < 26; j++)\n\t\t{\n\t\t\tif (A_fre[i][j] < B_fre[j])\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0)\n\t\t\tres.add(A.get(i));\n\t}\n\tif (res.size() != 0)\n\t{\n\t\tfor(int i = 0; i < res.size(); i++)\n\t\t{\n\t\t\tfor(int j = 0;\n\t\t\t\t\tj < res.get(i).length(); j++)\n\t\t\tSystem.out.print(res.get(i).charAt(j));\n\t\t}\n\t\tSystem.out.print(\" \");\n\t}\n\telse\n\tSystem.out.print(\"-1\");\n}", "3692": "public static void\n\tfindPair(int a[], int n)\n\t{\n\t\tint min_dist = Integer.MAX_VALUE;\n\t\tint index_a = -1, index_b = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (j - i < min_dist) {\n\t\t\t\t\tif (a[i] % a[j] == 0 a[j] % a[i] == 0) {\n\t\t\t\t\t\tmin_dist = j - i;\n\t\t\t\t\t\tindex_a = i;\n\t\t\t\t\t\tindex_b = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (index_a == -1) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.print(\n\t\t\t\t\"(\" + a[index_a] + \", \" + a[index_b] + \")\");\n\t\t}\n\t}", "3704": "static void printNum(int L, int R)\n{\n\tfor(int i = L; i <= R; i++)\n\t{\n\t\tint temp = i;\n\t\tint c = 10;\n\t\tint flag = 0;\n\t\twhile (temp > 0)\n\t\t{\n\t\t\tif (temp % 10 >= c)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = temp % 10;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tif (flag == 0)\n\t\t\tSystem.out.print(i + \" \");\n\t}\n}", "3742": "static int findMissing(int arr[], int left, int right, int diff)\n{\n\tif (right <= left)\n\t\treturn 0;\n\tint mid = left + (right - left) / 2;\n\tif (arr[mid + 1] - arr[mid] != diff)\n\t\treturn (arr[mid] + diff);\n\tif (mid > 0 && arr[mid] - arr[mid - 1] != diff)\n\t\treturn (arr[mid - 1] + diff);\n\tif (arr[mid] == arr[0] + mid * diff)\n\t\treturn findMissing(arr, mid + 1, right, diff);\n\treturn findMissing(arr, left, mid - 1, diff);\n}\nstatic int missingElement(int arr[], int n)\n{\n\tArrays.sort(arr);\n\tint diff = (arr[n - 1] - arr[0]) / n;\n\treturn findMissing(arr, 0, n - 1, diff);\n}", "3743": "static int missingElement(int arr[], int n)\n{\n\tint max_ele = arr[0];\n\tint min_ele = arr[0];\n\tint x = 0;\n\tint d;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tif (arr[i] > max_ele)\n\t\tmax_ele = arr[i];\n\tif (arr[i] < min_ele)\n\t\tmin_ele = arr[i];\n\t}\n\td = (max_ele - min_ele) / n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tx = x ^ arr[i];\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t{\n\tx = x ^ (min_ele + (i * d));\n\t}\n\treturn x;\n}", "3752": "static int power(int x, int y)\n{\n\tint temp;\n\tif (y == 0)\n\t\treturn 1;\n\ttemp = power(x, y / 2);\n\tif (y % 2 == 0)\n\t\treturn temp * temp;\n\telse\n\t\treturn x * temp * temp;\n}\nstatic int nthRootSearch(int low, int high, int N, int K)\n{\n\tif (low <= high)\n\t{\n\t\tint mid = (low + high) / 2;\n\t\tif ((power(mid, K) <= N) &&\n\t\t\t(power(mid + 1, K) > N))\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\telse if (power(mid, K) < N)\n\t\t{\n\t\t\treturn nthRootSearch(mid + 1, high, N, K);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn nthRootSearch(low, mid - 1, N, K);\n\t\t}\n\t}\n\treturn low;\n}", "3755": "static int get_subset_count(int arr[], int K, int N)\n{\n\tArrays.sort(arr);\n\tint left, right;\n\tleft = 0;\n\tright = N - 1;\n\tint ans = 0;\n\twhile (left <= right)\n\t{\n\t\tif (arr[left] + arr[right] < K)\n\t\t{\n\t\t\tans += 1 << (right - left);\n\t\t\tleft++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tright--;\n\t\t}\n\t}\n\treturn ans;\n}", "3765": "static int minMaxDiff(int arr[], int n, int k)\n{\n\tint max_adj_dif = Integer.MIN_VALUE;\n\tfor(int i = 0; i < n - 1; i++)\n\t\tmax_adj_dif = Math.max(max_adj_dif,\n\t\t\t\t\tMath.abs(arr[i] - arr[i + 1]));\n\tif (max_adj_dif == 0)\n\t\treturn 0;\n\tint best = 1;\n\tint worst = max_adj_dif;\n\tint mid, required;\n\twhile (best < worst)\n\t{\n\t\tmid = (best + worst) / 2;\n\t\trequired = 0;\n\t\tfor(int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\trequired += (Math.abs(arr[i] - arr[i + 1]) - 1) / mid;\n\t\t}\n\t\tif (required > k)\n\t\t\tbest = mid + 1;\n\t\telse\n\t\t\tworst = mid;\n\t}\n\treturn worst;\n}", "3773": "static void checkMin(int arr[], int len)\n{\n\tint smallest = Integer.MAX_VALUE;\n\tint secondSmallest = Integer.MAX_VALUE;\n\tfor(int i = 0; i < len; i++)\n\t{\n\tif (arr[i] < smallest)\n\t{\n\t\tsecondSmallest = smallest;\n\t\tsmallest = arr[i];\n\t}\n\telse if (arr[i] < secondSmallest)\n\t{\n\t\tsecondSmallest = arr[i];\n\t}\n\t}\n\tif (2 * smallest <= secondSmallest)\n\t\tSystem.out.print(\"Yes\");\n\telse\n\t\tSystem.out.print(\"No\");\n}", "3798": "static void createHash(HashSet<Integer> hash, int maxElement)\n{\n\tint prev = 0, curr = 1;\n\thash.add(prev);\n\thash.add(curr);\n\twhile (curr <= maxElement) {\n\t\tint temp = curr + prev;\n\t\thash.add(temp);\n\t\tprev = curr;\n\t\tcurr = temp;\n\t}\n}\nstatic void fibonacci(int arr[], int n)\n{\n\tint max_val= Arrays.stream(arr).max().getAsInt();\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\tcreateHash(hash, max_val);\n\tint minimum = Integer.MAX_VALUE;\n\tint maximum = Integer.MIN_VALUE;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (hash.contains(arr[i])) {\n\t\t\tminimum = Math.min(minimum, arr[i]);\n\t\t\tmaximum = Math.max(maximum, arr[i]);\n\t\t}\n\t}\n\tSystem.out.print(minimum+ \", \" + maximum +\"\\n\");\n}", "3814": "static boolean isValidLen(String s, int len, int k)\n\t{\n\t\tint n = s.length();\n\t\tMap<Character,\n\t\t\tInteger> mp = new HashMap<Character,\n\t\t\t\t\t\t\t\t\tInteger>();\n\t\tint right = 0;\n\t\twhile (right < len)\n\t\t{\n\t\t\tif (mp.containsKey(s.charAt(right)))\n\t\t\t{\n\t\t\t\tmp.put(s.charAt(right),\n\t\t\t\tmp.get(s.charAt(right)) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.put(s.charAt(right), 1);\n\t\t\t}\n\t\t\tright++;\n\t\t}\n\t\tif (mp.size() <= k)\n\t\t\treturn true;\n\t\twhile (right < n)\n\t\t{\n\t\t\tif (mp.containsKey(s.charAt(right)))\n\t\t\t{\n\t\t\t\tmp.put(s.charAt(right),\n\t\t\t\tmp.get(s.charAt(right)) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.put(s.charAt(right), 1);\n\t\t\t}\n\t\t\tif (mp.containsKey(s.charAt(right - len)))\n\t\t\t{\n\t\t\t\tmp.put(s.charAt(right - len),\n\t\t\t\tmp.get(s.charAt(right - len)) - 1);\n\t\t\t}\n\t\t\tif (mp.get(s.charAt(right - len)) == 0)\n\t\t\t\tmp.remove(s.charAt(right - len));\n\t\t\tif (mp.size() <= k)\n\t\t\t\treturn true;\n\t\t\tright++;\n\t\t}\n\t\treturn mp.size() <= k;\n\t}\nstatic int maxLenSubStr(String s, int k)\n\t{\n\t\tSet<Character> uni = new HashSet<Character>();\n\t\tfor (Character x : s.toCharArray())\n\t\t\tuni.add(x);\n\t\tif (uni.size() < k)\n\t\t\treturn -1;\n\t\tint n = s.length();\n\t\tint lo = -1, hi = n + 1;\n\t\twhile (hi - lo > 1)\n\t\t{\n\t\t\tint mid = lo + hi >> 1;\n\t\t\tif (isValidLen(s, mid, k))\n\t\t\t\tlo = mid;\n\t\t\telse\n\t\t\t\thi = mid;\n\t\t}\n\t\treturn lo;\n\t}", "3822": "static boolean isSquarePossible(int arr[], int n, int l)\n\t{\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] >= l)\n\t\t\t\tcnt++;\n\t\t\tif (cnt >= l)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\nstatic int maxArea(int arr[], int n)\n\t{\n\t\tint l = 0, r = n;\n\t\tint len = 0;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint m = l + ((r - l) / 2);\n\t\t\tif (isSquarePossible(arr, n, m))\n\t\t\t{\n\t\t\t\tlen = m;\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tr = m - 1;\n\t\t}\n\t\treturn (len * len);\n\t}", "3825": "static boolean kOverlap(ArrayList<Pair> pairs, int k)\n{\n\tArrayList<Pair> vec = new ArrayList<>();\n\tfor(int i = 0; i < pairs.size(); i++)\n\t{\n\t\tvec.add(new Pair(pairs.get(i).first, -1));\n\t\tvec.add(new Pair(pairs.get(i).second, +1));\n\t}\n\tCollections.sort(vec, new Comparator<Pair>()\n\t{\n\t\tpublic int compare(Pair a, Pair b)\n\t\t{\n\t\t\tif (a.first != b.first)\n\t\t\t\treturn a.first - b.first;\n\t\t\treturn (a.second - b.second); } });\n\tStack<Pair> st = new Stack<>();\n\tfor(int i = 0; i < vec.size(); i++)\n\t{\n\t\tPair cur = vec.get(i);\n\t\tif (cur.second == -1)\n\t\t{\n\t\t\tst.push(cur);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tst.pop();\n\t\t}\n\t\tif (st.size() >= k)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\npublic int compare(Pair a, Pair b)\n\t\t{\n\t\t\tif (a.first != b.first)\n\t\t\t\treturn a.first - b.first;\n\t\t\treturn (a.second - b.second); }", "3829": "static void insertNames(String arr[], int n)\n{\n\tHashSet<String> set = new HashSet<String>();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (!set.contains(arr[i]))\n\t\t{\n\t\t\tSystem.out.print(\"No\\n\");\n\t\t\tset.add(arr[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(\"Yes\\n\");\n\t\t}\n\t}\n}", "3871": "static int countLessThan(int arr[], int n, int key)\n\t{\n\t\tint l = 0, r = n - 1;\n\t\tint index = -1;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (arr[m] < key)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t\tindex = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t}\n\t\t}\n\t\treturn (index + 1);\n\t}\nstatic int countGreaterThan(int arr[], int n, int key)\n\t{\n\t\tint l = 0, r = n - 1;\n\t\tint index = -1;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (arr[m] <= key)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t\tindex = m;\n\t\t\t}\n\t\t}\n\t\tif (index == -1)\n\t\t\treturn 0;\n\t\treturn (n - index);\n\t}\nstatic int countTriplets(int n, int a[], int b[], int c[])\n\t{\n\t\tArrays.sort(a) ;\n\t\tArrays.sort(b);\n\t\tArrays.sort(c);\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint current = b[i];\n\t\t\tint low = countLessThan(a, n, current);\n\t\t\tint high = countGreaterThan(c, n, current);\n\t\t\tcount += (low * high);\n\t\t}\n\t\treturn count;\n\t}", "3885": "static void Printksubstring(String str, int n, int k)\n\t{\n\t\tint total = (n * (n + 1)) / 2;\n\t\tif (k > total)\n\t\t{\n\t\t\tSystem.out.printf(\"-1\\n\");\n\t\t\treturn;\n\t\t}\n\t\tint substring[] = new int[n + 1];\n\t\tsubstring[0] = 0;\n\t\tint temp = n;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tsubstring[i] = substring[i - 1] + temp;\n\t\t\ttemp--;\n\t\t}\n\t\tint l = 1;\n\t\tint h = n;\n\t\tint start = 0;\n\t\twhile (l <= h)\n\t\t{\n\t\t\tint m = (l + h) / 2;\n\t\t\tif (substring[m] > k)\n\t\t\t{\n\t\t\t\tstart = m;\n\t\t\t\th = m - 1;\n\t\t\t}\n\t\t\telse if (substring[m] < k)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint end = n - (substring[start] - k);\n\t\tfor (int i = start - 1; i < end; i++)\n\t\t{\n\t\t\tSystem.out.print(str.charAt(i));\n\t\t}\n\t}", "3932": "static int LowerInsertionPoint(int arr[], int n, int X)\n\t{\n\tif (X < arr[0])\n\t\treturn 0;\n\telse if (X > arr[n - 1])\n\t\treturn n;\n\tint lowerPnt = 0;\n\tint i = 1;\n\twhile (i < n && arr[i] < X) {\n\t\tlowerPnt = i;\n\t\ti = i * 2;\n\t}\n\twhile (lowerPnt < n && arr[lowerPnt] < X)\n\t\tlowerPnt++;\n\treturn lowerPnt;\n\t}", "3967": "static int LongestFibSubseq(int A[], int n) {\n\t\tTreeSet<Integer> S = new TreeSet<>();\n\t\tfor (int t : A) {\n\t\t\tS.add(t);\n\t\t}\n\t\tint maxLen = 0, x, y;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tx = A[j];\n\t\t\t\ty = A[i] + A[j];\n\t\t\t\tint length = 3;\n\t\t\t\twhile (S.contains(y) && (y != S.last())) {\n\t\t\t\t\tint z = x + y;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = z;\n\t\t\t\t\tmaxLen = Math.max(maxLen, ++length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxLen >= 3 ? maxLen : 0;\n\t}", "4039": "static int getCount(int M, int N)\n{\n\tint count = 0;\n\tif (M == 1)\n\t\treturn N;\n\tif (N == 1)\n\t\treturn M;\n\tif (N > M) {\n\t\tfor (int i = 1; i <= M; i++) {\n\t\t\tint numerator = N * i - N + M - i;\n\t\t\tint denominator = M - 1;\n\t\t\tif (numerator % denominator == 0) {\n\t\t\t\tint j = numerator / denominator;\n\t\t\t\tif (j >= 1 && j <= N)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tint numerator = M * j - M + N - j;\n\t\t\tint denominator = N - 1;\n\t\t\tif (numerator % denominator == 0) {\n\t\t\t\tint i = numerator / denominator;\n\t\t\t\tif (i >= 1 && i <= M)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "4048": "static boolean swapElement(int[] arr1, int[] arr2, int n)\n{\n\tint wrongIdx = 0;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (arr1[i] < arr1[i - 1])\n\t\t{\n\t\t\twrongIdx = i;\n\t\t}\n\t}\n\tint maximum = Integer.MIN_VALUE;\n\tint maxIdx = -1;\n\tboolean res = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr2[i] > maximum && arr2[i] >= arr1[wrongIdx - 1])\n\t\t{\n\t\t\tif (wrongIdx + 1 <= n - 1 && arr2[i] <= arr1[wrongIdx + 1])\n\t\t\t{\n\t\t\t\tmaximum = arr2[i];\n\t\t\t\tmaxIdx = i;\n\t\t\t\tres = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (res)\n\t{\n\t\tswap(arr1, wrongIdx, arr2, maxIdx);\n\t}\n\treturn res;\n}\nstatic void swap(int[] a, int wrongIdx, int[] b, int maxIdx)\n{\n\tint c = a[wrongIdx];\n\ta[wrongIdx] = b[maxIdx];\n\tb[maxIdx] = c;\n}\nstatic void getSortedArray(int arr1[], int arr2[], int n)\n{\n\tif (swapElement(arr1, arr2, n))\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tSystem.out.print(arr1[i] + \" \");\n\t\t}\n\t}\n\telse\n\t{\n\t\tSystem.out.println(\"Not Possible\");\n\t}\n}", "4052": "static int costToBalance(String s)\n\t{\n\t\tif (s.length() == 0)\n\t\t\tSystem.out.println(0);\n\t\tint ans = 0;\n\t\tint o = 0, c = 0;\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t{\n\t\t\tif (s.charAt(i) == '(')\n\t\t\t\to++;\n\t\t\tif (s.charAt(i) == ')')\n\t\t\t\tc++;\n\t\t}\n\t\tif (o != c)\n\t\t\treturn -1;\n\t\tint []a = new int[s.length()];\n\t\tif (s.charAt(0) == '(')\n\t\t\ta[0] = 1;\n\t\telse\n\t\t\ta[0] = -1;\n\t\tif (a[0] < 0)\n\t\t\tans += Math.abs(a[0]);\n\t\tfor (int i = 1; i < s.length(); i++)\n\t\t{\n\t\t\tif (s.charAt(i) == '(')\n\t\t\t\ta[i] = a[i - 1] + 1;\n\t\t\telse\n\t\t\t\ta[i] = a[i - 1] - 1;\n\t\t\tif (a[i] < 0)\n\t\t\t\tans += Math.abs(a[i]);\n\t\t}\n\t\treturn ans;\n\t}", "4079": "public static int middleOfThree(int a, int b, int c)\n\t{\n\t\tif ((a < b && b < c) || (c < b && b < a))\n\t\t\treturn b;\n\t\telse if ((b < a && a < c) || (c < a && a < b))\n\t\treturn a;\n\t\telse\n\t\treturn c;\n\t}", "4080": "public static int middleOfThree(int a, int b, int c)\n\t{\n\t\tif (a > b)\n\t\t{\n\t\t\tif (b > c)\n\t\t\t\treturn b;\n\t\t\telse if (a > c)\n\t\t\t\treturn c;\n\t\t\telse\n\t\t\t\treturn a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a > c)\n\t\t\t\treturn a;\n\t\t\telse if (b > c)\n\t\t\t\treturn c;\n\t\t\telse\n\t\t\t\treturn b;\n\t\t}\n\t}", "4081": "public static int middleOfThree(int a, int b, int c)\n\t{\n\t\tint x = a - b;\nint y = b - c; \nint z = a - c; \n\t\tif (x * y > 0)\n\t\t\treturn b;\n\t\telse if (x * z > 0)\n\t\t\treturn c;\n\t\telse\n\t\t\treturn a;\n\t}", "4099": "public static void missing4(int[] arr)\n\t{\n\t\tint[] helper = new int[4];\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tint temp = Math.abs(arr[i]);\n\t\t\tif (temp <= arr.length)\n\t\t\t\tarr[temp - 1] *= (-1);\n\t\t\telse if (temp > arr.length) {\n\t\t\t\tif (temp % arr.length != 0)\n\t\t\t\t\thelper[temp % arr.length - 1] = -1;\n\t\t\t\telse\n\t\t\t\t\thelper[(temp % arr.length) + arr.length - 1] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tif (arr[i] > 0)\n\t\t\t\tSystem.out.print(i + 1 + \" \");\t\n\t\tfor (int i = 0; i < helper.length; i++)\n\t\t\tif (helper[i] >= 0)\n\t\t\t\tSystem.out.print(arr.length + i + 1 + \" \");\t\t\n\t\treturn;\n\t}", "4129": "static void lexiMiddleSmallest(int K, int N)\n\t{\n\t\tif (K % 2 == 0) {\n\t\t\tSystem.out.print(K / 2 + \" \");\n\t\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\t\tSystem.out.print(K + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\treturn;\n\t\t}\n\t\tArrayList<Integer> a = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < N / 2; ++i) {\n\t\t\tif (a.get(a.size() - 1) == 1) {\n\t\t\t\ta.remove(a.size() - 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = a.get(a.size() - 1) - 1;\n\t\t\t\ta.set(a.get(a.size() - 1), t);\n\t\t\t\twhile (a.size() < N) {\n\t\t\t\t\ta.add(K);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i : a) {\n\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}", "4155": "static int[][] transpose(int[][] mat, int row, int col)\n{\n\tint[][] tr = new int[col][row];\n\tfor(int i = 0; i < row; i++)\n\t{\n\t\tfor(int j = 0; j < col; j++)\n\t\t{\n\t\t\ttr[j][i] = mat[i][j];\n\t\t}\n\t}\n\treturn tr;\n}\nstatic void RowWiseSort(int[][] B)\n{\n\tfor(int i = 0; i < (int)B.length; i++)\n\t{\n\t\tArrays.sort(B[i]);\n\t}\n}\nstatic void sortCol(int[][] mat, int N, int M)\n{\n\tint[][] B = transpose(mat, N, M);\n\tRowWiseSort(B);\n\tmat = transpose(B, M, N);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tfor(int j = 0; j < M; j++)\n\t\t{\n\t\t\tSystem.out.print(mat[i][j] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "4169": "static void largestArea(int N, int M, int[] H, int[] V)\n\t{\n\t\tSet<Integer> s1 = new HashSet<>();\n\t\tSet<Integer> s2 = new HashSet<>();\n\t\tfor (int i = 1; i <= N + 1; i++)\n\t\t\ts1.add(i);\n\t\tfor (int i = 1; i <= M + 1; i++)\n\t\t\ts2.add(i);\n\t\tfor (int i = 0; i < H.length; i++) {\n\t\t\ts1.remove(H[i]);\n\t\t}\n\t\tfor (int i = 0; i < V.length; i++) {\n\t\t\ts2.remove(V[i]);\n\t\t}\n\t\tint[] list1 = new int[s1.size()];\n\t\tint[] list2 = new int[s2.size()];\n\t\tint i = 0;\n\t\tIterator it1 = s1.iterator();\n\t\twhile (it1.hasNext()) {\n\t\t\tlist1[i++] = (int)it1.next();\n\t\t}\n\t\ti = 0;\n\t\tIterator it2 = s2.iterator();\n\t\twhile (it2.hasNext()) {\n\t\t\tlist2[i++] = (int)it2.next();\n\t\t}\n\t\tArrays.sort(list1);\n\t\tArrays.sort(list2);\n\t\tint maxH = 0, p1 = 0, maxV = 0, p2 = 0;\n\t\tfor (int j = 0; j < list1.length; j++) {\n\t\t\tmaxH = Math.max(maxH, list1[j] - p1);\n\t\t\tp1 = list1[j];\n\t\t}\n\t\tfor (int j = 0; j < list2.length; j++) {\n\t\t\tmaxV = Math.max(maxV, list2[j] - p2);\n\t\t\tp2 = list2[j];\n\t\t}\n\t\tSystem.out.println(maxV * maxH);\n\t}", "4179": "static void findLastElement(int arr[], int N)\n {\n\tArrays.sort(arr);\n\tint i = 0;\n\tfor (i = 1; i < N; i++) {\n\tif (arr[i] - arr[i - 1] != 0 && arr[i] - arr[i - 1] != 2)\n\t{\n\t\tSystem.out.println(\"-1\");\n\t\treturn;\n\t}\n\t}\n\tSystem.out.println( arr[N - 1]);\n }", "4185": "static boolean checkifSorted(int A[], int B[], int N)\n\t{\n\t\tboolean flag = false;\n\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\tif (A[i] > A[i + 1]) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) {\n\t\t\treturn true;\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (B[i] == 0) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (B[i] == 1) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (count == 2) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "4186": "static void maxDivisions(Integer arr[], int N, int X)\n{\n\tArrays.sort(arr,Collections.reverseOrder());\n\tint maxSub = 0;\n\tint size = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tsize++;\n\t\tif (arr[i] * size >= X)\n\t\t{\n\t\t\tmaxSub++;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\tSystem.out.print(maxSub +\"\\n\");\n}", "4194": "public static void maxPossibleSum(int[] arr, int N)\n\t{\n\t\tArrays.sort(arr);\n\t\tint sum = 0;\n\t\tint j = N - 3;\n\t\twhile (j >= 0) {\n\t\t\tsum += arr[j];\n\t\t\tj -= 3;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}", "4197": "static int minSteps(StringBuilder A, StringBuilder B, int M, int N)\n {\n\tif (A.charAt(0) > B.charAt(0))\n\treturn 0;\n\tif (B.charAt(0) > A.charAt(0))\n\t{\n\treturn 1;\n\t}\n\tif (M <= N && A.charAt(0) == B.charAt(0)\n\t\t&& count(A, A.charAt(0)) == M\n\t\t&& count(B, B.charAt(0)) == N)\n\treturn -1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\tif (B.charAt(i) > B.charAt(0))\n\t\treturn 1;\n\t}\n\tfor (int i = 1; i < M; i++)\n\t{\n\tif (A.charAt(i) < A.charAt(0))\n\t\treturn 1;\n\t}\n\tfor (int i = 1; i < M; i++)\n\t{\n\tif (A.charAt(i) > A.charAt(0))\n\t{\n\t\tswap(A, i, B, 0);\n\t\tswap(A, 0, B, 0);\n\t\treturn 2;\n\t}\n\t}\n\tfor (int i = 1; i < N; i++)\n\t{\n\tif (B.charAt(i) < B.charAt(0))\n\t{\n\t\tswap(A, 0, B, i);\n\t\tswap(A, 0, B, 0);\n\t\treturn 2;\n\t}\n\t}\n\treturn 0;\n }\nstatic int count(StringBuilder a, char c)\n {\n\tint count = 0;\n\tfor(int i = 0; i < a.length(); i++)\n\tif(a.charAt(i) == c)\n\t\tcount++; \n\treturn count; \n }\nstatic void swap(StringBuilder s1, int index1, StringBuilder s2, int index2)\n {\n\tchar c = s1.charAt(index1);\n\ts1.setCharAt(index1,s2.charAt(index2));\n\ts2.setCharAt(index2,c);\n }", "4209": "static int CountMaximum(int arr[], int n, int k)\n\t{\n\t\tArrays.sort(arr);\n\t\tint sum = 0, count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum += arr[i];\n\t\t\tif (sum > k)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "4210": "static int CountMaximum(int arr[], int n, int k)\n\t{\n\t\tArrays.sort(arr);\n\t\tint sum = 0, count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum += arr[i];\n\t\t\tif (sum > k)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "4219": "static void insertionSort(int arr[], int n)\n{\n\tint i, key, j;\n\tfor (i = 1; i < n; i++)\n\t{\n\t\tkey = arr[i];\n\t\tj = i - 1;\n\t\twhile (j >= 0 && arr[j] > key)\n\t\t{\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\tarr[j + 1] = key;\n\t}\n}\nstatic void printArray(int arr[], int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tSystem.out.print(arr[i] + \" \");\n\t}\n\tSystem.out.println();\n}", "4220": "static void selectionSort(int arr[], int n)\n{\n\tint i, j, min_idx;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tmin_idx = i;\n\t\tfor (j = i + 1; j < n; j++)\n\t\t\tif (arr[j] < arr[min_idx])\n\t\t\t\tmin_idx = j;\n\t\tint temp = arr[min_idx];\n\t\tarr[min_idx]= arr[i];\n\t\tarr[i] = temp;\n\t}\n}\nstatic void printArray(int arr[], int size)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tSystem.out.print(arr[i]+ \" \");\n\t}\n\tSystem.out.println();\n}", "4237": "static void getPairs(int arr[], int N, int K)\n{\n\tint count = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (arr[i] > K * arr[i + 1])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tSystem.out.print(count);\n}", "4238": "static int merge(int arr[], int temp[], int l, int m, int r, int K)\n\t{\n\t\tint i = l;\n\t\tint j = m + 1;\n\t\tint cnt = 0;\n\t\tfor (i = l; i <= m; i++)\n\t\t{\n\t\t\tboolean found = false;\n\t\t\twhile (j <= r)\n\t\t\t{\n\t\t\t\tif (arr[i] >= K * arr[j])\n\t\t\t\t{\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (found == true)\n\t\t\t{\n\t\t\t\tcnt += j - (m + 1);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tint k = l;\n\t\ti = l;\n\t\tj = m + 1;\n\t\twhile (i <= m && j <= r)\n\t\t{\n\t\t\tif (arr[i] <= arr[j])\n\t\t\t\ttemp[k++] = arr[i++];\n\t\t\telse\n\t\t\t\ttemp[k++] = arr[j++];\n\t\t}\n\t\twhile (i <= m)\n\t\t\ttemp[k++] = arr[i++];\n\t\twhile (j <= r)\n\t\t\ttemp[k++] = arr[j++];\n\t\tfor (i = l; i <= r; i++)\n\t\t\tarr[i] = temp[i];\n\t\treturn cnt;\n\t}\nstatic int mergeSortUtil(int arr[], int temp[], int l, int r, int K)\n\t{\n\t\tint cnt = 0;\n\t\tif (l < r)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tcnt += mergeSortUtil(arr, temp, l, m, K);\n\t\t\tcnt += mergeSortUtil(arr, temp, m + 1, r, K);\n\t\t\tcnt += merge(arr, temp, l, m, r, K);\n\t\t} \n\t\treturn cnt;\n\t}\nstatic void mergeSort(int arr[], int N, int K)\n\t{\n\t\tint temp[] = new int[N];\n\t\tSystem.out.print(mergeSortUtil(arr, temp, 0, N - 1, K));\n\t}", "4249": "static void minRemovals(int []A, int N)\n\t{\n\t\tArrays.sort(A);\n\t\tint mx = A[N - 1];\n\t\tint sum = 1;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tsum += A[i];\n\t\t}\n\t\tif (sum - mx >= mx) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(2 * mx - sum);\n\t\t}\n\t}", "4250": "static void rearrangeArray(int a[], int n)\n{\n\tArrays.sort(a);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tif (a[i] == i + 1)\n\t\t{\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[i + 1];\n\t\t\ta[i + 1] = temp;\n\t\t}\n\t}\n\tif (a[n - 1] == n)\n\t{\n\t\tint temp = a[n - 1];\n\t\ta[n - 1] = a[n - 2];\n\t\ta[n - 2] = temp;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tSystem.out.print(a[i] + \" \");\n\t}\n}", "4256": "static boolean checkStr1CanConStr2(String str1, String str2)\n{\n\tint N = str1.length();\n\tint M = str2.length();\n\tHashSet<Integer> st1 = new HashSet<>();\n\tHashSet<Integer> st2 = new HashSet<>();\n\tint hash1[] = new int[256];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\thash1[str1.charAt(i)]++;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tst1.add((int)str1.charAt(i));\n\t}\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tst2.add((int)str2.charAt(i));\n\t}\n\tif (!st1.equals(st2))\n\t{\n\t\treturn false;\n\t}\n\tint hash2[] = new int[256];\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\thash2[str2.charAt(i)]++;\n\t}\n\tArrays.sort(hash1);\n\tArrays.sort(hash2);\n\tfor (int i = 0; i < 256; i++)\n\t{\n\t\tif (hash1[i] != hash2[i])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "4305": "static int minOperations(int arr1[], int arr2[], int i, int j)\n{\n\tif (arr1.equals(arr2))\n\t\treturn 0;\n\tif (i >= arr1.length j >= arr2.length)\n\t\treturn 0;\n\tif (arr1[i] < arr2[j])\n\t\treturn 1 + minOperations(arr1, arr2, i + 1, j + 1);\n\treturn Math.max(minOperations(arr1, arr2, i, j + 1),\n\t\t\t\t\tminOperations(arr1, arr2, i + 1, j));\n}\nstatic void minOperationsUtil(int[] arr)\n{\n\tint brr[] = new int[arr.length];\n\tfor(int i = 0; i < arr.length; i++)\n\t\tbrr[i] = arr[i];\n\tArrays.sort(brr);\n\tif (arr.equals(brr))\n\t\tSystem.out.print(\"0\");\n\telse\n\t\tSystem.out.println(minOperations(arr, brr, 0, 0));\n}", "4307": "public static int minOperations(int[] arr, int n)\n\t{\n\t\tPair[] num = new Pair[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnum[i] = new Pair(arr[i], i);\n\t\t}\n\t\tArrays.sort(num, (Pair a, Pair b) -> a.val - b.val);\n\t\tint res = 1;\n\t\tint streak = 1;\n\t\tint prev = num[0].idx;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (prev < num[i].idx) {\n\t\t\t\tres++;\n\t\t\t\tstreak = Math.max(res, streak);\n\t\t\t}\n\t\t\telse\n\t\t\t\tres = 1;\n\t\t\tprev = num[i].idx;\n\t\t}\n\t\treturn n - streak;\n\t}", "4310": "static void canTransform(String s, String t)\n{\n int n = s.length();\n Vector<Integer> occur[] = new Vector[26];\n for (int i = 0; i < occur.length; i++)\n\toccur[i] = new Vector<Integer>();\n for (int x = 0; x < n; x++)\n {\n\tchar ch = (char)(s.charAt(x) - 'a');\n\toccur[ch].add(x);\n }\n int []idx = new int[26];\n boolean poss = true;\n for (int x = 0; x < n; x++)\n {\n\tchar ch = (char)(t.charAt(x) - 'a');\n\tif (idx[ch] >= occur[ch].size())\n\t{\n\tposs = false;\n\tbreak;\n\t}\n\tfor (int small = 0; small < ch; small++)\n\t{\n\tif (idx[small] < occur[small].size() &&\n\t\toccur[small].get(idx[small]) <\n\t\toccur[ch].get(idx[ch]))\n\t{\n\t\tposs = false;\n\t\tbreak;\n\t}\n\t}\n\tidx[ch]++;\n }\n if (poss)\n {\n\tSystem.out.print(\"Yes\" + \"\\n\");\n }\n else\n {\n\tSystem.out.print(\"No\" + \"\\n\");\n }\n}", "4326": "static int getMaxSum(int i, int j, int k, int arr1[], int arr2[], int arr3[])\n{\n\tint cnt = 0;\n\tif (i >= n1)\n\t\tcnt++;\n\tif (j >= n2)\n\t\tcnt++;\n\tif (k >= n3)\n\t\tcnt++;\n\tif (cnt >= 2)\n\t\treturn 0;\n\tif (dp[i][j][k] != -1)\n\t\treturn dp[i][j][k];\n\tint ans = 0;\n\tif (i < n1 && j < n2)\n\t\tans = Math.max(ans,\n\t\t\t\t\tgetMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j]);\n\tif (i < n1 && k < n3)\n\t\tans = Math.max(ans,\n\t\t\t\t\tgetMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k]);\n\tif (j < n2 && k < n3)\n\t\tans = Math.max(ans,\n\t\t\t\t\tgetMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k]);\n\tdp[i][j][k] = ans;\n\treturn dp[i][j][k];\n}\nstatic void reverse(int[] tmp)\n{\n\tint i, k, t;\n\tint n = tmp.length;\n\t\tfor(i = 0; i < n/ 2; i++)\n\t\t{\n\t\t\tt = tmp[i];\n\t\t\ttmp[i] = tmp[n - i - 1];\n\t\t\ttmp[n - i - 1] = t;\n\t\t}\n}\nstatic int maxProductSum(int arr1[], int arr2[], int arr3[])\n{\n\tfor(int i = 0; i < dp.length; i++)\n\t\tfor(int j = 0; j < dp[0].length; j++)\n\t\t\tfor(int k = 0; k < dp[j][0].length; k++)\n\t\t\t\tdp[i][j][k] = -1;\n\tArrays.sort(arr1);\n\treverse(arr1);\n\tArrays.sort(arr2);\n\treverse(arr2);\n\tArrays.sort(arr3);\n\treverse(arr3);\n\treturn getMaxSum(0, 0, 0, arr1, arr2, arr3);\n}", "4347": "static void findTriplet(int arr[], int N)\n{\n\tArrays.sort(arr);\n\tint flag = 0, i;\n\tfor(i = N - 1; i - 2 >= 0; i--)\n\t{\n\t\tif (arr[i - 2] + arr[i - 1] > arr[i])\n\t\t{\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag != 0)\n\t{\n\t\tSystem.out.println(arr[i - 2] + \" \" + arr[i - 1] + \" \" + arr[i] );\n\t}\n\telse\n\t{\n\t\tSystem.out.println(-1);\n\t}\n}", "4354": "static int inversionCount(String s)\n{\n\tint[] freq = new int[26];\n\tint inv = 0;\n\tfor(int i = 0; i < s.length(); i++)\n\t{\n\t\tint temp = 0;\n\t\tfor(int j = 0;\n\t\t\t\tj < (int)(s.charAt(i) - 'a'); j++)\n\t\ttemp += freq[j];\n\t\tinv += (i - temp);\n\t\tfreq[s.charAt(i) - 'a']++;\n\t}\n\treturn inv;\n}\nstatic boolean haveRepeated(String S1, String S2)\n{\n\tint[] freq = new int[26];\n\tfor(char i : S1.toCharArray())\n\t{\n\t\tif (freq[i - 'a'] > 0)\n\t\t\treturn true;\n\t\tfreq[i - 'a']++;\n\t}\n\tfor(int i = 0; i < 26; i++)\n\t\tfreq[i] = 0;\n\tfor(char i : S2.toCharArray())\n\t{\n\t\tif (freq[i - 'a'] > 0)\n\t\t\treturn true;\n\t\tfreq[i - 'a']++;\n\t}\n\treturn false;\n}\nstatic void checkToMakeEqual(String S1, String S2)\n{\n\tint[] freq = new int[26];\n\tfor(int i = 0; i < S1.length(); i++)\n\t{\n\t\tfreq[S1.charAt(i) - 'a']++;\n\t}\n\tboolean flag = false;\n\tfor(int i = 0; i < S2.length(); i++)\n\t{\n\t\tif (freq[S2.charAt(i) - 'a'] == 0)\n\t\t{\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t\tfreq[S2.charAt(i) - 'a']--;\n\t}\n\tif (flag == true)\n\t{\n\t\tSystem.out.println(\"No\");\n\t\treturn;\n\t}\n\tint invCount1 = inversionCount(S1);\n\tint invCount2 = inversionCount(S2);\n\tif (invCount1 == invCount2 ||\n\t(invCount1 & 1) == (invCount2 & 1) ||\n\t\thaveRepeated(S1, S2))\n\t{\n\t\tSystem.out.println(\"Yes\");\n\t}\n\telse\n\tSystem.out.println(\"No\");\n}", "4357": "static int numberofpairs(int []arr, int N)\n{\n\tint answer = 0;\n\tArrays.sort(arr);\n\tint minDiff = 10000000;\n\tfor (int i = 0; i < N - 1; i++)\n\t\tminDiff = Math.min(minDiff, arr[i + 1] - arr[i]);\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\tif (arr[i + 1] - arr[i] == minDiff)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "4360": "static void sortArr(int a[], int n)\n{\n\tint i, k;\n\tk = (int)(Math.log(n) / Math.log(2));\n\tk = (int) Math.pow(2, k);\n\twhile (k > 0)\n\t{\n\t\tfor(i = 0; i + k < n; i++)\n\t\t\tif (a[i] > a[i + k])\n\t\t\t{\n\t\t\t\tint tmp = a[i];\n\t\t\t\ta[i] = a[i + k];\n\t\t\t\ta[i + k] = tmp;\n\t\t\t}\n\t\tk = k / 2;\n\t}\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tSystem.out.print(a[i] + \" \");\n\t}\n}", "4362": "static void maximumSum(int arr[], int n, int k)\n{\n\tint elt = n / k;\n\tint sum = 0;\n\tArrays.sort(arr);\n\tint count = 0;\n\tint i = n - 1;\n\twhile (count < k)\n\t{\n\t\tsum += arr[i];\n\t\ti--;\n\t\tcount++;\n\t}\n\tcount = 0;\n\ti = 0;\n\twhile (count < k)\n\t{\n\t\tsum += arr[i];\n\t\ti += elt - 1;\n\t\tcount++;\n\t}\n\tSystem.out.println(sum);\n}", "4369": "static int findMinSum(int []arr, int K, int L, int size)\n{\n\tif (K * L > size)\n\t\treturn -1;\n\tint minsum = 0;\n\tArrays.sort(arr);\n\tfor(int i = 0; i < K; i++)\n\t\tminsum += arr[i];\n\treturn minsum;\n}", "4371": "static void find_max_length( int []arr, int index, int sum, int k)\n{\n\tsum = sum + arr[index];\n\tstore.add(arr[index]);\n\tif (sum == k)\n\t{\n\t\tif (max_length < store.size())\n\t\t{\n\t\t\tmax_length = store.size();\n\t\t\tans = store;\n\t\t}\n\t}\n\tfor (int i = index + 1; i < arr.length; i++)\n\t{\n\t\tif (sum + arr[i] <= k)\n\t\t{\n\t\t\tfind_max_length(arr, i, sum, k);\n\t\t\tstore.remove(store.size() - 1);\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\treturn;\n}\nstatic int longestSubsequence(int []arr, int n, int k)\n{\n\tArrays.sort(arr);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (max_length >= n - i)\n\t\t\tbreak;\n\t\tstore.clear();\n\t\tfind_max_length(arr, i, 0, k);\n\t}\n\treturn max_length;\n}", "4378": "static int findKthSmallest(int[] arr, int n, int k)\n\t{\n\t\tint max = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] > max)\n\t\t\t\tmax = arr[i];\n\t\t}\n\t\tint[] counter = new int[max + 1];\n\t\tint smallest = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tcounter[arr[i]]++;\n\t\t}\n\t\tfor (int num = 1; num <= max; num++)\n\t\t{\n\t\t\tif (counter[num] > 0)\n\t\t\t{\n\t\t\t\tsmallest += counter[num];\n\t\t\t}\n\t\t\tif (smallest >= k)\n\t\t\t{\n\t\t\t\treturn num;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "4385": "static void lexNumbers(int n)\n{\n\tVector<String> s = new Vector<String>();\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\ts.add(String.valueOf(i));\n\t}\n\tCollections.sort(s);\n\tVector<Integer> ans = new Vector<Integer>();\n\tfor (int i = 0; i < n; i++)\n\t\tans.add(Integer.valueOf(s.get(i)));\n\tfor (int i = 0; i < n; i++)\n\t\tSystem.out.print(ans.get(i) + \" \");\n}", "4386": "public static void lexNumbers(int n)\n\t{\n\t\tList<Integer> sol = new ArrayList<>();\n\t\tdfs(1, n, sol);\n\t\tSystem.out.println(sol);\n\t}\npublic static void dfs(int temp, int n, List<Integer> sol)\n\t{\n\t\tif (temp > n)\n\t\t\treturn;\n\t\tsol.add(temp);\n\t\tdfs(temp * 10, n, sol);\n\t\tif (temp % 10 != 9)\n\t\t\tdfs(temp + 1, n, sol);\n\t}", "4392": "static void func(int a[][])\n{\n\tint i, j, k;\n\tfor(i = 0; i < N; i++)\n\t{\n\tif (i % 2 == 0)\n\t{\n\t\tfor(j = 0; j < N; j++)\n\t\t{\n\t\t\tfor(k = j + 1; k < N; ++k)\n\t\t\t{\n\t\t\t\tif (a[i][j] > a[i][k])\n\t\t\t\t{\n\t\t\t\t\tint temp = a[i][j];\n\t\t\t\t\ta[i][j] = a[i][k];\n\t\t\t\t\ta[i][k] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(j = 0; j < N; j++)\n\t\t{\n\t\t\tfor(k = j + 1; k < N; ++k)\n\t\t\t{\n\t\t\t\tif (a[i][j] < a[i][k])\n\t\t\t\t{\n\t\t\t\t\tint temp = a[i][j];\n\t\t\t\t\ta[i][j] = a[i][k];\n\t\t\t\t\ta[i][k] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tfor(i = 0; i < N; i++)\n\t{\n\tfor(j = 0; j < N; j++)\n\t{\n\t\tSystem.out.print(a[i][j] + \" \");\n\t}\n\tSystem.out.print(\"\\n\");\n\t}\n}", "4400": "static int partition(int arr[], int l, int h)\n{\n\tint pivot = arr[l];\n\tint i = l + 1;\n\tint j = h;\n\twhile (i <= j)\n\t{\n\t\twhile (i <= h && arr[i] < pivot)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\twhile (j > l && arr[j] > pivot)\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\tif (i < j)\n\t\t{\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[l] = arr[j];\n\tarr[j] = pivot;\n\treturn j;\n}\nstatic void sortArray(int arr[], int l, int h)\n{\n\tif (l >= h)\n\t\treturn;\n\tint pivot = partition(arr, l, h);\n\tsortArray(arr, l, pivot - 1);\n\tsortArray(arr, pivot + 1, h);\n}\nstatic int findMaxIntervals(int start[], int end[], int n, int R)\n{\n\tint ans = 0;\n\tint prev = 0;\n\tint currActive = 0;\n\tint i = 0;\n\tint j = 0;\n\tif (start[0] > 0)\n\t\tans++;\n\twhile (i < n && j < n)\n\t{\n\t\tif (start[i] < end[j])\n\t\t{\n\t\t\ti++;\n\t\t\tcurrActive++;\n\t\t}\n\t\telse if (start[i] > end[j])\n\t\t{\n\t\t\tj++;\n\t\t\tcurrActive--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tif (currActive == 0)\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\tif (end[n - 1] < R)\n\t\tans++;\n\treturn ans;\n}", "4401": "static void sortArray(int A[], int N)\n{\n\tint x = 0, y = 0, z = 0;\n\tif (N % 4 == 0 N % 4 == 1)\n\t{\n\t\tfor(int i = 0; i < N / 2; i++)\n\t\t{\n\t\tx = i;\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\ty = N - i - 2;\n\t\t\tz = N - i - 1;\n\t\t}\n\t\tA[z] = A[y];\n\t\tA[y] = A[x];\n\t\tA[x] = x + 1;\n\t\t}\n\t\tSystem.out.print(\"Sorted Array: \");\n\t\tfor(int i = 0; i < N; i++)\n\t\tSystem.out.print(A[i] + \" \");\n\t}\n\telse\n\t{\n\t\tSystem.out.print(\"-1\");\n\t}\n}", "4412": "static void dfs(int x)\n{\n Vector<Integer> v = new Vector<>();\n v.clear();\n ns.clear();\n for (int it : s)\n {\n\tif (g[x].get(it) != null)\n\t{\n\tv.add(it);\n\t}\n\telse\n\t{\n\tns.add(it);\n\t}\n }\n s = ns;\n for (int i : v)\n {\n\tdfs(i);\n }\n}\nstatic void weightOfMST(int N)\n{\n int cnt = 0;\n for (int i = 1; i <= N; ++i)\n {\n\ts.add(i);\n }\n Vector<Integer> qt = new Vector<>();\n for (int t : s)\n\tqt.add(t);\n while (!qt.isEmpty())\n {\n\t++cnt;\n\tint t = qt.get(0);\n\tqt.remove(0);\n\tdfs(t);\n }\n System.out.print(cnt - 4);\n}", "4420": "static int countPairs(int [] A, int [] B)\n{\n\tint n = A.length;\n\tint ans = 0;\n\tArrays.sort(A);\n\tArrays.sort(B);\n\tfor(int i = 0; i < n; i++)\n\t{\n\tif (A[i] > B[ans])\n\t{\n\t\tans++;\n\t}\n\t}\n\treturn ans;\n}", "4455": "static boolean compare(int []arr1, int []arr2)\n{\n\tfor(int i = 0; i < 256; i++)\n\t\tif (arr1[i] != arr2[i])\n\t\t\treturn false;\n\treturn true;\n}\nstatic boolean search(String pat, String txt)\n{\n\tint M = pat.length();\n\tint N = txt.length();\n\tint []countP = new int [256];\n\tint []countTW = new int [256];\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\tcountP[i] = 0;\n\t\tcountTW[i] = 0;\n\t}\n\tfor(int i = 0; i < M; i++)\n\t{\n\t\t(countP[pat.charAt(i)])++;\n\t\t(countTW[txt.charAt(i)])++;\n\t}\n\tfor(int i = M; i < N; i++)\n\t{\n\t\tif (compare(countP, countTW))\n\t\t\treturn true;\n\t\t(countTW[txt.charAt(i)])++;\n\t\tcountTW[txt.charAt(i - M)]--;\n\t}\n\tif (compare(countP, countTW))\n\t\treturn true;\n\t\treturn false;\n}", "4459": "static int findK(int arr[], int size, int N)\n\t{\n\t\tArrays.sort(arr);\n\t\tint temp_sum = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\ttemp_sum += arr[i];\n\t\t\tif (N - temp_sum == arr[i] * (size - i - 1))\n\t\t\t{\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "4460": "static int minimumSwaps(int[] arr)\n\t{\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile (i < arr.length) {\n\t\t\tif (arr[i] != i + 1) {\n\t\t\t\twhile (arr[i] != i + 1) {\n\t\t\t\t\tint temp = 0;\n\t\t\t\t\ttemp = arr[arr[i] - 1];\n\t\t\t\t\tarr[arr[i] - 1] = arr[i];\n\t\t\t\t\tarr[i] = temp;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn count;\n\t}", "4482": "static int max_element(int arr[], int n)\n\t{\n\t\tint max = arr[0];\n\t\tfor(int i = 1; i < n ; i++)\n\t\t{\n\t\t\tif (max < arr[i])\n\t\t\t\tmax = arr[i];\n\t\t}\n\t\treturn max;\n\t}\nstatic int maxMod(int arr[], int n)\n\t{\n\t\tint maxVal = max_element(arr, n);\n\t\tint secondMax = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] < maxVal && arr[i] > secondMax)\n\t\t\t{\n\t\t\t\tsecondMax = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn secondMax;\n\t}", "4493": "static boolean isPossible(int A[], int B[], int n, int m, int x, int y)\n\t{\n\t\tif (x > n y > m)\n\t\t\treturn false;\n\t\tArrays.sort(A);\n\t\tArrays.sort(B);\n\t\tif (A[x - 1] < B[m - y])\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "4507": "static int Min_Replace(int [] arr, int n, int k)\n\t{\n\t\tArrays.sort(arr);\n\t\tInteger [] freq = new Integer[MAX];\n\t\tArrays.fill(freq, 0);\n\t\tint p = 0;\n\t\tfreq[p] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] == arr[i - 1])\n\t\t\t\t++freq[p];\n\t\t\telse\n\t\t\t\t++freq[++p];\n\t\t}\n\t\tArrays.sort(freq, Collections.reverseOrder());\n\t\tint ans = 0;\n\t\tfor (int i = k; i <= p; i++)\n\t\t\tans += freq[i];\n\t\treturn ans;\n\t}", "4508": "static Node append(Node head_ref, int new_data)\n{\n\tNode new_node = new Node();\n\tNode last = head_ref;\n\tnew_node.data = new_data;\n\tnew_node.next = null;\n\tif (head_ref == null)\n\t{\n\t\tnew_node.prev = null;\n\t\thead_ref = new_node;\n\t\treturn head_ref;\n\t}\n\twhile (last.next != null)\n\t\tlast = last.next;\n\tlast.next = new_node;\n\tnew_node.prev = last;\n\treturn head_ref;\n}\nstatic void printList(Node node)\n{\n\tNode last;\n\twhile (node != null)\n\t{\n\t\tSystem.out.print( node.data + \" \");\n\t\tlast = node;\n\t\tnode = node.next;\n\t}\n}\nstatic Node mergeList(Node p, Node q)\n{\n\tNode s = null;\n\tif (p == null q == null)\n\t{\n\t\treturn (p == null ? q : p);\n\t}\n\tif (p.data < q.data)\n\t{\n\t\tp.prev = s;\n\t\ts = p;\n\t\tp = p.next;\n\t}\n\telse\n\t{\n\t\tq.prev = s;\n\t\ts = q;\n\t\tq = q.next;\n\t}\n\tNode head = s;\n\twhile (p != null && q != null)\n\t{\n\t\tif (p.data < q.data)\n\t\t{\n\t\t\ts.next = p;\n\t\t\tp.prev = s;\n\t\t\ts = s.next;\n\t\t\tp = p.next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts.next = q;\n\t\t\tq.prev = s;\n\t\t\ts = s.next;\n\t\t\tq = q.next;\n\t\t}\n\t}\n\tif (p == null)\n\t{\n\t\ts.next = q;\n\t\tq.prev = s;\n\t}\n\tif (q == null)\n\t{\n\t\ts.next = p;\n\t\tp.prev = s;\n\t}\n\treturn head;\n}\nstatic Node mergeAllList(Node head[], int k)\n{\n\tNode finalList = null;\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tfinalList = mergeList(finalList, head[i]);\n\t}\n\treturn finalList;\n}", "4510": "static int Segment(int x[], int l[], int n)\n{\n\tif (n == 1)\n\t\treturn 1;\n\tint ans = 2;\n\tfor (int i = 1; i < n - 1; i++)\n\t{\n\t\tif (x[i] - l[i] > x[i - 1])\n\t\t\tans++;\n\t\telse if (x[i] + l[i] < x[i + 1])\n\t\t{\n\t\t\tx[i] = x[i] + l[i];\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4529": "static boolean existsTriplet(int a[], int b[], int c[], int x, int l1, int l2, int l3)\n{\n\tif (l2 <= l1 && l2 <= l3)\n\t{\n\t\tswap(l2, l1);\n\t\tswap(a, b);\n\t}\n\telse if (l3 <= l1 && l3 <= l2)\n\t{\n\t\tswap(l3, l1);\n\t\tswap(a, c);\n\t}\n\tfor (int i = 0; i < l1; i++)\n\t{\n\t\tint j = 0, k = l3 - 1;\n\t\twhile (j < l2 && k >= 0)\n\t\t{\n\t\t\tif (a[i] + b[j] + c[k] == x)\n\t\t\t\treturn true;\n\t\t\tif (a[i] + b[j] + c[k] < x)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tk--;\n\t\t}\n\t}\n\treturn false;\n}\nprivate static void swap(int x, int y)\n{\n\tint temp = x;\n\tx = y;\n\ty = temp;\n}\nprivate static void swap(int []x, int []y)\n{\n\tint []temp = x;\n\tx = y;\n\ty = temp;\n}", "4570": "static int MinimizeleftOverSum(int a[], int n)\n{\n\tVector<Integer> v1 = new Vector<Integer>(),\n\t\t\t\t\tv2 = new Vector<Integer>();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] % 2 == 1)\n\t\t\tv1.add(a[i]);\n\t\telse\n\t\t\tv2.add(a[i]);\n\t}\n\tif (v1.size() > v2.size())\n\t{\n\t\tCollections.sort(v1);\n\t\tCollections.sort(v2);\n\t\tint x = v1.size() - v2.size() - 1;\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile (i < x)\n\t\t{\n\t\t\tsum += v1.get(i++);\n\t\t}\n\t\treturn sum;\n\t}\n\telse if (v2.size() > v1.size())\n\t{\n\t\tCollections.sort(v1);\n\t\tCollections.sort(v2);\n\t\tint x = v2.size() - v1.size() - 1;\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile (i < x)\n\t\t{\n\t\t\tsum += v2.get(i++);\n\t\t}\n\t\treturn sum;\n\t}\n\telse\n\t\treturn 0;\n}", "4578": "public static void printArr(int[] arr, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tSystem.out.print(arr[i]);\n\t}\npublic static int compare(int num1, int num2)\n\t{\n\t\tString A = Integer.toString(num1);\n\t\tString B = Integer.toString(num2);\n\t\treturn (A+B).compareTo(B+A);\n\t}\npublic static void printSmallest(int N, int[] arr)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tif (compare(arr[i], arr[j]) > 0)\n\t\t\t\t{\n\t\t\t\t\tint temp = arr[i];\n\t\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\tarr[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintArr(arr, N);\n\t}", "4585": "static double getMaxMedian(int[] arr, int n, int k)\n\t{\n\t\tint size = n + k;\n\t\tArrays.sort(arr);\n\t\tif (size % 2 == 0)\n\t\t{\n\t\t\tdouble median = (double) (arr[(size / 2) - 1] + arr[size / 2])\n\t\t\t\t\t/ 2;\n\t\t\treturn median;\n\t\t}\n\t\tdouble median1 = arr[size / 2];\n\t\treturn median1;\n\t}", "4591": "static void minOperation(String S, int N, int K)\n\t{\n\t\tif (N % K != 0)\n\t\t{\n\t\t\tSystem.out.println(\"Not Possible\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint [] count = new int[26];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tcount[(S.charAt(i) - 97)]++;\n\t\t\t}\n\t\t\tint E = N / K;\n\t\t\tVector<Integer> greaterE = new Vector<>();\n\t\t\tVector<Integer> lessE = new Vector<>();\n\t\t\tfor (int i = 0; i < 26; i++)\n\t\t\t{\n\t\t\t\tif (count[i] < E)\n\t\t\t\t\tlessE.add(E - count[i]);\n\t\t\t\telse\n\t\t\t\t\tgreaterE.add(count[i] - E);\n\t\t\t}\n\t\t\tCollections.sort(greaterE);\n\t\t\tCollections.sort(lessE);\n\t\t\tint mi = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i <= K; i++)\n\t\t\t{\n\t\t\t\tint set1 = i;\n\t\t\t\tint set2 = K - i;\n\t\t\t\tif (greaterE.size() >= set1 &&\n\t\t\t\t\t\t\tlessE.size() >= set2)\n\t\t\t\t{\n\t\t\t\t\tint step1 = 0;\n\t\t\t\t\tint step2 = 0;\n\t\t\t\t\tfor (int j = 0; j < set1; j++)\n\t\t\t\t\t\tstep1 += greaterE.get(j);\n\t\t\t\t\tfor (int j = 0; j < set2; j++)\n\t\t\t\t\t\tstep2 += lessE.get(j);\n\t\t\t\t\tmi = Math.min(mi, Math.max(step1, step2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(mi);\n\t\t}\n\t}", "4620": "static void partSort(int[] arr, int N, int a, int b)\n\t{\n\t\tint l = Math.min(a, b);\n\t\tint r = Math.max(a, b);\n\t\tint[] temp = new int[r - l + 1];\n\t\tint j = 0;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\ttemp[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\tArrays.sort(temp);\n\t\tj = 0;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tarr[i] = temp[j];\n\t\t\tj++;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}", "4621": "static void partSort(int[] arr, int N, int a, int b)\n\t{\n\t\tint l = Math.min(a, b);\n\t\tint r = Math.max(a, b);\n\t\tArrays.sort(arr, l, r + 1);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t}", "4622": "static int minMovesToSort(int arr[], int n)\n{\n\tint moves = 0;\n\tint i, mn = arr[n - 1];\n\tfor (i = n - 2; i >= 0; i--) {\n\t\tif (arr[i] > mn)\n\t\t\tmoves += arr[i] - mn;\n\t}\n\treturn moves;\n}", "4624": "static void sortByRow(int[][] mat, int n, boolean descending)\n{\n\tint temp = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (descending == true)\n\t\t{\n\t\t\tint t = i;\n\t\t\tfor (int p = 0; p < n; p++)\n\t\t\t{\n\t\t\t\tfor (int j = p + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (mat[t][p] < mat[t][j])\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp = mat[t][p];\n\t\t\t\t\t\tmat[t][p] = mat[t][j];\n\t\t\t\t\t\tmat[t][j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tArrays.sort(mat[i]);\n\t}\n}\nstatic void transpose(int mat[][], int n)\n{\n\tint temp = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\ttemp = mat[i][j];\n\t\t\tmat[i][j] = mat[j][i];\n\t\t\tmat[j][i] = temp;\n\t\t}\n\t}\n}\nstatic void sortMatRowAndColWise(int mat[][], int n)\n{\n\tsortByRow(mat, n, true);\n\ttranspose(mat, n);\n\tsortByRow(mat, n, false);\n\ttranspose(mat, n);\n}\nstatic void printMat(int mat[][], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tSystem.out.print(mat[i][j] + \" \");\n\t\tSystem.out.println();\n\t}\n}", "4648": "static void SieveOfEratosthenes(int n)\n\t{\n\t\tArrays.fill(prime, true);\n\t\tprime[1] = false;\n\t\tfor (int p = 2; p * p <= n; p++)\n\t\t{\n\t\t\tif (prime[p]) {\n\t\t\t\tfor (int i = p * 2; i < n; i += p)\n\t\t\t\t{\n\t\t\t\t\tprime[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nstatic void sortPrimes(int arr[], int n)\n\t{\n\t\tSieveOfEratosthenes(100005);\n\t\tVector<Integer> v = new Vector<Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (prime[arr[i]])\n\t\t\t{\n\t\t\t\tv.add(arr[i]);\n\t\t\t}\n\t\t}\n\t\tComparator comparator = Collections.reverseOrder();\n\t\tCollections.sort(v, comparator);\n\t\tint j = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (prime[arr[i]])\n\t\t\t{\n\t\t\t\tarr[i] = v.get(j++);\n\t\t\t}\n\t\t}\n\t}", "4701": "static void findOptimalPairs(int arr[], int N)\n{\n\tArrays.sort(arr);\n\tfor (int i = 0, j = N - 1; i <= j; i++, j--)\n\t\tSystem.out.print( \"(\" + arr[i] + \", \" + arr[j] + \")\" + \" \");\n}", "4740": "static void stableSelectionSort(int[] a, int n)\n\t{\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tint min = i;\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\tif (a[min] > a[j])\n\t\t\t\t\tmin = j;\n\t\t\tint key = a[min];\n\t\t\twhile (min > i)\n\t\t\t{\n\t\t\t\ta[min] = a[min - 1];\n\t\t\t\tmin--;\n\t\t\t}\n\t\t\ta[i] = key;\n\t\t}\n\t}\nstatic void printArray(int[] a, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\tSystem.out.print(a[i]+ \" \");\n\t\tSystem.out.println();\n\t}", "4762": "static int minIndex(int a[], int i, int j)\n\t{\n\t\tif (i == j)\n\t\t\treturn i;\n\t\tint k = minIndex(a, i + 1, j);\n\t\treturn (a[i] < a[k])? i : k;\n\t}\nstatic void recurSelectionSort(int a[], int n, int index)\n\t{\n\t\tif (index == n)\n\t\treturn;\n\t\tint k = minIndex(a, index, n-1);\n\t\tif (k != index){\n\t\tint temp = a[k];\n\t\ta[k] = a[index];\n\t\ta[index] = temp;\n\t\t}\n\t\trecurSelectionSort(a, n, index + 1);\n\t}", "4783": "static void printSorted(int a, int b, int c)\n\t{\n\t\tint get_max = Math.max(a, Math.max(b, c));\n\t\tint get_min = -Math.max(-a, Math.max(-b, -c));\n\t\tint get_mid = (a + b + c)\n\t\t\t\t\t- (get_max + get_min);\n\t\tSystem.out.print(get_min + \" \" + get_mid + \" \" + get_max);\n\t}", "4786": "static void insertionSortRecursive(int arr[], int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn;\n\t\tinsertionSortRecursive( arr, n-1 );\n\t\tint last = arr[n-1];\n\t\tint j = n-2;\n\t\twhile (j >= 0 && arr[j] > last)\n\t\t{\n\t\t\tarr[j+1] = arr[j];\n\t\t\tj--;\n\t\t}\n\t\tarr[j+1] = last;\n\t}", "4793": "static void bubbleSort(int arr[], int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn;\n\t\tfor (int i=0; i<n-1; i++)\n\t\t\tif (arr[i] > arr[i+1])\n\t\t\t{\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[i+1];\n\t\t\t\tarr[i+1] = temp;\n\t\t\t}\n\t\tbubbleSort(arr, n-1);\n\t}", "4804": "static boolean isPossible(Integer a[], int b[], int n, int k)\n{\n\tArrays.sort(a, Collections.reverseOrder());\n\tArrays.sort(b);\n\tfor (int i = 0; i < n; i++)\n\tif (a[i] + b[i] < k)\n\t\treturn false;\n\treturn true;\n}", "4817": "static int countBits(int a)\n{\n\tint count = 0;\n\twhile (a > 0)\n\t{\n\t\tif ((a & 1) > 0)\n\t\t\tcount+= 1;\n\t\ta = a >> 1;\n\t}\n\treturn count;\n}\nstatic void insertionSort(int arr[], int aux[], int n)\n{\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint key1 = aux[i];\n\t\tint key2 = arr[i];\n\t\tint j = i - 1;\n\t\twhile (j >= 0 && aux[j] < key1)\n\t\t{\n\t\t\taux[j + 1] = aux[j];\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\taux[j + 1] = key1;\n\t\tarr[j + 1] = key2;\n\t}\n}\nstatic void sortBySetBitCount(int arr[], int n)\n{\n\tint aux[] = new int[n];\n\tfor (int i = 0; i < n; i++)\n\t\taux[i] = countBits(arr[i]);\n\tinsertionSort(arr, aux, n);\n}\nstatic void printArr(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tSystem.out.print(arr[i] + \" \");\n}", "4819": "static int countBits(int a)\n{\n int count = 0;\n while (a > 0)\n {\n\tif ((a & 1) > 0 )\n\tcount += 1;\n\ta = a >> 1;\n }\n return count;\n}\nstatic void sortBySetBitCount(int arr[], int n)\n{\n Vector<Integer> []count =\n\t\tnew Vector[32];\n for (int i = 0; i < count.length; i++)\n\tcount[i] = new Vector<Integer>();\n int setbitcount = 0;\n for (int i = 0; i < n; i++)\n {\n\tsetbitcount = countBits(arr[i]);\n\tcount[setbitcount].add(arr[i]);\n }\n int j = 0; \n for (int i = 31; i >= 0; i--)\n {\n\tVector<Integer> v1 = count[i];\n\tfor (int p = 0; p < v1.size(); p++)\n\tarr[j++] = v1.get(p);\n }\n}\nstatic void printArr(int arr[], int n)\n{\n for (int i = 0; i < n; i++)\n\tSystem.out.print(arr[i] + \" \");\n}", "4820": "static int setBitCount(int num)\n {\n\tint count = 0;\n\twhile ( num != 0 )\n\t{\n\tif ( (num & 1) != 0)\n\t\tcount++;\n\tnum >>= 1;\n\t}\n\treturn count;\n }\nstatic void sortBySetBitCount(int[] arr, int n)\n {\n\tArrayList<ArrayList<Integer>> count = new ArrayList<ArrayList<Integer>>();\n\tfor( int i = 0 ; i < n ; ++i )\n\t{\n\tcount.add(new ArrayList<Integer>(Arrays.asList((-1) * setBitCount(arr[i]), arr[i])));\n\t}\n\tCollections.sort(count, new Comparator<ArrayList<Integer>>() { \n\t@Override\n\tpublic int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {\n\t\treturn o1.get(0).compareTo(o2.get(0)); } });\n\tfor(int i = 0; i < count.size(); i++)\n\t{\n\tSystem.out.print(count.get(i).get(1) + \" \");\n\t}\n }\n@Override\n\tpublic int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {\n\t\treturn o1.get(0).compareTo(o2.get(0)); }", "4847": "static int binarySearch(int a[], int item, int low, int high)\n{\n\twhile (low <= high) {\n\t\tint mid = low + (high - low) / 2;\n\t\tif (item == a[mid])\n\t\t\treturn mid + 1;\n\t\telse if (item > a[mid])\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn low;\n}\nstatic void insertionSort(int a[], int n)\n{\n\tint i, loc, j, k, selected;\n\tfor (i = 1; i < n; ++i) {\n\t\tj = i - 1;\n\t\tselected = a[i];\n\t\tloc = binarySearch(a, selected, 0, j);\n\t\twhile (j >= loc) {\n\t\t\ta[j + 1] = a[j];\n\t\t\tj--;\n\t\t}\n\t\ta[j + 1] = selected;\n\t}\n}", "4855": "void sort(int arr[])\n\t{\n\t\tint n = arr.length;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tint key = arr[i];\n\t\t\tint j = i - 1;\n\t\t\twhile (j >= 0 && arr[j] > key) {\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tj = j - 1;\n\t\t\t}\n\t\t\tarr[j + 1] = key;\n\t\t}\n\t}\nstatic void printArray(int arr[])\n\t{\n\t\tint n = arr.length;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\tSystem.out.println();\n\t}", "4859": "static int canReach(String s, int L, int R)\n\t{\n\t\tint dp[] = new int[s.length()];\n\t\tdp[0] = 1;\n\t\tint pre = 0;\n\t\tfor (int i = 1; i < s.length(); i++) {\n\t\t\tif (i >= L) {\n\t\t\t\tpre += dp[i - L];\n\t\t\t}\n\t\t\tif (i > R) {\n\t\t\t\tpre -= dp[i - R - 1];\n\t\t\t}\n\t\t\tif (pre > 0 && s.charAt(i) == '0')\n\t\t\t\tdp[i] = 1;\n\t\t\telse\n\t\t\t\tdp[i] = 0;\n\t\t}\n\t\treturn dp[s.length() - 1];\n\t}", "4889": "static void generateString(int k1, int k2, char[] s)\n{\n\tint C1s = 0, C0s = 0;\n\tint flag = 0;\n\tVector<Integer> pos = new Vector<Integer>();\n\tfor (int i = 0; i < s.length; i++) {\n\t\tif (s[i] == '0') {\n\t\t\tC0s++;\n\t\t\tif ((i + 1) % k1 != 0\n\t\t\t\t&& (i + 1) % k2 != 0) {\n\t\t\t\tpos.add(i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tC1s++;\n\t\t}\n\t\tif (C0s >= C1s) {\n\t\t\tif (pos.size() == 0) {\n\t\t\t\tSystem.out.print(-1);\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint k = pos.get(pos.size()-1);\n\t\t\t\ts[k] = '1';\n\t\t\t\tC0s--;\n\t\t\t\tC1s++;\n\t\t\t\tpos.remove(pos.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\tSystem.out.print(s);\n\t}\n}", "4893": "static void maximizeProduct(int N)\n{\n\tint MSB = (int)(Math.log(N) / Math.log(2));\n\tint X = 1 << MSB;\n\tint Y = N - (1 << MSB);\n\tfor (int i = 0; i < MSB; i++) {\n\t\tif ((N & (1 << i))==0) {\n\t\t\tX += 1 << i;\n\t\t\tY += 1 << i;\n\t\t}\n\t}\n\tSystem.out.println(X+\" \"+Y);\n}", "4899": "static boolean check(int num)\n{\n\tint sm = 0;\n\tint num2 = num * num;\n\twhile (num > 0) {\n\t\tsm += num % 10;\n\t\tnum /= 10;\n\t}\n\tint sm2 = 0;\n\twhile (num2>0) {\n\t\tsm2 += num2 % 10;\n\t\tnum2 /= 10;\n\t}\n\treturn ((sm * sm) == sm2);\n}\nstatic int convert(String s)\n{\n\tint val = 0;\n\ts = reverse(s);\n\tint cur = 1;\n\tfor (int i = 0; i < s.length(); i++) {\n\t\tval += (s.charAt(i) - '0') * cur;\n\t\tcur *= 10;\n\t}\n\treturn val;\n}\nstatic void generate(String s, int len, HashSet<Integer> uniq)\n{\n\tif (s.length() == len) {\n\t\tif (check(convert(s))) {\n\t\t\tuniq.add(convert(s));\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= 3; i++) {\n\t\tgenerate(s + (char)(i + '0'), len, uniq);\n\t}\n}\nstatic String reverse(String input) {\n\tchar[] a = input.toCharArray();\n\tint l, r = a.length - 1;\n\tfor (l = 0; l < r; l++, r--) {\n\t\tchar temp = a[l];\n\t\ta[l] = a[r];\n\t\ta[r] = temp;\n\t}\n\treturn String.valueOf(a);\n}\nstatic int totalNumbers(int L, int R)\n{\n\tint ans = 0;\n\tint max_len = (int) (Math.log10(R) + 1);\n\tHashSet<Integer> uniq = new HashSet<Integer>();\n\tfor (int i = 1; i <= max_len; i++) {\n\t\tgenerate(\"\", i, uniq);\n\t}\n\tfor (int x : uniq) {\n\t\tif (x >= L && x <= R) {\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4906": "static int maxSumAfterPartition(int arr[], int n)\n\t{\n\tArrayList<Integer> pos\n\t\t\t= new ArrayList<Integer>();\n\t\tArrayList<Integer> neg\n\t\t\t= new ArrayList<Integer>();\n\t\tint zero = 0;\n\t\tint pos_sum = 0;\n\t\tint neg_sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] > 0) {\n\t\t\t\tpos.add(arr[i]);\n\t\t\t\tpos_sum += arr[i];\n\t\t\t}\n\t\t\telse if (arr[i] < 0) {\n\t\t\t\tneg.add(arr[i]);\n\t\t\t\tneg_sum += arr[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tzero++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tCollections.sort(pos);\n\t\tCollections.sort(neg);\n\t\tif (pos.size() > 0 && neg.size() > 0) {\n\t\t\tans = (pos_sum - neg_sum);\n\t\t}\n\t\telse if (pos.size() > 0) {\n\t\t\tif (zero > 0) {\n\t\t\t\tans = (pos_sum);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = (pos_sum - 2 * pos.get(0));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (zero > 0) {\n\t\t\t\tans = (-1 * neg_sum);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = (neg.get(0) - (neg_sum - neg.get(0)));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}", "4916": "static int validPermutations(String str)\n\t{\n\t\tHashMap<Character, Integer> m\n\t\t\t= new HashMap<Character, Integer>();\n\t\tint count = str.length(), ans = 0;\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tm.put(str.charAt(i),\n\t\t\t\tm.getOrDefault(str.charAt(i), 0) + 1);\n\t\t}\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tans += count - m.get(str.charAt(i));\n\t\t\tm.put(str.charAt(i), m.get(str.charAt(i)) - 1);\n\t\t\tcount--;\n\t\t}\n\t\treturn ans + 1;\n\t}", "4961": "public static int num_candyTypes(int []candies)\n{\n\tDictionary<Integer,\n\t\t\tInteger> s = new Hashtable<Integer,\n\t\t\t\t\t\t\t\t\t\tInteger>();\n\tfor(int i = 0; i < candies.length; i++)\n\t{\n\t\ts.put(candies[i], 1);\n\t}\n\treturn s.size();\n}\npublic static void distribute_candies(int []candies)\n{\n\tint allowed = candies.length / 2;\n\tint types = num_candyTypes(candies);\n\tif (types < allowed)\n\t\tSystem.out.println(types);\n\telse\n\t\tSystem.out.println(allowed);\n}", "4962": "static void convertXintoY(int X, int Y)\n{\n\twhile (Y > X) {\n\t\tif (Y % 2 == 0)\n\t\t\tY /= 2;\n\t\telse if (Y % 10 == 1)\n\t\t\tY /= 10;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (X == Y)\n\t\tSystem.out.print(\"Yes\");\n\telse\n\t\tSystem.out.print(\"No\");\n}", "4964": "static int maxXORUtil(int arr[], int N, int xrr, int orr)\n\t{\n\t\tif (N == 0)\n\t\t\treturn xrr ^ orr;\n\t\tint x\n\t\t\t= maxXORUtil(arr, N - 1, xrr ^ orr, arr[N - 1]);\n\t\tint y\n\t\t\t= maxXORUtil(arr, N - 1, xrr, orr arr[N - 1]);\n\t\treturn Math.max(x, y);\n\t}\nstatic int maximumXOR(int arr[], int N)\n\t{\n\t\treturn maxXORUtil(arr, N, 0, 0);\n\t}", "4965": "static int MaxXOR(int arr[], int N)\n{\n\tint res = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tres |= arr[i];\n\t}\n\treturn res;\n}", "4989": "static void generateString(int K)\n{\n\tString s = \"\";\n\tfor(int i = 97; i < 97 + K; i++)\n\t{\n\t\ts = s + (char)(i);\n\t\tfor(int j = i + 1; j < 97 + K; j++)\n\t\t{\n\t\t\ts += (char)(i);\n\t\t\ts += (char)(j);\n\t\t}\n\t}\n\ts += (char)(97);\n\tSystem.out.println(s);\n}", "4990": "static int countEqual(int A[], int B[], int N)\n{\n\tint first = 0;\n\tint second = N - 1;\n\tint count = 0;\n\twhile (first < N && second >= 0) {\n\t\tif (A[first] < B[second]) {\n\t\t\tfirst++;\n\t\t}\n\t\telse if (B[second] < A[first]) {\n\t\t\tsecond--;\n\t\t}\n\t\telse {\n\t\t\tcount++;\n\t\t\tfirst++;\n\t\t\tsecond--;\n\t\t}\n\t}\n\treturn count;\n}", "5016": "public static void findEquation(int S, int M)\n{\n\tSystem.out.println(\"1 \" + ((-1) * S) + \" \" + M); \n}", "5030": "static boolean isPalindrome(int N)\n{\n\tint temp = N;\n\tint res = 0;\n\twhile (temp != 0)\n\t{\n\t\tint rem = temp % 10;\n\t\tres = res * 10 + rem;\n\t\ttemp /= 10;\n\t}\n\tif (res == N)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nstatic int sumOfDigits(int N)\n{\n\tint sum = 0;\n\twhile (N != 0)\n\t{\n\t\tsum += N % 10;\n\t\tN /= 10;\n\t}\n\treturn sum;\n}\nstatic boolean isPrime(int n)\n{\n\tif (n <= 1)\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 2; i <= n / 2; ++i)\n\t{\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nstatic void precompute()\n{\n\tfor(int i = 1; i <= 100000; i++)\n\t{\n\t\tif (isPalindrome(i))\n\t\t{\n\t\t\tint sum = sumOfDigits(i);\n\t\t\tif (isPrime(sum))\n\t\t\t\tarr[i] = 1;\n\t\t\telse\n\t\t\t\tarr[i] = 0;\n\t\t}\n\t\telse\n\t\t\tarr[i] = 0;\n\t}\n\tfor(int i = 1; i <= 100000; i++)\n\t{\n\t\tarr[i] = arr[i] + arr[i - 1];\n\t}\n}\nstatic void countNumbers(int[][] Q, int N)\n{\n\tprecompute();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tSystem.out.println((arr[Q[i][1]] - arr[Q[i][0] - 1]));\n\t}\n}", "5038": "static int minSteps(ArrayList<Integer> a, int n)\n{\n\tint []prefix_sum = new int[n];\n\tprefix_sum[0] = a.get(0);\n\tfor(int i = 1; i < n; i++)\n\t\tprefix_sum[i] += prefix_sum[i - 1] + a.get(i);\n\tint mx = -1;\n\tfor(int subgroupsum : prefix_sum)\n\t{\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\tint grp_count = 0;\n\t\twhile (i < n)\n\t\t{\n\t\t\tsum += a.get(i);\n\t\t\tif (sum == subgroupsum)\n\t\t\t{\n\t\t\t\tgrp_count += 1;\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\telse if(sum > subgroupsum)\n\t\t\t{\n\t\t\t\tgrp_count = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t\tif (grp_count > mx)\n\t\t\tmx = grp_count;\n\t}\n\treturn n - mx;\n}", "5056": "public static void\n\tmaxOccuringCharacter(String s)\n\t{\n\t\tint count0 = 0, count1 = 0;\n\t\tfor (int i = 0;\n\t\t\ti < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '1') {\n\t\t\t\tcount1++;\n\t\t\t}\n\t\t\telse if (s.charAt(i) == '0') {\n\t\t\t\tcount0++;\n\t\t\t}\n\t\t}\n\t\tint prev = -1;\n\t\tfor (int i = 0;\n\t\t\ti < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '1') {\n\t\t\t\tprev = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = prev + 1;\n\t\t\ti < s.length(); i++) {\n\t\t\tif (s.charAt(i) != 'X') {\n\t\t\t\tif (s.charAt(i) == '1') {\n\t\t\t\t\tcount1 += i - prev - 1;\n\t\t\t\t\tprev = i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor (int j = i + 1;\n\t\t\t\t\t\tj < s.length(); j++) {\n\t\t\t\t\t\tif (s.charAt(j) == '1') {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tprev = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag) {\n\t\t\t\t\t\ti = prev;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ti = s.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprev = -1;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '0') {\n\t\t\t\tprev = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = prev + 1;\n\t\t\ti < s.length(); i++) {\n\t\t\tif (s.charAt(i) != 'X') {\n\t\t\t\tif (s.charAt(i) == '0') {\n\t\t\t\t\tcount0 += i - prev - 1;\n\t\t\t\t\tprev = i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor (int j = i + 1;\n\t\t\t\t\t\tj < s.length(); j++) {\n\t\t\t\t\t\tif (s.charAt(j) == '0') {\n\t\t\t\t\t\t\tprev = j;\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag) {\n\t\t\t\t\t\ti = prev;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ti = s.length();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (s.charAt(0) == 'X') {\n\t\t\tint count = 0;\n\t\t\tint i = 0;\n\t\t\twhile (s.charAt(i) == 'X') {\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (s.charAt(i) == '1') {\n\t\t\t\tcount1 += count;\n\t\t\t}\n\t\t}\n\t\tif (s.charAt(s.length() - 1) == 'X') {\n\t\t\tint count = 0;\n\t\t\tint i = s.length() - 1;\n\t\t\twhile (s.charAt(i) == 'X') {\n\t\t\t\tcount++;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (s.charAt(i) == '0') {\n\t\t\t\tcount0 += count;\n\t\t\t}\n\t\t}\n\t\tif (count0 == count1) {\n\t\t\tSystem.out.println(\"X\");\n\t\t}\n\t\telse if (count0 > count1) {\n\t\t\tSystem.out.println(0);\n\t\t}\n\t\telse\n\t\t\tSystem.out.println(1);\n\t}", "5062": "static void winner(int arr[], int N)\n{\n\tif (N % 2 == 1)\n\t{\n\t\tSystem.out.print(\"A\");\n\t}\n\telse\n\t{\n\t\tSystem.out.print(\"B\");\n\t}\n}", "5090": "static int maxSheets(int A, int B)\n {\n\tint area = A * B;\n\tint count = 1;\n\twhile (area % 2 == 0)\n\t{\n\tarea /= 2;\n\tcount *= 2;\n\t}\n\treturn count;\n }", "5093": "static void findMinMoves(int a, int b)\n {\n\tint ans = 0;\n\tif (a == b || Math.abs(a - b) == 1)\n\t{\n\tans = a + b;\n\t}\n\telse\n\t{\n\tint k = Math.min(a, b);\n\tint j = Math.max(a, b);\n\tans = 2 * k + 2 * (j - k) - 1;\n\t}\n\tSystem.out.print(ans);\n }", "5102": "static long cntEvenSumPairs(long X, long Y)\n\t{\n\t\tlong cntXEvenNums = X / 2;\n\t\tlong cntXOddNums = (X + 1) / 2;\n\t\tlong cntYEvenNums = Y / 2;\n\t\tlong cntYOddNums = (Y + 1) / 2;\n\t\tlong cntPairs = (cntXEvenNums * cntYEvenNums)\n\t\t\t\t\t\t+ (cntXOddNums * cntYOddNums);\n\t\treturn cntPairs;\n\t}", "5118": "static int minMoves(int []arr)\n{\n\tint N = arr.length;\n\tif (N <= 2)\n\t\treturn 0;\n\tint ans = Integer.MAX_VALUE;\n\tfor (int i = -1; i <= 1; i++)\n\t{\n\t\tfor (int j = -1; j <= 1; j++)\n\t\t{\n\t\t\tint num1 = arr[0] + i;\n\t\t\tint num2 = arr[1] + j;\n\t\t\tint flag = 1;\n\t\t\tint moves = Math.abs(i) + Math.abs(j);\n\t\t\tfor (int idx = 2; idx < N; idx++)\n\t\t\t{\n\t\t\t\tint num = num1 + num2;\n\t\t\t\tif (Math.abs(arr[idx] - num) > 1)\n\t\t\t\t\tflag = 0;\n\t\t\t\telse\n\t\t\t\t\tmoves += Math.abs(arr[idx] - num);\n\t\t\t\tnum1 = num2;\n\t\t\t\tnum2 = num;\n\t\t\t}\n\t\t\tif (flag > 0)\n\t\t\t\tans = Math.min(ans, moves);\n\t\t}\n\t}\n\tif (ans == Integer.MAX_VALUE)\n\t\treturn -1;\n\treturn ans;\n}", "5119": "static void querySum(int arr[], int N, int Q[][], int M)\n{\n\tfor(int i = 0; i < M; i++)\n\t{\n\t\tint x = Q[i][0];\n\t\tint y = Q[i][1];\n\t\tint sum = 0;\n\t\twhile (x < N)\n\t\t{\n\t\t\tsum += arr[x];\n\t\t\tx += y;\n\t\t}\n\t\tSystem.out.print(sum + \" \");\n\t}\n}", "5120": "static void precomputeExpressionForAllVal(int arr[], int N, int dp[][])\n{\n\tfor(int i = N - 1; i >= 0; i--)\n\t{\n\t\tfor(int j = 1; j <= Math.sqrt(N); j++)\n\t\t{\n\t\t\tif (i + j < N)\n\t\t\t{\n\t\t\t\tdp[i][j] = arr[i] + dp[i + j][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void querySum(int arr[], int N, int Q[][], int M)\n{\n\tint [][]dp = new int[sz][sqr];\n\tprecomputeExpressionForAllVal(arr, N, dp);\n\tfor(int i = 0; i < M; i++)\n\t{\n\t\tint x = Q[i][0];\n\t\tint y = Q[i][1];\n\t\tif (y <= Math.sqrt(N))\n\t\t{\n\t\t\tSystem.out.print(dp[x][y] + \" \");\n\t\t\tcontinue;\n\t\t}\n\t\tint sum = 0;\n\t\twhile (x < N)\n\t\t{\n\t\t\tsum += arr[x];\n\t\t\tx += y;\n\t\t}\n\t\tSystem.out.print(sum + \" \");\n\t}\n}", "5167": "static void construct_tree(int weights[], int n)\n{\n\tint minimum = Arrays.stream(weights).min().getAsInt();\n\tint maximum = Arrays.stream(weights).max().getAsInt();\n\tif (minimum == maximum)\n\t{\n\t\tSystem.out.println(\"No\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSystem.out.println(\"Yes\");\n\t}\n\tint root = weights[0];\n\tvisited[1] = 1;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] != root && visited[i + 1] == 0)\n\t\t{\n\t\t\tSystem.out.println(1 + \" \" +\n\t\t\t\t\t\t\t(i + 1) + \" \");\n\t\t\tvisited[i + 1] = 1;\n\t\t}\n\t}\n\tint notroot = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] != root)\n\t\t{\n\t\t\tnotroot = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] == root && visited[i + 1] == 0)\n\t\t{\n\t\t\tSystem.out.println(notroot + \" \" +\n\t\t\t\t\t\t\t\t\t(i + 1));\n\t\t\tvisited[i + 1] = 1;\n\t\t}\n\t}\n}", "5170": "static int findBitwiseORGivenXORAND(int X, int Y)\n\t{\n\t\treturn X + Y;\n\t}", "5198": "static int GCD(int a, int b)\n{\n if (b == 0)\n\treturn a;\n return GCD(b, a % b);\n}\nstatic void canReach(int N, int A, int B, int K)\n{\n int gcd = GCD(N, K);\n if (Math.abs(A - B) % gcd == 0)\n {\n\tSystem.out.println(\"Yes\");\n }\n else\n {\n\tSystem.out.println(\"No\");\n }\n}", "5199": "static int sum(int n)\n{\n\tint res = 0;\n\twhile (n > 0)\n\t{\n\t\tres += n % 10;\n\t\tn /= 10;\n\t}\n\treturn res;\n}\nstatic int smallestNumber(int n, int s)\n{\n\tif (sum(n) <= s)\n\t{\n\t\treturn n;\n\t}\n\tint ans = n, k = 1;\n\tfor(int i = 0; i < 9; ++i)\n\t{\n\t\tint digit = (ans / k) % 10;\n\t\tint add = k * ((10 - digit) % 10);\n\t\tans += add;\n\t\tif (sum(ans) <= s)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tk *= 10;\n\t}\n\treturn ans;\n}", "5218": "static void countOfSubarray(int arr[], int N)\n{\n\tMap<Integer,\n\t\tInteger> mp = new HashMap<Integer,\n\t\t\t\t\t\t\t\tInteger>(); \n\tint answer = 0;\n\tint sum = 0;\n\tif (mp.get(1) != null)\n\t\tmp.put(1, mp.get(1) + 1);\n\telse\n\t\tmp.put(1, 1);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tsum += arr[i];\n\t\tif (mp.get(sum - i) != null)\n\t\t\tanswer += mp.get(sum - i);\n\t\tif (mp.get(sum - i) != null)\n\t\t\tmp.put(sum - i, mp.get(sum - i) + 1);\n\t\telse\n\t\t\tmp.put(sum - i, 1);\n\t}\n\tSystem.out.print(answer);\n}", "5227": "static void minCost(String s, int k)\n\t{\n\t\tint n = s.length();\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint[] a = new int[26];\n\t\t\tfor (int j = i; j < n; j += k) {\n\t\t\t\ta[s.charAt(j) - 'a']++;\n\t\t\t}\n\t\t\tint min_cost\n\t\t\t\t= Integer.MAX_VALUE;\n\t\t\tfor (int ch = 0; ch < 26; ch++) {\n\t\t\t\tint cost = 0;\n\t\t\t\tfor (int tr = 0; tr < 26; tr++)\n\t\t\t\t\tcost += Math.abs(ch - tr)\n\t\t\t\t\t\t\t* a[tr];\n\t\t\t\tmin_cost = Math.min(min_cost, cost);\n\t\t\t}\n\t\t\tans += min_cost;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}", "5233": "static int minAbsDiff(int N)\n{\n\tint sumSet1 = 0;\n\tint sumSet2 = 0;\n\tfor(int i = N; i > 0; i--)\n\t{\n\t\tif (sumSet1 <= sumSet2)\n\t\t{\n\t\t\tsumSet1 += i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsumSet2 += i;\n\t\t}\n\t}\n\treturn Math.abs(sumSet1 - sumSet2);\n}", "5234": "static int minAbsDiff(int N)\n{\n\tif (N % 4 == 0 N % 4 == 3)\n\t{\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "5250": "static boolean checkDigits(int n)\n{\n do\n {\n\tint r = n % 10;\n\tif (r == 3 r == 4 r == 6 r == 7 r == 9)\n\treturn false;\n\tn /= 10;\n } while (n != 0);\n return true;\n}\nstatic boolean isPrime(int n)\n{\n if (n <= 1)\n\treturn false;\n for (int i = 2; i * i <= n; i++)\n {\n\tif (n % i == 0)\n\treturn false;\n }\n return true;\n}\nstatic boolean isAllPrime(int n)\n{\n return isPrime(n) &&\n\t\tcheckDigits(n);\n}", "5262": "static int maximumSubarrays(int arr[], int N, int target)\n{\n\tint ans = 0;\n\tint availIdx = -1;\n\tint cur_sum = 0;\n\tHashMap<Integer,\n\t\t\tInteger> mp = new HashMap<Integer,\n\t\t\t\t\t\t\t\t\tInteger>();\n\tmp.put(0, 1);\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tcur_sum += arr[i];\n\t\tif (mp.containsKey(cur_sum - target) &&\n\t\t\tmp.get(cur_sum - target) >= availIdx)\n\t\t{\n\t\t\tans++;\n\t\t\tavailIdx = i;\n\t\t}\n\t\tmp.put(cur_sum, i);\n\t}\n\treturn ans;\n}", "5291": "public static int getMinOps(int[] arr)\n\t{\n\t\tint res = 0;\n\t\tfor (int i = 0; i < arr.length - 1; i++)\n\t\t{\n\t\t\tres += Math.max(arr[i + 1] - arr[i], 0);\n\t\t}\n\t\treturn res;\n\t}", "5310": "static void minCost(String str, int a, int b)\n{\n\tint openUnbalanced = 0;\n\tint closedUnbalanced = 0;\n\tint openCount = 0;\n\tint closedCount = 0;\n\tfor(int i = 0; i < str.length(); i++)\n\t{\n\t\tif (str.charAt(i) == '(')\n\t\t{\n\t\t\topenUnbalanced++;\n\t\t\topenCount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (openUnbalanced == 0)\n\t\t\t\tclosedUnbalanced++;\n\t\t\telse\n\t\t\t\topenUnbalanced--;\n\t\t\tclosedCount++;\n\t\t}\n\t}\n\tint result = a * (Math.abs(openCount - closedCount));\n\tif (closedCount > openCount)\n\t\tclosedUnbalanced -= (closedCount - openCount);\n\tif (openCount > closedCount)\n\t\topenUnbalanced -= (openCount - closedCount);\n\tresult += Math.min(a * (openUnbalanced + closedUnbalanced), b * closedUnbalanced);\n\tSystem.out.print(result + \"\\n\");\n}", "5322": "public static void\n\tcountEvenSum(int low, int high, int k)\n\t{\n\t\tint even_count = high / 2 - (low - 1) / 2;\n\t\tint odd_count = (high + 1) / 2 - low / 2;\n\t\tlong even_sum = 1;\n\t\tlong odd_sum = 0;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tlong prev_even = even_sum;\n\t\t\tlong prev_odd = odd_sum;\n\t\t\teven_sum = (prev_even * even_count)\n\t\t\t\t\t+ (prev_odd * odd_count);\n\t\t\todd_sum = (prev_even * odd_count)\n\t\t\t\t\t+ (prev_odd * even_count);\n\t\t}\n\t\tSystem.out.println(even_sum);\n\t}", "5329": "static double[] Length_Diagonals(int a, double theta)\n{\n\tdouble p = a * Math.sqrt(2 + (2 *\n\t\t\t\tMath.cos(theta * (Math.PI / 180))));\n\tdouble q = a * Math.sqrt(2 - (2 *\n\t\t\t\tMath.cos(theta * (Math.PI / 180))));\n\treturn new double[]{ p, q };\n}", "5333": "static void AddEdge(int u, int v)\n{\n\tadj[u].add(v);\n\tadj[v].add(u);\n}\nstatic void Matching_dfs(int u, int p)\n{\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tif (adj[u].get(i) != p)\n\t\t{\n\t\t\tMatching_dfs(adj[u].get(i), u);\n\t\t}\n\t}\n\tif (used[u] == 0 && used[p] == 0 && p != 0)\n\t{\n\t\tmax_matching++;\n\t\tused[u] = used[p] = 1;\n\t}\n}\nstatic void maxMatching()\n{\n\tMatching_dfs(1, 0);\n\tSystem.out.print(max_matching + \"\\n\");\n}", "5353": "static String balancedMatrix(int mat[][])\n\t{\n\t\tboolean is_balanced = true;\n\t\tfor (int i = 0; i < N && is_balanced; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M && is_balanced; j++)\n\t\t\t{\n\t\t\t\tif ((i == 0 i == N - 1) &&\n\t\t\t\t\t(j == 0 j == M - 1))\n\t\t\t\t{\n\t\t\t\t\tif (mat[i][j] >= 2)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t\telse if (i == 0 i == N - 1 j == 0 j == M - 1)\n\t\t\t\t{\n\t\t\t\t\tif (mat[i][j] >= 3)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (mat[i][j] >= 4)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (is_balanced)\n\t\t\treturn \"Balanced\";\n\t\telse\n\t\t\treturn \"Unbalanced\";\n\t}", "5361": "static int getMinCost(int [] A, int [] B, int N)\n{\n\tint mini = Integer.MAX_VALUE;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tmini = Math.min(mini,\n\t\t\tMath.min(A[i], B[i]));\n\t}\n\treturn mini * (2 * N - 1);\n}", "5370": "static int maxSubsequences(int arr[], int n)\n\t{\n\t\tHashMap<Integer, Integer> map\n\t\t\t= new HashMap<>();\n\t\tint maxCount = 0;\n\t\tint count;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (map.containsKey(arr[i]))\n\t\t\t{\n\t\t\t\tcount = map.get(arr[i]);\n\t\t\t\tif (count > 1)\n\t\t\t\t{\n\t\t\t\t\tmap.put(arr[i], count - 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmap.remove(arr[i]);\n\t\t\t\tif (arr[i] - 1 > 0)\n\t\t\t\t\tmap.put(arr[i] - 1,\n\t\t\t\t\tmap.getOrDefault(arr[i] - 1, 0) + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxCount++;\n\t\t\t\tif (arr[i] - 1 > 0)\n\t\t\t\t\tmap.put(arr[i] - 1,\n\t\t\t\t\tmap.getOrDefault(arr[i] - 1, 0) + 1);\n\t\t\t}\n\t\t}\n\t\treturn maxCount;\n\t}", "5373": "public static void count(int n, int k)\n\t{\n\t\tlong count\n\t\t\t= (long)(Math.pow(10, k)\n\t\t\t\t\t- Math.pow(10, k - 1));\n\t\tSystem.out.print(count);\n\t}", "5380": "static int func(int N, int P)\n{\n\tint sumUptoN = (N * (N + 1) / 2);\n\tint sumOfMultiplesOfP;\n\tif (N < P)\n\t{\n\t\treturn sumUptoN;\n\t}\n\telse if ((N / P) == 1)\n\t{\n\t\treturn sumUptoN - P + 1;\n\t}\n\tsumOfMultiplesOfP = ((N / P) * (2 * P +\n\t\t\t\t\t\t(N / P - 1) * P)) / 2;\n\treturn (sumUptoN + func(N / P, P) - sumOfMultiplesOfP);\n}", "5383": "static String removeOcc(String s, char ch)\n{\n\tfor (int i = 0; i < s.length(); i++)\n\t{\n\t\tif (s.charAt(i) == ch)\n\t\t{\n\t\t\ts = s.substring(0, i) +\n\t\t\t\ts.substring(i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = s.length() - 1; i > -1; i--)\n\t{\n\t\tif (s.charAt(i) == ch)\n\t\t{\n\t\t\ts = s.substring(0, i) +\n\t\t\t\ts.substring(i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s;\n}", "5388": "public static void findShifts(int[] A, int N)\n{\n\tint[] shift = new int[N];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (i == A[i] - 1)\n\t\t\tshift[i] = 0;\n\t\telse\n\t\t\tshift[i] = (A[i] - 1 - i + N) % N;\n\t}\n\tfor(int i = 0; i < N; i++)\n\t\tSystem.out.print(shift[i] + \" \");\n}", "5398": "static void printVector(ArrayList<Integer> arr)\n{\n\tif (arr.size() != 1)\n\t{\n\t\tfor(int i = 0; i < arr.size(); i++)\n\t\t{\n\t\t\tSystem.out.print(arr.get(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\nstatic void findWays(ArrayList<Integer> arr, int i, int n)\n{\n\tif (n == 0)\n\t\tprintVector(arr);\n\tfor(int j = i; j <= n; j++)\n\t{\n\t\tarr.add(j);\n\t\tfindWays(arr, j, n - j);\n\t\tarr.remove(arr.size() - 1);\n\t}\n}", "5405": "public static void Maximum_subsequence( int[] A, int N)\n\t{\n\t\tHashMap<Integer, Integer> frequency\n\t\t\t= new HashMap<>();\n\t\tint max_freq = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (frequency.containsKey(A[i])) {\n\t\t\t\tfrequency.replace(A[i],\n\t\t\t\t\t\t\t\tfrequency.get(A[i]) + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfrequency.put(A[i], 1);\n\t\t\t}\n\t\t}\n\t\tfor (Map.Entry it : frequency.entrySet()) {\n\t\t\tif ((int)it.getValue() > max_freq) {\n\t\t\t\tmax_freq = (int)it.getValue();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max_freq);\n\t}", "5407": "public static void\n\tminSteps(int N, int[] increasing, int[] decreasing)\n\t{\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i : increasing) {\n\t\t\tif (min > i)\n\t\t\t\tmin = i;\n\t\t}\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor (int i : decreasing) {\n\t\t\tif (max < i)\n\t\t\t\tmax = i;\n\t\t}\n\t\tint minSteps = Math.max(max, N - min);\n\t\tSystem.out.println(minSteps);\n\t}", "5416": "public static void constructmatrix(int N)\n\t{\n\t\tboolean check = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tSystem.out.print(\"1 \");\n\t\t\t\t}\n\t\t\t\telse if (check) {\n\t\t\t\t\tSystem.out.print(\"2 \");\n\t\t\t\t\tcheck = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.print(\"-2 \");\n\t\t\t\t\tcheck = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "5418": "static int countChanges(int matrix[][], int n, int m)\n{\n\tint dist = n + m - 1;\n\tint [][]freq = new int[dist][10];\n\tfor(int i = 0; i < dist; i++)\n\t{\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tfreq[i][j] = 0;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tfreq[i + j][matrix[i][j]]++;\n\t\t}\n\t}\n\tint min_changes_sum = 0;\n\tfor(int i = 0; i < dist / 2; i++)\n\t{\n\t\tint maximum = 0;\n\t\tint total_values = 0;\n\t\tfor(int j = 0; j < 10; j++)\n\t\t{\n\t\t\tmaximum = Math.max(maximum, freq[i][j] + freq[n + m - 2 - i][j]);\n\t\t\ttotal_values += (freq[i][j] + freq[n + m - 2 - i][j]);\n\t\t}\n\t\tmin_changes_sum += (total_values - maximum);\n\t}\n\treturn min_changes_sum;\n}", "5440": "public static void DivideString(String s, int n, int k)\n{\n\tint i, c = 0, no = 1;\n\tint c1 = 0, c2 = 0;\n\tint[] fr = new int[26];\n\tchar[] ans = new char[n];\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tfr[s.charAt(i) - 'a']++;\n\t}\n\tchar ch = 'a', ch1 = 'a';\n\tfor(i = 0; i < 26; i++)\n\t{\n\t\tif (fr[i] == k)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t\tif (fr[i] > k && fr[i] != 2 * k)\n\t\t{\n\t\t\tc1++;\n\t\t\tch = (char)(i + 'a');\n\t\t}\n\t\tif (fr[i] == 2 * k)\n\t\t{\n\t\t\tc2++;\n\t\t\tch1 = (char)(i + 'a');\n\t\t}\n\t}\n\tfor(i = 0; i < n; i++)\n\t\tans[i] = '1';\n\tHashMap<Character, Integer> mp = new HashMap<>();\n\tif (c % 2 == 0 c1 > 0 c2 > 0)\n\t{\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tif (fr[s.charAt(i) - 'a'] == k)\n\t\t\t{\n\t\t\t\tif (mp.containsKey(s.charAt(i)))\n\t\t\t\t{\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (no <= (c / 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i] = '2';\n\t\t\t\t\t\tno++;\n\t\t\t\t\t\tmp.replace(s.charAt(i), 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( (c % 2 == 1) && (c1 > 0) )\n\t\t{\n\t\t\tno = 1;\n\t\t\tfor(i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (s.charAt(i) == ch && no <= k)\n\t\t\t\t{\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tno++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c % 2 == 1 && c1 == 0)\n\t\t{\n\t\t\tno = 1;\n\t\t\tint flag = 0;\n\t\t\tfor(i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (s.charAt(i) == ch1 && no <= k)\n\t\t\t\t{\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tno++;\n\t\t\t\t}\n\t\t\t\tif (fr[s.charAt(i) - 'a'] == k && flag == 0 && ans[i] == '1')\n\t\t\t\t{\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\telse\n\t{\n\t\tSystem.out.println(\"NO\");\n\t}\n}", "5447": "static int check(int unit_digit, int X)\n{\n\tint times, digit;\n\tfor (times = 1; times <= 10; times++)\n\t{\n\t\tdigit = (X * times) % 10;\n\t\tif (digit == unit_digit)\n\t\t\treturn times;\n\t}\n\treturn -1;\n}\nstatic int getNum(int N, int X)\n{\n\tint unit_digit;\n\tunit_digit = N % 10;\n\tint times = check(unit_digit, X);\n\tif (times == -1)\n\t\treturn times;\n\telse\n\t{\n\t\tif (N >= (times * X))\n\t\t\treturn times;\n\t\telse\n\t\t\treturn -1;\n\t}\n}", "5455": "static int minPoints(int n, int m)\n{\n\tint ans = 0;\n\tif ((n % 2 != 0) && (m % 2 != 0))\n\t{\n\t\tans = ((n * m) / 2) + 1;\n\t}\n\telse\n\t{\n\t\tans = (n * m) / 2;\n\t}\n\treturn ans;\n}", "5468": "static void solve(int P[], int n)\n{\n\tint arr[] = new int[n + 1];\n\tarr[0] = 0;\n\tfor(int i = 0; i < n; i++)\n\tarr[i + 1] = P[i];\n\tint cnt = 0;\n\tfor(int i = 1; i < n; i++)\n\t{\n\tif (arr[i] == i)\n\t{\n\t\tint t = arr[i + 1];\n\t\tarr[i + 1] = arr[i];\n\t\tarr[i] = t;\n\t\tcnt++;\n\t}\n\t}\n\tif (arr[n] == n)\n\t{\n\t\tint t = arr[n - 1];\n\t\tarr[n - 1] = arr[n];\n\t\tarr[n] = t;\n\t\tcnt++;\n\t}\n\tSystem.out.println(cnt);\n}", "5482": "static int __builtin_popcount(int n)\n\t{\n\t\tint count = 0;\n\t\twhile (n > 0) {\n\t\t\tcount += n & 1;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn count;\n\t}\nstatic void countEvenOdd(int arr[], int n, int K)\n\t{\n\t\tint even = 0, odd = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = __builtin_popcount(arr[i]);\n\t\t\tif (x % 2 == 0)\n\t\t\t\teven++;\n\t\t\telse\n\t\t\t\todd++;\n\t\t}\n\t\tint y;\n\t\ty = __builtin_popcount(K);\n\t\tif ((y & 1) != 0) {\n\t\t\tSystem.out.println(\"Even = \"+ odd + \", Odd = \" + even);\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Even = \" + even + \", Odd = \" + odd);\n\t\t}\n\t}", "5495": "static String check(int S, int prices[], int type[], int n)\n{\n\tfor (int j = 0; j < n; j++)\n\t{\n\t\tfor (int k = j + 1; k < n; k++)\n\t\t{\n\t\t\tif ((type[j] == 0 && type[k] == 1) ||\n\t\t\t\t(type[j] == 1 && type[k] == 0))\n\t\t\t{\n\t\t\t\tif (prices[j] + prices[k] <= S)\n\t\t\t\t{\n\t\t\t\t\treturn \"Yes\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"No\";\n}", "5501": "static String getLargestString(String s, int k)\n{\n int []frequency_array = new int[26];\n for (int i = 0;\n\t\ti < s.length(); i++)\n {\n\tfrequency_array[s.charAt(i) - 'a']++;\n }\n String ans = \"\";\n for (int i = 25; i >= 0\n {\n\tif (frequency_array[i] > k)\n\t{\n\tint temp = k;\n\tString st = String.valueOf((char)(i + 'a'));\n\twhile (temp > 0)\n\t{\n\t\tans += st;\n\t\ttemp--;\n\t}\n\tfrequency_array[i] -= k;\n\tint j = i - 1;\n\twhile (frequency_array[j] <= 0 && j >= 0)\n\t{\n\t\tj--;\n\t}\n\tif (frequency_array[j] > 0 && j >= 0)\n\t{\n\t\tString str = String.valueOf((char)(j + 'a'));\n\t\tans += str;\n\t\tfrequency_array[j] -= 1;\n\t}\n\telse\n\t{\n\t\tbreak;\n\t}\n\t}\n\telse if (frequency_array[i] > 0)\n\t{\n\tint temp = frequency_array[i];\n\tfrequency_array[i] -= temp;\n\tString st = String.valueOf((char)(i + 'a'));\n\twhile (temp > 0)\n\t{\n\t\tans += st;\n\t\ttemp--;\n\t}\n\t}\n\telse\n\t{\n\ti--;\n\t}\n }\n return ans;\n}", "5512": "static int minOperations(int a[], int b[], int n)\n{\n\tint minA = Arrays.stream(a).min().getAsInt();\n\tfor (int x = minA; x >= 0; x--)\n\t{\n\t\tboolean check = true;\n\t\tint operations = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (x % b[i] == a[i] % b[i])\n\t\t\t{\n\t\t\t\toperations += (a[i] - x) / b[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check)\n\t\t\treturn operations;\n\t}\n\treturn -1;\n}", "5538": "static int getLargestSum(int N)\n{\n\tint max_sum = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\tif (i * j % (i + j) == 0)\n\t\t\t\tmax_sum = Math.max(max_sum, i + j);\n\t\t}\n\t}\n\treturn max_sum;\n}", "5539": "static int getLargestSum(int N)\n{\n\tint max_sum = 0;\n\tfor (int i = 1; i * i <= N; i++) {\n\t\tfor (int j = i + 1; j * j <= N; j++) {\n\t\t\tint k = N / j;\n\t\t\tint a = k * i;\n\t\t\tint b = k * j;\n\t\t\tif (a <= N && b <= N &&\n\t\t\t\ta * b % (a + b) == 0)\n\t\t\t\tmax_sum = Math.max(max_sum, a + b);\n\t\t}\n\t}\n\treturn max_sum;\n}", "5544": "static int maxSubArraySum(int a[], int size)\n\t{\n\t\tint max_so_far = Integer.MIN_VALUE,\n\t\t\tmax_ending_here = 0;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tmax_ending_here =\n\t\t\t\tmax_ending_here + a[i];\n\t\t\tif (max_ending_here < 0)\n\t\t\t\tmax_ending_here = 0;\n\t\t\tif (max_so_far < max_ending_here)\n\t\t\t\tmax_so_far = max_ending_here;\n\t\t}\n\t\treturn max_so_far;\n\t}\nstatic int maxSum(int a[], int n)\n\t{\n\t\tint S = 0;\n\t\tint i;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tS += a[i];\n\t\tint X = maxSubArraySum(a, n);\n\t\treturn 2 * X - S;\n\t}", "5548": "static boolean isPrime(int n)\n{\n\tint flag = 1;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tflag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (flag == 1 ? true : false);\n}\nstatic boolean isPerfectSquare(int x)\n{\n\tdouble sr = Math.sqrt(x);\n\treturn ((sr - Math.floor(sr)) == 0);\n}\nstatic int countInterestingPrimes(int n)\n{\n\tint answer = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isPrime(i)) {\n\t\t\tfor (int j = 1; j * j * j * j <= i; j++) {\n\t\t\t\tif (\n\t\t\t\t\tisPerfectSquare( i - j * j * j * j)) {\n\t\t\t\t\tanswer++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn answer;\n}", "5549": "static void SieveOfEratosthenes( int n, HashSet<Integer> allPrimes)\n{\n\tboolean []prime = new boolean[n + 1];\n\tArrays.fill(prime, true);\n\tfor (int p = 2; p * p <= n; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tallPrimes.add(p);\n}\nstatic int countInterestingPrimes(int n)\n{\n\tHashSet<Integer> allPrimes = new HashSet<Integer>();\n\tSieveOfEratosthenes(n, allPrimes);\n\tHashSet<Integer> intersetingPrimes = new HashSet<Integer>();\n\tVector<Integer> squares = new Vector<Integer>()\n\t\t\t, quadruples = new Vector<Integer>();\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tsquares.add(i * i);\n\t}\n\tfor (int i = 1; i * i * i * i <= n; i++) {\n\t\tquadruples.add(i * i * i * i);\n\t}\n\tfor (int a : squares) {\n\t\tfor (int b : quadruples) {\n\t\t\tif (allPrimes.contains(a + b))\n\t\t\t\tintersetingPrimes.add(a + b);\n\t\t}\n\t}\n\treturn intersetingPrimes.size();\n}", "5585": "static void decBinary(int arr[], int n)\n\t{\n\t\tint k = (int)(Math.log(n) /\n\t\t\t\t\tMath.log(2));\n\t\twhile (n > 0)\n\t\t{\n\t\t\tarr[k--] = n % 2;\n\t\t\tn /= 2;\n\t\t}\n\t}\nstatic int binaryDec(int arr[], int n)\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans += arr[i] << (n - i - 1);\n\t\treturn ans;\n\t}\nstatic int maxNum(int n, int k)\n\t{\n\t\tint l = (int)(Math.log(n) /\n\t\t\t\t\tMath.log(2)) + 1;\n\t\tint a[] = new int[l];\n\t\tdecBinary(a, n);\n\t\tint cn = 0;\n\t\tfor (int i = 0; i < l; i++)\n\t\t{\n\t\t\tif (a[i] == 0 && cn < k)\n\t\t\t{\n\t\t\t\ta[i] = 1;\n\t\t\t\tcn++;\n\t\t\t}\n\t\t}\n\t\treturn binaryDec(a, l);\n\t}", "5588": "static void findSubSeq(int arr[], int n, int sum)\n\t{\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (sum < arr[i])\n\t\t\t\tarr[i] = -1;\n\t\t\telse\n\t\t\t\tsum -= arr[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] != -1)\n\t\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}", "5594": "static char maxAlpha(String str, int len)\n{\n\tint []first = new int[MAX];\n\tint []last = new int[MAX];\n\tfor (int i = 0; i < MAX; i++)\n\t{\n\t\tfirst[i] = -1;\n\t\tlast[i] = -1;\n\t}\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tint index = (str.charAt(i) - 'a');\n\t\tif (first[index] == -1)\n\t\t\tfirst[index] = i;\n\t\tlast[index] = i;\n\t}\n\tint ans = -1, maxVal = -1;\n\tfor (int i = 0; i < MAX; i++)\n\t{\n\t\tif (first[i] == -1)\n\t\t\tcontinue;\n\t\tif ((last[i] - first[i]) > maxVal)\n\t\t{\n\t\t\tmaxVal = last[i] - first[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn (char)(ans + 'a');\n}", "5621": "static void find_distinct(int a[], int n, int q, int queries[])\n{\n\tint []check = new int[MAX];\n\tint []idx = new int[MAX];\n\tint cnt = 1;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tif (check[a[i]] == 0)\n\t\t{\n\t\t\tidx[i] = cnt;\n\t\t\tcheck[a[i]] = 1;\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tidx[i] = cnt - 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\t\tint m = queries[i];\n\t\t\tSystem.out.print(idx[m] + \" \");\n\t}\n}", "5627": "static int countOp(int x)\n{\n\tint arr[] = new int[MAX];\n\tarr[0] = 1;\n\tfor (int i = 1; i < MAX; i++)\n\t\tarr[i] = arr[i - 1] * 2;\n\tint temp = x;\n\tboolean flag = true;\n\tint ans =0;\n\tint operations = 0;\n\tboolean flag2 = false;\n\tfor (int i = 0; i < MAX; i++)\n\t{\n\t\tif (arr[i] - 1 == x)\n\t\t\tflag2 = true;\n\t\tif (arr[i] > x)\n\t\t{\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag2)\n\t\treturn 0;\n\twhile (flag)\n\t{\n\t\tif (arr[ans] < x)\n\t\t\tans++;\n\t\toperations++;\n\t\tfor (int i = 0; i < MAX; i++)\n\t\t{\n\t\t\tint take = x ^ (arr[i] - 1);\n\t\t\tif (take <= arr[ans] - 1)\n\t\t\t{\n\t\t\t\tif (take > temp)\n\t\t\t\t\ttemp = take;\n\t\t\t}\n\t\t}\n\t\tif (temp == arr[ans] - 1)\n\t\t{\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t\ttemp++;\n\t\toperations++;\n\t\tx = temp;\n\t\tif (x == arr[ans] - 1)\n\t\t\tflag = false;\n\t}\n\treturn operations;\n}", "5636": "static int minOperations(int[] arr, int n)\n\t{\n\t\tint maxi, result = 0;\n\t\tint[] freq = new int[1000001];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x = arr[i];\n\t\t\tfreq[x]++;\n\t\t}\n\t\tmaxi = Arrays.stream(arr).max().getAsInt();\n\t\tfor (int i = 1; i <= maxi; i++)\n\t\t{\n\t\t\tif (freq[i] != 0)\n\t\t\t{\n\t\t\t\tfor (int j = i * 2; j <= maxi; j = j + i)\n\t\t\t\t{\n\t\t\t\t\tfreq[j] = 0;\n\t\t\t\t}\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "5675": "static String encryptString(String str, int n)\n{\n\tint i = 0, cnt = 0;\n\tString encryptedStr = \"\";\n\twhile (i < n)\n\t{\n\t\tcnt = i + 1;\n\t\twhile (cnt-- >0)\n\t\t\tencryptedStr += str.charAt(i);\n\t\ti++;\n\t}\n\treturn encryptedStr;\n}", "5676": "static int __gcd(int a, int b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn __gcd(b % a, a);\n}\nstatic int minGCD(int arr[], int n)\n{\n\tint minGCD = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tminGCD = __gcd(minGCD, arr[i]);\n\treturn minGCD;\n}\nstatic int minLCM(int arr[], int n)\n{\n\tint minLCM = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t\tminLCM = Math.min(minLCM, arr[i]);\n\treturn minLCM;\n}", "5687": "static String formStringMinOperations(char[] s)\n\t{\n\t\tint count[] = new int[3];\n\t\tfor (char c : s)\n\t\t{\n\t\t\tcount[(int)c - 48] += 1;\n\t\t}\n\t\tint processed[] = new int[3];\n\t\tint reqd = (int) s.length / 3;\n\t\tfor (int i = 0; i < s.length; i++)\n\t\t{\n\t\t\tif (count[s[i] - '0'] == reqd)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[i] == '0' && count[0] > reqd && processed[0] >= reqd)\n\t\t\t{\n\t\t\t\tif (count[1] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '1';\n\t\t\t\t\tcount[1]++;\n\t\t\t\t\tcount[0]--;\n\t\t\t\t}\n\t\t\t\telse if (count[2] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '2';\n\t\t\t\t\tcount[2]++;\n\t\t\t\t\tcount[0]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '1' && count[1] > reqd)\n\t\t\t{\n\t\t\t\tif (count[0] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '0';\n\t\t\t\t\tcount[0]++;\n\t\t\t\t\tcount[1]--;\n\t\t\t\t}\n\t\t\t\telse if (count[2] < reqd && processed[1] >= reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '2';\n\t\t\t\t\tcount[2]++;\n\t\t\t\t\tcount[1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '2' && count[2] > reqd)\n\t\t\t{\n\t\t\t\tif (count[0] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '0';\n\t\t\t\t\tcount[0]++;\n\t\t\t\t\tcount[2]--;\n\t\t\t\t}\n\t\t\t\telse if (count[1] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '1';\n\t\t\t\t\tcount[1]++;\n\t\t\t\t\tcount[2]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed[s[i] - '0']++;\n\t\t}\n\t\treturn String.valueOf(s);\n\t}", "5730": "static int minDiff(int n, int x, int A[])\n\t{\n\t\tint mn = A[0], mx = A[0];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tmn = Math.min(mn, A[i]);\n\t\t\tmx = Math.max(mx, A[i]);\n\t\t}\n\t\treturn Math.max(0, mx - mn - 2 * x);\n\t}", "5739": "", "5742": "static boolean isWaveArray(int arr[], int n)\n\t{\n\t\tboolean result = true;\n\t\tif (arr[1] > arr[0] && arr[1] > arr[2]) {\n\t\t\tfor (int i = 1; i < n - 1; i += 2) {\n\t\t\t\tif (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == true && n % 2 == 0) {\n\t\t\t\tif (arr[n - 1] <= arr[n - 2]) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (arr[1] < arr[0] && arr[1] < arr[2]) {\n\t\t\tfor (int i = 1; i < n - 1; i += 2) {\n\t\t\t\tif (arr[i] < arr[i - 1] && arr[i] < arr[i + 1]) {\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == true && n % 2 == 0) {\n\t\t\t\tif (arr[n - 1] >= arr[n - 2]) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "5762": "static int findMinimumAdjacentSwaps(int arr[], int N)\n{\n\tboolean[] visited = new boolean[N + 1];\n\tint minimumSwaps = 0;\n\tArrays.fill(visited,false);\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tif (visited[arr[i]] == false) {\n\t\t\tvisited[arr[i]] = true;\n\t\t\tint count = 0;\n\t\t\tfor (int j = i + 1; j < 2 * N; j++) {\n\t\t\t\tif (visited[arr[j]] == false)\n\t\t\t\t\tcount++;\n\t\t\t\telse if (arr[i] == arr[j])\n\t\t\t\t\tminimumSwaps += count;\n\t\t\t}\n\t\t}\n\t}\n\treturn minimumSwaps;\n}", "5772": "static boolean possibility(HashMap<Integer, Integer> m, int length, String s)\n{\n int countodd = 0;\n for (int i = 0; i < length; i++)\n {\n\tif (m.get(s.charAt(i) - '0') % 2 == 1)\n\tcountodd++;\n\tif (countodd > 1)\n\treturn false;\n }\n return true;\n}\nstatic void largestPalindrome(String s)\n{\n int l = s.length();\n HashMap<Integer,\n\t\tInteger> m = new HashMap<>();\n for (int i = 0; i < l; i++)\n\tif(m.containsKey(s.charAt(i) - '0'))\n\tm.put(s.charAt(i) - '0',\n\tm.get(s.charAt(i) - '0') + 1);\n else\n\tm.put(s.charAt(i) - '0', 1);\n if (possibility(m, l, s) == false)\n {\n\tSystem.out.print(\"Palindrome cannot be formed\");\n\treturn;\n }\n char []largest = new char[l];\n int front = 0;\n for (int i = 9; i >= 0; i--)\n {\n\tif (m.containsKey(i) &&\n\t\tm.get(i)%2==1)\n\t{\n\tlargest[l / 2] = (char)(i + 48);\n\tm.put(i, m.get(i)-1);\n\twhile (m.get(i) > 0)\n\t{\n\t\tlargest[front] = (char)(i + 48);\n\t\tlargest[l - front - 1] =\n\t\t\t\t\t(char)(i + 48);\n\t\tm.put(i, m.get(i) - 2);\n\t\tfront++;\n\t}\n\t}\n\telse\n\t{\n\twhile (m.containsKey(i) &&\n\t\t\tm.get(i) > 0)\n\t{\n\t\tlargest[front] = (char)(i + 48);\n\t\tlargest[l - front - 1] =\n\t\t\t(char)(i + 48);\n\t\tm.put(i, m.get(i) - 2);\n\t\tfront++;\n\t}\n\t}\n }\n for (int i = 0; i < l; i++)\n\tSystem.out.print(largest[i]);\n}", "5797": "public static long swapCount(String s)\n{\n\tVector<Integer> pos = new Vector<Integer>();\n\tfor(int i = 0; i < s.length(); ++i)\n\t\tif (s.charAt(i) == '[')\n\t\t\tpos.add(i);\n\tint count = 0;\n\tint p = 0; \n\tlong sum = 0;\n\tchar[] S = s.toCharArray();\n\tfor(int i = 0; i < s.length(); ++i)\n\t{\n\t\tif (S[i] == '[')\n\t\t{\n\t\t\t++count;\n\t\t\t++p;\n\t\t}\n\t\telse if (S[i] == ']')\n\t\t\t--count;\n\t\tif (count < 0)\n\t\t{\n\t\t\tsum += pos.get(p) - i;\n\t\t\tchar temp = S[i];\n\t\t\tS[i] = S[pos.get(p)];\n\t\t\tS[pos.get(p)] = temp;\n\t\t\t++p;\n\t\t\tcount = 1;\n\t\t}\n\t}\n\treturn sum;\n}", "5798": "static long swapCount(String s)\n\t{\n\t\tchar[] chars = s.toCharArray();\n\t\tint countLeft = 0, countRight = 0;\n\t\tint swap = 0 , imbalance = 0;\n\t\tfor(int i =0; i< chars.length; i++)\n\t\t{\n\t\t\tif(chars[i] == '[')\n\t\t\t{\n\t\t\t\tcountLeft++;\n\t\t\t\tif(imbalance > 0)\n\t\t\t\t{\n\t\t\t\t\tswap += imbalance;\n\t\t\t\t\timbalance--;\t\n\t\t\t\t}\n\t\t\t} else if(chars[i] == ']' )\n\t\t\t{\n\t\t\t\tcountRight++;\n\t\t\t\timbalance = (countRight-countLeft);\n\t\t\t}\n\t\t}\n\t\treturn swap;\n\t}", "5811": "static void minimizeWithKSwaps(int arr[], int n, int k)\n\t{\n\t\tfor (int i = 0; i < n-1 && k > 0; ++i)\n\t\t{\n\t\t\tint pos = i;\n\t\t\tfor (int j = i+1; j < n ; ++j)\n\t\t\t{\n\t\t\t\tif (j - i > k)\n\t\t\t\t\tbreak;\n\t\t\t\tif (arr[j] < arr[pos])\n\t\t\t\t\tpos = j;\n\t\t\t}\n\t\t\tint temp;\n\t\t\tfor (int j = pos; j>i; --j)\n\t\t\t{\n\t\t\t\ttemp=arr[j];\n\t\t\t\tarr[j]=arr[j-1];\n\t\t\t\tarr[j-1]=temp;\n\t\t\t}\n\t\t\tk -= pos-i;\n\t\t}\n\t}", "5816": "static int minimumCostOfBreaking(Integer X[], Integer Y[], int m, int n)\n\t{\n\t\tint res = 0;\n\t\tArrays.sort(X, Collections.reverseOrder());\n\t\tArrays.sort(Y, Collections.reverseOrder());\n\t\tint hzntl = 1, vert = 1;\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n)\n\t\t{\n\t\t\tif (X[i] > Y[j])\n\t\t\t{\n\t\t\t\tres += X[i] * vert;\n\t\t\t\thzntl++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += Y[j] * hzntl;\n\t\t\t\tvert++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tint total = 0;\n\t\twhile (i < m)\n\t\t\ttotal += X[i++];\n\t\tres += total * vert;\n\t\ttotal = 0;\n\t\twhile (j < n)\n\t\t\ttotal += Y[j++];\n\t\tres += total * hzntl;\n\t\treturn res;\n\t}", "5865": "static int getMin(int x, int y, int z)\n{\n\treturn Math.min(Math.min(x, y), z);\n}\nstatic int editDistance(String str1, String str2, int m, int n)\n{\n\tint [][]dp = new int[m + 1][n + 1];\n\tfor (int i = 0; i <= m; i++)\n\t{\n\t\tfor (int j = 0; j <= n; j++)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t\tdp[i][j] = j;\n\t\t\telse if (j == 0)\n\t\t\t\tdp[i][j] = i;\n\t\t\telse if (str1.charAt(i - 1) == str2.charAt(j - 1))\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\telse {\n\t\t\t\tdp[i][j] = 1\n\t\t\t\t\t\t+ getMin( dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[m][n];\n}\nstatic void minimumSteps(String S, int N)\n{\n\tint ans = Integer.MAX_VALUE;\n\tfor (int i = 1; i < N; i++) {\n\t\tString S1 = S.substring(0, i);\n\t\tString S2 = S.substring(i);\n\t\tint count = editDistance(\n\t\t\tS1, S2, S1.length(),\n\t\t\tS2.length());\n\t\tans = Math.min(ans, count);\n\t}\n\tSystem.out.print(ans);\n}", "5872": "static int minimumOperations(int N)\n\t{\n\t\tint[] dp = new int[N + 1];\n\t\tint i;\n\t\tfor (i = 0; i <= N; i++) {\n\t\t\tdp[i] = (int)1e9;\n\t\t}\n\t\tdp[2] = 0;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tif (dp[i] == (int)1e9)\n\t\t\t\tcontinue;\n\t\t\tif (i * 5 <= N) {\n\t\t\t\tdp[i * 5] = Math.min(dp[i * 5], dp[i] + 1);\n\t\t\t}\n\t\t\tif (i + 3 <= N) {\n\t\t\t\tdp[i + 3] = Math.min(dp[i + 3], dp[i] + 1);\n\t\t\t}\n\t\t}\n\t\tif (dp[N] == 1e9)\n\t\t\treturn -1;\n\t\treturn dp[N];\n\t}", "5880": "static int MaxProfit(int arr[], int n, int transactionFee)\n\t{\n\t\tint buy = -arr[0];\n\t\tint sell = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint temp = buy;\n\t\t\tbuy = Math.max(buy, sell - arr[i]);\n\t\t\tsell = Math.max(sell, temp + arr[i] - transactionFee);\n\t\t}\n\t\treturn Math.max(sell, buy);\n\t}", "5904": "static void countPossiblities(int arr[], int n)\n\t{\n\t\tint[] lastOccur = new int[100000];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlastOccur[i] = -1;\n\t\t}\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint curEle = arr[i - 1];\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (lastOccur[curEle] != -1 & lastOccur[curEle] < i - 1) {\n\t\t\t\tdp[i] += dp[lastOccur[curEle]];\n\t\t\t}\n\t\t\tlastOccur[curEle] = i;\n\t\t}\n\t\tSystem.out.println(dp[n]);\n\t}", "5919": "public static Integer longestSubSequence(int[][] A, int N, int ind, int lastf, int lasts)\n{\n\tind = (ind > 0 ? ind : 0);\n\tlastf = (lastf > 0 ? lastf: Integer.MIN_VALUE);\n\tlasts = (lasts > 0 ? lasts: Integer.MAX_VALUE);\n\tif (ind == N)\n\t\treturn 0;\n\tint ans = longestSubSequence(A, N, ind + 1, lastf, lasts);\n\tif (A[ind][0] > lastf && A[ind][1] < lasts)\n\t\tans = Math.max(ans, longestSubSequence(A, N, ind + 1, A[ind][0], A[ind][1]) + 1);\n\treturn ans;\n}\npublic static int longestSubSequence(int[][] A, int N)\n{\n\treturn longestSubSequence(A, N, 0, 0, 0);\n}", "5920": "public static void longestSubSequence(int[][] A, int N)\n{\n\tint[] dp = new int[N];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tdp[i] = 1;\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tif (A[j][0] < A[i][0] && A[j][1] > A[i][1])\n\t\t\t{\n\t\t\t\tdp[i] = Math.max(dp[i], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tSystem.out.println(dp[N - 1]);\n}", "5924": "static void calculateStart(int n, int m)\n{\n\tfor(int i = 1; i < m; ++i)\n\t{\n\t\tstart[0][i] += start[0][i - 1];\n\t}\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tstart[i][0] += start[i - 1][0];\n\t}\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tfor(int j = 1; j < m; ++j)\n\t\t{\n\t\t\tstart[i][j] += Math.max(start[i - 1][j], start[i][j - 1]);\n\t\t}\n\t}\n}\nstatic void calculateEnd(int n, int m)\n{\n\tfor(int i = n - 2; i >= 0; --i)\n\t{\n\t\tending[i][m - 1] += ending[i + 1][m - 1];\n\t}\n\tfor(int i = m - 2; i >= 0; --i)\n\t{\n\t\tending[n - 1][i] += ending[n - 1][i + 1];\n\t}\n\tfor(int i = n - 2; i >= 0; --i)\n\t{\n\t\tfor(int j = m - 2; j >= 0; --j)\n\t\t{\n\t\t\tending[i][j] += Math.max(ending[i + 1][j], ending[i][j + 1]);\n\t\t}\n\t}\n}\nstatic void maximumPathSum(int mat[][], int n, int m, int q, int coordinates[][])\n{\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tfor(int j = 0; j < m; ++j)\n\t\t{\n\t\t\tstart[i][j] = mat[i][j];\n\t\t\tending[i][j] = mat[i][j];\n\t\t}\n\t}\n\tcalculateStart(n, m);\n\tcalculateEnd(n, m);\n\tint ans = 0;\n\tfor(int i = 0; i < q; ++i)\n\t{\n\t\tint X = coordinates[i][0] - 1;\n\t\tint Y = coordinates[i][1] - 1;\n\t\tans = Math.max(ans, start[X][Y] + ending[X][Y] - mat[X][Y]);\n\t}\n\tSystem.out.print(ans);\n}", "5946": "static int MaxSubsetlength(String arr[], int A, int B)\n{\n\tint dp[][] = new int[A + 1][B + 1];\n\tfor(String str : arr)\n\t{\n\t\tint zeros = 0, ones = 0;\n\t\tfor(char ch : str.toCharArray())\n\t\t{\n\t\t\tif (ch == '0')\n\t\t\t\tzeros++;\n\t\t\telse\n\t\t\t\tones++;\n\t\t}\n\t\tfor(int i = A; i >= zeros; i--)\n\t\t\tfor(int j = B; j >= ones; j--)\n\t\t\t\tdp[i][j] = Math.max( dp[i][j], dp[i - zeros][j - ones] + 1);\n\t}\n\treturn dp[A][B];\n}", "5957": "static int numOfWays(int a[][], int n, int i, HashSet<Integer> blue)\n{\n\tif (i == n)\n\t\treturn 1;\n\tint count = 0;\n\tfor(int j = 0; j < n; j++)\n\t{\n\t\tif (a[i][j] == 1 && !blue.contains(j))\n\t\t{\n\t\t\tblue.add(j);\n\t\t\tcount += numOfWays(a, n, i + 1, blue);\n\t\t\tblue.remove(j);\n\t\t}\n\t}\n\treturn count;\n}", "5970": "static void minCost(int arr[], int n)\n\t{\n\t\tif (n < 3) {\n\t\t\tSystem.out.println(arr[0]);\n\t\t\treturn;\n\t\t}\n\t\tint dp[] = new int[n];\n\t\tdp[0] = arr[0];\n\t\tdp[1] = dp[0] + arr[1] + arr[2];\n\t\tfor (int i = 2; i < n - 1; i++)\n\t\t\tdp[i] = Math.min(dp[i - 2] + arr[i], dp[i - 1] + arr[i] + arr[i + 1]);\n\t\tdp[n - 1] = Math.min(dp[n - 2], dp[n - 3] + arr[n - 1]);\n\t\tSystem.out.println(dp[n - 1]);\n\t}", "5995": "static int power(int X, int Y)\n {\n\tint res = 1;\n\tX = X % M;\n\tif (X == 0)\n\treturn 0;\n\twhile (Y > 0)\n\t{\n\tif ((Y & 1) != 0)\n\t{\n\t\tres = (res * X) % M;\n\t}\n\tY = Y >> 1;\n\tX = (X * X) % M;\n\t}\n\treturn res;\n }\nstatic int findValue(int n)\n {\n\tint X = 0;\n\tint pow_10 = 1;\n\twhile (n != 0)\n\t{\n\tif ((n & 1) != 0)\n\t{\n\t\tX += pow_10;\n\t}\n\tpow_10 *= 10;\n\tn /= 2;\n\t}\n\tX = (X * 2) % M;\n\tint res = power(2, X);\n\treturn res;\n }", "5996": "static long power(long X, long Y)\n {\n\tlong res = 1;\n\tX = X % M;\n\tif (X == 0)\n\treturn 0;\n\twhile (Y > 0)\n\t{\n\tif (Y % 2 == 1)\n\t{\n\t\tres = (res * X) % M;\n\t}\n\tY = Y >> 1;\n\tX = (X * X) % M;\n\t}\n\treturn res;\n }\nstatic long findValue(int N)\n {\n\tlong []dp = new long[N + 1];\n\tdp[1] = 2;\n\tdp[2] = 1024;\n\tfor (int i = 3; i <= N; i++)\n\t{\n\tint y = (i & (-i));\n\tint x = i - y;\n\tif (x == 0)\n\t{\n\t\tdp[i]\n\t\t= power(dp[i / 2], 10);\n\t}\n\telse\n\t{\n\t\tdp[i]\n\t\t= (dp[x] * dp[y]) % M;\n\t}\n\t}\n\treturn (dp[N] * dp[N]) % M;\n }", "6000": "static int countTriplets(int []A)\n{\n\tint cnt = 0;\n\tHashMap<Integer,Integer> tuples = new HashMap<Integer,Integer>();\n\tfor (int a : A)\n\t\tfor (int b : A)\n\t\t{\n\t\t\tif(tuples.containsKey(a & b))\n\t\t\t\ttuples.put(a & b, tuples.get(a & b) + 1);\n\t\t\telse\n\t\t\t\ttuples.put(a & b, 1);\n\t\t}\n\tfor (int a : A)\n\t\tfor (Map.Entry<Integer, Integer> t : tuples.entrySet())\n\t\t\tif ((t.getKey() & a) == 0)\n\t\t\t\tcnt += t.getValue();\n\treturn cnt;\n}", "6021": "public static int findMinimum(int[] arr, int N, int pos, int turn)\n{\n\tR x = new R(pos, turn);\n\tif (m.containsKey(x))\n\t{\n\t\treturn m.get(x);\n\t}\n\tif (pos >= N - 1)\n\t{\n\t\treturn 0;\n\t}\n\tif (turn == 0)\n\t{\n\t\tint ans = Math.min(\n\t\t\tfindMinimum(arr, N, pos + 1, 1) + arr[pos],\n\t\t\tfindMinimum(arr, N, pos + 2, 1) + arr[pos] + arr[pos + 1]);\n\t\tR v = new R(pos, turn);\n\t\tm.put(v, ans);\n\t\treturn ans;\n\t}\n\tif (turn != 0)\n\t{\n\t\tint ans = Math.min(\n\t\t\tfindMinimum(arr, N, pos + 1, 0),\n\t\t\tfindMinimum(arr, N, pos + 2, 0));\n\t\tR v = new R(pos, turn);\n\t\tm.put(v, ans);\n\t\treturn ans;\n\t}\n\treturn 0;\n}\npublic static int countPenality(int[] arr, int N)\n{\n\tint pos = 0;\n\tint turn = 0;\n\treturn findMinimum(arr, N, pos, turn) + 1;\n}\npublic static void printAnswer(int[] arr, int N)\n{\n\tint a = countPenality(arr, N);\n\tint sum = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tsum += arr[i];\n\t}\n\tSystem.out.println(a);\n}", "6028": "static void maxSum(int[][] arr, int n, int m)\n{\n\tint[][] dp = new int[n][m + 1];\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tfor(int j = 0; j <= m; j++)\n\t\t{\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tdp[0][m - 1] = arr[0][m - 1];\n\tdp[1][m - 1] = arr[1][m - 1];\n\tfor(int j = m - 2; j >= 0; j--)\n\t{\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (i == 1)\n\t\t\t{\n\t\t\t\tdp[i][j] = Math.max( arr[i][j] + dp[0][j + 1], arr[i][j] + dp[0][j + 2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = Math.max( arr[i][j] + dp[1][j + 1], arr[i][j] + dp[1][j + 2]);\n\t\t\t}\n\t\t}\n\t}\n\tSystem.out.println(Math.max(dp[0][0], dp[1][0]));\n}", "6029": "static void maxSum(int[][] arr, int n)\n{\n\tint r1 = 0, r2 = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint temp = r1;\n\t\tr1 = Math.max(r1, r2 + arr[0][i]);\n\t\tr2 = Math.max(r2, temp + arr[1][i]);\n\t}\n\tSystem.out.println(Math.max(r1, r2));\n}", "6065": "public static int Max_Sum(int[] arr, int K, int N)\n{\n\tint[] dp = new int[N + 1];\n\tArrays.fill(dp, 0);\n\tint[] prefix = new int[N + 1];\n\tprefix[0] = 0;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tprefix[i] = prefix[i - 1] + arr[i-1];\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1; i <= K - 1; i++)\n\t{\n\t\tdp[i] = prefix[i];\n\t}\n\tfor(int i = K ; i <= N; ++i)\n\t{\n\t\tfor(int j = i; j >= (i - K + 1); j--)\n\t\t{\n\t\t\tdp[i] = Math.max(dp[i], dp[j - 1] + prefix[i] - prefix[j]);\n\t\t}\n\t}\n\treturn dp[N];\n}", "6068": "static void Calculate_factorial()\n\t{\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= mx; i++) {\n\t\t\tfact[i] = i * fact[i - 1];\n\t\t\tfact[i] %= mod;\n\t\t}\n\t}\nstatic int UniModal_per(int a, int b)\n\t{\n\t\tint res = 1;\n\t\twhile (b > 0) {\n\t\t\tif (b % 2 != 0)\n\t\t\t\tres = res * a;\n\t\t\tres %= mod;\n\t\t\ta = a * a;\n\t\t\ta %= mod;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn res;\n\t}\nstatic void countPermutations(int n)\n\t{\n\t\tCalculate_factorial();\n\t\tint uni_modal = UniModal_per(2, n - 1);\n\t\tint nonuni_modal = fact[n] - uni_modal;\n\t\tSystem.out.print(uni_modal + \" \" + nonuni_modal);\n\t\treturn;\n\t}", "6071": "static int findWays(int N)\n{\n\tif (N == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint cnt = 0;\n\tfor(int i = 1; i <= 6; i++)\n\t{\n\t\tif (N - i >= 0)\n\t\t{\n\t\t\tcnt = cnt +\n\t\t\t\tfindWays(N - i);\n\t\t}\n\t}\n\treturn cnt;\n}", "6072": "static int findWays(int N, int dp[])\n{\n\tif (N == 0)\n\t{\n\t\treturn 1;\n\t}\n\tif (dp[N] != -1)\n\t{\n\t\treturn dp[N];\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= 6; i++)\n\t{\n\t\tif (N - i >= 0)\n\t\t{\n\t\t\tcnt = cnt +\n\t\t\t\tfindWays(N - i, dp);\n\t\t}\n\t}\n\treturn dp[N] = cnt;\n}", "6073": "static void findWays(int N)\n{\n\tint []dp = new int[N + 1];\n\tdp[0] = 1;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tdp[i] = 0;\n\t\tfor(int j = 1; j <= 6; j++)\n\t\t{\n\t\t\tif (i - j >= 0)\n\t\t\t{\n\t\t\t\tdp[i] = dp[i] + dp[i - j];\n\t\t\t}\n\t\t}\n\t}\n\tSystem.out.print(dp[N]);\n}", "6082": "static int checkEqualSumUtil(int arr[], int N, int sm1, int sm2, int sm3, int j)\n{\n if (j == N)\n {\n\tif (sm1 == sm2 && sm2 == sm3)\n\treturn 1;\n\telse\n\treturn 0;\n }\n else\n {\n\tint l = checkEqualSumUtil(arr, N, sm1 + arr[j], sm2, sm3, j + 1);\n\tint m = checkEqualSumUtil(arr, N, sm1, sm2 + arr[j], sm3, j + 1);\n\tint r = checkEqualSumUtil(arr, N, sm1, sm2, sm3 + arr[j], j + 1);\n\treturn Math.max(Math.max(l, m), r);\n }\n}\nstatic void checkEqualSum(int arr[], int N)\n{\n int sum1, sum2, sum3;\n sum1 = sum2 = sum3 = 0;\n if (checkEqualSumUtil(arr, N, sum1, sum2, sum3, 0) == 1)\n {\n\tSystem.out.print(\"Yes\");\n }\n else\n {\n\tSystem.out.print(\"No\");\n }\n}", "6083": "static int checkEqualSumUtil(int arr[], int N, int sm1, int sm2, int sm3, int j)\n{\n String s = String.valueOf(sm1) + \"_\" +\n String.valueOf(sm2) + String.valueOf(j);\n if (j == N)\n {\n\tif (sm1 == sm2 && sm2 == sm3)\n\treturn 1;\n\telse\n\treturn 0;\n }\n if (dp.containsKey(s))\n\treturn dp.get(s);\n else\n {\n\tint l = checkEqualSumUtil(arr, N, sm1 + arr[j], sm2, sm3, j + 1);\n\tint m = checkEqualSumUtil(arr, N, sm1, sm2 + arr[j], sm3, j + 1);\n\tint r = checkEqualSumUtil(arr, N, sm1, sm2, sm3 + arr[j], j + 1);\n\tdp.put(s, Math.max(Math.max(l, m), r));\n\treturn dp.get(s);\n }\n}\nstatic void checkEqualSum(int arr[], int N)\n{\n int sum1, sum2, sum3;\n sum1 = sum2 = sum3 = 0;\n if (checkEqualSumUtil(arr, N, sum1, sum2, sum3, 0) == 1)\n {\n\tSystem.out.print(\"Yes\");\n }\n else\n {\n\tSystem.out.print(\"No\");\n }\n}", "6113": "static void SieveOfEratosthenes()\n {\n\tArrays.fill(prime, 1);\n\tfor (int p = 2; p * p <= MAX; p++)\n\t{\n\tif (prime[p] == 1)\n\t{\n\t\tfor (int i = p * p; i <= MAX - 1; i += p)\n\t\tprime[i] = 0;\n\t}\n\t}\n }\nstatic int getMid(int s, int e)\n {\n\treturn s + (e - s) / 2;\n }\nstatic int getSumUtil(int[] st, int ss, int se, int qs, int qe, int si)\n {\n\tif (qs <= ss && qe >= se)\n\treturn st[si];\n\tif (se < qs ss > qe)\n\treturn 0;\n\tint mid = getMid(ss, se);\n\treturn getSumUtil(st, ss, mid, qs, qe, 2 * si + 1)\n\t+ getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2);\n }\nstatic void updateValueUtil(int[] st, int ss, int se, int i, int diff, int si)\n {\n\tif (i < ss i > se)\n\treturn;\n\tst[si] = st[si] + diff;\n\tif (se != ss)\n\t{\n\tint mid = getMid(ss, se);\n\tupdateValueUtil(st, ss, mid, i, diff, 2 * si + 1);\n\tupdateValueUtil(st, mid + 1, se, i, diff, 2 * si + 2);\n\t}\n }\nstatic void updateValue(int arr[], int[] st, int n, int i, int new_val)\n {\n\tif (i < 0 i > n - 1)\n\t{\n\tSystem.out.print(\"-1\");\n\treturn;\n\t}\n\tint diff = new_val - arr[i];\n\tint prev_val = arr[i];\n\tarr[i] = new_val;\n\tif ((prime[new_val] prime[prev_val]) != 0)\n\t{\n\tif (prime[prev_val] == 0)\n\t\tupdateValueUtil(st, 0, n - 1, i, new_val, 0);\n\telse if (prime[new_val] == 0)\n\t\tupdateValueUtil(st, 0, n - 1, i, -prev_val, 0);\n\telse\n\t\tupdateValueUtil(st, 0, n - 1, i, diff, 0);\n\t}\n }\nstatic int getSum(int[] st, int n, int qs, int qe)\n {\n\tif (qs < 0 qe > n - 1 qs > qe)\n\t{\n\tSystem.out.println( \"-1\");\n\treturn -1;\n\t}\n\treturn getSumUtil(st, 0, n - 1, qs, qe, 0);\n }\nstatic int constructSTUtil(int arr[], int ss, int se, int[] st, int si)\n {\n\tif (ss == se) {\n\tif (prime[arr[ss]] != 0)\n\t\tst[si] = arr[ss];\n\telse\n\t\tst[si] = 0;\n\treturn st[si];\n\t}\n\tint mid = getMid(ss, se);\n\tst[si] = constructSTUtil(arr, ss, mid, st, si * 2 + 1)\n\t+ constructSTUtil(arr, mid + 1, se, st, si * 2 + 2);\n\treturn st[si];\n }\nstatic int[] constructST(int arr[], int n)\n {\n\tint x = (int)(Math.ceil(Math.log(n)/Math.log(2)));\n\tint max_size = 2 * (int)Math.pow(2, x) - 1;\n\tint[] st = new int[max_size];\n\tconstructSTUtil(arr, 0, n - 1, st, 0);\n\treturn st;\n }", "6138": "static void precompute(int nextpos[], int arr[], int N)\n{\n\tnextpos[N - 1] = N;\n\tfor(int i = N - 2; i >= 0; i--)\n\t{\n\tif (arr[i] == arr[i + 1])\n\t\tnextpos[i] = nextpos[i + 1];\n\telse\n\t\tnextpos[i] = i + 1;\n\t}\n}\nstatic void findIndex(int query[][], int arr[], int N, int Q)\n{\n\tint []nextpos = new int[N];\n\tprecompute(nextpos, arr, N);\n\tfor(int i = 0; i < Q; i++)\n\t{\n\tint l, r, x;\n\tl = query[i][0];\n\tr = query[i][1];\n\tx = query[i][2];\n\tint ans = -1;\n\tif (arr[l] != x)\n\t\tans = l;\n\telse\n\t{\n\t\tint d = nextpos[l];\n\t\tif (d <= r)\n\t\t\tans = d;\n\t}\n\tSystem.out.print(ans + \"\\n\");\n\t}\n}", "6151": "static long countWays(String s, String t, int k)\n{\n\tint n = s.length();\n\tint a = 0, b = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tString p = s.substring(i, n - i) +\n\t\t\t\ts.substring(0, i);\n\tif (p == t)\n\t\ta++;\n\telse\n\t\tb++;\n\t}\n\tlong dp1[] = new long[k + 1];\n\tlong dp2[] = new long[k + 1];\n\tif (s == t)\n\t{\n\t\tdp1[0] = 1;\n\t\tdp2[0] = 0;\n\t}\n\telse\n\t{\n\t\tdp1[0] = 0;\n\t\tdp2[0] = 1;\n\t}\n\tfor(int i = 1; i <= k; i++)\n\t{\n\tdp1[i] = ((dp1[i - 1] * (a - 1)) % mod +\n\t\t\t\t(dp2[i - 1] * a) % mod) % mod;\n\tdp2[i] = ((dp1[i - 1] * (b)) % mod +\n\t\t\t\t(dp2[i - 1] * (b - 1)) % mod) % mod;\n\t}\n\treturn dp1[k];\n}", "6169": "static void insert(int idx, String s, TrieNode root)\n{\n\tTrieNode temp = root;\n\tfor(int i = idx; i < s.length(); i++)\n\t{\n\t\tif (temp.child[s.charAt(i) - 'a'] == null)\n\t\t\ttemp.child[s.charAt(i) - 'a'] = new TrieNode();\n\t\ttemp = temp.child[s.charAt(i) - 'a'];\n\t}\n}\nstatic int minCuts(String S1, String S2)\n{\n\tint n1 = S1.length();\n\tint n2 = S2.length();\n\tTrieNode root = new TrieNode();\n\tfor(int i = 0; i < n2; i++)\n\t{\n\t\tinsert(i, S2, root);\n\t}\n\tint []dp = new int[n1 + 1];\n\tArrays.fill(dp, INF);\n\tdp[0] = 0;\n\tfor(int i = 0; i < n1; i++)\n\t{\n\t\tTrieNode temp = root;\n\t\tfor(int j = i + 1; j <= n1; j++)\n\t\t{\n\t\t\tif (temp.child[S1.charAt(j - 1) - 'a'] == null)\n\t\t\t\tbreak;\n\t\t\tdp[j] = Math.min(dp[j], dp[i] + 1);\n\t\t\ttemp = temp.child[S1.charAt(j - 1) - 'a'];\n\t\t}\n\t}\n\tif (dp[n1] >= INF)\n\t\treturn -1;\n\telse\n\t\treturn dp[n1];\n}", "6174": "static int minOperation(int k)\n{\n\tint dp[] = new int[k + 1];\n\tfor(int i = 1; i <= k; i++)\n\t{\n\tdp[i] = dp[i - 1] + 1;\n\tif (i % 2 == 0)\n\t{\n\t\tdp[i] = Math.min(dp[i], dp[i / 2] + 1);\n\t}\n\t}\n\treturn dp[k];\n}", "6181": "static void longestSubseq(String s, int length)\n{\n\tint[] ones = new int[length + 1];\n\tint[] zeroes = new int[length + 1];\n\tfor(int i = 0; i < length; i++)\n\t{\n\t\tif (s.charAt(i) == '1')\n\t\t{\n\t\t\tones[i + 1] = ones[i] + 1;\n\t\t\tzeroes[i + 1] = zeroes[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzeroes[i + 1] = zeroes[i] + 1;\n\t\t\tones[i + 1] = ones[i];\n\t\t}\n\t}\n\tint answer = Integer.MIN_VALUE;\n\tint x = 0;\n\tfor(int i = 0; i <= length; i++)\n\t{\n\t\tfor(int j = i; j <= length; j++)\n\t\t{\n\t\t\tx += ones[i];\n\t\t\tx += (zeroes[j] - zeroes[i]);\n\t\t\tx += (ones[length] - ones[j]);\n\t\t\tanswer = Math.max(answer, x);\n\t\t\tx = 0;\n\t\t}\n\t}\n\tSystem.out.println(answer);\n}", "6209": "static void largestSquare(int matrix[][], int R, int C, int q_i[], int q_j[], int K, int Q)\n{\n\tfor(int q = 0; q < Q; q++) \n\t{\n\tint i = q_i[q];\n\tint j = q_j[q];\n\tint min_dist = Math.min(Math.min(i, j),\n\t\t\t\t\tMath.min(R - i - 1, C - j - 1));\n\tint ans = -1;\n\tfor(int k = 0; k <= min_dist; k++)\n\t{\n\t\tint count = 0;\n\t\tfor(int row = i - k; row <= i + k; row++)\n\t\t\tfor(int col = j - k; col <= j + k; col++)\n\t\t\t\tcount += matrix[row][col];\n\t\t\tif (count > K)\n\t\t\t\tbreak;\n\t\t\tans = 2 * k + 1;\n\t\t}\n\t\tSystem.out.print(ans + \"\\n\");\n\t}\n}", "6210": "static void largestSquare(int matrix[][], int R, int C, int q_i[], int q_j[], int K, int Q)\n{\n\tint [][]countDP = new int[R][C];\n\tcountDP[0][0] = matrix[0][0];\n\tfor(int i = 1; i < R; i++)\n\t\tcountDP[i][0] = countDP[i - 1][0] + \n\t\t\t\t\t\t\tmatrix[i][0];\n\tfor(int j = 1; j < C; j++)\n\t\tcountDP[0][j] = countDP[0][j - 1] +\n\t\t\t\t\t\tmatrix[0][j];\n\tfor(int i = 1; i < R; i++)\n\t\tfor(int j = 1; j < C; j++)\n\t\t\tcountDP[i][j] = matrix[i][j] +\n\t\t\t\t\t\tcountDP[i - 1][j] +\n\t\t\t\t\t\tcountDP[i][j - 1] -\n\t\t\t\t\t\tcountDP[i - 1][j - 1];\n\tfor(int q = 0; q < Q; q++)\n\t{\n\t\tint i = q_i[q];\n\t\tint j = q_j[q];\n\t\tint min_dist = Math.min(Math.min(i, j), \n\t\t\t\t\tMath.min(R - i - 1, C - j - 1));\n\t\tint ans = -1;\n\t\tfor(int k = 0; k <= min_dist; k++)\n\t\t{\n\t\t\tint x1 = i - k, x2 = i + k;\n\t\t\tint y1 = j - k, y2 = j + k;\n\t\t\tint count = countDP[x2][y2];\n\t\t\tif (x1 > 0)\n\t\t\t\tcount -= countDP[x1 - 1][y2];\n\t\t\tif (y1 > 0)\n\t\t\t\tcount -= countDP[x2][y1 - 1];\n\t\t\tif (x1 > 0 && y1 > 0)\n\t\t\t\tcount += countDP[x1 - 1][y1 - 1];\n\t\t\tif (count > K)\n\t\t\t\tbreak;\n\t\t\tans = 2 * k + 1;\n\t\t}\n\t\tSystem.out.print(ans + \"\\n\");\n\t}\n}", "6211": "static void largestSquare(int matrix[][], int R, int C, int q_i[], int q_j[], int K, int Q)\n{ \n\tint countDP[][] = new int[R][C]; \n\tfor(int i = 0; i < R; i++)\n\t\tfor(int j = 0; j < C; j++)\n\t\t\tcountDP[i][j] = 0; \n\tcountDP[0][0] = matrix[0][0]; \n\tfor(int i = 1; i < R; i++) \n\t\tcountDP[i][0] = countDP[i - 1][0] + \n\t\t\t\t\t\t\tmatrix[i][0]; \n\tfor(int j = 1; j < C; j++) \n\t\tcountDP[0][j] = countDP[0][j - 1] + \n\t\t\t\t\t\tmatrix[0][j]; \n\tfor(int i = 1; i < R; i++) \n\t\tfor(int j = 1; j < C; j++) \n\t\t\tcountDP[i][j] = matrix[i][j] + \n\t\t\t\t\t\tcountDP[i - 1][j] + \n\t\t\t\t\t\tcountDP[i][j - 1] - \n\t\t\t\t\t\tcountDP[i - 1][j - 1]; \n\tfor(int q = 0; q < Q; q++)\n\t{ \n\t\tint i = q_i[q]; \n\t\tint j = q_j[q]; \n\t\tint min_dist = Math.min(Math.min(i, j), \n\t\t\t\t\t\t\t\tMath.min(R - i - 1, C - j - 1)); \n\t\tint ans = -1, l = 0, u = min_dist; \n\t\twhile (l <= u)\n\t\t{ \n\t\t\tint mid = (l + u) / 2; \n\t\t\tint x1 = i - mid, x2 = i + mid; \n\t\t\tint y1 = j - mid, y2 = j + mid; \n\t\t\tint count = countDP[x2][y2]; \n\t\t\tif (x1 > 0) \n\t\t\t\tcount -= countDP[x1 - 1][y2]; \n\t\t\tif (y1 > 0) \n\t\t\t\tcount -= countDP[x2][y1 - 1]; \n\t\t\tif (x1 > 0 && y1 > 0) \n\t\t\t\tcount += countDP[x1 - 1][y1 - 1]; \n\t\t\tif (count <= K) \n\t\t\t{ \n\t\t\t\tans = 2 * mid + 1; \n\t\t\t\tl = mid + 1; \n\t\t\t} \n\t\t\telse\n\t\t\t\tu = mid - 1; \n\t\t} \n\t\tSystem.out.println(ans); \n\t} \n}", "6241": "static int count_special(int n)\n{\n\tint []fib = new int[n + 1];\n\tfib[0] = 1;\n\tfib[1] = 2;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\tfib[i] = (fib[i - 1] % mod + fib[i - 2] % mod) % mod;\n\t}\n\treturn fib[n];\n}", "6273": "static int maxSum(int p0, int p1, int a[], int pos, int n)\n\t{\n\t\tif (pos == n) {\n\t\t\tif (p0 == p1)\n\t\t\t\treturn p0;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tint ans = maxSum(p0, p1, a, pos + 1, n);\n\t\tans = Math.max(ans, maxSum(p0 + a[pos], p1, a, pos + 1, n));\n\t\tans = Math.max(ans, maxSum(p0, p1 + a[pos], a, pos + 1, n));\n\t\treturn ans;\n\t}", "6274": "static int maxSum(int a[], int n)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += a[i];\n\t\tint limit = 2 * sum + 1;\n\t\tint dp[][] = new int[n + 1][limit];\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\tfor (int j = 0; j < limit; j++)\n\t\t\t\tdp[i][j] = INT_MIN;\n\t\t}\n\t\tdp[0][sum] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j < limit; j++) {\n\t\t\t\tif ((j - a[i - 1]) >= 0 && dp[i - 1][j - a[i - 1]] != INT_MIN)\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][j - a[i - 1]] + a[i - 1]);\n\t\t\t\tif ((j + a[i - 1]) < limit && dp[i - 1][j + a[i - 1]] != INT_MIN)\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][j + a[i - 1]]);\n\t\t\t\tif (dp[i - 1][j] != INT_MIN)\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n\t\t\t}\n\t\t}\n\t\treturn dp[n][sum];\n\t}", "6281": "static int calculate(int pos, int prev, String s, Vector<Integer> index)\n{\n\tif (pos == s.length())\n\t\treturn 1;\n\tif (dp[pos][prev] != -1)\n\t\treturn dp[pos][prev];\n\tint answer = 0;\n\tfor (int i = 0; i < index.size(); i++) {\n\t\tif (index.get(i).compareTo(prev) >= 0) {\n\t\t\tanswer = (answer % mod + calculate(pos + 1,\n\t\t\t\t\t\tindex.get(i), s, index) % mod) % mod;\n\t\t}\n\t}\n\treturn dp[pos][prev] = answer;\n}\nstatic int countWays(Vector<String> a, String s)\n{\n\tint n = a.size();\n\tVector<Integer> []index = new Vector[26];\n\tfor (int i = 0; i < 26; i++)\n\t\tindex[i] = new Vector<Integer>();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < a.get(i).length(); j++) {\n\t\t\tindex[a.get(i).charAt(j) - 'a'].add(j + 1);\n\t\t}\n\t}\n\tfor(int i = 0;i< 1000;i++)\n\t{\n\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\treturn calculate(0, 0, s, index[0]);\n}", "6289": "static void computeFibonacci()\n\t{\n\t\tfib[0] = 1;\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i < 100005; i++) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t}\nstatic int countString(String str)\n\t{\n\t\tint ans = 1;\n\t\tint cnt = 1;\n\t\tfor (int i = 1; i<str.length(); i++) {\n\t\t\tif (str.charAt(i) == str.charAt(i - 1)) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = ans * fib[cnt];\n\t\t\t\tcnt = 1;\n\t\t\t}\n\t\t}\n\t\tans = ans * fib[cnt];\n\t\treturn ans;\n\t}", "6298": "static void printGolombSequence(int N)\n{\n\tint []arr = new int[MAX];\n\tfor(int i = 0; i < MAX; i++)\n\tarr[i] = 0;\n\tint cnt = 0;\n\tarr[0] = 0;\n\tarr[1] = 1;\n\tMap<Integer,Integer> M=new HashMap<Integer,Integer>();\n\tM.put(2,2);\n\tfor (int i = 2; i <= N; i++) {\n\t\tif (cnt == 0) {\n\t\t\tarr[i] = 1 + arr[i - 1];\n\t\t\tcnt = M.get(arr[i]);\n\t\t\tcnt--;\n\t\t}\n\t\telse {\n\t\t\tarr[i] = arr[i - 1];\n\t\t\tcnt--;\n\t\t}\n\t\t\tM.put(i, arr[i]);\n\t}\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tSystem.out.print(arr[i]+\" \");\n\t}\n}", "6299": "static int number_of_ways(int n)\n{\n\tint []includes_3 = new int[n + 1];\n\tint []not_includes_3 = new int[n + 1];\n\tincludes_3[3] = 1;\n\tnot_includes_3[1] = 1;\n\tnot_includes_3[2] = 2;\n\tnot_includes_3[3] = 3;\n\tfor (int i = 4; i <= n; i++)\n\t{\n\t\tincludes_3[i]\n\t\t\t= includes_3[i - 1] + includes_3[i - 2] +\n\t\t\tnot_includes_3[i - 3];\n\t\tnot_includes_3[i]\n\t\t\t= not_includes_3[i - 1] + not_includes_3[i - 2];\n\t}\n\treturn includes_3[n];\n}", "6301": "static void generateDivisors(int n)\n{\n\tfor (int i = 1; i <= Math.sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (n / i == i)\n\t\t\t{\n\t\t\t\tdivisors[i]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdivisors[i]++;\n\t\t\t\tdivisors[n / i]++;\n\t\t\t}\n\t\t}\n\t}\n}\nstatic int findMaxMultiples(int []arr, int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tans = Math.max(divisors[arr[i]], ans);\n\t\tgenerateDivisors(arr[i]);\n\t}\n\treturn ans;\n}", "6335": "static int countNum(int idx, int sum, int tight, Vector<Integer> num, int len, int k)\n{\n\tif (len == idx)\n\t{\n\t\tif (sum == 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tif (dp[idx][sum][tight] != -1)\n\t\treturn dp[idx][sum][tight];\n\tint res = 0, limit;\n\tif (tight == 0)\n\t{\n\t\tlimit = num.get(idx);\n\t}\n\telse\n\t{\n\t\tlimit = 9;\n\t}\n\tfor (int i = 0; i <= limit; i++)\n\t{\n\t\tint new_tight = tight;\n\t\tif (tight == 0 && i < limit)\n\t\t\tnew_tight = 1;\n\t\tres += countNum(idx + 1,\n\t\t\t\t\t\t(sum + i) % k, new_tight, num, len, k);\n\t\tres %= MOD;\n\t}\n\tif (res < 0)\n\t\tres += MOD;\n\treturn dp[idx][sum][tight] = res;\n}\nstatic Vector<Integer> process(String s)\n{\n\tVector<Integer> num = new Vector<Integer>();\n\tfor (int i = 0; i < s.length(); i++)\n\t{\n\t\tnum.add(s.charAt(i) - '0');\n\t}\n\treturn num;\n}", "6346": "static int MinCost(int arr[], int n)\n{\n\tint [][]dp = new int[n + 5][n + 5];\n\tint [][]sum = new int[n + 5][n + 5];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k = arr[i];\n\t\tfor (int j = i; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tsum[i][j] = k;\n\t\t\telse\n\t\t\t{\n\t\t\t\tk += arr[j];\n\t\t\t\tsum[i][j] = k;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = i; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\tif (i == j)\n\t\t\t\tdp[i][j] = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int k = i; k < j; k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}", "6364": "static int f(int i, int state, int A[], int dp[][], int N)\n\t{\n\t\tif (i >= N)\n\t\t\treturn 0;\n\t\telse if (dp[i][state] != -1)\n\t\t{\n\t\t\treturn dp[i][state];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (i == N - 1)\n\t\t\t\tdp[i][state] = 1;\n\t\t\telse if (state == 1 && A[i] > A[i + 1])\n\t\t\t\tdp[i][state] = 1;\n\t\t\telse if (state == 2 && A[i] < A[i + 1])\n\t\t\t\tdp[i][state] = 1;\n\t\t\telse if (state == 1 && A[i] <= A[i + 1])\n\t\t\t\tdp[i][state] = 1 + f(i + 1, 2, A, dp, N);\n\t\t\telse if (state == 2 && A[i] >= A[i + 1])\n\t\t\t\tdp[i][state] = 1 + f(i + 1, 1, A, dp, N);\n\t\t\treturn dp[i][state];\n\t\t}\n\t}\nstatic int maxLenSeq(int A[], int N)\n\t{\n\t\tint i,j, tmp, y, ans;\n\t\tint dp[][] = new int[1000][3];\n\t\tfor(i= 0; i < 1000; i++)\n\t\t\tfor(j = 0; j < 3; j++)\n\t\t\t\tdp[i][j] = -1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\ttmp = f(i, 1, A, dp, N);\n\t\t\ttmp = f(i, 2, A, dp, N);\n\t\t}\n\t\tans = -1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\ty = dp[i][1];\n\t\t\tif (i + y >= N)\n\t\t\t\tans = Math.max(ans, dp[i][1] + 1);\n\t\t\telse if (y % 2 == 0)\n\t\t\t{\n\t\t\t\tans = Math.max(ans, dp[i][1] + 1 + dp[i + y][2]);\n\t\t\t}\n\t\t\telse if (y % 2 == 1)\n\t\t\t{\n\t\t\t\tans = Math.max(ans, dp[i][1] + 1 + dp[i + y][1]);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}", "6380": "static int ways(int i, int arr[], int n)\n{\n\tif (i == n - 1)\n\t\treturn 1;\n\tint sum = 0;\n\tfor (int j = 1; j + i < n && j <= arr[i]; j++)\n\t{\n\t\tsum += (ways(i + j, arr, n)) % mod;\n\t\tsum %= mod;\n\t}\n\treturn sum % mod;\n}", "6381": "static int ways(int arr[], int n)\n\t{\n\t\tint dp[] = new int[n + 1];\n\t\tdp[n - 1] = 1;\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t{\n\t\t\tdp[i] = 0;\n\t\t\tfor (int j = 1; ((j + i) < n && j <= arr[i]); j++)\n\t\t\t{\n\t\t\t\tdp[i] += dp[i + j];\n\t\t\t\tdp[i] %= mod;\n\t\t\t}\n\t\t}\n\t\treturn dp[0] % mod;\n\t}", "6385": "public static int[] countSum(int arr[], int n)\n\t{\n\t\tint result = 0;\n\t\tint[] countODD = new int[n + 1];\n\t\tint[] countEVEN = new int[n + 1];\n\t\tcountODD[0] = 0;\n\t\tcountEVEN[0] = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (arr[i - 1] % 2 == 0)\n\t\t\t{\n\t\t\t\tcountEVEN[i] = countEVEN[i - 1] +\n\t\t\t\t\t\t\tcountEVEN[i - 1] + 1;\n\t\t\t\tcountODD[i] = countODD[i - 1] +\n\t\t\t\t\t\t\tcountODD[i - 1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcountEVEN[i] = countEVEN[i - 1] +\n\t\t\t\t\t\t\tcountODD[i - 1];\n\t\t\t\tcountODD[i] = countODD[i - 1] +\n\t\t\t\t\t\t\tcountEVEN[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tint[] ans = new int[2];\n\t\tans[0] = countEVEN[n];\n\t\tans[1] = countODD[n];\n\t\treturn ans;\n\t}", "6386": "static pair countSum(int arr[], int n)\n{\n\tint result = 0;\n\tint count_odd, count_even;\n\tcount_odd = 0;\n\tcount_even = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (arr[i - 1] % 2 == 0)\n\t\t{\n\t\t\tcount_even = count_even + count_even + 1;\n\t\t\tcount_odd = count_odd + count_odd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint temp = count_even;\n\t\t\tcount_even = count_even + count_odd;\n\t\t\tcount_odd = count_odd + temp + 1;\n\t\t}\n\t}\n\treturn new pair(count_even, count_odd );\n}", "6395": "static int gcd(int a, int b)\n\t{\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\nstatic int MaxGCD(int a[], int n)\n\t{\n\t\tint Prefix[] = new int[n + 2];\n\t\tint Suffix[] = new int[n + 2] ;\n\t\tPrefix[1] = a[0];\n\t\tfor (int i = 2; i <= n; i += 1)\n\t\t{\n\t\t\tPrefix[i] = gcd(Prefix[i - 1], a[i - 1]);\n\t\t}\n\t\tSuffix[n] = a[n - 1];\n\t\tfor (int i = n - 1; i >= 1; i -= 1)\n\t\t{\n\t\t\tSuffix[i] = gcd(Suffix[i + 1], a[i - 1]);\n\t\t}\n\t\tint ans = Math.max(Suffix[2], Prefix[n - 1]);\n\t\tfor (int i = 2; i < n; i += 1)\n\t\t{\n\t\t\tans = Math.max(ans, gcd(Prefix[i - 1], Suffix[i + 1]));\n\t\t}\n\t\treturn ans;\n\t}", "6396": "static Vector<Integer> numToVec(int N)\n{\n\tVector<Integer> digit = new Vector<Integer>();\n\twhile (N != 0)\n\t{\n\t\tdigit.add(N % 10);\n\t\tN = N / 10;\n\t}\n\tif (digit.size() == 0)\n\t\tdigit.add(0);\n\tCollections.reverse(digit);\n\treturn digit;\n}\nstatic int solve(Vector<Integer> A, int B, int C)\n{\n\tVector<Integer> digit = new Vector<Integer>();\n\tint d, d2;\n\tdigit = numToVec(C);\n\td = A.size();\n\tif (B > digit.size() d == 0)\n\t\treturn 0;\n\telse if (B < digit.size())\n\t{\n\t\tif (A.get(0) == 0 && B != 1)\n\t\t\treturn (int) ((d - 1) * Math.pow(d, B - 1));\n\t\telse\n\t\t\treturn (int) Math.pow(d, B);\n\t}\n\telse\n\t{\n\t\tint []dp = new int[B + 1];\n\t\tint []lower = new int[MAX + 1];\n\t\tfor (int i = 0; i < d; i++)\n\t\t\tlower[A.get(i) + 1] = 1;\n\t\tfor (int i = 1; i <= MAX; i++)\n\t\t\tlower[i] = lower[i - 1] + lower[i];\n\t\tboolean flag = true;\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= B; i++)\n\t\t{\n\t\t\td2 = lower[digit.get(i - 1)];\n\t\t\tdp[i] = dp[i - 1] * d;\n\t\t\tif (i == 1 && A.get(0) == 0 && B != 1)\n\t\t\t\td2 = d2 - 1;\n\t\t\tif (flag)\n\t\t\t\tdp[i] += d2;\n\t\t\tflag = (flag & (lower[digit.get(i - 1) + 1] ==\n\t\t\t\t\t\t\tlower[digit.get(i - 1)] + 1));\n\t\t}\n\t\treturn dp[B];\n\t}\n}", "6442": "static int countWays(int i, int j, int x, int arr[][])\n\t{\n\t\tif (i == n j == n) {\n\t\t\treturn 0;\n\t\t}\n\t\tx = (x & arr[i][j]);\n\t\tif (x == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (i == n - 1 && j == n - 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (v[i][j][x] == 1) {\n\t\t\treturn dp[i][j][x];\n\t\t}\n\t\tv[i][j][x] = 1;\n\t\tdp[i][j][x] = countWays(i + 1, j, x, arr)\n\t\t\t\t\t+ countWays(i, j + 1, x, arr);\n\t\treturn dp[i][j][x];\n\t}", "6454": "static void pre_process(boolean dp[][], char[] s)\n\t{\n\t\tint n = s.length;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tfor (int i = 0; i <= n - j; i++)\n\t\t\t{\n\t\t\t\tif (j <= 2)\n\t\t\t\t{\n\t\t\t\t\tif (s[i] == s[i + j - 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][i + j - 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (s[i] == s[i + j - 1])\n\t\t\t\t{\n\t\t\t\t\tdp[i][i + j - 1] = dp[i + 1][i + j - 2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nstatic int countPairs(String s)\n\t{\n\t\tboolean dp[][] = new boolean[N][N];\n\t\tpre_process(dp, s.toCharArray());\n\t\tint n = s.length();\n\t\tint left[] = new int[n];\n\t\tint right[] = new int[n];\n\t\tleft[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j <= i; j++)\n\t\t\t{\n\t\t\t\tif (dp[j][i] == true)\n\t\t\t\t{\n\t\t\t\t\tleft[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tright[n - 1] = 1;\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t{\n\t\t\tright[i] = right[i + 1];\n\t\t\tfor (int j = n - 1; j >= i; j--)\n\t\t\t{\n\t\t\t\tif (dp[i][j] == true)\n\t\t\t\t{\n\t\t\t\t\tright[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tans += left[i] * right[i + 1];\n\t\t}\n\t\treturn ans;\n\t}", "6469": "static int FindMaximumSum(int ind, int kon, int a[], int b[], int c[], int n, int dp[][])\n{\n\tif (ind == n)\n\t\treturn 0;\n\tif (dp[ind][kon] != -1)\n\t\treturn dp[ind][kon];\n\tint ans = (int) (-1e9 + 5);\n\tif (kon == 0) {\n\t\tans = Math.max(ans, b[ind] +\n\t\t\tFindMaximumSum(ind + 1, 1, a, b,c, n, dp));\n\t\tans = Math.max(ans, c[ind] +\n\t\t\tFindMaximumSum(ind + 1, 2, a, b,c, n, dp));\n\t}\n\telse if (kon == 1) {\n\t\tans = Math.max(ans, a[ind] +\n\t\t\tFindMaximumSum(ind + 1, 0, a, b, c, n, dp));\n\t\tans = Math.max(ans, c[ind] +\n\t\t\tFindMaximumSum(ind + 1, 2, a, b, c, n, dp));\n\t}\n\telse if (kon == 2) {\n\t\tans = Math.max(ans, a[ind] +\n\t\t\tFindMaximumSum(ind + 1, 1, a, b, c, n, dp));\n\t\tans = Math.max(ans, b[ind] +\n\t\t\tFindMaximumSum(ind + 1, 0, a, b, c, n, dp));\n\t}\n\treturn dp[ind][kon] = ans;\n}", "6471": "static int noOfBinaryStrings(int N, int k)\n{\n\tint dp[] = new int[100002];\n\tfor (int i = 1; i <= k - 1; i++)\n\t{\n\t\tdp[i] = 1;\n\t}\n\tdp[k] = 2;\n\tfor (int i = k + 1; i <= N; i++)\n\t{\n\t\tdp[i] = (dp[i - 1] + dp[i - k]) % mod;\n\t}\n\treturn dp[N];\n}", "6478": "static int findWaysToPair(int p)\n{\n\tint dp[] = new int[p + 1];\n\tdp[1] = 1;\n\tdp[2] = 2;\n\tfor (int i = 3; i <= p; i++)\n\t{\n\t\tdp[i] = dp[i - 1] + (i - 1) * dp[i - 2];\n\t}\n\treturn dp[p];\n}", "6480": "static int findSubarraySum(int ind, int flips, int n, int[] a, int k)\n\t{\n\t\tif (flips > k)\n\t\t\treturn (int)(-1e9);\n\t\tif (ind == n)\n\t\t\treturn 0;\n\t\tif (dp[ind][flips] != -1)\n\t\t\treturn dp[ind][flips];\n\t\tint ans = 0;\n\t\tans = Math.max(0, a[ind]\n\t\t\t\t\t\t\t+ findSubarraySum( ind + 1, flips, n, a, k));\n\t\tans = Math.max(ans, -a[ind]\n\t\t\t\t\t\t\t\t+ findSubarraySum(ind + 1, flips + 1, n, a, k));\n\t\treturn dp[ind][flips] = ans;\n\t}\nstatic int findMaxSubarraySum(int[] a, int n, int k)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < k + 1; j++)\n\t\t\t\tdp[i][j] = -1;\n\t\tint ans = (int)(-1e9);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans = Math.max(ans,\n\t\t\t\t\t\tfindSubarraySum(i, 0, n, a, k));\n\t\tif (ans == 0 && k == 0)\n\t\t\treturn Arrays.stream(a).max().getAsInt();\n\t\treturn ans;\n\t}", "6486": "static int maxWeight(int arr [] , int n, int w1_r, int w2_r, int i)\n\t{\n\t\tif (i == n)\n\t\t\treturn 0;\n\t\tif (dp[i][w1_r][w2_r] != -1)\n\t\t\treturn dp[i][w1_r][w2_r];\n\t\tint fill_w1 = 0, fill_w2 = 0, fill_none = 0;\n\t\tif (w1_r >= arr[i])\n\t\t\tfill_w1 = arr[i] +\n\t\t\tmaxWeight(arr, n, w1_r - arr[i], w2_r, i + 1);\n\t\tif (w2_r >= arr[i])\n\t\t\tfill_w2 = arr[i] +\n\t\t\tmaxWeight(arr, n, w1_r, w2_r - arr[i], i + 1);\n\t\tfill_none = maxWeight(arr, n, w1_r, w2_r, i + 1);\n\t\tdp[i][w1_r][w2_r] = Math.max(fill_none, Math.max(fill_w1, fill_w2));\n\t\treturn dp[i][w1_r][w2_r];\n\t}", "6488": "static void findPrefixCount(int p_arr[][], boolean set_bit[][])\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (!set_bit[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (j != n - 1)\n\t\t\t\tp_arr[i][j] += p_arr[i][j + 1];\n\t\t\tp_arr[i][j] += (set_bit[i][j]) ? 1 : 0;\n\t\t}\n\t}\n}\nstatic int matrixAllOne(boolean set_bit[][])\n{\n\tint p_arr[][] = new int[n][n];\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n;j++)\n\t\t\tp_arr[i][j] = 0;\n\tfindPrefixCount(p_arr, set_bit);\n\tint ans = 0;\n\tfor (int j = 0; j < n; j++)\n\t{\n\t\tint i = n - 1;\n\t\tStack<pair > q = new Stack<pair >();\n\t\tint to_sum = 0;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tint c = 0;\n\t\t\twhile (q.size() != 0 &&\n\t\t\t\t\tq.peek().first > p_arr[i][j])\n\t\t\t{\n\t\t\t\tto_sum -= (q.peek().second + 1) *\n\t\t\t\t\t\t\t(q.peek().first - p_arr[i][j]);\n\t\t\t\tc += q.peek().second + 1;\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\tto_sum += p_arr[i][j];\n\t\t\tans += to_sum;\n\t\t\tq.push(new pair( p_arr[i][j], c ));\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ans;\n}\nstatic int sumAndMatrix(int arr[][])\n{\n\tint sum = 0;\n\tint mul = 1;\n\tfor (int i = 0; i < 30; i++)\n\t{\n\t\tboolean set_bit[][] = new boolean[n][n];\n\t\tfor (int R = 0; R < n; R++)\n\t\t\tfor (int C = 0; C < n; C++)\n\t\t\t\tset_bit[R][C] = ((arr[R][C] & (1 << i)) != 0);\n\t\tsum += (mul * matrixAllOne(set_bit));\n\t\tmul *= 2;\n\t}\n\treturn sum;\n}", "6525": "public static int solve(int[][] dp, int wt, int K, int M, int used)\n\t{\n\t\tif (wt < 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (wt == 0)\n\t\t{\n\t\t\tif (used == 1)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp[wt][used] != -1)\n\t\t{\n\t\t\treturn dp[wt][used];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= K; i++)\n\t\t{\n\t\t\tif (i >= M)\n\t\t\t{\n\t\t\t\tans += solve(dp, wt - i, K, M, used 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += solve(dp, wt - i, K, M, used);\n\t\t\t}\n\t\t}\n\t\treturn dp[wt][used] = ans;\n\t}", "6531": "static int sumOddFibonacci(int n)\n{\n\tint Sum[]=new int[n + 1];\n\tSum[0] = 0;\n\tSum[1] = 1;\n\tSum[2] = 2;\n\tSum[3] = 5;\n\tSum[4] = 10;\n\tSum[5] = 23;\n\tfor (int i = 6; i <= n; i++) {\n\t\tSum[i] = ((Sum[i - 1] + (4 * Sum[i - 2]) % mod -\n\t\t\t\t(4 * Sum[i - 3]) % mod + mod) % mod +\n\t\t\t\t(Sum[i - 4] - Sum[i - 5] + mod) % mod) % mod;\n\t}\n\treturn Sum[n];\n}", "6536": "static int CountWays(int n)\n\t{\n\t\tif (n == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (n == 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (n == 2) {\n\t\t\treturn 1 + 1;\n\t\t}\n\t\treturn CountWays(n - 1) + CountWays(n - 3);\n\t}", "6537": "static int CountWays(int n)\n\t{\n\t\tint noOfWays[] = new int[n + 3];\n\t\tnoOfWays[0] = 1;\n\t\tnoOfWays[1] = 1;\n\t\tnoOfWays[2] = 1 + 1;\n\t\tfor (int i = 3; i < n + 1; i++) {\n\t\t\t\tnoOfWays[i] = noOfWays[i - 1] + noOfWays[i - 3];\n\t\t}\n\t\treturn noOfWays[n];\n\t}", "6538": "static int CountWays(int n)\n{\n\tint noOfWays[] = new int[n + 3];\n\tnoOfWays[0] = 1;\n\tnoOfWays[1] = 1;\n\tnoOfWays[2] = 1 + 1;\n\tfor (int i=3; i<n+1; i++) {\n\tnoOfWays[i] =\n\t\tnoOfWays[3-1]\n\t\t+ noOfWays[3-3];\n\tnoOfWays[0] = noOfWays[1];\n\tnoOfWays[1] = noOfWays[2];\n\tnoOfWays[2] = noOfWays[i];\n\t}\n\treturn noOfWays[n];\n}", "6550": "static long fun(int marks[],int n)\n\t{\n\t\tlong dp[] = new long[n] ;\n\t\tint temp;\n\t\tfor (int i = 0;i < n;i ++)\n\t\t\tdp[i] = 1 ;\n\t\tfor(int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tif (marks[i] > marks[i + 1])\n\t\t\t{ \n\t\t\t\ttemp = i;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif ((marks[temp] > marks[temp + 1]) && temp >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[temp] > dp[temp + 1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttemp -= 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[temp] = dp[temp + 1] + 1;\n\t\t\t\t\t\t\ttemp -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak; \n\t\t\t\t} \n\t\t\t}\n\t\t\telse if( marks[i] < marks[i + 1])\n\t\t\t\tdp[i + 1] = dp[i] + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\tsum += dp[i];\n\t\treturn sum;\n\t}", "6553": "static void sieve()\n\t{\n\t\tfor(int i = 2; i * i < MAX; i++)\n\t\t{\n\t\t\tif (prime[i] == 0)\n\t\t\t{\n\t\t\t\tfor (int j = i * i; j < MAX; j += i)\n\t\t\t\t\tprime[j] = 1;\n\t\t\t}\n\t\t}\n\t}\nstatic void dfs(int i, int j, int k, int n, int m, int[][] mappedMatrix, int[][] mark, pair[] ans)\n\t{\n\t\tif ((mappedMatrix[i][j] == 0 ? true : false) ||\n\t\t\t\t\t\t\t(i > n ? true : false) ||\n\t\t\t\t\t\t\t(j > m ? true : false) ||\n\t\t\t\t\t(mark[i][j] != 0 ? true : false) ||\n\t\t\t\t\t\t\t(q != 0 ? true : false))\n\t\t\treturn;\n\t\tmark[i][j] = 1;\n\t\tans[k] = new pair(i, j);\n\t\tif (i == n && j == m)\n\t\t{\n\t\t\t(q) = k;\n\t\t\treturn;\n\t\t}\n\t\tdfs(i + 1, j + 1, k + 1, n, m, mappedMatrix, mark, ans);\n\t\tdfs(i + 1, j, k + 1, n, m, mappedMatrix, mark, ans);\n\t\tdfs(i, j + 1, k + 1, n, m, mappedMatrix, mark, ans);\n\t}\nstatic void lexicographicalPath(int n, int m, int [][]mappedMatrix)\n\t{\n\t\tint q = 0;\n\t\tpair[] ans = new pair[MAX];\n\t\tint[][] mark = new int[MAX][MAX];\n\t\tdfs(1, 1, 1, n, m, mappedMatrix, mark, ans);\n\t\tint[][] anss = {{1, 1},{2, 1},{3, 2},{3, 3}};\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tSystem.out.println(anss[i][0] + \" \" + anss[i][1]);\n\t}\nstatic void countPrimePath(int[][] mappedMatrix, int n, int m)\n\t{\n\t\tint[][] dp = new int[MAX][MAX];\n\t\tfor(int i = 0; i < MAX; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < MAX; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1] = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor(int j = 1; j <= m; j++)\n\t\t\t{\n\t\t\t\tif (i == 1 && j == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]);\n\t\t\t\tif (mappedMatrix[i][j] == 0)\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n][m]);\n\t}\nstatic void preprocessMatrix(int[][] mappedMatrix, int[][] a, int n, int m)\n\t{\n\t\tsieve();\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif (prime[a[i][j]] == 0)\n\t\t\t\t\tmappedMatrix[i + 1][j + 1] = 1;\n\t\t\t\telse\n\t\t\t\t\tmappedMatrix[i + 1][j + 1] = 0;\n\t\t\t}\n\t\t}\n\t}", "6554": "static long partitions(int n)\n\t{\n\t\tlong p[] = new long[n + 1];\n\t\tp[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tint k = 1;\n\t\t\twhile ((k * (3 * k - 1)) / 2 <= i)\n\t\t\t{\n\t\t\t\tp[i] += (k % 2 != 0 ? 1 : -1) *\n\t\t\t\t\tp[i - (k * (3 * k - 1)) / 2];\n\t\t\t\tif (k > 0)\n\t\t\t\t{\n\t\t\t\t\tk *= -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tk = 1 - k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn p[n];\n\t}", "6586": "static ArrayList<Integer> factors(int n)\n{\n\tArrayList<Integer> v = new ArrayList<Integer>();\n\tv.add(1);\n\tfor (int i = 2;\n\t\t\ti <= Math.sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tv.add(i);\n\t\t\tif (n / i != i)\n\t\t\t{\n\t\t\t\tv.add(n / i);\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\nstatic boolean checkAbundant(int n)\n{\n\tArrayList<Integer> v;\n\tint sum = 0;\n\tv = factors(n);\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tsum += v.get(i);\n\t}\n\tif (sum > n)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nstatic boolean checkSemiPerfect(int n)\n{\n\tArrayList<Integer> v;\n\tv = factors(n);\n\tCollections.sort(v);\n\tint r = v.size();\n\tboolean subset[][] = new boolean[r + 1][n + 1];\n\tfor (int i = 0; i <= r; i++)\n\t\tsubset[i][0] = true;\n\tfor (int i = 1; i <= n; i++)\n\t\tsubset[0][i] = false;\n\tfor (int i = 1; i <= r; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (j < v.get(i - 1))\n\t\t\t\tsubset[i][j] = subset[i - 1][j];\n\t\t\telse {\n\t\t\t\tsubset[i][j] = subset[i - 1][j] ||\n\t\t\t\t\t\t\tsubset[i - 1][j - v.get(i - 1)];\n\t\t\t}\n\t\t}\n\t}\n\tif ((subset[r][n]) == false)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nstatic boolean checkweird(int n)\n{\n\tif (checkAbundant(n) == true &&\n\t\tcheckSemiPerfect(n) == false)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "6589": "static int solve(int N, int K)\n{\n\tint[] combo;\n\tcombo = new int[50];\n\tcombo[0] = 1;\n\tfor (int i = 1; i <= K; i++)\n\t{\n\t\tfor (int j = 0; j <= N; j++)\n\t\t{\n\t\t\tif (j >= i)\n\t\t\t{\n\t\t\t\tcombo[j] += combo[j - i];\n\t\t\t}\n\t\t}\n\t}\n\treturn combo[N];\n}", "6679": "static int maxSubArraySumRepeated(int a[], int n, int k)\n{\n\tint max_so_far = 0;\n\tint INT_MIN, max_ending_here=0;\n\tfor (int i = 0; i < n*k; i++)\n\t{\n\t\tmax_ending_here = max_ending_here +\n\t\t\t\t\t\t\t\t\ta[i % n];\n\t\tif (max_so_far < max_ending_here)\n\t\t\tmax_so_far = max_ending_here;\n\t\tif (max_ending_here < 0)\n\t\t\tmax_ending_here = 0;\n\t}\n\treturn max_so_far;\n}", "6712": "public static int longOddEvenIncSeq(int arr[], int n)\n\t{\n\t\tint[] lioes = new int[n];\n\t\tint maxLen = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlioes[i] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tif (arr[i] > arr[j] &&\n\t\t\t\t(arr[i] + arr[j]) % 2 != 0 && lioes[i] < lioes[j] + 1)\n\t\t\t\t\tlioes[i] = lioes[j] + 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (maxLen < lioes[i])\n\t\t\t\tmaxLen = lioes[i];\n\t\treturn maxLen;\n\t}", "6725": "static int isSubsetSum(int set[], int n, int sum)\n\t{\n\t\tboolean subset[][] = new boolean[sum + 1][n + 1];\n\t\tint count[][] = new int[sum + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsubset[0][i] = true;\n\t\t\tcount[0][i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= sum; i++) {\n\t\t\tsubset[i][0] = false;\n\t\t\tcount[i][0] = -1;\n\t\t}\n\t\tfor (int i = 1; i <= sum; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tsubset[i][j] = subset[i][j - 1];\n\t\t\t\tcount[i][j] = count[i][j - 1];\n\t\t\t\tif (i >= set[j - 1]) {\n\t\t\t\t\tsubset[i][j] = subset[i][j] ||\n\t\t\t\t\tsubset[i - set[j - 1]][j - 1];\n\t\t\t\t\tif (subset[i][j])\n\t\t\t\t\t\tcount[i][j] = Math.max(count[i][j - 1], count[i - set[j - 1]][j - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count[sum][n];\n\t}", "6749": "static int LIP(int dp[][], int mat[][], int n, int m, int x, int y)\n\t{\n\t\tif (dp[x][y] < 0) {\n\t\t\tint result = 0;\n\t\t\tif (x == n - 1 && y == m - 1)\n\t\t\t\treturn dp[x][y] = 1;\n\t\t\tif (x == n - 1 y == m - 1)\n\t\t\t\tresult = 1;\n\t\t\tif (x + 1 < n && mat[x][y] < mat[x + 1][y])\n\t\t\t\tresult = 1 + LIP(dp, mat, n, m, x + 1, y);\n\t\t\tif (y + 1 < m && mat[x][y] < mat[x][y + 1])\n\t\t\t\tresult = Math.max(result, 1 + LIP(dp, mat, n, m, x, y + 1));\n\t\t\tdp[x][y] = result;\n\t\t}\n\t\treturn dp[x][y];\n\t}\nstatic int wrapper(int mat[][], int n, int m)\n\t{\n\t\tint dp[][] = new int[10][10];\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tArrays.fill(dp[i], -1);\n\t\treturn LIP(dp, mat, n, m, 0, 0);\n\t}", "6787": "static int computeLIS(int circBuff[], int start, int end, int n)\n\t{\n\t\tint LIS[] = new int[n+end-start];\n\t\tfor (int i = start; i < end; i++)\n\t\t\tLIS[i] = 1;\n\t\tfor (int i = start + 1; i < end; i++)\n\t\t\tfor (int j = start; j < i; j++ )\n\t\t\t\tif (circBuff[i] > circBuff[j] && LIS[i] < LIS[j] + 1)\n\t\t\t\t\tLIS[i] = LIS[j] + 1;\n\t\tint res = Integer.MIN_VALUE;\n\t\tfor (int i = start; i < end; i++)\n\t\t\tres = Math.max(res, LIS[i]);\n\t\treturn res;\n\t}\nstatic int LICS(int arr[], int n)\n\t{\n\t\tint circBuff[] = new int[2 * n];\n\t\tfor (int i = 0; i<n; i++)\n\t\t\tcircBuff[i] = arr[i];\n\t\tfor (int i = n; i < 2*n; i++)\n\t\t\tcircBuff[i] = arr[i-n];\n\t\tint res = Integer.MIN_VALUE;\n\t\tfor (int i=0; i<n; i++)\n\t\t\tres = Math.max(computeLIS(circBuff, i, i + n, n), res);\n\t\treturn res;\n\t}", "6791": "static int countPaths(int n, int m)\n\t{\n\t\tif (n == 0 m == 0)\n\t\t\treturn 1;\n\t\treturn (countPaths(n - 1, m) + countPaths(n, m - 1));\n\t}", "6792": "static int countPaths(int n, int m)\n\t{\n\t\tint dp[][] = new int[n + 1][m + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tdp[i][0] = 1;\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tdp[0][i] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\t\treturn dp[n][m];\n\t}", "6793": "static int min(int a,int b)\n\t{\n\t\treturn a<b?a:b;\n\t}\nstatic int binomialCoeff(int n, int k) \n\t{ \n\t\tint C[] = new int[k + 1]; \n\t\tC[0] = 1; \n\t\tfor (int i = 1; i <= n; i++) \n\t\t{ \n\t\t\tfor (int j = min(i,k); j > 0; j--) \n\t\t\t\tC[j] = C[j] + C[j-1]; \n\t\t} \n\t\treturn C[k]; \n\t}", "6848": "static int getMaxGold(int gold[][], int m, int n)\n\t{\n\t\tint goldTable[][] = new int[m][n];\n\t\tfor(int[] rows:goldTable)\n\t\t\tArrays.fill(rows, 0);\n\t\tfor (int col = n-1; col >= 0; col--)\n\t\t{\n\t\t\tfor (int row = 0; row < m; row++)\n\t\t\t{\n\t\t\t\tint right = (col == n-1) ? 0\n\t\t\t\t\t\t: goldTable[row][col+1];\n\t\t\t\tint right_up = (row == 0 col == n-1) ? 0 :\n\t\t\t\t\t\tgoldTable[row-1][col+1];\n\t\t\t\tint right_down = (row == m-1 col == n-1) ? 0 :\n\t\t\t\t\t\tgoldTable[row+1][col+1];\n\t\t\t\tgoldTable[row][col] = gold[row][col]\n\t\t\t\t+ Math.max(right, Math.max(right_up, right_down));\n\t\t\t}\n\t\t}\n\t\tint res = goldTable[0][0];\n\t\tfor (int i = 1; i < m; i++)\n\t\t\tres = Math.max(res, goldTable[i][0]);\n\t\treturn res;\n\t}", "6885": "static boolean isOperator(char op)\n {\n\treturn (op == '+' op == '*');\n }\nstatic void printMinAndMaxValueOfExp(String exp)\n {\n\tVector<Integer> num = new Vector<Integer>();\n\tVector<Character> opr = new Vector<Character>();\n\tString tmp = \"\";\n\tfor (int i = 0; i < exp.length(); i++)\n\t{\n\tif (isOperator(exp.charAt(i)))\n\t{\n\t\topr.add(exp.charAt(i));\n\t\tnum.add(Integer.parseInt(tmp));\n\t\ttmp = \"\";\n\t}\n\telse\n\t{\n\t\ttmp += exp.charAt(i);\n\t}\n\t}\n\tnum.add(Integer.parseInt(tmp));\n\tint len = num.size();\n\tint[][] minVal = new int[len][len];\n\tint[][] maxVal = new int[len][len];\n\tfor (int i = 0; i < len; i++)\n\t{\n\tfor (int j = 0; j < len; j++)\n\t{\n\t\tminVal[i][j] = Integer.MAX_VALUE;\n\t\tmaxVal[i][j] = 0;\n\t\tif (i == j)\n\t\tminVal[i][j] = maxVal[i][j]\n\t\t= num.get(i);\n\t}\n\t}\n\tfor (int L = 2; L <= len; L++)\n\t{\n\tfor (int i = 0; i < len - L + 1; i++)\n\t{\n\t\tint j = i + L - 1;\n\t\tfor (int k = i; k < j; k++)\n\t\t{\n\t\tint minTmp = 0, maxTmp = 0;\n\t\tif (opr.get(k) == '+')\n\t\t{\n\t\t\tminTmp = minVal[i][k]\n\t\t\t+ minVal[k + 1][j];\n\t\t\tmaxTmp = maxVal[i][k]\n\t\t\t+ maxVal[k + 1][j];\n\t\t}\n\t\telse if (opr.get(k) == '*')\n\t\t{\n\t\t\tminTmp = minVal[i][k]\n\t\t\t* minVal[k + 1][j];\n\t\t\tmaxTmp = maxVal[i][k]\n\t\t\t* maxVal[k + 1][j];\n\t\t}\n\t\tif (minTmp < minVal[i][j])\n\t\t\tminVal[i][j] = minTmp;\n\t\tif (maxTmp > maxVal[i][j])\n\t\t\tmaxVal[i][j] = maxTmp;\n\t\t}\n\t}\n\t}\n\tSystem.out.print( \"Minimum value : \" + minVal[0][len - 1] + \", Maximum value : \" + maxVal[0][len - 1]);\n }", "6907": "static int lcs(String str1, String str2, int len1, int len2, int i, int j)\n {\n\tint ret = dp[i][j];\n\tif (i == len1 j == len2)\n\treturn ret = 0;\n\tif (ret != -1)\n\treturn ret;\t\n\tret = 0;\n\tif (str1.charAt(i) == str2.charAt(j))\n\tret = 1 + lcs(str1, str2, len1, len2, i + 1, j + 1);\n\telse\n\tret = Math.max(lcs(str1, str2, len1, len2, i + 1, j),\n\t\t\t\t\tlcs(str1, str2, len1, len2, i, j + 1));\n\treturn ret;\n }\nstatic void printAll(String str1, String str2, int len1, int len2, char[] data, int indx1, int indx2, int currlcs)\n {\n\tif (currlcs == lcslen)\n\t{\n\tdata[currlcs] = '\\0';\n\tSystem.out.println(new String(data));\n\treturn;\n\t}\n\tif (indx1 == len1 indx2 == len2)\n\treturn;\n\tfor (char ch ='a'; ch <='z'; ch++)\n\t{\n\tboolean done = false;\n\tfor (int i = indx1; i < len1; i++)\n\t{\n\t\tif (ch == str1.charAt(i))\n\t\t{\n\t\tfor (int j = indx2; j < len2; j++)\n\t\t{\n\t\t\tif (ch == str2.charAt(j) && dp[i][j] == lcslen - currlcs)\n\t\t\t{\n\t\t\tdata[currlcs] = ch;\n\t\t\tprintAll(str1, str2, len1, len2, data, i + 1, j + 1, currlcs + 1);\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif (done)\n\t\tbreak;\n\t}\n\t}\n }\nstatic void prinlAllLCSSorted(String str1, String str2)\n {\n\tint len1 = str1.length(), len2 = str2.length();\n\tfor(int i = 0; i < MAX; i++)\n\t{\n\tfor(int j = 0; j < MAX; j++)\n\t{\n\t\tdp[i][j] = -1;\n\t}\n\t}\n\tlcslen = lcs(str1, str2, len1, len2, 0, 0);\n\tchar[] data = new char[MAX];\n\tprintAll(str1, str2, len1, len2, data, 0, 0, 0);\n }", "6933": "static int minAdjustmentCost(int A[], int n, int target)\n\t{\n\t\tint[][] dp = new int[n][M + 1];\n\t\tfor (int j = 0; j <= M; j++)\n\t\t\tdp[0][j] = Math.abs(j - A[0]);\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j <= M; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t\tint k = Math.max(j-target,0);\n\t\t\t\tfor ( ; k <= Math.min(M,j+target); k++)\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + \n\t\t\t\t\t\t\t\t\t\t\t\tMath.abs(A[i] - j));\n\t\t\t}\n\t\t} \n\t\tint res = Integer.MAX_VALUE;\n\t\tfor (int j = 0; j <= M; j++)\n\t\t\tres = Math.min(res, dp[n - 1][j]);\n\t\treturn res;\n\t}", "6944": "static int LCIS(int arr1[], int n, int arr2[], int m)\n\t{\n\t\tint table[] = new int[m];\n\t\tfor (int j = 0; j < m; j++)\n\t\t\ttable[j] = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint current = 0;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif (arr1[i] == arr2[j])\n\t\t\t\t\tif (current + 1 > table[j])\n\t\t\t\t\t\ttable[j] = current + 1;\n\t\t\t\tif (arr1[i] > arr2[j])\n\t\t\t\t\tif (table[j] > current)\n\t\t\t\t\t\tcurrent = table[j];\n\t\t\t}\n\t\t}\n\t\tint result = 0;\n\t\tfor (int i=0; i<m; i++)\n\t\t\tif (table[i] > result)\n\t\t\tresult = table[i];\n\t\treturn result;\n\t}", "7051": "static int cutRod(int price[],int n)\n\t{\n\t\tint val[] = new int[n+1];\n\t\tval[0] = 0;\n\t\tfor (int i = 1; i<=n; i++)\n\t\t{\n\t\t\tint max_val = Integer.MIN_VALUE;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tmax_val = Math.max(max_val, price[j] + val[i-j-1]);\n\t\t\tval[i] = max_val;\n\t\t}\n\t\treturn val[n];\n\t}", "7068": "static int MatrixChainOrder(int p[], int i, int j)\n\t{\n\t\tif (i == j)\n\t\t\treturn 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int k = i; k < j; k++)\n\t\t{\n\t\t\tint count = MatrixChainOrder(p, i, k)\n\t\t\t\t\t\t+ MatrixChainOrder(p, k + 1, j)\n\t\t\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\t\tif (count < min)\n\t\t\t\tmin = count;\n\t\t}\n\t\treturn min;\n\t}", "7069": "static int matrixChainMemoised(int[] p, int i, int j)\n {\n\tif (i == j) \n\t{\n\treturn 0;\n\t}\n\tif (dp[i][j] != -1) \n\t{\n\treturn dp[i][j];\n\t}\n\tdp[i][j] = Integer.MAX_VALUE;\n\tfor (int k = i; k < j; k++) \n\t{\n\tdp[i][j] = Math.min(\n\t\tdp[i][j], matrixChainMemoised(p, i, k)\n\t\t+ matrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n\t}\n\treturn dp[i][j];\n }\nstatic int MatrixChainOrder(int[] p, int n)\n {\n\tint i = 1, j = n - 1;\n\treturn matrixChainMemoised(p, i, j);\n }", "7071": "static int count(int S[], int m, int n)\n{\n\tif (n == 0)\n\t\treturn 1;\n\tif (n < 0)\n\t\treturn 0;\n\tif (m <= 0 && n >= 1)\n\t\treturn 0;\n\treturn count(S, m - 1, n) +\n\t\tcount(S, m, n - S[m - 1]);\n}", "7074": "static int coinchange(int[] a, int v, int n, int[][] dp)\n\t{\n\t\tif (v == 0)\n\t\t\treturn dp[n][v] = 1;\n\t\tif (n == 0)\n\t\t\treturn 0;\n\t\tif (dp[n][v] != -1)\n\t\t\treturn dp[n][v];\n\t\tif (a[n - 1] <= v)\n\t\t{\n\t\t\treturn dp[n][v]\n\t\t\t\t= coinchange(a, v - a[n - 1], n, dp)\n\t\t\t\t+ coinchange(a, v, n - 1, dp);\n\t\t}\n\t\t\treturn dp[n][v] = coinchange(a, v, n - 1, dp);\n\t}", "7119": "static int totalCombination(int L, int R)\n {\n\tint count = 0;\n\tint K = R - L;\n\tif (K < L)\n\treturn 0;\n\tint ans = K - L;\n\tcount = ((ans + 1) * (ans + 2)) / 2;\n\treturn count;\n }", "7135": "static void printArrays(int n)\n{\n\tArrayList<Integer> A = new ArrayList<Integer>();\n\tArrayList<Integer> B = new ArrayList<Integer>();\n\tfor(int i = 1; i <= 2 * n; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tA.add(i);\n\t\telse\n\t\t\tB.add(i);\n\t}\n\tSystem.out.print(\"{ \");\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tSystem.out.print(A.get(i));\n\t\tif (i != n - 1)\n\t\t\tSystem.out.print(\", \");\n\t}\n\tSystem.out.print(\" }\\n\");\n\tSystem.out.print(\"{ \");\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tSystem.out.print(B.get(i));\n\t\tif (i != n - 1)\n\t\t\tSystem.out.print(\", \");\n\t}\n\tSystem.out.print(\" }\");\n}", "7139": "static void flipBitsOfAandB(int A, int B)\n{\n\tfor(int i = 0; i < 32; i++)\n\t{\n\t\tif (((A & (1 << i)) &\n\t\t\t(B & (1 << i))) != 0)\n\t\t{\n\t\t\tA = A ^ (1 << i);\n\t\t\tB = B ^ (1 << i);\n\t\t}\n\t}\n\tSystem.out.print(A + \" \" + B);\n}", "7140": "static void flipBitsOfAandB(int A, int B)\n{\n\tA = A ^ (A & B);\n\tB = B ^ (A & B);\n\tSystem.out.print(A + \" \" + B);\n}", "7167": "static int TotalHammingDistance(int n)\n{\n\tint i = 1, sum = 0;\n\twhile (n / i > 0)\n\t{\n\t\tsum = sum + n / i;\n\t\ti = i * 2;\n\t}\n\treturn sum;\n}", "7176": "static void solve(long n)\n{\n long s = 0;\n for (int l = 1; l <= n;)\n {\n\tint r = (int)(n /\n\t\t\tMath.floor(n / l));\n\tint x = (((r % m) *\n\t\t\t((r + 1) % m)) / 2) % m;\n\tint y = (((l % m) *\n\t\t\t((l - 1) % m)) / 2) % m;\n\tint p = (int)((n / l) % m);\n\ts = (s + (((x - y) % m) * p) % m + m) % m;\n\ts %= m;\n\tl = r + 1;\n }\n System.out.print((s + m) % m);\n}", "7187": "static int min_time_to_cut(int N)\n{\n\tif (N == 0)\n\t\treturn 0;\n\treturn (int)Math.ceil(Math.log(N) /\n\t\t\t\t\t\tMath.log(2));\n}", "7203": "static int findDistinctSums(int n)\n{\n\tHashSet<Integer> s = new HashSet<>();\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = i; j <= n; j++)\n\t\t{\n\t\t\ts.add(i + j);\n\t\t}\n\t}\n\treturn s.size();\n}", "7204": "static int findDistinctSums(int N)\n{\n\treturn (2 * N - 1);\n}", "7234": "static int printPattern( int i, int j, int n)\n{\n\tif (j >= n) {\n\t\treturn 0;\n\t}\n\tif (i >= n) {\n\t\treturn 1;\n\t}\n\tif (j == i j == n - 1 - i) {\n\t\tif (i == n - 1 - j) {\n\t\t\tSystem.out.print(\"/\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.print(\"\\\\\");\n\t\t}\n\t}\n\telse {\n\t\tSystem.out.print(\"*\");\n\t}\n\tif (printPattern(i, j + 1, n) == 1) {\n\t\treturn 1;\n\t}\n\tSystem.out.println();\n\treturn printPattern(i + 1, 0, n);\n}", "7248": "private static int[] zArray(int arr[])\n\t{\n\t\tint z[];\n\t\tint n = arr.length;\n\t\tz = new int[n];\n\t\tint r = 0, l = 0;\n\t\tfor (int k = 1; k < n; k++) {\n\t\t\tif (k > r) {\n\t\t\t\tr = l = k;\n\t\t\t\twhile (r < n && arr[r] == arr[r - l])\n\t\t\t\t\tr++;\n\t\t\t\tz[k] = r - l;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint k1 = k - l;\n\t\t\t\tif (z[k1] < r - k + 1)\n\t\t\t\t\tz[k] = z[k1];\n\t\t\t\telse {\n\t\t\t\t\tl = k;\n\t\t\t\t\twhile (r < n && arr[r] == arr[r - l])\n\t\t\t\t\t\tr++;\n\t\t\t\t\tz[k] = r - l;\n\t\t\t\t\tr--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}\nprivate static int[] mergeArray(int A[], int B[])\n\t{\n\t\tint n = A.length;\n\t\tint m = B.length;\n\t\tint z[];\n\t\tint c[] = new int[n + m + 1];\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tc[i] = B[i];\n\t\tc[m] = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tc[m + i + 1] = A[i];\n\t\tz = zArray(c);\n\t\treturn z;\n\t}\nprivate static void findZArray(int A[], int B[], int n)\n\t{\n\t\tint flag = 0;\n\t\tint z[];\n\t\tz = mergeArray(A, B);\n\t\tfor (int i = 0; i < z.length; i++) {\n\t\t\tif (z[i] == n) {\n\t\t\t\tSystem.out.print((i - n - 1) + \" \");\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0) {\n\t\t\tSystem.out.println(\"Not Found\");\n\t\t}\n\t}", "7276": "static int getCount(String a, String b)\n\t{\n\t\tif(b.length() % a.length() != 0)\n\t\t\treturn -1;\n\t\tint count = b.length() / a.length();\n\t\tString str = \"\";\n\t\tfor(int i = 0; i < count; i++)\n\t\t{\n\t\t\tstr = str + a;\n\t\t}\n\t\tif(str.equals(b))\n\t\t\treturn count;\n\t\treturn -1;\n\t}", "7287": "public static void printSpiral(int size)\n\t{\n\t\tint row = 0, col = 0;\n\t\tint boundary = size - 1;\n\t\tint sizeLeft = size - 1;\n\t\tint flag = 1;\n\t\tchar move = 'r';\n\t\tint matrix[][] = new int[size][size];\n\t\tfor (int i = 1; i < size * size + 1; i++) {\n\t\t\tmatrix[row][col] = i;\n\t\t\tswitch (move) {\n\t\t\tcase 'r':\n\t\t\t\tcol += 1;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcol -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\trow -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\trow += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == boundary) {\n\t\t\t\tboundary += sizeLeft;\n\t\t\t\tif (flag != 2) {\n\t\t\t\t\tflag = 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tsizeLeft -= 1;\n\t\t\t\t}\n\t\t\t\tswitch (move) {\n\t\t\t\tcase 'r':\n\t\t\t\t\tmove = 'd';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tmove = 'l';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\tmove = 'u';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tmove = 'r';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (row = 0; row < size; row++) {\n\t\t\tfor (col = 0; col < size; col++) {\n\t\t\t\tint n = matrix[row][col];\n\t\t\t\tSystem.out.print((n < 10)\n\t\t\t\t\t\t\t\t\t? (n + \" \")\n\t\t\t\t\t\t\t\t\t: (n + \" \"));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "7298": "static boolean check(String S1, String S2)\n{\n\tint n1 = S1.length();\n\tint n2 = S2.length();\n\tHashMap<Integer,Integer> mp =\n\t\tnew HashMap<Integer,Integer>();\n\tfor (int i = 0; i < n1; i++)\n\t{\n\t\tif(mp.containsKey((int)S1.charAt(i)))\n\t\t{\n\t\t\tmp.put((int)S1.charAt(i),\n\t\t\tmp.get((int)S1.charAt(i)) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.put((int)S1.charAt(i), 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < n2; i++)\n\t{\n\t\tif(mp.containsKey((int)S2.charAt(i)))\n\t\t{\n\t\t\tmp.put((int)S2.charAt(i),\n\t\t\tmp.get((int)S2.charAt(i)) - 1);\n\t\t}\n\t\telse if (mp.containsKey(S2.charAt(i)-1) &&\n\t\t\t\t\tmp.containsKey(S2.charAt(i)-2))\n\t\t{\n\t\t\tmp.put((S2.charAt(i) - 1),\n\t\t\tmp.get(S2.charAt(i) - 1) - 1);\n\t\t\tmp.put((S2.charAt(i) - 2),\n\t\t\tmp.get(S2.charAt(i) - 2) - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "7309": "static int countPattern(String str)\n\t{\n\t\tint len = str.length();\n\t\tboolean oneSeen = false;\n\t\tfor(int i = 0; i < len ; i++)\n\t\t{\n\t\t\tchar getChar = str.charAt(i);\n\t\t\tif (getChar == '1' && oneSeen == true){\n\t\t\t\tif (str.charAt(i - 1) == '0')\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(getChar == '1' && oneSeen == false)\n\t\t\t\toneSeen = true;\n\t\t\tif(getChar != '0' && str.charAt(i) != '1')\n\t\t\t\toneSeen = false;\n\t\t}\n\t\treturn count;\n\t}", "7336": "public static int countSubstrings(String str)\n\t{\n\t\tint[] freq = new int[3];\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tfor (int j = 0;\n\t\t\tj < str.length(); j++) {\n\t\t\tfreq[str.charAt(j) - '0']++;\n\t\t\twhile (freq[0] > 0 && freq[1] > 0 && freq[2] > 0) {\n\t\t\t\tfreq[str.charAt(i++) - '0']--;\n\t\t\t}\n\t\t\tcount += i;\n\t\t}\n\t\treturn count;\n\t}", "7347": "static int minFlips(String str)\n{\n\tint count = 0;\n\tif (str.length() <= 2) {\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < str.length() - 2 {\n\t\tif (str.charAt(i) == str.charAt(i+1)\n\t\t\t&& str.charAt(i+2) == str.charAt(i+1)) {\n\t\t\ti = i + 3;\n\t\t\tcount++;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn count;\n}\npublic static void main(String[] args)\n{\n\tString S = \"0011101\";\n System.out.println(minFlips(S));\n}", "7382": "static String checkIfPossible( int N, String[] arr, String T)\n\t{\n\t\tint[] freqS = new int[256];\n\t\tint[] freqT = new int[256];\n\t\tfor (char ch : T.toCharArray()) {\n\t\t\tfreqT[ch - 'a']++;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (char ch : arr[i].toCharArray()) {\n\t\t\t\tfreqS[ch - 'a']++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tif (freqT[i] == 0 && freqS[i] != 0) {\n\t\t\t\treturn \"No\";\n\t\t\t}\n\t\t\telse if (freqS[i] == 0 && freqT[i] != 0) {\n\t\t\t\treturn \"No\";\n\t\t\t}\n\t\t\telse if (freqT[i] != 0\n\t\t\t\t\t&& freqS[i]\n\t\t\t\t\t\t\t!= (freqT[i] * N)) {\n\t\t\t\treturn \"No\";\n\t\t\t}\n\t\t}\n\t\treturn \"Yes\";\n\t}", "7390": "static String convertToHex(int num)\n\t{\n\t\tStringBuilder temp = new StringBuilder();\n\t\twhile (num != 0) {\n\t\t\tint rem = num % 16;\n\t\t\tchar c;\n\t\t\tif (rem < 10) {\n\t\t\t\tc = (char) (rem + 48);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = (char) (rem + 87);\n\t\t\t}\n\t\t\ttemp.append(c);\n\t\t\tnum = num / 16;\n\t\t}\n\t\treturn temp.toString();\n\t}\nstatic String encryptString(String S, int N)\n\t{\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tchar ch = S.charAt(i);\n\t\t\tint count = 0;\n\t\t\tString hex;\n\t\t\twhile (i < N && S.charAt(i) == ch) {\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ti--;\n\t\t\thex = convertToHex(count);\n\t\t\tans.append(ch);\n\t\t\tans.append(hex);\n\t\t}\n\t\tans.reverse();\n\t\treturn ans.toString();\n\t}", "7401": "static int groupsOfOnes(String S, int N)\n{\n\tint count = 0;\n\tStack<Integer> st = new Stack<>();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (S.charAt(i) == '1')\n\t\t\tst.push(1);\n\t\telse\n\t\t{\n\t\t\tif (!st.empty())\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\twhile (!st.empty())\n\t\t\t\t{\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!st.empty())\n\t\tcount++;\n\treturn count;\n}", "7412": "static void generatePalindrome(String S)\n\t{\n\t\tHashMap<Character, Integer> Hash = new HashMap<>();\n\t\tfor(int i = 0; i < S.length(); i++)\n\t\t{\n\t\t\tif (Hash.containsKey(S.charAt(i)))\n\t\t\t\tHash.put(S.charAt(i), Hash.get(S.charAt(i))+1);\n\t\t\telse\n\t\t\t\tHash.put(S.charAt(i), 1);\n\t\t}\n\t\tTreeSet<String> st = new TreeSet<String>();\n\t\tfor(char i = 'a'; i <= 'z'; i++)\n\t\t{\n\t\t\tif (Hash.containsKey(i) && Hash.get(i) == 2)\n\t\t\t{\n\t\t\t\tfor(char j = 'a'; j <= 'z'; j++)\n\t\t\t\t{\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tif (Hash.containsKey(j) && i != j)\n\t\t\t\t\t{\n\t\t\t\t\t\ts += i;\n\t\t\t\t\t\ts += j;\n\t\t\t\t\t\ts += i;\n\t\t\t\t\t\tst.add(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Hash.containsKey(i) && Hash.get(i) >= 3)\n\t\t\t{\n\t\t\t\tfor(char j = 'a'; j <= 'z'; j++)\n\t\t\t\t{\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tif (Hash.containsKey(j))\n\t\t\t\t\t{\n\t\t\t\t\t\ts += i;\n\t\t\t\t\t\ts += j;\n\t\t\t\t\t\ts += i;\n\t\t\t\t\t\tst.add(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(String ans : st)\n\t\t{\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}", "7423": "static void countOccurrences(String S, String X, String Y)\n\t{\n\t\tint count = 0;\n\t\tint N = S.length(), A = X.length();\n\t\tint B = Y.length();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (S.substring(i, Math.min(N, i + B))\n\t\t\t\t\t.equals(Y))\n\t\t\t\tcount++;\n\t\t\tif (S.substring(i, Math.min(N, i + A))\n\t\t\t\t\t.equals(X))\n\t\t\t\tSystem.out.print(count + \" \");\n\t\t}\n\t}", "7487": "static void findWinner(String a, int n)\n {\n\tVector<Integer> v = new Vector<Integer>(); \n\tint c = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\tif (a.charAt(i) == '0')\n\t{\n\t\tc++;\n\t}\n\telse\n\t{\n\t\tif (c != 0)\n\t\tv.add(c);\n\t\tc = 0;\n\t}\n\t}\n\tif (c != 0)\n\tv.add(c);\n\tif (v.size() == 0)\n\t{\n\tSystem.out.print(\"Player B\");\n\treturn;\n\t}\n\tif (v.size() == 1)\n\t{\n\tif ((v.get(0) & 1) != 0)\n\t\tSystem.out.print(\"Player A\");\n\telse\n\t\tSystem.out.print(\"Player B\");\n\treturn;\n\t}\n\tint first = Integer.MIN_VALUE;\n\tint second = Integer.MIN_VALUE;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\tif (a.charAt(i) > first) {\n\t\tsecond = first;\n\t\tfirst = a.charAt(i);\n\t}\n\telse if (a.charAt(i) > second\n\t\t\t&& a.charAt(i) != first)\n\t\tsecond = a.charAt(i);\n\t}\n\tif ((first & 1) != 0\n\t\t&& (first + 1) / 2 > second)\n\tSystem.out.print(\"Player A\");\n\telse\n\tSystem.out.print(\"Player B\");\n }", "7507": "static void DFA(String str, int N)\n {\n\tif (N <= 1)\n\t{\n\tSystem.out.print(\"No\");\n\treturn;\n\t}\n\tint count = 0;\n\tif (str.charAt(0) == 'C')\n\t{\n\tcount++;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (str.charAt(i) == 'A' ||\n\t\t\tstr.charAt(i) == 'B')\n\t\tcount++;\n\t\telse\n\t\tbreak;\n\t}\n\t}\n\telse\n\t{\n\tSystem.out.print(\"No\");\n\treturn;\n\t}\n\tif (count == N)\n\tSystem.out.print(\"Yes\");\n\telse\n\tSystem.out.print(\"No\");\n }", "7542": "static void minMaxDigits(String str, int N)\n{\n\tint arr[] = new int[N];\n\tfor(int i = 0; i < N; i++)\n\t\tarr[i] = (str.charAt(i) - '0') % 3;\n\tint zero = 0, one = 0, two = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t\tzero++;\n\t\tif (arr[i] == 1)\n\t\t\tone++;\n\t\tif (arr[i] == 2)\n\t\t\ttwo++;\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tsum = (sum + arr[i]) % 3;\n\t}\n\tif (sum == 0)\n\t{\n\t\tSystem.out.print(0 + \" \");\n\t}\n\tif (sum == 1)\n\t{\n\t\tif ((one != 0) && (N > 1))\n\t\t\tSystem.out.print(1 + \" \");\n\t\telse if (two > 1 && N > 2)\n\t\t\tSystem.out.print(2 + \" \");\n\t\telse\n\t\t\tSystem.out.print(-1 + \" \");\n\t}\n\tif (sum == 2)\n\t{\n\t\tif (two != 0 && N > 1)\n\t\t\tSystem.out.print(1 + \" \");\n\t\telse if (one > 1 && N > 2)\n\t\t\tSystem.out.print(2 + \" \");\n\t\telse\n\t\t\tSystem.out.print(-1 + \" \");\n\t}\n\tif (zero > 0)\n\t\tSystem.out.print(N - 1 + \" \");\n\telse if (one > 0 && two > 0)\n\t\tSystem.out.print(N - 2 + \" \");\n\telse if (one > 2 two > 2)\n\t\tSystem.out.print(N - 3 + \" \");\n\telse\n\t\tSystem.out.print(-1 + \" \");\n}", "7548": "static int findMinimumChanges(int N, int K, char[] S)\n{\n\tint ans = 0;\n\tfor(int i = 0; i < (K + 1) / 2; i++)\n\t{\n\t\tHashMap<Character, Integer> mp = new HashMap<>();\n\t\tfor(int j = i; j < N; j += K)\n\t\t{\n\t\t\tif (mp.containsKey(S[j]))\n\t\t\t{\n\t\t\t\tmp.put(S[j], mp.get(S[j]) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.put(S[j], 1);\n\t\t\t}\n\t\t}\n\t\tfor(int j = N - i - 1; j >= 0; j -= K)\n\t\t{\n\t\t\tif (K % 2 == 1 && i == K / 2)\n\t\t\t\tbreak;\n\t\t\tif (mp.containsKey(S[j]))\n\t\t\t{\n\t\t\t\tmp.put(S[j], mp.get(S[j]) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.put(S[j], 1);\n\t\t\t}\n\t\t}\n\t\tint curr_max = Integer.MIN_VALUE;\n\t\tfor(Map.Entry<Character,\n\t\t\t\t\tInteger> p : mp.entrySet())\n\t\t{\n\t\t\tcurr_max = Math.max(curr_max,\n\t\t\t\t\t\t\t\tp.getValue());\n\t\t}\n\t\tif ((K % 2 == 1) && i == K / 2)\n\t\t\tans += (N / K - curr_max);\n\t\telse\n\t\t\tans += (N / K * 2 - curr_max);\n\t}\n\treturn ans;\n}", "7564": "static int longComPre(String arr[], int N)\n{\n int [][]freq = new int[N][256];\n for (int i = 0; i < N; i++)\n {\n\tint M = arr[i].length();\n\tfor (int j = 0; j < M; j++)\n\t{\n\tfreq[i][arr[i].charAt(j)]++;\n\t}\n }\n int maxLen = 0;\n for (int j = 0; j < 256; j++)\n {\n\tint minRowVal = Integer.MAX_VALUE;\n\tfor (int i = 0; i < N; i++)\n\t{\n\tminRowVal = Math.min(minRowVal, freq[i][j]);\n\t}\n\tmaxLen += minRowVal;\n }\n return maxLen;\n}", "7587": "static int binomialCoeff(int n, int k)\n{\n\tint res = 1;\n\tif (k > n - k)\n\t\tk = n - k;\n\tfor(int i = 0; i < k; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}\nstatic int countOfString(int N)\n{\n\tint Stotal = (int) Math.pow(2, N);\n\tint Sequal = 0;\n\tif (N % 2 == 0)\n\t\tSequal = binomialCoeff(N, N / 2);\n\tint S1 = (Stotal - Sequal) / 2;\n\treturn S1;\n}", "7593": "static String removeCharRecursive(String str, char X)\n{\n\tif (str.length() == 0)\n\t{\n\t\treturn \"\";\n\t}\n\tif (str.charAt(0) == X)\n\t{\n\t\treturn removeCharRecursive(\n\t\t\tstr.substring(1), X);\n\t}\n\treturn str.charAt(0) +\n\t\tremoveCharRecursive(\n\t\tstr.substring(1), X);\n}", "7594": "static String checkString(String s, int K)\n{\n\tint n = s.length();\n\tMap<Character,\n\t\tInteger> mp = new HashMap<>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tmp.put(s.charAt(i), i);\n\t}\n\tint cnt = 0, f = 0;\n\tSet<Character> st = new HashSet<>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tst.add(s.charAt(i));\n\t\tif (st.size() > K)\n\t\t{\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (mp.get(s.charAt(i)) == i)\n\t\t\tst.remove(s.charAt(i));\n\t}\n\treturn (f == 1 ? \"Yes\" : \"No\");\n}", "7609": "static boolean isValid(char a1, char a2, String str, int flag)\n{\n char v1, v2;\n if (flag == 0)\n {\n\tv1 = str.charAt(4);\n\tv2 = str.charAt(3);\n }\n else\n {\n\tv1 = str.charAt(1);\n\tv2 = str.charAt(0);\n }\n if (v1 != a1 && v1 != '?')\n\treturn false;\n if (v2 != a2 && v2 != '?')\n\treturn false;\n return true;\n}\nstatic boolean inRange(int hh, int mm, int L, int R)\n{\n int a = Math.abs(hh - mm);\n if (a < L a > R)\n\treturn false;\n return true;\n}\nstatic void displayTime(int hh, int mm)\n{\n if (hh > 10)\n\tSystem.out.print(hh + \":\");\n else if (hh < 10)\n\tSystem.out.print(\"0\" + hh + \":\");\n if (mm > 10)\n\tSystem.out.println(mm);\n else if (mm < 10)\n\tSystem.out.println(\"0\" + mm);\n}\nstatic void maximumTimeWithDifferenceInRange(String str, int L, int R)\n{\n int i = 0, j = 0;\n int h1, h2, m1, m2;\n for (i = 23; i >= 0; i--)\n {\n\th1 = i % 10;\n\th2 = i / 10;\n\tif (!isValid((char)h1,\n\t\t\t\t(char)h2, str, 1))\n\t{\n\tcontinue;\n\t}\n\tfor (j = 59; j >= 0; j--)\n\t{\n\tm1 = j % 10;\n\tm2 = j / 10;\n\tif (!isValid((char)m1,\n\t\t\t\t(char)m2, str, 0))\n\t{\n\t\tcontinue;\n\t}\n\tif (inRange(i, j, L, R))\n\t{\n\t\tdisplayTime(i, j);\n\t\treturn;\n\t}\n\t}\n }\n if (inRange(i, j, L, R))\n\tdisplayTime(i, j);\n else\n\tSystem.out.println(\"-1\");\n}", "7622": "static boolean check(String s, int n)\n{\n\tStack<Character> st = new Stack<Character>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\tif (!st.isEmpty() &&\n\t\t\tst.peek() == s.charAt(i))\n\t\tst.pop();\n\telse\n\t\tst.add(s.charAt(i));\n\t}\n\tif (st.isEmpty())\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}", "7646": "static boolean can_Construct(String S, int K)\n{\n\tMap<Character, Integer> m = new HashMap<>();\n\tint p = 0;\n\tif (S.length() == K)\n\t\treturn true;\n\tfor(int i = 0; i < S.length(); i++)\n\t\tm.put(S.charAt(i),\n\t\t\tm.getOrDefault(S.charAt(i), 0) + 1);\n\tif (K > S.length())\n\t\treturn false;\n\telse\n\t{\n\t\tfor(Integer h : m.values())\n\t\t{\n\t\t\tif (h % 2 != 0)\n\t\t\t\tp = p + 1;\n\t\t}\n\t}\n\tif (K < p)\n\t\treturn false;\n\treturn true;\n}", "7688": "static void findNumOfValidWords(Vector<String> w, Vector<String> p)\n{\n HashMap<Integer,\n\t\tInteger> m = new HashMap<>();\n Vector<Integer> res = new Vector<>();\n for (String s : w)\n {\n\tint val = 0;\n\tfor (char c : s.toCharArray())\n\t{\n\tval = val | (1 << (c - 'a'));\n\t}\n\tif(m.containsKey(val))\n\tm.put(val, m.get(val) + 1);\n\telse\n\tm.put(val, 1);\n }\n for (String s : p)\n {\n\tint val = 0;\n\tfor (char c : s.toCharArray())\n\t{\n\tval = val | (1 << (c - 'a'));\n\t}\n\tint temp = val;\n\tint first = s.charAt(0) - 'a';\n\tint count = 0;\n\twhile (temp != 0)\n\t{\n\tif (((temp >> first) & 1) == 1)\n\t{\n\t\tif (m.containsKey(temp))\n\t\t{\n\t\tcount += m.get(temp);\n\t\t}\n\t}\n\ttemp = (temp - 1) & val;\n\t}\n\tres.add(count);\n }\n for (int it : res)\n {\n\tSystem.out.println(it);\n }\n}", "7693": "static void flip(String s)\n{\n\tStringBuilder sb = new StringBuilder(s);\n\tfor(int i = 0; i < sb.length(); i++)\n\t{\n\tif (sb.charAt(i) == '0')\n\t{\n\t\twhile (sb.charAt(i) == '0')\n\t\t{\n\t\t\tsb.setCharAt(i, '1');\n\t\t\ti++;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\tSystem.out.println(sb.toString());\n}", "7694": "public static void distinct(String[] S, int M)\n{\n\tint count = 0;\n\tfor(int i = 0; i < S.length; i++)\n\t{\n\tSet<Character> set = new HashSet<>();\n\tfor(int j = 0; j < S[i].length(); j++)\n\t{\n\t\tif (!set.contains(S[i].charAt(j)))\n\t\t\tset.add(S[i].charAt(j));\n\t}\n\tint c = set.size();\n\tif (c <= M)\n\t\tcount += 1;\n\t}\n\tSystem.out.println(count);\n}", "7734": "static String removeOddFrequencyCharacters(String s)\n\t{\n\t\tHashMap<Character, Integer> m = new HashMap<Character,Integer>();\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar p = s.charAt(i);\n\t\t\tInteger count = m.get(p);\n\t\t\tif( count == null)\n\t\t\t{\n\t\t\t\tcount=0;\n\t\t\t\tm.put(p,1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tm.put(p,count + 1);\n\t\t}\n\t\tString new_string = \"\";\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif ((m.get(s.charAt(i))& 1)==1)\n\t\t\t\tcontinue;\n\t\t\tnew_string += s.charAt(i);\n\t\t}\n\t\treturn new_string;\n\t}", "7735": "static String removeChars(char arr[], int k)\n{\n\tint []hash = new int[MAX_CHAR];\n\tint n = arr.length;\n\tfor (int i = 0; i < n; ++i)\n\t\thash[arr[i] - 'a']++;\n\tString ans = \"\";\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (hash[arr[i] - 'a'] != k) {\n\t\t\tans += arr[i];\n\t\t}\n\t}\n\treturn ans;\n}", "7753": "static int productAtKthLevel( String tree, int k, int level){\n\t\tif (tree.charAt(i++) == '(') {\n\t\t\tif (tree.charAt(i) == ')')\n\t\t\t\treturn 1;\n\t\t\tint product = 1;\n\t\t\tif (level == k)\n\t\t\t\tproduct = tree.charAt(i) - '0';\n\t\t\t++i;\n\t\t\tint leftproduct = productAtKthLevel( tree, k, level + 1);\n\t\t\t++i;\n\t\t\tint rightproduct = productAtKthLevel( tree, k, level + 1);\n\t\t\t++i;\n\t\t\treturn product * leftproduct\n\t\t\t* rightproduct;\n\t\t}\n\t\treturn Integer.MIN_VALUE;\n\t}", "7758": "static void findMostOccurringChar(Vector<String> str)\n{\n\tint []hash = new int[26];\n\tfor (int i = 0; i < str.size(); i++)\n\t{\n\t\tfor (int j = 0; j < str.get(i).length(); j++)\n\t\t{\n\t\t\thash[str.get(i).charAt(j)-97]++;\n\t\t}\n\t}\n\tint max = 0;\n\tfor (int i = 0; i < 26; i++)\n\t{\n\t\tmax = hash[i] > hash[max] ? i : max;\n\t}\n\tSystem.out.print((char)(max + 97) +\"\\n\");\n}", "7788": "static void sub_segments(String str, int n)\n{\n\tint l = str.length();\n\tfor (int x = 0; x < l; x += n)\n\t{\n\t\tString newlist = str.substring(x, x + n);\n\t\tList<Character> arr = new ArrayList<Character>();\n\t\tfor (char y : newlist.toCharArray())\n\t\t{\n\t\t\tif (!arr.contains(y))\n\t\t\t\tarr.add(y);\n\t\t}\n\t\tfor (char y : arr)\n\t\t\tSystem.out.print(y);\n\t\tSystem.out.println();\n\t}\n}", "7816": "public static boolean isPalindrome(float num)\n\t{\n\t\tString s = String.valueOf(num);\n\t\tint low = 0;\n\t\tint high = s.length() - 1;\n\t\twhile (low < high) {\n\t\t\tif (s.charAt(low) != s.charAt(high))\n\t\t\t\treturn false;\n\t\t\tlow++;\n\t\t\thigh--;\n\t\t}\n\t\treturn true;\n\t}", "7819": "static int maxSubStr(char []str1, int len1, char []str2, int len2)\n\t{\n\t\tif (len1 > len2)\n\t\t\treturn 0;\n\t\tint freq1[] = new int[MAX];\n\t\tfor (int i = 0; i < len1; i++)\n\t\t\tfreq1[i] = 0;\n\t\tfor (int i = 0; i < len1; i++)\n\t\t\tfreq1[str1[i] - 'a']++;\n\t\tint freq2[] = new int[MAX];\n\t\tfor (int i = 0; i < len2; i++)\n\t\t\tfreq2[i] = 0;\n\t\tfor (int i = 0; i < len2; i++)\n\t\t\tfreq2[str2[i] - 'a']++;\n\t\tint minPoss = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < MAX; i++)\n\t\t{\n\t\t\tif (freq1[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (freq1[i] > freq2[i])\n\t\t\t\treturn 0;\n\t\t\tminPoss = Math.min(minPoss, freq2[i] / freq1[i]);\n\t\t}\n\t\treturn minPoss;\n\t}", "7820": "static int cntWays(String str, int n)\n{\n\tint x = n + 1;\n\tint ways = x * x * (x * x - 1) / 12;\n\treturn ways;\n}", "7828": "static void findSubStr(String str, int cnt, int start)\n{\n\tif (start == str.length())\n\t{\n\t\tminCnt = Math.min(cnt, minCnt);\n\t}\n\tfor (int len = 1;\n\t\t\tlen <= (str.length() - start); len++)\n\t{\n\t\tString subStr = str.substring(start, start + len);\n\t\tif (uSet.contains(subStr))\n\t\t{\n\t\t\tfindSubStr(str, cnt + 1, start + len);\n\t\t}\n\t}\n}\nstatic void findMinSubStr(String arr[], int n, String str)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tuSet.add(arr[i]);\n\tfindSubStr(str, 0, 0);\n}", "7851": "static int countSubStr(String s, int n)\n\t{\n\t\tint c1 = 0, c2 = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (i < n - 5 &&\n\t\t\t\t\"geeks\".equals(s.substring(i, i + 5)))\n\t\t\t{\n\t\t\t\tc1++;\n\t\t\t}\n\t\t\tif (i < n - 3 &&\n\t\t\t\t\"for\".equals(s.substring(i, i + 3)))\n\t\t\t{\n\t\t\t\tc2 = c2 + c1;\n\t\t\t}\n\t\t}\n\t\treturn c2;\n\t}", "7861": "public static void findWord(String c, int n)\n{\n\tint co = 0, i;\n\tchar s[] = new char[n];\n\tfor (i = 0; i < n ; i++)\n\t{\n\t\tif (i < n / 2)\n\t\t\tco++;\n\t\telse\n\t\t\tco = n - i;\n\t\tif ((c.charAt(i) + co) <= 122)\n\t\t\ts[i] = (char)((int)c.charAt(i) + co);\n\t\telse\n\t\t\ts[i] = (char)((int)c.charAt(i) + co - 26);\n\t}\n\tString str = Arrays.toString(s);\n\tSystem.out.println(str);\n}", "7864": "", "7868": "static String encryptStr(String str, int n, int x)\n\t{\n\t\tx = x % MAX;\n\t\tchar arr[] = str.toCharArray();\n\t\tint freq[] = new int[MAX];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfreq[arr[i] - 'a']++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (freq[arr[i] - 'a'] % 2 == 0) {\n\t\t\t\tint pos = (arr[i] - 'a' + x) % MAX;\n\t\t\t\tarr[i] = (char)(pos + 'a');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint pos = (arr[i] - 'a' - x);\n\t\t\t\tif (pos < 0)\n\t\t\t\t\tpos += MAX;\n\t\t\t\tarr[i] = (char)(pos + 'a');\n\t\t\t}\n\t\t}\n\t\treturn String.valueOf(arr);\n\t}", "7889": "static void getOrgString(String s)\n\t{\n\t\tSystem.out.print(s.charAt(0));\n\t\tint i = 1;\n\t\twhile (i < s.length())\n\t\t{\n\t\t\tif (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z')\n\t\t\t\tSystem.out.print(\" \"+ Character.toLowerCase(s.charAt(i)));\n\t\t\telse\n\t\t\t\tSystem.out.print(s.charAt(i));\n\t\t\ti++;\n\t\t}\n\t}", "7892": "static boolean isPossible(char[] str)\n\t{\n\t\tMap<Character, Integer> freq = new HashMap<>();\n\t\tint max_freq = 0;\n\t\tfor (int j = 0; j < (str.length); j++) {\n\t\t\tif (freq.containsKey(str[j])) {\n\t\t\t\tfreq.put(str[j], freq.get(str[j]) + 1);\n\t\t\t\tif (freq.get(str[j]) > max_freq)\n\t\t\t\t\tmax_freq = freq.get(str[j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfreq.put(str[j], 1);\n\t\t\t\tif (freq.get(str[j]) > max_freq)\n\t\t\t\t\tmax_freq = freq.get(str[j]);\n\t\t\t}\n\t\t}\n\t\tif (max_freq <= (str.length - max_freq + 1))\n\t\t\treturn true;\n\t\treturn false;\n\t}", "7899": "static void printUncommon(String str1, String str2)\n\t{\n\t\tint a1 = 0, a2 = 0;\n\t\tfor (int i = 0; i < str1.length(); i++)\n\t\t{\n\t\t\tint ch = (str1.charAt(i)) - 'a';\n\t\t\ta1 = a1 | (1 << ch);\n\t\t}\n\t\tfor (int i = 0; i < str2.length(); i++)\n\t\t{\n\t\t\tint ch = (str2.charAt(i)) - 'a';\n\t\t\ta2 = a2 | (1 << ch);\n\t\t}\n\t\tint ans = a1 ^ a2;\n\t\tint i = 0;\n\t\twhile (i < 26)\n\t\t{\n\t\t\tif (ans % 2 == 1)\n\t\t\t{\n\t\t\t\tSystem.out.print((char) ('a' + i));\n\t\t\t}\n\t\t\tans = ans / 2;\n\t\t\ti++;\n\t\t}\n\t}", "7900": "static boolean isPalin(int i, int j, int k, int l, int p, int q, String s)\n\t{\n\t\tint start = i, end = q;\n\t\twhile (start < end) {\n\t\t\tif (s.charAt(start) != s.charAt(end))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstart++;\n\t\t\tif (start == j + 1)\n\t\t\t{\n\t\t\t\tstart = k;\n\t\t\t}\n\t\t\tend--;\n\t\t\tif (end == p - 1)\n\t\t\t{\n\t\t\t\tend = l;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\nstatic int countSubStr(String s)\n\t{\n\t\tint count = 0;\n\t\tint n = s.length();\n\t\tfor (int i = 0; i < n - 2; i++)\n\t\t{\n\t\t\tfor (int j = i; j < n - 2; j++)\n\t\t\t{\n\t\t\t\tfor (int k = j + 1; k < n - 1; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = k; l < n - 1; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int p = l + 1; p < n; p++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int q = p; q < n; q++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isPalin(i, j, k, l, p, q, s))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "7938": "static boolean equalIgnoreCase(String str1, String str2)\n{\n\tint i = 0;\n\tint len1 = str1.length();\n\tint len2 = str2.length();\n\tif (len1 != len2)\n\t\treturn false;\n\twhile (i < len1)\n\t{\n\t\tif (str1.charAt(i) == str2.charAt(i))\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse if (!((str1.charAt(i) >= 'a' && str1.charAt(i) <= 'z')\n\t\t\t\t|| (str1.charAt(i) >= 'A' && str1.charAt(i) <= 'Z')))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if (!((str2.charAt(i) >= 'a' && str2.charAt(i) <= 'z')\n\t\t\t\t|| (str2.charAt(i) >= 'A' && str2.charAt(i) <= 'Z')))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (str1.charAt(i) >= 'a' && str1.charAt(i) <= 'z')\n\t\t\t{\n\t\t\t\tif (str1.charAt(i) - 32 != str2.charAt(i))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (str1.charAt(i) >= 'A' && str1.charAt(i) <= 'Z')\n\t\t\t{\n\t\t\t\tif (str1.charAt(i) + 32 != str2.charAt(i))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\treturn true;\nstatic void equalIgnoreCaseUtil(String str1, String str2)\n{\n\tboolean res = equalIgnoreCase(str1, str2);\n\tif (res == true)\n\t\tSystem.out.println( \"Same\" );\n\telse\n\t\tSystem.out.println( \"Not Same\" );\n}\npublic static void main(String args[])\n{\n\tString str1, str2;\n\tstr1 = \"Geeks\";\n\tstr2 = \"geeks\";\n\tequalIgnoreCaseUtil(str1, str2);\n\tstr1 = \"Geek\";\n\tstr2 = \"geeksforgeeks\";\n\tequalIgnoreCaseUtil(str1, str2);\n}\n}", "7939": "static boolean equalIgnoreCase(String str1, String str2)\n\t{\n\t\tint i = 0;\n\t\tstr1 = str1.toUpperCase();\n\t\tstr2 = str2.toUpperCase();\n\t\tint x = str1.compareTo(str2);\n\t\tif (x != 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\nstatic void equalIgnoreCaseUtil(String str1, String str2)\n\t{\n\t\tboolean res = equalIgnoreCase(str1, str2);\n\t\tif (res == true)\n\t\t{\n\t\t\tSystem.out.println(\"Same\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(\"Not Same\");\n\t\t}\n\t}", "7940": "static boolean equalIgnoreCase(String str1, String str2)\n{\n\tint i = 0;\n\tstr1 = str1.toLowerCase();\n\tstr2 = str2.toLowerCase();\n\tint x = str1.compareTo(str2);\n\treturn x == 0;\n}\nstatic void equalIgnoreCaseUtil(String str1, String str2)\n{\n\tboolean res = equalIgnoreCase(str1, str2);\n\tif (res == true)\n\t\tSystem.out.println(\"Same\");\n\telse\n\t\tSystem.out.println(\"Not Same\");\n}", "7966": "static int countMinReversals(String expr)\n{\n\tint len = expr.length();\n\tif (len % 2 != 0)\n\t\treturn -1;\n\tint ans = 0;\n\tint i;\n\tint open = 0;\n\tint close = 0;\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tif (expr.charAt(i) == '{')\n\t\t\topen++;\n\t\telse\n\t\t{\n\t\t\tif (open == 0)\n\t\t\t\tclose++;\n\t\t\telse\n\t\t\t\topen--;\n\t\t}\n\t}\n\tans = (close / 2) + (open / 2);\n\tclose %= 2;\n\topen %= 2;\n\tif (close != 0)\n\t\tans += 2;\n\treturn ans;\n}", "7977": "static int totalPairs(String s1, String s2)\n\t{\n\t\tint a1 = 0, b1 = 0;\n\t\tfor (int i = 0; i < s1.length(); i++)\n\t\t{\n\t\t\tif ((int)s1.charAt(i) % 2 != 0)\n\t\t\t\ta1++;\n\t\t\telse\n\t\t\t\tb1++;\n\t\t}\n\t\tint a2 = 0, b2 = 0;\n\t\tfor (int i = 0; i < s2.length(); i++)\n\t\t{\n\t\t\tif ((int)s2.charAt(i) % 2 != 0)\n\t\t\t\ta2++;\n\t\t\telse\n\t\t\t\tb2++;\n\t\t}\n\t\treturn ((a1 * a2) + (b1 * b2));\n\t}", "7978": "static String replaceConsonants(String str)\n\t{\n\t\tString res = \"\";\n\t\tint i = 0, count = 0;\n\t\twhile (i < str.length()) {\n\t\t\tif (str.charAt(i) != 'a'\n\t\t\t\t&& str.charAt(i) != 'e'\n\t\t\t\t&& str.charAt(i) != 'i'\n\t\t\t\t&& str.charAt(i) != 'o'\n\t\t\t\t&& str.charAt(i) != 'u') {\n\t\t\t\ti++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (count > 0)\n\t\t\t\t\tres += count;\n\t\t\t\tres += str.charAt(i);\n\t\t\t\ti++;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\tif (count > 0)\n\t\t\tres += count;\n\t\treturn res;\n\t}", "7979": "static int prefixOccurrences(String str)\n{\n\tchar c = str.charAt(0);\n\tint countc = 0;\n\tfor (int i = 0; i < str.length(); i++)\n\t{\n\t\tif (str.charAt(i) == c)\n\t\t\tcountc++;\n\t}\n\treturn countc;\n}", "7989": "static int minOperations(String s, String t, int n)\n{\n\tint ct0 = 0, ct1 = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s.charAt(i) == t.charAt(i))\n\t\t\tcontinue;\n\t\tif (s.charAt(i) == '0')\n\t\t\tct0++;\n\t\telse\n\t\t\tct1++;\n\t}\n\treturn Math.max(ct0, ct1);\n}", "7991": "static String maxValue(char []a, char []b)\n{\n\tArrays.sort(b);\n\tint n = a.length;\n\tint m = b.length;\n\tint j = m - 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (j < 0)\n\t\t\tbreak;\n\t\tif (b[j] > a[i]) {\n\t\t\ta[i] = b[j];\n\t\t\tj--;\n\t\t}\n\t}\n\treturn String.valueOf(a);\n}", "8004": "static String decryptString(String str, int n)\n{\n\tint i = 0, jump = 1;\n\tString decryptedStr = \"\";\n\twhile (i < n)\n\t{\n\t\tdecryptedStr += str.charAt(i);\n\t\ti += jump;\n\t\tjump++;\n\t}\n\treturn decryptedStr;\n}", "8015": "static void steps(String str, int n)\n{\n\tboolean flag = false;\n\tint x = 0;\n\tfor (int i = 0; i < str.length(); i++) {\n\t\tif (x == 0)\n\t\t\tflag = true;\n\t\tif (x == n - 1)\n\t\t\tflag = false;\n\t\tfor (int j = 0; j < x; j++)\n\t\t\tSystem.out.print(\"*\");\n\t\tSystem.out.print(str.charAt(i)+\"\\n\");\n\t\tif (flag == true)\n\t\t\tx++;\n\t\telse\n\t\t\tx--;\n\t}\n}", "8054": "static char bitToBeFlipped(String s)\n{\n\tchar last = s.charAt(s.length() - 1);\n\tchar first = s.charAt(0);\n\tif (last == first) {\n\t\tif (last == '0') {\n\t\t\treturn '1';\n\t\t}\n\t\telse {\n\t\t\treturn '0';\n\t\t}\n\t}\n\telse if (last != first) {\n\t\treturn last;\n\t}\n\treturn last;\n}", "8061": "static void SieveOfEratosthenes(boolean prime[], int p_size)\n\t{\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\t\tfor (int p = 2; p * p <= p_size; p++)\n\t\t{\n\t\t\tif (prime[p])\n\t\t\t{\n\t\t\t\tfor (int i = p * 2; i < p_size; i += p)\n\t\t\t\t{\n\t\t\t\t\tprime[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nstatic void sumProdOfPrimeFreq(char[] s)\n\t{\n\t\tboolean[] prime = new boolean[s.length + 1];\n\t\tArrays.fill(prime, true);\n\t\tSieveOfEratosthenes(prime, s.length + 1);\n\t\tint i, j;\n\t\tMap<Character, Integer> mp = new HashMap<>();\n\t\tfor (i = 0; i < s.length; i++)\n\t\t{\n\t\t\tmp.put(s[i], mp.get(s[i]) == null ? 1 : mp.get(s[i]) + 1);\n\t\t}\n\t\tint sum = 0, product = 1;\n\t\tfor (Map.Entry<Character, Integer> it : mp.entrySet())\n\t\t{\n\t\t\tif (prime[it.getValue()])\n\t\t\t{\n\t\t\t\tsum += it.getValue();\n\t\t\t\tproduct *= it.getValue();\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(\"Sum = \" + sum);\n\t\tSystem.out.println(\"\\nProduct = \" + product);\n\t}", "8078": "static int countChar(String str, char x)\n{\n\tint count = 0;\n\tint n = 10;\n\tfor (int i = 0; i < str.length(); i++)\n\t\tif (str.charAt(i) == x)\n\t\t\tcount++;\n\tint repetitions = n / str.length();\n\tcount = count * repetitions;\n\tfor (int i = 0;\n\t\t\ti < n % str.length(); i++)\n\t{\n\t\tif (str.charAt(i) == x)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "8085": "public static boolean multipleOrFactor(String s1, String s2)\n\t{\n\t\tHashMap<Character, Integer> m1 = new HashMap<>();\n\t\tHashMap<Character, Integer> m2 = new HashMap<>();\n\t\tfor (int i = 0; i < s1.length(); i++)\n\t\t{\n\t\t\tif (m1.containsKey(s1.charAt(i)))\n\t\t\t{\n\t\t\t\tint x = m1.get(s1.charAt(i));\n\t\t\t\tm1.put(s1.charAt(i), ++x);\n\t\t\t}\n\t\t\telse\n\t\t\t\tm1.put(s1.charAt(i), 1);\n\t\t}\n\t\tfor (int i = 0; i < s2.length(); i++)\n\t\t{\n\t\t\tif (m2.containsKey(s2.charAt(i)))\n\t\t\t{\n\t\t\t\tint x = m2.get(s2.charAt(i));\n\t\t\t\tm2.put(s2.charAt(i), ++x);\n\t\t\t}\n\t\t\telse\n\t\t\t\tm2.put(s2.charAt(i), 1);\n\t\t}\n\t\tfor (HashMap.Entry<Character, Integer> entry : m1.entrySet())\n\t\t{\n\t\t\tif (!m2.containsKey(entry.getKey()))\n\t\t\t\tcontinue;\n\t\t\tif (m2.get(entry.getKey()) != null &&\n\t\t\t\t(m2.get(entry.getKey()) % entry.getValue() == 0\n\t\t\t\t|| entry.getValue() % m2.get(entry.getKey()) == 0))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}", "8099": "static boolean checkIfUnequal(int n, int q)\n\t{\n\t\tString s1 = Integer.toString(n);\n\t\tint a[] = new int[26];\n\t\tfor (int i = 0; i < s1.length(); i++)\n\t\t\ta[s1.charAt(i) - '0']++;\n\t\tint prod = n * q;\n\t\tString s2 = Integer.toString(prod);\n\t\tfor (int i = 0; i < s2.length(); i++)\n\t\t{\n\t\t\tif (a[s2.charAt(i) - '0'] > 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\nstatic int countInRange(int l, int r, int q)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (checkIfUnequal(i, q))\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "8110": "public static boolean is_possible(String s)\n\t{\n\t\tint l = s.length();\n\t\tint one = 0, zero = 0;\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\tif (s.charAt(i) == '0')\n\t\t\t\tzero++;\n\t\t\telse\n\t\t\t\tone++;\n\t\t}\n\t\tif (l % 2 == 0) \n\t\t\treturn (one == zero);\n\t\telse\n\t\t\treturn (Math.abs(one - zero) == 1);\n\t}", "8128": "static void solve(String s)\n\t{\n\t\tHashMap<Character, Integer> m = new HashMap<>();\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t{\n\t\t\tif(m.containsKey(s.charAt(i)))\n\t\t\t\t\t\tm.put(s.charAt(i),\n\t\t\t\t\t\tm.get(s.charAt(i)) + 1);\n\t\t\telse\n\t\t\t\tm.put(s.charAt(i), 1);\n\t\t}\n\t\tString new_string = \"\";\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t{\n\t\t\tif (m.get(s.charAt(i)) % 2 == 0)\n\t\t\t\tcontinue;\n\t\t\tnew_string = new_string + s.charAt(i);\n\t\t}\n\t\tSystem.out.println(new_string);\n\t}", "8167": "static void countFreq(int arr[], int n)\n{\n\tboolean []visited = new boolean[n];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (visited[i] == true)\n\t\t\tcontinue;\n\t\tint count = 1;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] == arr[j])\n\t\t\t{\n\t\t\t\tvisited[j] = true;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(arr[i] + \" \" + count);\n\t}\n}", "8168": "static void countFreq(int arr[], int n, int limit)\n{\n\tint []count = new int[limit + 1];\n\tfor (int i = 0; i < n; i++)\n\t\tcount[arr[i]]++;\n\tfor (int i = 0; i <= limit; i++)\n\tif (count[i] > 0)\n\t\t\tSystem.out.println(i + \" \" + count[i]);\n}", "8169": "static void countFreq(String str)\n{\n\tint []count= new int[limit + 1];\n\tfor (int i = 0; i < str.length(); i++)\n\t\tcount[str.charAt(i)]++;\n\tfor (int i = 0; i <= limit; i++)\n\tif (count[i] > 0)\n\t\tSystem.out.println((char)i + \" \" + count[i]);\n}", "8184": "static int __builtin_popcount(int n)\n\t{\n\t\tint count = 0;\n\t\twhile (n > 0) {\n\t\t\tcount += n & 1;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn count;\n\t}\nstatic void countEvenOdd(int arr[], int n, int K)\n\t{\n\t\tint even = 0, odd = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = __builtin_popcount(arr[i]);\n\t\t\tif (x % 2 == 0)\n\t\t\t\teven++;\n\t\t\telse\n\t\t\t\todd++;\n\t\t}\n\t\tint y;\n\t\ty = __builtin_popcount(K);\n\t\tif ((y & 1) != 0) {\n\t\t\tSystem.out.println(\"Even = \"+ odd + \", Odd = \" + even);\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Even = \" + even + \", Odd = \" + odd);\n\t\t}\n\t}", "8213": "static boolean check(String s, int m)\n{\n\tint l = s.length();\n\tint c1 = 0;\n\tint c2 = 0;\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tif (s.charAt(i) == '0')\n\t\t{\n\t\t\tc2 = 0;\n\t\t\tc1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc1 = 0;\n\t\t\tc2++;\n\t\t}\n\t\tif (c1 == m c2 == m)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "8241": "static boolean isDivisible(String str, int k)\n\t{\n\t\tint n = str.length();\n\t\tint c = 0;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tif (str.charAt(n - i - 1) == '0')\t\t\n\t\t\t\tc++;\n\t\treturn (c == k);\n\t}", "8281": "static int productAtKthLevel(String tree, int k)\n\t{\n\t\tint level = -1;\n\t\tint product = 1;\n\t\tint n = tree.length();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (tree.charAt(i) == '(')\n\t\t\t\tlevel++;\n\t\t\telse if (tree.charAt(i) == ')')\n\t\t\t\tlevel--;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (level == k)\n\t\t\t\t\tproduct *= (tree.charAt(i) - '0');\n\t\t\t}\n\t\t}\n\t\treturn product;\n\t}", "8296": "static boolean isPalindrome(String str)\n\t{\n\t\tint i = 0, j = str.length() - 1;\n\t\twhile (i < j)\n\t\t{\n\t\t\tif (str.charAt(i++) != str.charAt(j--))\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\nstatic String removePalinWords(String str)\n\t{\n\t\tString final_str = \"\", word = \"\";\n\t\tstr = str + \" \";\n\t\tint n = str.length();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (str.charAt(i) != ' ')\n\t\t\tword = word + str.charAt(i);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!(isPalindrome(word)))\n\t\t\t\t\tfinal_str += word + \" \";\n\t\t\t\tword = \"\";\n\t\t\t}\n\t\t}\n\t\treturn final_str;\n\t}", "8301": "static int findSubSequence(String s, int num)\n\t{\n\t\tint res = 0;\n\t\tint i = 0;\n\t\twhile (num > 0) {\n\t\t\tif ((num & 1) == 1)\n\t\t\t\tres += s.charAt(i) - '0';\n\t\t\ti++;\n\t\t\tnum = num >> 1;\n\t\t}\n\t\treturn res;\n\t}\nstatic int combinedSum(String s)\n\t{\n\t\tint n = s.length();\n\t\tint c_sum = 0;\n\t\tint range = (1 << n) - 1;\n\t\tfor (int i = 0; i <= range; i++)\n\t\t\tc_sum += findSubSequence(s, i);\n\t\treturn c_sum;\n\t}", "8304": "static void findSubsequence(String str, int k)\n\t{\n\t\tint a[] = new int[MAX_CHAR];\n\t\tfor (int i = 0; i < str.length(); i++)\n\t\t\ta[str.charAt(i) - 'a']++;\n\t\tfor (int i = 0; i < str.length(); i++)\n\t\t\tif (a[str.charAt(i) - 'a'] >= k)\n\t\t\t\tSystem.out.print(str.charAt(i));\n\t}", "8310": "static void findDuplciates(String []a, int n, int m)\n\t{\n\t\tboolean [][]isPresent = new boolean[n] [m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tisPresent[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[i].charAt(j)== a[k].charAt(j) && i != k)\n\t\t\t\t\t{\n\t\t\t\t\t\tisPresent[i][j] = true;\n\t\t\t\t\t\tisPresent[k][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < m; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[i].charAt(j)== a[i].charAt(k) && j != k)\n\t\t\t\t\t{\n\t\t\t\t\t\tisPresent[i][j] = true;\n\t\t\t\t\t\tisPresent[i][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tif (isPresent[i][j]==false)\n\t\t\t\t\tSystem.out.print(a[i].charAt(j));\n\t}", "8315": "static String convert(String str)\n\t{\n\t\tString w = \"\", z = \"\";\n\t\tstr = str.toUpperCase() + \" \";\n\t\tfor (int i = 0; i < str.length(); i++)\n\t\t{\n\t\t\tchar ch = str.charAt(i);\n\t\t\tif (ch != ' ')\n\t\t\t\tw = w + ch;\n\t\t\telse {\n\t\t\t\tz = z + (Character.toLowerCase(w.charAt(0))) +\n\t\t\t\t\t\tw.substring(1) + \" \";\n\t\t\t\tw = \"\";\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}", "8316": "static String convert(String s)\n\t{\n\t\tint n = s.length();\n\t\tString s1 = \"\";\n\t\ts1 = s1 + Character.toLowerCase(s.charAt(0));\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (s.charAt(i) == ' ' && i < n)\n\t\t\t{\n\t\t\t\ts1 = s1 + \" \" + Character.toLowerCase\n\t\t\t\t\t\t\t\t(s.charAt(i + 1));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\ts1= s1 + Character.toUpperCase(s.charAt(i));\n\t\t}\n\t\treturn s1;\n\t}", "8317": "public static String change_case(String a)\n\t{\n\t\tString temp = \"\";\n\t\tint l = a.length();\n\t\tfor(int i = 0 ; i < l ; i++)\n\t\t{\n\t\t\tchar ch=a.charAt(i);\n\t\t\tif(ch >= 'a' &&ch <= 'z')\n\t\t\tch = (char)(65 + (int)(ch - 'a'));\n\t\t\telse if(ch >= 'A' &&ch <= 'Z')\n\t\t\tch = (char)(97 +\n\t\t\t\t(int)(ch - 'A'));\n\t\t\ttemp += ch;\n\t\t}\n\t\treturn temp;\n\t}\npublic static String delete_vowels(String a)\n\t{\n\t\tString temp = \"\";\n\t\tint l = a.length();\n\t\tfor(int i = 0 ; i < l ; i++)\n\t\t{\n\t\t\tchar ch = a.charAt(i);\n\t\t\tif(ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' && ch != 'A' && ch != 'E' && ch != 'O' && ch != 'U'&&ch != 'I')\n\t\t\t\ttemp += ch;\n\t\t}\n\t\treturn temp;\n\t}\npublic static String insert_hash(String a)\n\t{\n\t\tString temp = \"\";\n\t\tint l = a.length();\n\t\tchar hash = '#';\n\t\tfor(int i = 0 ; i < l ; i++)\n\t\t{\n\t\t\tchar ch=a.charAt(i);\n\t\t\tif((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= 'A' && ch <= 'Z'))\n\t\t\t\ttemp = temp + hash + ch;\n\t\t\telse\n\t\t\t\ttemp = temp + ch;\n\t\t}\n\t\treturn temp;\n\t}\npublic static void transformString(String a)\n\t{\n\t\tString b = delete_vowels(a);\n\t\tString c = change_case(b);\n\t\tString d = insert_hash(c);\n\t\tSystem.out.println(d);\n\t}", "8366": "static boolean isVowel(char c) {\n\t\treturn (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');\n\t}\nstatic String encryptString(String s, int n, int k) {\n\t\tint countVowels = 0;\n\t\tint countConsonants = 0;\n\t\tString ans = \"\";\n\t\tfor (int l = 0; l <= n - k; l++) {\n\t\t\tcountVowels = 0;\n\t\t\tcountConsonants = 0;\n\t\t\tfor (int r = l; r <= l + k - 1; r++) {\n\t\t\t\tif (isVowel(s.charAt(r)) == true) {\n\t\t\t\t\tcountVowels++;\n\t\t\t\t} else {\n\t\t\t\t\tcountConsonants++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += String.valueOf(countVowels * countConsonants);\n\t\t}\n\t\treturn ans;\n\t}", "8367": "static boolean isVowel(char c)\n\t{\n\t\treturn (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');\n\t}\nstatic String encryptString(char[] s, int n, int k)\n\t{\n\t\tint[] cv = new int[n];\n\t\tint[] cc = new int[n];\n\t\tif (isVowel(s[0]))\n\t\t\tcv[0] = 1;\n\t\telse\n\t\t\tcc[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tcv[i] = cv[i - 1] + (isVowel(s[i]) == true ? 1 : 0);\n\t\t\tcc[i] = cc[i - 1] + (isVowel(s[i]) == true ? 0 : 1);\n\t\t}\n\t\tString ans = \"\";\n\t\tint prod = 0;\n\t\tprod = cc[k - 1] * cv[k - 1];\n\t\tans += String.valueOf(prod);\n\t\tfor (int i = k; i < s.length; i++)\n\t\t{\n\t\t\tprod = (cc[i] - cc[i - k]) *\n\t\t\t\t(cv[i] - cv[i - k]);\n\t\t\tans += String.valueOf(prod);\n\t\t}\n\t\treturn ans;\n\t}", "8374": "static int countOccurrences(String str, String word)\n{\n\tString a[] = str.split(\" \");\n\tint count = 0;\n\tfor (int i = 0; i < a.length; i++)\n\t{\n\tif (word.equals(a[i]))\n\t\tcount++;\n\t}\n\treturn count;\n}", "8396": "static boolean isValidISBN(String isbn)\n\t{\n\t\tint n = isbn.length();\n\t\tif (n != 10)\n\t\t\treturn false;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tint digit = isbn.charAt(i) - '0';\n\t\t\tif (0 > digit 9 < digit)\n\t\t\t\treturn false;\n\t\t\tsum += (digit * (10 - i));\n\t\t}\n\t\tchar last = isbn.charAt(9);\n\t\tif (last != 'X' && (last < '0' last > '9'))\n\t\t\treturn false;\n\t\tsum += ((last == 'X') ? 10 : (last - '0'));\n\t\treturn (sum % 11 == 0);\n\t}", "8439": "static void printInitials(String name)\n\t{\n\t\tif (name.length() == 0)\n\t\t\treturn;\n\t\tString words[] = name.split(\" \");\n\t\tfor(String word : words) {\n\t\t\tSystem.out.print(Character.toUpperCase(word.charAt(0)) + \" \");\n\t\t}\n\t}", "8460": "static boolean canFormPalindrome(String str)\n\t{\n\t\tint[] count = new int[NO_OF_CHARS];\n\t\tfor (int i = 0; i < str.length(); i++)\n\t\t\tcount[str.charAt(i)]++;\n\t\tint odd = 0;\n\t\tfor (int i = 0; i < NO_OF_CHARS; i++) {\n\t\t\tif ((count[i] & 1) != 0)\n\t\t\t\todd++;\n\t\t\tif (odd > 1)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}", "8490": "static void permute(String input)\n\t{\n\t\tint n = input.length();\n\t\tint max = 1 << n;\n\t\tinput = input.toLowerCase();\n\t\tfor(int i = 0;i < max; i++)\n\t\t{\n\t\t\tchar combination[] = input.toCharArray();\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif(((i >> j) & 1) == 1)\n\t\t\t\t\tcombination[j] = (char) (combination[j]-32);\n\t\t\t}\n\t\t\tSystem.out.print(combination);\n\t\t\tSystem.out.print(\" \");\n\t\t}\n\t}", "8501": "static boolean isNumber(String s)\n\t{\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t\tif (Character.isDigit(s.charAt(i)) == false)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "8506": "static void printString(String str, char ch, int count)\n\t{\n\t\tint occ = 0, i;\n\t\tif (count == 0) {\n\t\t\tSystem.out.println(str);\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 0; i < str.length(); i++) {\n\t\t\tif (str.charAt(i) == ch)\n\t\t\t\tocc++;\n\t\t\tif (occ == count)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < str.length() - 1)\n\t\t\tSystem.out.println(str.substring(i + 1));\n\t\telse\n\t\t\tSystem.out.println(\"Empty string\");\n\t}", "8527": "static boolean isVowel(char c) {\n\t\treturn (c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U');\n\t}\nstatic String reverseVowel(String str1) {\n\t\tint j = 0;\n\t\tchar[] str = str1.toCharArray();\n\t\tString vowel = \"\";\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tif (isVowel(str[i])) {\n\t\t\t\tj++;\n\t\t\t\tvowel += str[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tif (isVowel(str[i])) {\n\t\t\t\tstr[i] = vowel.charAt(--j);\n\t\t\t}\n\t\t}\n\t\treturn String.valueOf(str);\n\t}", "8528": "static boolean isVowel(char c) {\n\t\treturn (c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U');\n\t}\nstatic String reverseVowel(String str) {\n\tint i = 0;\n\tint j = str.length()-1;\n\tchar[] str1 = str.toCharArray();\n\twhile (i < j)\n\t{\n\t\tif (!isVowel(str1[i]))\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isVowel(str1[j]))\n\t\t{\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\t\tchar t = str1[i];\n\t\tstr1[i]= str1[j];\n\t\tstr1[j]= t;\n\t\ti++;\n\t\tj--;\n\t}\n\tString str2 = String.copyValueOf(str1);\n\treturn str2;\n}", "8538": "static String firstLetterWord(String str)\n\t{\n\t\tString result = \"\";\n\t\tboolean v = true;\n\t\tfor (int i = 0; i < str.length(); i++)\n\t\t{\n\t\t\tif (str.charAt(i) == ' ')\n\t\t\t{\n\t\t\t\tv = true;\n\t\t\t}\n\t\t\telse if (str.charAt(i) != ' ' && v == true)\n\t\t\t{\n\t\t\t\tresult += (str.charAt(i));\n\t\t\t\tv = false;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "8539": "public static String processWords(String input)\n {\n\t\tString s[] = input.split(\"(\\\\s)+\");\n\t\tfor(String values : s)\n\t\t{\n\t\t\tcharBuffer.append(values.charAt(0));\n\t\t}\n\treturn charBuffer.toString();\n }", "8577": "static char largest_alphabet(String a, int n)\n\t{\n\t\tchar max = 'A';\n\t\tfor (int i=0; i<n; i++) \n\t\t\tif (a.charAt(i) > max)\n\t\t\t\tmax = a.charAt(i); \n\t\treturn max;\n\t}\nstatic char smallest_alphabet(String a, int n)\n\t{\n\t\tchar min = 'z';\n\t\tfor (int i=0; i<n-1; i++) \n\t\t\tif (a.charAt(i) < min)\n\t\t\t\tmin = a.charAt(i); \n\t\treturn min;\n\t}", "8615": "static String maximumPalinUsingKChanges(String str, int k)\n {\n\tchar palin[] = str.toCharArray();\n\tString ans = \"\";\n\tint l = 0;\n\tint r = str.length() - 1;\n\twhile (l < r) {\n\tif (str.charAt(l) != str.charAt(r)) {\n\t\tpalin[l] = palin[r] = (char)Math.max(\n\t\tstr.charAt(l), str.charAt(r));\n\t\tk--;\n\t}\n\tl++;\n\tr--;\n\t}\n\tif (k < 0) {\n\treturn \"Not possible\";\n\t}\n\tl = 0;\n\tr = str.length() - 1;\n\twhile (l <= r) {\n\tif (l == r) {\n\t\tif (k > 0) {\n\t\tpalin[l] = '9';\n\t\t}\n\t}\n\tif (palin[l] < '9') {\n\t\tif (k >= 2 && palin[l] == str.charAt(l)\n\t\t\t&& palin[r] == str.charAt(r)) {\n\t\tk -= 2;\n\t\tpalin[l] = palin[r] = '9';\n\t\t}\n\t\telse if (k >= 1\n\t\t\t\t&& (palin[l] != str.charAt(l)\n\t\t\t\t\t|| palin[r]\n\t\t\t\t\t!= str.charAt(r))) {\n\t\tk--;\n\t\tpalin[l] = palin[r] = '9';\n\t\t}\n\t}\n\tl++;\n\tr--;\n\t}\n\tfor (int i = 0; i < palin.length; i++)\n\tans += palin[i];\n\treturn ans;\n }", "8636": "public static String toString(char[] a) {\n\t\tString string = new String(a);\n\t\treturn string;\n\t}\nstatic void generate(int k, char[] ch, int n) {\n\t\tif (n == k) {\n\t\t\tSystem.out.print(toString(ch)+\" \");\n\t\t\treturn;\n\t\t}\n\t\tif (ch[n - 1] == '0') {\n\t\t\tch[n] = '0';\n\t\t\tgenerate(k, ch, n + 1);\n\t\t\tch[n] = '1';\n\t\t\tgenerate(k, ch, n + 1);\n\t\t}\n\t\tif (ch[n - 1] == '1') {\n\t\t\tch[n] = '0';\n\t\t\tgenerate(k, ch, n + 1);\n\t\t}\n\t}\nstatic void fun(int k) {\n\t\tif (k <= 0) {\n\t\t\treturn;\n\t\t}\n\t\tchar[] ch = new char[k];\n\t\tch[0] = '0';\n\t\tgenerate(k, ch, 1);\n\t\tch[0] = '1';\n\t\tgenerate(k, ch, 1);\n\t}", "8702": "static int countTriplets(int []A)\n{\n\tint cnt = 0;\n\tHashMap<Integer,Integer> tuples = new HashMap<Integer,Integer>();\n\tfor (int a : A)\n\t\tfor (int b : A)\n\t\t{\n\t\t\tif(tuples.containsKey(a & b))\n\t\t\t\ttuples.put(a & b, tuples.get(a & b) + 1);\n\t\t\telse\n\t\t\t\ttuples.put(a & b, 1);\n\t\t}\n\tfor (int a : A)\n\t\tfor (Map.Entry<Integer, Integer> t : tuples.entrySet())\n\t\t\tif ((t.getKey() & a) == 0)\n\t\t\t\tcnt += t.getValue();\n\treturn cnt;\n}", "8705": "static boolean isPalindrome(String str)\n{\n\tint l = 0;\n\tint h = str.length() - 1;\n\twhile (h > l)\n\t\tif (str.charAt(l++) != str.charAt(h--))\n\t\t\treturn false;\n\treturn true;\n}\nstatic int minRemovals(String str)\n{\n\tif (str.charAt(0) == '')\n\t\treturn 0;\n\tif (isPalindrome(str))\n\t\treturn 1;\n\treturn 2;\n}", "8787": "", "8788": "public static String[] RevString(String[] s, int l)\n{\n\tif (l % 2 == 0)\n\t{\n\t\tint j = l / 2;\n\t\twhile (j <= l - 1)\n\t\t{\n\t\t\tString temp;\n\t\t\ttemp = s[l - j - 1];\n\t\t\ts[l - j - 1] = s[j];\n\t\t\ts[j] = temp;\n\t\t\tj += 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint j = (l / 2) + 1;\n\t\twhile (j <= l - 1)\n\t\t{\n\t\t\tString temp;\n\t\t\ttemp = s[l - j - 1];\n\t\t\ts[l - j - 1] = s[j];\n\t\t\ts[j] = temp;\n\t\t\tj += 1;\n\t\t}\n\t}\n\treturn s;\n}", "8795": "void reverse(String str)\n\t{\n\t\tif ((str==null)||(str.length() <= 1))\n\t\tSystem.out.println(str);\n\t\telse\n\t\t{\n\t\t\tSystem.out.print(str.charAt(str.length()-1));\n\t\t\treverse(str.substring(0,str.length()-1));\n\t\t}\n\t}", "8823": "public static double getProbability(int[] balls)\n\t{\n\t\tfactorial(10);\n\t\tbox2 = balls.length;\n\t\tint K = 0;\n\t\tfor (int i = 0; i < balls.length; i++)\n\t\t\tK += balls[i];\n\t\tif (K % 2 == 1)\n\t\t\treturn 0;\n\t\tlong all = comb(K, K / 2);\n\t\tlong validPermutations = validPermutations(K / 2, balls, 0, 0);\n\t\treturn (double)validPermutations / all;\n\t}\nstatic long validPermutations(int n, int[] balls, int usedBalls, int i)\n\t{\n\t\tif (usedBalls == n) {\n\t\t\treturn box1 == box2 ? 1 : 0;\n\t\t}\n\t\tif (i >= balls.length)\n\t\t\treturn 0;\n\t\tlong res = validPermutations(n, balls, usedBalls, i + 1);\n\t\tbox1++;\n\t\tfor (int j = 1; j <= balls[i]; j++) {\n\t\t\tif (j == balls[i])\n\t\t\t\tbox2--;\n\t\t\tlong combinations = comb(balls[i], j);\n\t\t\tres += combinations * validPermutations(n, balls, usedBalls + j, i + 1);\n\t\t}\n\t\tbox1--;\n\t\tbox2++;\n\t\treturn res;\n\t}\nstatic void factorial(int N)\n\t{\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= N; i++)\n\t\t\tfact[i] = fact[i - 1] * i;\n\t}\nstatic long comb(int n, int r)\n\t{\n\t\tlong res = fact[n] / fact[r];\n\t\tres /= fact[n - r];\n\t\treturn res;\n\t}", "8840": "static void parity(List<Integer> even, List<Integer> odd, List<Integer> v, int i) \n\t{ \n\t\tif (i == v.size() || even.size() == 0 && \n\t\t\todd.size() == 0) \n\t\t{\n\t\t\tint count = 0; \n\t\t\tfor(int j = 0; j < v.size() - 1; j++)\n\t\t\t{\n\t\t\t\tif (v.get(j) % 2 != v.get(j + 1) % 2) \n\t\t\t\t\tcount++; \n\t\t\t} \n\t\t\tif (count < min) \n\t\t\t\tmin = count; \n\t\t\treturn; \n\t\t} \n\t\tif (v.get(i) != -1) \n\t\t\tparity(even, odd, v, i + 1); \n\t\telse\n\t\t{\n\t\t\tif (even.size() != 0)\n\t\t\t{ \n\t\t\t\tint x = even.get(even.size() - 1); \n\t\t\t\teven.remove(even.size() - 1); \n\t\t\t\tv.set(i,x); \n\t\t\t\tparity(even, odd, v, i + 1); \n\t\t\t\teven.add(x); \n\t\t\t} \n\t\t\tif (odd.size() != 0)\n\t\t\t{ \n\t\t\t\tint x = odd.get(odd.size() - 1); \n\t\t\t\todd.remove(odd.size() - 1); \n\t\t\t\tv.set(i, x); \n\t\t\t\tparity(even, odd, v, i + 1); \n\t\t\t\todd.add(x); \n\t\t\t} \n\t\t} \n\t}\nstatic void minDiffParity(List<Integer> v, int n) \n\t{ \n\t\tList<Integer> even = new ArrayList<Integer>(); \n\t\tList<Integer> odd = new ArrayList<Integer>(); \n\t\tHashMap<Integer, Integer> m = new HashMap<>(); \n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (m.containsKey(i))\n\t\t\t{\n\t\t\t\tm.replace(i, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm.put(i, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < v.size(); i++)\n\t\t{ \n\t\t\tif (v.get(i) != -1) \n\t\t\t\tm.remove(v.get(i)); \n\t\t} \n\t\tfor (Map.Entry<Integer, Integer> i : m.entrySet()) \n\t\t{\n\t\t\tif (i.getKey() % 2 == 0) \n\t\t\t{\n\t\t\t\teven.add(i.getKey()); \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\todd.add(i.getKey());\n\t\t\t}\n\t\t}\n\t\tmin = 1000;\n\t\tparity(even, odd, v, 0); \n\t\tSystem.out.println(min); \n\t}", "8855": "static void dfs(int u, int count)\n{\n\tvisited[u] = true;\n\tint temp = 0;\n\tfor (int i = 0; i < adjacent.get(u).size(); i++)\n\t{\n\t\tif (!visited[adjacent.get(u).get(i)])\n\t\t{\n\t\t\ttemp++;\n\t\t\tdfs(adjacent.get(u).get(i), count + 1);\n\t\t}\n\t}\n\tif (temp == 0)\n\t{\n\t\tif (maxi < count)\n\t\t{\n\t\t\tmaxi = count;\n\t\t\tstartnode = u;\n\t\t}\n\t}\n}\nstatic void dfs1(int u, int count)\n{\n\tvisited[u] = true;\n\tint temp = 0;\n\tfor (int i = 0; i < adjacent.get(u).size(); i++)\n\t{\n\t\tif (!visited[adjacent.get(u).get(i)])\n\t\t{\n\t\t\ttemp++;\n\t\t\tparent[adjacent.get(u).get(i)] = u;\n\t\t\tdfs1(adjacent.get(u).get(i), count + 1);\n\t\t}\n\t}\n\tif (temp == 0)\n\t{\n\t\tif (maxi < count)\n\t\t{\n\t\t\tmaxi = count;\n\t\t\tendnode = u;\n\t\t}\n\t}\n}\nstatic void dfs2(int u, int count)\n{\n\tvisited[u] = true;\n\tint temp = 0;\n\tfor (int i = 0; i < adjacent.get(u).size(); i++)\n\t{\n\t\tif (!visited[adjacent.get(u).get(i)] &&\n\t\t\t!vis[adjacent.get(u).get(i)])\n\t\t{\n\t\t\ttemp++;\n\t\t\tdfs2(adjacent.get(u).get(i), count + 1);\n\t\t}\n\t}\n\tif (temp == 0)\n\t{\n\t\tif (maxi < count)\n\t\t{\n\t\t\tmaxi = count;\n\t\t\tthirdnode = u;\n\t\t}\n\t}\n}\nstatic void findNodes()\n{\n\tdfs(1, 0);\n\tfor (int i = 0; i <= N; i++)\n\t\tvisited[i] = false;\n\tmaxi = -1;\n\tdfs1(startnode, 0);\n\tfor (int i = 0; i <= N; i++)\n\t\tvisited[i] = false;\n\tint x = endnode;\n\tvis[startnode] = true;\n\twhile (x != startnode)\n\t{\n\t\tvis[x] = true;\n\t\tx = parent[x];\n\t}\n\tmaxi = -1;\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tif (vis[i])\n\t\t\tdfs2(i, 0);\n\t}\n}", "8858": "static void dfs(int i, int j, int[][] grid, boolean[][] vis, int z, int z_count)\n {\n\tint n = grid.length, m = grid[0].length;\n\tvis[i][j] = true;\n\tif (grid[i][j] == 0)\n\tz++;\n\tif (grid[i][j] == 2)\n\t{\n\tif (z == z_count)\n\t\tans++;\n\tvis[i][j] = false;\n\treturn;\n\t}\n\tif (i >= 1 && !vis[i - 1][j] && grid[i - 1][j] != -1)\n\tdfs(i - 1, j, grid, vis, z, z_count);\n\tif (i < n - 1 && !vis[i + 1][j] && grid[i + 1][j] != -1)\n\tdfs(i + 1, j, grid, vis, z, z_count);\n\tif (j >= 1 && !vis[i][j - 1] && grid[i][j - 1] != -1)\n\tdfs(i, j - 1, grid, vis, z, z_count);\n\tif (j < m - 1 && !vis[i][j + 1] && grid[i][j + 1] != -1)\n\tdfs(i, j + 1, grid, vis, z, z_count);\n\tvis[i][j] = false;\n }\nstatic int uniquePaths(int[][] grid)\n {\n\tint n = grid.length, m = grid[0].length;\n\tboolean[][] vis = new boolean[n][m];\n\tfor (int i = 0; i < n; i++)\n\t{\n\tArrays.fill(vis[i], false);\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\tfor (int j = 0; j < m; ++j)\n\t{\n\t\tif (grid[i][j] == 0)\n\t\tz_count++;\n\t\telse if (grid[i][j] == 1)\n\t\t{\n\t\tx = i;\n\t\ty = j;\n\t\t}\n\t}\n\t}\n\tdfs(x, y, grid, vis, 0, z_count);\n\treturn ans;\n }", "8907": "static int numPairs(int a[], int n)\n{\n\tint ans, i, index;\n\tans = 0;\n\tfor (i = 0; i < n; i++)\n\t\ta[i] = Math.abs(a[i]);\n\tArrays.sort(a);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tindex = 2;\n\t\tans += index - i - 1;\n\t}\n\treturn ans;\n}", "8939": "static int power(int x, int y, int p)\n\t{\n\t\tint res = 1;\n\t\tx = x % p;\n\t\twhile (y > 0)\n\t\t{\n\t\t\tif (y % 2 == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\nstatic int findModuloByM(int X, int N, int M)\n\t{\n\t\tif (N < 6)\n\t\t{\n\t\t\tString temp=\"\";\n\t\t\tfor(int i = 0; i< N ; i++)\n\t\t\t\ttemp = temp + (char)(X + 48);\n\t\t\tint res = Integer.parseInt(temp) % M;\n\t\t\treturn res;\n\t\t}\n\t\tif (N % 2 == 0)\n\t\t{\n\t\t\tint half = findModuloByM(X, N / 2, M) % M;\n\t\t\tint res = (half * power(10, N / 2, M) + half)\n\t\t\t\t\t% M;\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint half = findModuloByM(X, N / 2, M) % M;\n\t\t\tint res = (half * power(10, N / 2 + 1, M) + half * 10 + X)\n\t\t\t\t\t% M;\n\t\t\treturn res;\n\t\t}\n\t}", "9007": "static boolean check(circle C[])\n{\n\tdouble C1C2 = Math.sqrt(\n\t\t(C[1].x - C[0].x) * (C[1].x - C[0].x) +\n\t\t(C[1].y - C[0].y) * (C[1].y - C[0].y));\n\tboolean flag = false;\n\tif (C1C2 < (C[0].r + C[1].r))\n\t{\n\t\tif ((C[0].x + C[1].x) == 2 * C[2].x &&\n\t\t\t(C[0].y + C[1].y) == 2 * C[2].y)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t}\n\treturn flag;\n}\nstatic boolean IsFairTriplet(circle c[])\n{\n\tboolean f = false;\n\tf |= check(c);\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tswap(c[0], c[2]);\n\t\tf |= check(c);\n\t}\n\treturn f;\n}\nstatic void swap(circle circle1, circle circle2)\n{\n\tcircle temp = circle1;\n\tcircle1 = circle2;\n\tcircle2 = temp;\n}", "9009": "static double eccHyperbola(double A, double B)\n{\n\tdouble r = (double)B * B / A * A;\n\tr += 1;\n\treturn Math.sqrt(r);\n}", "9012": "static float calculateArea(float A, float B, float C, float D)\n{\n\tfloat S = (A + B + C + D) / 2;\n\tfloat area = (float)Math.sqrt((S - A) * (S - B) *\n\t\t\t\t\t\t\t\t(S - C) * (S - D));\n\treturn area;\n}", "9015": "static void triangleArea(int a, int b)\n{\n\tdouble ratio = (double)b / a;\n\tSystem.out.println(ratio);\n}", "9021": "static float distance(int m, int n, int p, int q)\n{\n\treturn (float)Math.sqrt(Math.pow(n - m, 2) +\n\t\t\t\t\t\t\tMath.pow(q - p, 2) * 1.0);\n}\nstatic void Excenters(int x1, int y1, int x2, int y2, int x3, int y3)\n{\n\tfloat a = distance(x2, x3, y2, y3);\n\tfloat b = distance(x3, x1, y3, y1);\n\tfloat c = distance(x1, x2, y1, y2);\n\tpair[] excenter = new pair[4];\n\texcenter[1] = new pair((-(a * x1) + (b * x2) +\n\t\t\t\t\t\t\t(c * x3)) / (-a + b + c),\n\t\t\t\t\t\t(-(a * y1) + (b * y2) +\n\t\t\t\t\t\t\t(c * y3)) / (-a + b + c));\n\texcenter[2] = new pair(((a * x1) - (b * x2) +\n\t\t\t\t\t\t\t(c * x3)) / (a - b + c),\n\t\t\t\t\t\t((a * y1) - (b * y2) +\n\t\t\t\t\t\t\t(c * y3)) / (a - b + c));\n\texcenter[3] = new pair(((a * x1) + (b * x2) -\n\t\t\t\t\t\t\t(c * x3)) / (a + b - c),\n\t\t\t\t\t\t((a * y1) + (b * y2) -\n\t\t\t\t\t\t\t(c * y3)) / (a + b - c));\n\tfor(int i = 1; i <= 3; i++)\n\t{\n\t\tSystem.out.println((int)excenter[i].first + \" \" +\n\t\t\t\t\t\t(int)excenter[i].second);\n\t}\n}", "9035": "static void findHeight(float p1, float p2, float b, float c)\n{\n\tfloat a = Math.max(p1, p2) - Math.min(p1, p2);\n\tfloat s = (a + b + c) / 2;\n\tfloat area = (int)Math.sqrt(s * (s - a)\n\t\t\t\t\t* (s - b) * (s - c));\n\tfloat height = (area * 2) / a;\n\tSystem.out.print(\"Height is: \" + height);\n}", "9070": "static int areaOfSquare(int S)\n{\n\tint area = S * S;\n\treturn area;\n}", "9079": "static int maxPointOfIntersection(int x, int y)\n{\n\tint k = y * (y - 1) / 2;\n\tk = k + x * (2 * y + x - 1);\n\treturn k;\n}", "9113": "static int Icositetragonal_num(int n)\n{\n\treturn (22 * n * n - 20 * n) / 2;\n}", "9114": "static int Icosihenagonal_num(int n)\n{\n\treturn (19 * n * n - 17 * n) / 2;\n}", "9119": "static double area_of_circle(int m, int n) \n\t{ \n\t\tint square_of_radius = ( m * n ) / 4; \n\t\tdouble area = ( 3.141 * square_of_radius ); \n\t\treturn area; \n\t}", "9129": "static double area(int R) {\n\t\tdouble base = 1.732 * R;\n\t\tdouble height = (1.5) * R;\n\t\tdouble area = 0.5 * base * height;\n\t\treturn area;\n\t}", "9130": "static float circlearea(float R)\n\t{\n\t\tif (R < 0)\n\t\t\treturn -1;\n\t\tfloat a = (float)((3.14 * R * R) / 4);\n\t\treturn a;\n\t}", "9137": "static int countPairs(int []P, int []Q, int N, int M)\n{\n\tint []A = new int[2], B = new int[2];\n\tfor (int i = 0; i < N; i++)\n\t\tA[P[i] % 2]++;\n\tfor (int i = 0; i < M; i++)\n\t\tB[Q[i] % 2]++;\n\treturn (A[0] * B[0] + A[1] * B[1]);\n}", "9142": "static double[] find_Centroid(double v[][]) \n\t{ \n\t\tdouble []ans = new double[2]; \n\t\tint n = v.length; \n\t\tdouble signedArea = 0; \n\t\tfor (int i = 0; i < n; i++)\n\t\t{ \n\t\t\tdouble x0 = v[i][0], y0 = v[i][1]; \n\t\t\tdouble x1 = v[(i + 1) % n][0], y1 = v[(i + 1) % n][1]; \n\t\t\tdouble A = (x0 * y1) - (x1 * y0); \n\t\t\tsignedArea += A; \n\t\t\tans[0] += (x0 + x1) * A; \n\t\t\tans[1] += (y0 + y1) * A; \n\t\t} \n\t\tsignedArea *= 0.5; \n\t\tans[0] = (ans[0]) / (6 * signedArea); \n\t\tans[1]= (ans[1]) / (6 * signedArea); \n\t\treturn ans; \n\t}", "9147": "static int countIntersections(int n)\n\t{\n\t\treturn n * (n - 1) / 2;\n\t}", "9169": "static void newvol(double x)\n{\n\tSystem.out.print( \"percentage increase in the\"\n\t\t+ \" volume of the sphere is \"\n\t\t+( Math.pow(x, 3) / 10000 + 3 * x\n\t\t\t\t+ (3 * Math.pow(x, 2)) / 100) + \"%\");\n}", "9177": "static double areaOfTriangle(float d)\n\t{\n\t\tfloat c = (float) (1.618 * d);\n\t\tfloat s = (d + c + c) / 2;\n\t\tdouble area = Math.sqrt(s * (s - c)\n\t\t\t\t* (s - c) * (s - d));\n\t\treturn 5 * area;\n\t}\nstatic double areaOfRegPentagon(float d)\n\t{\n\t\tdouble cal = 4 * Math.tan(PI / 5);\n\t\tdouble area = (5 * d * d) / cal;\n\t\treturn area;\n\t}\nstatic double areaOfPentagram(float d)\n\t{\n\t\treturn areaOfRegPentagon(d)\n\t\t\t\t+ areaOfTriangle(d);\n\t}", "9181": "static void anglequichord(int z)\n{\n\tSystem.out.println (\"The angle is \" + z + \" degrees\");\n}", "9187": "static void circle(int x1, int y1, int x2, int y2, int r1, int r2) \n\t{ \n\t\tint distSq = (int)Math.sqrt(((x1 - x2) \n\t\t\t\t\t\t\t\t\t* (x1 - x2)) \n\t\t\t\t\t\t\t\t\t+ ((y1 - y2) \n\t\t\t\t\t\t\t\t\t* (y1 - y2))); \n\t\tif (distSq + r2 == r1) \n\t\t{\n\t\t\tSystem.out.println(\"The smaller circle lies completely\" + \" inside the bigger circle with \" + \"touching each other \" + \"at a point of circumference. \") ;\n\t\t}\n\t\telse if (distSq + r2 < r1) \n\t\t{\n\t\t\tSystem.out.println(\"The smaller circle lies completely\" + \" inside the bigger circle without\" + \" touching each other \" + \"at a point of circumference.\") ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(\"The smaller does not lies inside\" + \" the bigger circle completely.\") ;\n\t\t}\n\t}", "9195": "static void lengtang(double r1, double r2, double d)\n\t{\n\t\tSystem.out.println(\"The length of the direct\"\n\t\t\t\t+ \" common tangent is \"\n\t\t\t\t+ (Math.sqrt(Math.pow(d, 2) -\n\t\t\t\t\tMath.pow((r1 - r2), 2))));\n\t}", "9196": "static void rad(double d, double h)\n{\n\tSystem.out.println( \"The radius of the circle is \"\n\t\t+ ((d * d) / (8 * h) + h / 2));\n}", "9197": "static void shortdis(double r, double d)\n{\n\tSystem.out.println(\"The shortest distance \"\n\t\t+ \"from the chord to centre \"\n\t\t+ (Math.sqrt((r * r) - ((d * d) / 4))));\n}", "9200": "static void lengtang(double r1, double r2, double d)\n{\n\tSystem.out.println(\"The length of the direct\"\n\t\t+\" common tangent is \"\n\t\t+(Math.sqrt(Math.pow(d, 2) -\n\t\tMath.pow((r1 - r2), 2))));\n}", "9201": "static void length_of_chord(double r, double x)\n{\n\tSystem.out.println(\"The length of the chord\"\n\t\t+ \" of the circle is \"\n\t\t+ 2 * r * Math.sin(x * (3.14 / 180)));\n}", "9232": "static double square(double a)\n\t{\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tdouble x = 0.464 * a;\n\t\treturn x;\n\t}", "9238": "double polyapothem(double n, double a)\n\t{\n\t\tif (a < 0 && n < 0)\n\t\t\treturn -1;\n\t\treturn (a / (2 * java.lang.Math.tan((180 / n) * 3.14159 / 180)));\n\t}", "9240": "static double polyarea(double n, double r)\n\t{\n\t\tif (r < 0 && n < 0)\n\t\t\treturn -1;\n\t\tdouble A = ((r * r * n) * Math.sin((360 / n) * 3.14159 / 180)) / 2;\n\t\treturn A;\n\t}", "9241": "static float polyarea(float n, float a)\n{\n\tif (a < 0 && n < 0)\n\t\treturn -1;\n\tfloat A = (a * a * n) /(float) (4 * Math.tan((180 / n) * 3.14159 / 180));\n\treturn A;\n}", "9247": "static double hexDiagonal(float a)\n\t{\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tdouble d = (double)1.73 * a;\n\t\treturn d;\n\t}", "9250": "static double calculateSide(double n, double r)\n{\n\tdouble theta, theta_in_radians;\n\ttheta = 360 / n;\n\ttheta_in_radians = theta * 3.14 / 180;\n\treturn 2 * r * Math.sin(theta_in_radians / 2);\n}", "9257": "static float cyl(float r, float R, float h)\n{\n\tif (h < 0 && r < 0 && R < 0)\n\t\treturn -1;\n\tfloat r1 = r;\n\tfloat h1 = h;\n\tfloat V = (float)(3.14 * Math.pow(r1, 2) * h1);\n\treturn V;\n}", "9258": "static float findVolume(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat r = a / 2;\n\tfloat h = a;\n\tfloat V = (float)(3.14 * Math.pow(r, 2) * h);\n\treturn V;\n}", "9290": "static double Perimeter(double s, int n)\n\t{\n\t\tdouble perimeter = 1;\n\t\tperimeter = n * s;\n\t\treturn perimeter;\n\t}", "9291": "static float area(float r)\n{\n\treturn (float)((0.5)*(3.14)*(r * r));\n}\nstatic float perimeter(float r)\n{\n\treturn (float)((3.14)*(r));\n}", "9302": "", "9305": "static float rhombusarea(float l, float b)\n{\n\tif (l < 0 b < 0)\n\t\treturn -1;\n\treturn (l * b) / 2;\n}", "9318": "static float area(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat area = (float)Math.sqrt(a) / 6;\n\treturn area;\n}", "9329": "static double longestRodInCuboid(int length, int breadth, int height)\n{\n\tdouble result;\n\tint temp;\n\ttemp = length * length + breadth *\n\t\tbreadth + height * height;\n\tresult = Math.sqrt(temp);\n\treturn result;\n}", "9346": "static void is_partition_possible(int n, int x[], int y[], int w[])\n{\n\tMap<Integer, Integer> weight_at_x = new HashMap<Integer, Integer>();\n\tint max_x = (int) -2e3, min_x = (int) 2e3;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint new_x = x[i] - y[i];\n\t\tmax_x = Math.max(max_x, new_x);\n\t\tmin_x = Math.min(min_x, new_x);\n\t\tif(weight_at_x.containsKey(new_x))\n\t\t{\n\t\t\tweight_at_x.put(new_x, weight_at_x.get(new_x) + w[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tweight_at_x.put(new_x,w[i]);\n\t\t}\n\t}\n\tVector<Integer> sum_till = new Vector<>();\n\tsum_till.add(0);\n\tfor (int s = min_x; s <= max_x; s++)\n\t{\n\t\tif(weight_at_x.get(s) == null)\n\t\t\tsum_till.add(sum_till.lastElement());\n\t\telse\n\t\t\tsum_till.add(sum_till.lastElement() +\n\t\t\t\t\t\t\tweight_at_x.get(s));\n\t}\n\tint total_sum = sum_till.lastElement();\n\tint partition_possible = 0;\n\tfor (int i = 1; i < sum_till.size(); i++)\n\t{\n\t\tif (sum_till.get(i) == total_sum - sum_till.get(i))\n\t\t\tpartition_possible = 1;\n\t\tif (sum_till.get(i-1) == total_sum - sum_till.get(i))\n\t\t\tpartition_possible = 1;\n\t}\n\tSystem.out.printf(partition_possible == 1 ? \"YES\\n\" : \"NO\\n\");\n}", "9348": "static boolean LiesInsieRectangle(int a, int b, int x, int y)\n{\nif (x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0)\n\treturn true;\nreturn false;\n}", "9358": "static boolean FindPoint(int x1, int y1, int x2, int y2, int x, int y)\n{\nif (x > x1 && x < x2 && y > y1 && y < y2)\n\treturn true;\nreturn false;\n}", "9359": "static void distance(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2)\n{\n\tfloat x1,y1,z1,d;\n\tif (a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2)\n\t{\n\t\tx1 = y1 = 0;\n\t\tz1 =-d1 / c1;\n\t\td = Math.abs(( c2 * z1 + d2)) /\n\t\t\t(float)(Math.sqrt(a2 * a2 + b2 * b2 + c2 * c2));\n\t\tSystem.out.println(\"Perpendicular distance is \"+ d);\n\t}\n\telse\n\t\tSystem.out.println(\"Planes are not parallel\");\n}", "9362": "static void shortest_distance(float x1, float y1, float z1, float a, float b, float c, float d)\n{\n\td = Math.abs((a * x1 + b * y1 + c * z1 + d));\n\tfloat e = (float)Math.sqrt(a * a + b * b + c * c);\n\tSystem.out.println(\"Perpendicular distance \" + \"is \" + d / e);\n}", "9369": "static float findVolume(float l, float b, float h)\n\t{\n\t\tfloat volume = (l * b * h) / 2;\n\t\treturn volume;\n\t}", "9405": "static double findPCSlope(double m)\n\t{\n\t\treturn -1.0 / m;\n\t}", "9423": "static boolean isRectangle(int a, int b, int c, int d)\n\t{\n\t\tif (a == b && a == c && a == d && c == d && b == c && b == d)\n\t\t\treturn true;\n\t\telse if (a == b && c == d)\n\t\t\treturn true;\n\t\telse if (a == d && c == b)\n\t\t\treturn true;\n\t\telse if (a == c && d == b)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "9430": "static float \narea_of_segment(float radius, float angle)\n{\n\tfloat area_of_sector = pi *\n (radius * radius) * (angle / 360);\n\tfloat area_of_triangle =\n\t\t(float)1 / 2 * (radius * radius) *\n\t\t(float)Math.sin((angle * pi) / 180);\n\treturn area_of_sector - area_of_triangle;\n}", "9432": "static void midpoint(int x1, int x2, int y1, int y2)\n\t{\n\t\tSystem.out.print((x1 + x2) / 2 +\n\t\t\t\t\t\t\" , \" + (y1 + y2) / 2) ;\n\t}", "9445": "static int maxvolume(int s)\n\t{\n\t\tint maxvalue = 0;\n\t\tfor (int i = 1; i <= s - 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= s - 1; j++)\n\t\t\t{\n\t\t\t\tint k = s - i - j;\n\t\t\t\tmaxvalue = Math.max(maxvalue, i * j * k);\n\t\t\t}\n\t\t}\n\t\treturn maxvalue;\n\t}", "9446": "static int maxvolume(int s)\n\t{\n\t\tint length = s / 3;\n\t\ts -= length;\n\t\tint breadth = s / 2;\n\t\tint height = s - breadth;\n\t\treturn length * breadth * height;\n\t}", "9452": "public static float volumeTriangular(int a, int b, int h)\n\t{\n\t\tfloat vol = (float)(0.1666) * a * b * h;\n\t\treturn vol;\n\t}\npublic static float volumeSquare(int b, int h)\n\t{\n\t\tfloat vol = (float)(0.33) * b * b * h;\n\t\treturn vol;\n\t}\npublic static float volumePentagonal(int a, int b, int h)\n\t{\n\t\tfloat vol = (float)(0.83) * a * b * h;\n\t\treturn vol;\n\t}\npublic static float volumeHexagonal(int a, int b, int h)\n\t{\n\t\tfloat vol = (float)a * b * h;\n\t\treturn vol;\n\t}", "9457": "static double Area(int b1, int b2, int h)\n\t{\n\t\treturn ((b1 + b2) / 2) * h;\n\t}", "9458": "public static double hexagonArea(double s)\n\t{\n\t\treturn ((3 * Math.sqrt(3) *\n\t\t\t\t(s * s)) / 2);\n\t}", "9467": "static double arcLength(double diameter, double angle)\n\t{\n\t\tdouble pi = 22.0 / 7.0;\n\t\tdouble arc;\n\t\tif (angle >= 360) {\n\t\t\tSystem.out.println(\"Angle cannot\" + \" be formed\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tarc = (pi * diameter) * (angle / 360.0);\n\t\t\treturn arc;\n\t\t}\n\t}", "9468": "static void SectorArea(double radius,double angle)\n\t{\n\t\tif(angle >= 360)\n\t\t\tSystem.out.println(\"Angle not possible\");\n\t\telse\n\t\t{\n\t\t\tdouble sector =((22 * radius * radius) / 7)\n\t\t\t\t\t\t* (angle / 360);\n\t\t\tSystem.out.println(sector);\n\t\t}\n\t}", "9476": "static int maxSquare(int b, int m)\n\t{\n\t\treturn (b / m - 1) * (b / m) / 2;\n\t}", "9478": "static void checkCollision(int a, int b, int c, int x, int y, int radius)\n\t{\n\t\tdouble dist = (Math.abs(a * x + b * y + c)) /\n\t\t\t\t\t\tMath.sqrt(a * a + b * b);\n\t\tif (radius == dist)\n\t\t\tSystem.out.println ( \"Touch\" );\n\t\telse if (radius > dist)\n\t\t\tSystem.out.println( \"Intersect\") ;\n\t\telse\n\t\t\tSystem.out.println( \"Outside\") ;\n\t}", "9496": "static int numberOfDiagonals(int n)\n\t{\n\t\treturn n * (n - 3) / 2;\n\t}", "9505": "static void findRightAngle(double A, double H)\n\t{\n\t\tdouble D = Math.pow(H, 4) - 16 * A * A;\n\t\tif (D >= 0)\n\t\t{\n\t\t\tdouble root1 = (H * H + Math.sqrt(D)) / 2;\n\t\t\tdouble root2 = (H * H - Math.sqrt(D)) / 2;\n\t\t\tdouble a = Math.sqrt(root1);\n\t\t\tdouble b = Math.sqrt(root2);\n\t\t\tif (b >= a)\n\t\t\t\tSystem.out.print(a + \" \" + b + \" \" + H);\n\t\t\telse\n\t\t\t\tSystem.out.print(b + \" \" + a + \" \" + H);\n\t\t}\n\t\telse\n\t\t\tSystem.out.print(\"-1\");\n\t}", "9507": "public static int numberOfSquares(int base)\n {\n\tbase = (base - 2);\n\tbase = Math.floorDiv(base, 2);\n\treturn base * (base + 1)/2;\n }", "9528": "static double polygonArea(double X[], double Y[], int n)\n\t{\n\t\tdouble area = 0.0;\n\t\tint j = n - 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tarea += (X[j] + X[i]) * (Y[j] - Y[i]);\n\t\t\tj = i;\n\t\t}\n\t\treturn Math.abs(area / 2.0);\n\t}", "9567": "static int chk(int n)\n{\n\tVector<Integer> v = new Vector<Integer>();\n\twhile (n != 0) {\n\t\tv.add(n % 2);\n\t\tn = n / 2;\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v.get(i) == 1) {\n\t\t\treturn (int) Math.pow(2, i);\n\t\t}\n\t}\n\treturn 0;\n}\nstatic void sumOfLSB(int arr[], int N)\n{\n\tVector<Integer> lsb_arr = new Vector<Integer>() ;\n\tfor (int i = 0; i < N; i++) {\n\t\tlsb_arr.add(chk(arr[i]));\n\t}\n\tCollections.sort(lsb_arr);\n\tint ans = 0;\n\tfor (int i = 0; i < N - 1; i += 2) {\n\t\tans += (lsb_arr.get(i + 1));\n\t}\n\tSystem.out.print(ans);\n}", "9574": "static int countSubsequences(int arr[], int N)\n\t{\n\t\tint odd = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((arr[i] & 1) % 2 == 1)\n\t\t\t\todd++;\n\t\t}\n\t\treturn (1 << odd) - 1;\n\t}", "9608": "static void performQuery(int arr[], int Q[][])\n\t{\n\t\tfor (int i = 0; i < Q.length; i++) {\n\t\t\tint or = 0;\n\t\t\tint x = Q[i][0];\n\t\t\tarr[x - 1] = Q[i][1];\n\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\tor = or | arr[j];\n\t\t\t}\n\t\t\tSystem.out.print(or + \" \");\n\t\t}\n\t}", "9638": "static int smallest(int k, int d)\n{\n\tint cnt = 1;\n\tint m = d % k;\n\tint[] v = new int[k];\n\tArrays.fill(v, 0);\n\tv[m] = 1;\n\twhile (1 != 0)\n\t{\n\t\tif (m == 0)\n\t\t\treturn cnt;\n\t\tm = (((m * (10 % k)) % k) + (d % k)) % k;\n\t\tif (v[m] == 1)\n\t\t\treturn -1;\n\t\tv[m] = 1;\n\t\tcnt++;\n\t}\n}", "9639": "static int getPairsCount(int arr[], int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = arr[i] - (i % arr[i]); j < n; j += arr[i]) {\n\t\t\t\tif (i < j\n\t\t\t\t\t&& Math.abs(arr[i] - arr[j])\n\t\t\t\t\t\t>= Math.min(arr[i], arr[j])) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "9673": "static void check(int N)\n{\n\tint twos = 0, fives = 0;\n\twhile (N % 2 == 0)\n\t{\n\t\tN /= 2;\n\t\ttwos++;\n\t}\n\twhile (N % 5 == 0)\n\t{\n\t\tN /= 5;\n\t\tfives++;\n\t}\n\tif (N == 1 && twos <= fives)\n\t{\n\t\tSystem.out.println( 2 * fives - twos);\n\t}\n\telse\n\t{\n\t\tSystem.out.println(-1);\n\t}\n}", "9685": "static void rangeSum(int arr[], int N, int L, int R)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = L - 1; i < R; i++) {\n\t\t\tsum += arr[i % N];\n\t\t}\n\t\tSystem.out.println(sum);\n\t}", "9686": "static void rangeSum(int arr[], int N, int L, int R)\n{\n\tint prefix[] = new int[N+1];\n\tprefix[0] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tprefix[i] = prefix[i - 1]\n\t\t\t\t\t+ arr[i - 1];\n\t}\n\tint leftsum\n\t\t= ((L - 1) / N) * prefix[N]\n\t\t+ prefix[(L - 1) % N];\n\tint rightsum = (R / N) * prefix[N]\n\t\t\t\t+ prefix[R % N];\n\tSystem.out.print( rightsum - leftsum);\n}", "9702": "static int ExpoFactorial(int N)\n{\n\tint res = 1;\n\tint mod = 1000000007;\n\tfor(int i = 2; i < N + 1; i++)\n\t\tres = (int)Math.pow(i, res) % mod;\n\treturn res;\n}", "9704": "static int maxSubArraySumRepeated(int[] arr, int N, int K)\n{\n\tint sum = 0;\n\tfor(int i = 0; i < N; i++)\n\t\tsum += arr[i];\n\tint curr = arr[0];\n\tint ans = arr[0];\n\tif (K == 1)\n\t{\n\t\tfor(int i = 1; i < N; i++)\n\t\t{\n\t\t\tcurr = Math.max(arr[i], curr + arr[i]);\n\t\t\tans = Math.max(ans, curr);\n\t\t}\n\t\treturn ans;\n\t}\n\tArrayList<Integer> V = new ArrayList<Integer>();\n\tfor(int i = 0; i < 2 * N; i++)\n\t{\n\t\tV.add(arr[i % N]);\n\t}\n\tint maxSuf = V.get(0);\n\tint maxPref = V.get(2 * N - 1);\n\tcurr = V.get(0);\n\tfor(int i = 1; i < 2 * N; i++)\n\t{\n\t\tcurr += V.get(i);\n\t\tmaxPref = Math.max(maxPref, curr);\n\t}\n\tcurr = V.get(2 * N - 1);\n\tfor(int i = 2 * N - 2; i >= 0; i--)\n\t{\n\t\tcurr += V.get(i);\n\t\tmaxSuf = Math.max(maxSuf, curr);\n\t}\n\tcurr = V.get(0);\n\tfor(int i = 1; i < 2 * N; i++)\n\t{\n\t\tcurr = Math.max(V.get(i), curr + V.get(i));\n\t\tans = Math.max(ans, curr);\n\t}\n\tif (sum > 0)\n\t{\n\t\tint temp = sum * (K - 2);\n\t\tans = Math.max(ans, Math.max(temp + maxPref, temp + maxSuf));\n\t}\n\treturn ans;\n}", "9707": "static int factorial(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\treturn n * factorial(n - 1);\n\t}\nstatic long numOfNecklace(int N)\n\t{\n\t\tlong ans = factorial(N)\n\t\t\t\t/ (factorial(N / 2) * factorial(N / 2));\n\t\tans = ans * factorial(N / 2 - 1);\n\t\tans = ans * factorial(N / 2 - 1);\n\t\tans /= 2;\n\t\treturn ans;\n\t}", "9726": "static int gcd(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\nstatic void countPairs(int[] arr, int N)\n{\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tint count = 0;\n\t\tfor(int x = 1; x <= arr[i]; x++)\n\t\t{\n\t\t\tfor(int y = x; y <= arr[i]; y++)\n\t\t\t{\n\t\t\t\tif (gcd(x, y) > 1)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(count + \" \");\n\t}\n}", "9727": "static void preCalculate(int[] phi, int[] ans)\n{\n\tphi[0] = 0;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAX; i++)\n\t\tphi[i] = i;\n\tfor (int i = 2; i <= MAX; i++) {\n\t\tif (phi[i] == i) {\n\t\t\tfor (int j = i; j <= MAX; j += i)\n\t\t\t\tphi[j] -= (phi[j] / i);\n\t\t}\n\t}\n\tfor (int i = 1; i <= MAX; i++)\n\t\tans[i] = ans[i - 1] + (i - phi[i]);\n}\nstatic void countPairs(int[] arr, int N)\n{\n\tint[] phi = new int[100000];\n\tArrays.fill(phi, 0);\n\tint[] ans = new int[100000];\n\tArrays.fill(ans, 0);\n\tpreCalculate(phi, ans);\n\tfor (int i = 0; i < N; ++i) {\n\t\tSystem.out.print(ans[arr[i]] + \" \");\n\t}\n}", "9735": "public static void countSubarray(int arr[], int n)\n{\n\tint count = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = i; j < n; j++)\n\t\t{\n\t\t\tint mxSubarray = 0;\n\t\t\tint mxOther = 0;\n\t\t\tfor(int k = i; k <= j; k++)\n\t\t\t{\n\t\t\t\tmxSubarray = Math.max( mxSubarray, arr[k]);\n\t\t\t}\n\t\t\tfor(int k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tmxOther = Math.max(mxOther, arr[k]);\n\t\t\t}\n\t\t\tfor(int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tmxOther = Math.max(mxOther, arr[k]);\n\t\t\t}\n\t\t\tif (mxSubarray > (2 * mxOther))\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tSystem.out.println(count);\n}", "9736": "static void countSubarray(int[] arr, int n)\n\t{\n\t\tint L = 0, R = 0;\n\t\tint mx = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmx = Math.max(mx, arr[i]);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] * 2 > mx) {\n\t\t\t\tL = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (arr[i] * 2 > mx) {\n\t\t\t\tR = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((L + 1) * (n - R));\n\t}", "9738": "static boolean isPrime(int X)\n{\n\tfor(int i = 2; i * i <= X; i++)\n\t\tif (X % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nstatic void printPrimes(int A[], int N)\n{\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tfor(int j = A[i] - 1;; j--)\n\t\t{\n\t\t\tif (isPrime(j))\n\t\t\t{\n\t\t\t\tSystem.out.print(j + \" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = A[i] + 1;; j++)\n\t\t{\n\t\t\tif (isPrime(j))\n\t\t\t{\n\t\t\t\tSystem.out.print( j + \" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "9759": "static int gcd(int a, int b)\n\t{\n\t\tif (b == 0)\n\t\t{\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\nstatic HashMap<Integer, Integer> PrimeFactor(int N)\n\t{\n\t\tHashMap<Integer, Integer> primef = new HashMap<Integer, Integer>();\n\t\twhile (N % 2 == 0)\n\t\t{\n\t\t\tif (primef.containsKey(2))\n\t\t\t{\n\t\t\t\tprimef.put(2, primef.get(2) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprimef.put(2, 1);\n\t\t\t}\n\t\t\tN = N / 2;\n\t\t}\n\t\tfor(int i = 3; i <= Math.sqrt(N); i++)\n\t\t{\n\t\t\twhile (N % i == 0)\n\t\t\t{\n\t\t\t\tif (primef.containsKey(i))\n\t\t\t\t{\n\t\t\t\t\tprimef.put(i, primef.get(i) + 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprimef.put(i, 1);\n\t\t\t\t}\n\t\t\t\tN = N / 2;\n\t\t\t}\n\t\t}\n\t\tif (N > 2)\n\t\t{\n\t\t\tprimef.put(N, 1);\n\t\t}\n\t\treturn primef;\n\t}\nstatic int CountToMakeEqual(int X, int Y)\n\t{\n\t\tint gcdofXY = gcd(X, Y);\n\t\tint newX = Y / gcdofXY;\n\t\tint newY = X / gcdofXY;\n\t\tHashMap<Integer, Integer> primeX = PrimeFactor(newX);\n\t\tHashMap<Integer, Integer> primeY = PrimeFactor(newY);\n\t\tint ans = 0;\n\t\tfor (Map.Entry keys : primeX.entrySet()) {\n\t\t\tif (X % (int)keys.getKey() != 0)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tans += primeX.get(keys.getKey());\n\t\t}\n\t\tfor (Map.Entry keys : primeY.entrySet()) {\n\t\t\tif (Y % (int)keys.getKey() != 0)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tans += primeY.get(keys.getKey());\n\t\t}\n\t\treturn ans;\n\t}", "9777": "static String isDivisibleByDivisor(int S, int D)\n{\n\tS %= D;\n\tSet<Integer> hashMap = new HashSet<>();\n\thashMap.add(S);\n\tfor(int i = 0; i <= D; i++)\n\t{\n\t\tS += (S % D);\n\t\tS %= D;\n\t\tif (hashMap.contains(S))\n\t\t{\n\t\t\tif (S == 0)\n\t\t\t{\n\t\t\t\treturn \"Yes\";\n\t\t\t}\n\t\t\treturn \"No\";\n\t\t}\n\t\telse\n\t\t\thashMap.add(S);\n\t}\n\treturn \"Yes\";\n}", "9787": "static int KthSmallest(int A[], int B[], int N, int K)\n\t{\n\t\tint M = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tM = Math.max(A[i], M);\n\t\t}\n\t\tint freq[] = new int[M + 1];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfreq[A[i]] += B[i];\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i <= M; i++) {\n\t\t\tsum += freq[i];\n\t\t\tif (sum >= K) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "9804": "static void findbitwiseOR(int[] a, int n)\n\t{\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint curr_sub_array = a[i];\n\t\t\tres = res | curr_sub_array;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tcurr_sub_array = curr_sub_array & a[j];\n\t\t\t\tres = res | curr_sub_array;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}", "9805": "static void findbitwiseOR(int[] a, int n)\n{\n\tint res = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tres = res | a[i];\n\tSystem.out.println(res);\n}", "9818": "static void check(int n)\n{\n\tint sumOfDigit = 0;\n\tint prodOfDigit = 1;\n\twhile (n > 0)\n\t{\n\t\tint rem;\n\t\trem = n % 10;\n\t\tsumOfDigit += rem;\n\t\tprodOfDigit *= rem;\n\t\tn /= 10;\n\t}\n\tif (sumOfDigit > prodOfDigit)\n\t\tSystem.out.println(\"Yes\");\n\telse\n\t\tSystem.out.println(\"No\");\n}", "9824": "static void evenOddBitwiseXOR(int N)\n{\n\tSystem.out.print(\"Even: \" + 0 + \" \");\n\tfor(int i = 4; i <= N; i = i + 4)\n\t{\n\t\tSystem.out.print(i + \" \");\n\t}\n\tSystem.out.print(\"\\n\");\n\tSystem.out.print(\"Odd: \" + 1 + \" \");\n\tfor(int i = 4; i <= N; i = i + 4)\n\t{\n\t\tSystem.out.print(i - 1 + \" \");\n\t}\n\tif (N % 4 == 2)\n\t\tSystem.out.print(N + 1);\n\telse if (N % 4 == 3)\n\t\tSystem.out.print(N);\n}", "9829": "static void findPermutation(int[] arr)\n{\n\tint N = arr.length;\n\tint i = N - 2;\n\twhile (i >= 0 && arr[i] <= arr[i + 1])\n\t\ti--;\n\tif (i == -1)\n\t{\n\t\tSystem.out.print(\"-1\");\n\t\treturn;\n\t}\n\tint j = N - 1;\n\twhile (j > i && arr[j] >= arr[i])\n\t\tj--;\n\twhile (j > i && arr[j] == arr[j - 1])\n\t{\n\t\tj--;\n\t}\n\tint temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n\tfor(int it : arr)\n\t{\n\t\tSystem.out.print(it + \" \");\n\t}\n}", "9849": "static void sieveOfEratosthenes(int N, int s[])\n{\n\tboolean []prime = new boolean[N + 1];\n\tfor(int i = 2; i <= N; i += 2)\n\t\ts[i] = 2;\n\tfor(int i = 3; i <= N; i += 2)\n\t{\n\t\tif (prime[i] == false)\n\t\t{\n\t\t\ts[i] = i;\n\t\t\tfor(int j = i; j * i <= N; j += 2)\n\t\t\t{\n\t\t\t\tif (!prime[i * j])\n\t\t\t\t{\n\t\t\t\t\tprime[i * j] = true;\n\t\t\t\t\ts[i * j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void findDifference(int N)\n{\n\tint []s = new int[N + 1];\n\tsieveOfEratosthenes(N, s);\n\tint total = 1, odd = 1, even = 0;\n\tint curr = s[N];\n\tint cnt = 1;\n\twhile (N > 1)\n\t{\n\t\tN /= s[N];\n\t\tif (curr == s[N])\n\t\t{\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (curr == 2)\n\t\t{\n\t\t\ttotal = total * (cnt + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotal = total * (cnt + 1);\n\t\t\todd = odd * (cnt + 1);\n\t\t}\n\t\tcurr = s[N];\n\t\tcnt = 1;\n\t}\n\teven = total - odd;\n\tSystem.out.print(Math.abs(even - odd));\n}", "9877": "static void findMedian(int Mean, int Mode)\n{\n\tdouble Median = (2 * Mean + Mode) / 3.0;\n\tSystem.out.print((int)Median);\n}", "9889": "private static double vectorMagnitude(int x, int y, int z)\n{\n\tint sum = x * x + y * y + z * z;\n\treturn Math.sqrt(sum);\n}", "9905": "static void minimumSteps(int x, int y)\n{\n\tint cnt = 0;\n\twhile (x != 0 && y != 0)\n\t{\n\t\tif (x > y)\n\t\t{\n\t\t\tcnt += x / y;\n\t\t\tx %= y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcnt += y / x;\n\t\t\ty %= x;\n\t\t}\n\t}\n\tcnt--;\n\tif (x > 1 y > 1)\n\t\tcnt = -1;\n\tSystem.out.println(cnt);\n}", "9915": "static boolean check(ArrayList<Integer> Adj[], int Src, int N, boolean visited[])\n{\n\tint color[] = new int[N];\n\tvisited[Src] = true;\n\tArrayDeque<Integer> q = new ArrayDeque<>();\n\tq.addLast(Src);\n\twhile (!q.isEmpty())\n\t{\n\t\tint u = q.removeFirst();\n\t\tint Col = color[u];\n\t\tfor(int x : Adj[u])\n\t\t{\n\t\t\tif (visited[x] == true && color[x] == Col)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (visited[x] == false)\n\t\t\t{\n\t\t\t\tvisited[x] = true;\n\t\t\t\tq.addLast(x);\n\t\t\t\tcolor[x] = 1 - Col;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nstatic void addEdge(ArrayList<Integer> Adj[], int u, int v)\n{\n\tAdj[u].add(v);\n\tAdj[v].add(u);\n}\nstatic void isPossible(Node Arr[], int N)\n{\n\t@SuppressWarnings(\"unchecked\")\n\tArrayList<Integer> [] Adj = (ArrayList<Integer>[])new ArrayList[N];\n\tfor(int i = 0; i < N; i++)\n\t\tAdj[i] = new ArrayList<>();\n\tfor(int i = 0; i < N - 1; i++)\n\t{\n\t\tfor(int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (Arr[i].R < Arr[j].L Arr[i].L > Arr[j].R)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (Arr[i].V == Arr[j].V)\n\t\t\t\t{\n\t\t\t\t\taddEdge(Adj, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tboolean visited[] = new boolean[N];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (visited[i] == false && Adj[i].size() > 0)\n\t\t{\n\t\t\tif (check(Adj, i, N, visited) == false)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tSystem.out.println(\"Yes\");\n}", "9935": "static void checkCommonDivisor(int[] arr, int N, int X)\n{\n\tint G = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tG = gcd(G, arr[i]);\n\t}\n\tint copy_G = G;\n\tfor(int divisor = 2; divisor <= X; divisor++)\n\t{\n\t\twhile (G % divisor == 0)\n\t\t{\n\t\t\tG = G / divisor;\n\t\t}\n\t}\n\tif (G <= X)\n\t{\n\t\tSystem.out.println(\"Yes\");\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tSystem.out.print((arr[i] / copy_G) + \" \");\n\t\tSystem.out.println();\n\t}\n\telse\n\t\tSystem.out.println(\"No\");\n}\nstatic int gcd(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}", "9948": "static long multiplyByMersenne(long N, long M)\n{\n\tlong x = (int)(Math.log(M + 1) / Math.log(2));\n\treturn ((N << x) - N);\n}", "9958": "static int perfectSquare(int num)\n {\n\tint sr = (int)(Math.sqrt(num));\n\tint a = sr * sr;\n\tint b = (sr + 1) * (sr + 1);\n\tif ((num - a) < (b - num)) {\n\treturn a;\n\t}\n\telse {\n\treturn b;\n\t}\n }\nstatic int powerOfTwo(int num)\n {\n\tint lg = (int)(Math.log(num) / Math.log(2));\n\tint p = (int)(Math.pow(2, lg));\n\treturn p;\n }\nstatic void uniqueElement(int arr[], int N)\n {\n\tboolean ans = true;\n\tHashMap<Integer, Integer> freq\n\t= new HashMap<Integer, Integer>();\n\tfor (int i = 0; i < N; i++) {\n\tif (freq.containsKey(arr[i])) {\n\t\tfreq.put(arr[i], freq.get(arr[i]) + 1);\n\t}\n\telse {\n\t\tfreq.put(arr[i], 1);\n\t}\n\t}\n\tfor (Map.Entry<Integer, Integer> el :\n\t\tfreq.entrySet()) {\n\tif (el.getValue() == 1) {\n\t\tans = false;\n\t\tint ps = perfectSquare(el.getKey());\n\t\tSystem.out.print(powerOfTwo(ps) + \" \");\n\t}\n\t}\n\tif (ans)\n\tSystem.out.print(\"-1\");\n }", "9963": "static void partitionArray(int a[], int n)\n\t{\n\t\tint min[] = new int[n];\n\t\tint mini = Integer.MAX_VALUE;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tmini = Math.min(mini, a[i]);\n\t\t\tmin[i] = mini;\n\t\t}\n\t\tint maxi = Integer.MIN_VALUE;\n\t\tint ind = -1;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tmaxi = Math.max(maxi, a[i]);\n\t\t\tif (maxi < min[i + 1]) {\n\t\t\t\tind = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ind != -1) {\n\t\t\tfor (int i = 0; i <= ind; i++)\n\t\t\t\tSystem.out.print(a[i] + \" \");\n\t\t\tSystem.out.println();\n\t\t\tfor (int i = ind + 1; i < n; i++)\n\t\t\t\tSystem.out.print(a[i] + \" \");\n\t\t}\n\t\telse\n\t\t\tSystem.out.println(\"Impossible\");\n\t}", "9971": "static int countPrimeFactors(int n)\n{\n\tint count = 0;\n\twhile (n % 2 == 0)\n\t{\n\t\tn = n / 2;\n\t\tcount++;\n\t}\n\tfor(int i = 3;\n\t\t\ti <= (int)Math.sqrt(n); i = i + 2)\n\t{\n\t\twhile (n % i == 0)\n\t\t{\n\t\t\tn = n / i;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (n > 2)\n\t\tcount++;\n\treturn (count);\n}\nstatic int findSum(int n)\n{\n\tint sum = 0;\n\tfor(int i = 1, num = 2; i <= n; num++)\n\t{\n\t\tif (countPrimeFactors(num) == 2)\n\t\t{\n\t\t\tsum += num;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn sum;\n}\nstatic void check(int n, int k)\n{\n\tint s = findSum(k - 1);\n\tif (s >= n)\n\t\tSystem.out.print(\"No\");\n\telse\n\t\tSystem.out.print(\"Yes\");\n}", "9979": "static int gcd(int a, int b)\n{\n\twhile (b > 0) {\n\t\tint rem = a % b;\n\t\ta = b;\n\t\tb = rem;\n\t}\n\treturn a;\n}\nstatic int countNumberOfWays(int n)\n{\n\tif (n == 1)\n\t\treturn -1;\n\tint g = 0;\n\tint power = 0;\n\twhile (n % 2 == 0) {\n\t\tpower++;\n\t\tn /= 2;\n\t}\n\tg = gcd(g, power);\n\tfor (int i = 3; i <= (int)Math.sqrt(n); i += 2) {\n\t\tpower = 0;\n\t\twhile (n % i == 0) {\n\t\t\tpower++;\n\t\t\tn /= i;\n\t\t}\n\t\tg = gcd(g, power);\n\t}\n\tif (n > 2)\n\t\tg = gcd(g, 1);\n\tint ways = 1;\n\tpower = 0;\n\twhile (g % 2 == 0) {\n\t\tg /= 2;\n\t\tpower++;\n\t}\n\tways *= (power + 1);\n\tfor (int i = 3; i <= (int)Math.sqrt(g); i += 2) {\n\t\tpower = 0;\n\t\twhile (g % i == 0) {\n\t\t\tpower++;\n\t\t\tg /= i;\n\t\t}\n\t\tways *= (power + 1);\n\t}\n\tif (g > 2)\n\t\tways *= 2;\n\treturn ways;\n}", "9989": "public static void printSpiral(int size)\n\t{\n\t\tint row = 0, col = 0;\n\t\tint boundary = size - 1;\n\t\tint sizeLeft = size - 1;\n\t\tint flag = 1;\n\t\tchar move = 'r';\n\t\tint matrix[][] = new int[size][size];\n\t\tfor (int i = 1; i < size * size + 1; i++) {\n\t\t\tmatrix[row][col] = i;\n\t\t\tswitch (move) {\n\t\t\tcase 'r':\n\t\t\t\tcol += 1;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcol -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\trow -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\trow += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == boundary) {\n\t\t\t\tboundary += sizeLeft;\n\t\t\t\tif (flag != 2) {\n\t\t\t\t\tflag = 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tsizeLeft -= 1;\n\t\t\t\t}\n\t\t\t\tswitch (move) {\n\t\t\t\tcase 'r':\n\t\t\t\t\tmove = 'd';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tmove = 'l';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\tmove = 'u';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tmove = 'r';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (row = 0; row < size; row++) {\n\t\t\tfor (col = 0; col < size; col++) {\n\t\t\t\tint n = matrix[row][col];\n\t\t\t\tSystem.out.print((n < 10)\n\t\t\t\t\t\t\t\t\t? (n + \" \")\n\t\t\t\t\t\t\t\t\t: (n + \" \"));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "10030": "public static boolean isPossible(int[] target)\n\t{\n\t\tint max = 0;\n\t\tint index = 0;\n\t\tfor (int i = 0; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tif (max == 1)\n\t\t\treturn true;\n\t\tfor (int i = 0; i < target.length; i++) {\n\t\t\tif (i != index) {\n\t\t\t\tmax -= target[i];\n\t\t\t\tif (max <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\ttarget[index] = max;\n\t\treturn isPossible(target);\n\t}", "10041": "static void convertToASCII(int N)\n{\n\tString num = Integer.toString(N);\n\tfor (char ch : num.toCharArray()) {\n\t\tSystem.out.print(ch + \" (\"\n\t\t\t+ (int)ch + \")\\n\");\n\t}\n}", "10049": "static void productExceptSelf(int arr[], int N)\n{\n\tint product = 1;\n\tint z = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (arr[i] != 0)\n\t\t\tproduct *= arr[i];\n\t\tif (arr[i] == 0)\n\t\t\tz += 1;\n\t}\n\tint a = Math.abs(product);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (z == 1) {\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[i] = 0;\n\t\t\telse\n\t\t\t\tarr[i] = product;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (z > 1) {\n\t\t\tarr[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint b = Math.abs(arr[i]);\n\t\tint curr = (int)Math.round(Math.exp(Math.log(a) - Math.log(b)));\n\t\tif (arr[i] < 0 && product < 0)\n\t\t\tarr[i] = curr;\n\t\telse if (arr[i] > 0 && product > 0)\n\t\t\tarr[i] = curr;\n\t\telse\n\t\t\tarr[i] = -1 * curr;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tSystem.out.print(arr[i] + \" \");\n\t}\n}", "10054": "static void singleDigitSubarrayCount(int arr[], int N)\n{\n\tint res = 0;\n\tint count = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] <= 9)\n\t\t{\n\t\t\tcount++;\n\t\t\tres += count;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tSystem.out.print(res);\n}", "10057": "static int isPossible(int N)\n{\n\treturn (((N & (N - 1)) & N));\n}\nstatic void countElements(int N)\n{\n\tint count = 0;\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tif (isPossible(i) != 0)\n\t\t\tcount++;\n\t}\n\tSystem.out.println(count);\n}", "10058": "static void countElements(int N)\n {\n\tint Cur_Ele = 1;\n\tint Count = 0;\n\twhile (Cur_Ele <= N)\n\t{\n\tCount++;\n\tCur_Ele = Cur_Ele * 2;\n\t}\n\tSystem.out.print(N - Count);\n }", "10062": "static int minSum(int A[], int N)\n{\n\tHashMap<Integer,Integer> mp = new HashMap<Integer,Integer>();\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tsum += A[i];\n\t\tif(mp.containsKey(A[i]))\n\t\t{\n\t\t\tmp.put(A[i], mp.get(A[i]) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.put(A[i], 1);\n\t\t}\n\t}\n\tint minSum = Integer.MAX_VALUE;\n\tfor (Map.Entry<Integer,Integer> it : mp.entrySet())\n\t{\n\t\tminSum = Math.min(\n\t\t\tminSum, sum - (it.getKey() * it.getValue()));\n\t}\n\treturn minSum;\n}", "10063": "static void maxAdjacent(int[] arr, int N)\n {\n\tArrayList<Integer> res = new ArrayList<Integer>();\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\tint prev = arr[0];\n\tint maxi = Integer.MIN_VALUE;\n\tfor (int j = 1; j < N; j++)\n\t{\n\t\tif (i == j)\n\t\tcontinue;\n\t\tmaxi = Math.max(maxi, Math.abs(arr[j] - prev));\n\t\tprev = arr[j];\n\t}\n\tres.add(maxi);\n\t}\n\tfor (int x : res)\n\t{\n\tSystem.out.print(x + \" \");\n\t}\n\tSystem.out.println();\n }", "10064": "static void maxAdjacent(int []arr, int N)\n {\n\tVector<Integer> res = new Vector<Integer>();\n\tint arr_max = Integer.MIN_VALUE;\n\tfor (int i = 1; i < N; i++)\n\t{\n\tarr_max = Math.max(arr_max,\n\t\t\t\t\t\tMath.abs(arr[i - 1] - arr[i]));\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\tint curr_max = Math.abs(arr[i - 1] - arr[i + 1]);\n\tint ans = Math.max(curr_max, arr_max);\n\tres.add(ans);\n\t}\n\tfor (int x : res)\n\tSystem.out.print(x + \" \");\n\tSystem.out.println();\n }", "10071": "static int minimumIncrement(int arr[], int N)\n{\n\tif (N % 2 != 0)\n\t{\n\t\tSystem.out.println( \"-1\");\n\t\tSystem.exit(0);\n\t}\n\tint cntEven = 0;\n\tint cntOdd = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] % 2 == 0)\n\t\t{\n\t\t\tcntEven += 1;\n\t\t}\n\t}\n\tcntOdd = N - cntEven;\n\treturn Math.abs(cntEven - cntOdd) / 2;\n}", "10076": "static int findSize(int N)\n{\n\tif (N == 0)\n\t\treturn 1;\n\tif (N == 1)\n\t\treturn 1;\n\tint Size = 2 * findSize(N / 2) + 1;\n\treturn Size;\n}\nstatic int CountOnes(int N, int L, int R)\n{\n\tif (L > R)\n\t{\n\t\treturn 0;\n\t}\n\tif (N <= 1)\n\t{\n\t\treturn N;\n\t} \n\tint ret = 0;\n\tint M = N / 2;\n\tint Siz_M = findSize(M);\n\tif (L <= Siz_M)\n\t{\n\t\tret += CountOnes(N / 2, L,\n\t\t\t\t\t\tMath.min(Siz_M, R));\n\t}\n\tif (L <= Siz_M + 1 && Siz_M + 1 <= R)\n\t{\n\t\tret += N % 2;\n\t}\n\tif (Siz_M + 1 < R)\n\t{\n\t\tret += CountOnes(N / 2,\n\t\t\t\t\t\tMath.max(1, L - Siz_M - 1), R - Siz_M - 1);\n\t}\n\treturn ret;\n}", "10114": "static void cntWaysConsArray(int A[], int N)\n{\n\tint total = 1;\n\tint oddArray = 1;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\ttotal = total * 3;\n\t\tif (A[i] % 2 == 0)\n\t\t{\n\t\t\toddArray *= 2;\n\t\t}\n\t}\n\tSystem.out.println( total - oddArray);\n}", "10120": "static void countNumberHavingKthBitSet(int N, int K)\n{\n\tint numbers_rightmost_setbit_K = 0;\n\tfor (int i = 1; i <= K; i++)\n\t{\n\t\tint numbers_rightmost_bit_i = (N + 1) / 2;\n\t\tN -= numbers_rightmost_bit_i;\n\t\tif (i == K)\n\t\t{\n\t\t\tnumbers_rightmost_setbit_K\n\t\t\t\t= numbers_rightmost_bit_i;\n\t\t}\n\t}\n\tSystem.out.println(numbers_rightmost_setbit_K);\n}", "10123": "static int countSetBits(int N)\n{\n\tint count = 0;\n\twhile (N != 0)\n\t{\n\t\tN = N & (N - 1);\n\t\tcount++;\n\t}\n\treturn count;\n}", "10124": "static void minMoves(int arr[], int N)\n{\n\tint odd_element_cnt = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] % 2 != 0)\n\t\t{\n\t\t\todd_element_cnt++;\n\t\t}\n\t}\n\tint moves = (odd_element_cnt) / 2;\n\tif (odd_element_cnt % 2 != 0)\n\t\tmoves += 2;\n\tSystem.out.print(moves);\n}", "10145": "static void minimumSubsetDifference(int N)\n{\n\tint blockOfSize8 = N / 8;\n\tString str = \"ABBABAAB\";\n\tint subsetDifference = 0;\n\tString partition = \"\";\n\twhile (blockOfSize8-- > 0)\n\t{\n\t\tpartition += str;\n\t}\n\tint A[] = new int[N];\n\tint B[] = new int[N];\n\tint x = 0, y = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (partition.charAt(i) == 'A')\n\t\t{\n\t\t\tA[x++] = ((i + 1) * (i + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tB[y++] = ((i + 1) * (i + 1));\n\t\t}\n\t}\n\tSystem.out.println(subsetDifference);\n\tfor(int i = 0; i < x; i++)\n\t\tSystem.out.print(A[i] + \" \");\n\tSystem.out.println();\n\tfor(int i = 0; i < y; i++)\n\t\tSystem.out.print(B[i] + \" \");\n}", "10155": "static void findTheGreatestX(int P, int Q)\n{\n\tHashMap<Integer, Integer> divisiors = new HashMap<>();\n\tfor(int i = 2; i * i <= Q; i++)\n\t{\n\t\twhile (Q % i == 0 && Q > 1)\n\t\t{\n\t\t\tQ /= i;\n\t\t\tif (divisiors.containsKey(i))\n\t\t\t{\n\t\t\t\tdivisiors.put(i, divisiors.get(i) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdivisiors.put(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (Q > 1)\n\t\tif (divisiors.containsKey(Q))\n\t\t{\n\t\t\tdivisiors.put(Q, divisiors.get(Q) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdivisiors.put(Q, 1);\n\t\t}\n\tint ans = 0;\n\tfor(Map.Entry<Integer, Integer> i : divisiors.entrySet())\n\t{\n\t\tint frequency = i.getValue();\n\t\tint temp = P;\n\t\tint cur = 0;\n\t\twhile (temp % i.getKey() == 0)\n\t\t{\n\t\t\ttemp /= i.getKey();\n\t\t\tcur++;\n\t\t}\n\t\tif (cur < frequency)\n\t\t{\n\t\t\tans = P;\n\t\t\tbreak;\n\t\t}\n\t\ttemp = P;\n\t\tfor(int j = cur; j >= frequency; j--)\n\t\t{\n\t\t\ttemp /= i.getKey();\n\t\t}\n\t\tans = Math.max(temp, ans);\n\t}\n\tSystem.out.print(ans);\n}", "10174": "static String checkRearrangements(int[][] mat, int N, int M)\n{\n for (int i = 0; i < N; i++)\n {\n\tfor (int j = 1; j < M; j++)\n\t{\n\tif (mat[i][0] != mat[i][j])\n\t{\n\t\treturn \"Yes\";\n\t}\n\t}\n }\n return \"No\";\n}\nstatic String nonZeroXor(int[][] mat, int N, int M)\n{\n int res = 0;\n for (int i = 0; i < N; i++)\n {\n\tres = res ^ mat[i][0];\n }\n if (res != 0)\n\treturn \"Yes\";\n else\n\treturn checkRearrangements(mat, N, M);\n}", "10186": "static void findPrimeNos(int L, int R, Map<Integer, Integer> M, int K)\n{\n for (int i = L; i <= R; i++)\n {\n\tif(M.get(i) != null)\n\tM.put(i, M.get(i) + 1);\n\telse\n\tM.put(i, 1);\n }\n if (M.get(1) != null)\n {\n\tM.remove(1);\n }\n for (int i = 2;\n\t\ti <= Math.sqrt(R); i++)\n {\n\tint multiple = 2;\n\twhile ((i * multiple) <= R)\n\t{\n\tif (M.get(i * multiple) != null)\n\t{\n\t\tM.remove(i * multiple);\n\t}\n\tmultiple++;\n\t}\n }\n for (Map.Entry<Integer,\n\t\t\t\tInteger> entry :\n\tM.entrySet()) \n {\n\tif (M.get(entry.getKey() + K) != null)\n\t{\n\tSystem.out.print(\"(\" + entry.getKey() +\n\t\t\t\t\t\", \" + (entry.getKey() + K) + \") \");\n\t}\n }\n}\nstatic void getPrimePairs(int L, int R, int K)\n{\n Map<Integer,\n\tInteger> M = new HashMap<Integer,\n\t\t\t\t\t\t\tInteger>(); \n findPrimeNos(L, R, M, K);\n}", "10212": "static int functionMax(int arr[], int n)\n{\n\tVector<Integer> []setBit = new Vector[32 + 1];\n\tfor (int i = 0; i < setBit.length; i++)\n\t\tsetBit[i] = new Vector<Integer>();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < size_int; j++)\n\t\t{\n\t\t\tif ((arr[i] & (1 << j)) > 0)\n\t\t\t\tsetBit[j].add(i);\n\t\t}\n\t}\n\tfor (int i = size_int; i >= 0; i--)\n\t{\n\t\tif (setBit[i].size() == 1)\n\t\t{\n\t\t\tswap(arr, 0, setBit[i].get(0));\n\t\t\tbreak;\n\t\t}\n\t}\n\tint maxAnd = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tmaxAnd = maxAnd & (~arr[i]);\n\t}\n\treturn maxAnd;\n}\nstatic int[] swap(int []arr, int i, int j)\n{\n\tint temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n\treturn arr;\n}", "10228": "static boolean prime(int n)\n{\n\tif (n == 1)\n\t\treturn false;\n\tfor (int i = 2; i * i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nstatic void minDivisior(int n)\n{\n\tif (prime(n))\n\t{\n\t\tSystem.out.print(1 + \" \" + (n - 1));\n\t}\n\telse\n\t{\n\t\tfor (int i = 2; i * i <= n; i++)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tSystem.out.print(n / i + \" \" +\n\t\t\t\t\t\t\t\t(n / i * (i - 1)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "10233": "static int gcd(int a, int b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b % a, a);\n}\nstatic int lcm(int a, int b)\n{\n\treturn (a * b) / gcd(a, b);\n}\nstatic void findLCM(Vector<Integer> arr)\n{\n\tint nth_lcm = arr.get(0);\n\tfor(int i = 1; i < arr.size(); i++)\n\t\tnth_lcm = lcm(nth_lcm, arr.get(i));\n\tLandau = Math.max(Landau, nth_lcm);\n}\nstatic void findWays(Vector<Integer> arr, int i, int n)\n{\n\tif (n == 0)\n\t\tfindLCM(arr);\n\tfor(int j = i; j <= n; j++)\n\t{\n\t\tarr.add(j);\n\t\tfindWays(arr, j, n - j);\n\t\tarr.remove(arr.size() - 1);\n\t}\n}\nstatic void Landau_function(int n)\n{\n\tVector<Integer> arr = new Vector<>();\n\tfindWays(arr, 1, n);\n\tSystem.out.print(Landau);\n}", "10237": "static int nCr(int n, int r)\n{\n\tint res = 1;\n\tif (r > n - r)\n\t\tr = n - r;\n\tfor (int i = 0; i < r; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}\nstatic int solve(int n, int m, int k)\n{\n\tint sum = 0;\n\tfor (int i = 0; i <= k; i++)\n\t\tsum += nCr(n, i)\n\t\t\t* nCr(m, k - i);\n\treturn sum;\n}", "10238": "static int nCr(int n, int r)\n{\n\tint res = 1;\n\tif (r > n - r)\n\t\tr = n - r;\n\tfor (int i = 0; i < r; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}", "10267": "static int powerOptimised(int a, int n)\n{\n\tint ans = 1;\n\twhile (n > 0)\n\t{\n\t\tint last_bit = (n & 1);\n\t\tif (last_bit > 0)\n\t\t{\n\t\t\tans = ans * a;\n\t\t}\n\t\ta = a * a;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}", "10269": "static int findMaximumGcd(int n)\n{\n\tint max_gcd = 1;\n\tfor(int i = 1; i * i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (i > max_gcd)\n\t\t\t\tmax_gcd = i;\n\t\t\tif ((n / i != i) &&\n\t\t\t\t(n / i != n) &&\n\t\t\t((n / i) > max_gcd))\n\t\t\t\tmax_gcd = n / i;\n\t\t}\n\t}\n\treturn max_gcd;\n}", "10309": "static void sieve()\n{\n\tv[1] = 1;\n\tfor(int i = 2; i < x; i++)\n\t\tv[i] = i;\n\tfor(int i = 4; i < x; i += 2)\n\t\tv[i] = 2;\n\tfor(int i = 3; i * i < x; i++)\n\t{\n\t\tif (v[i] == i)\n\t\t{\n\t\t\tfor(int j = i * i; j < x; j += i)\n\t\t\t{\n\t\t\t\tif (v[j] == j)\n\t\t\t\t{\n\t\t\t\t\tv[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic int prime_factors(int n)\n{\n\tHashSet<Integer> s = new HashSet<Integer>();\n\twhile (n != 1)\n\t{\n\t\ts.add(v[n]);\n\t\tn = n / v[n];\n\t}\n\treturn s.size();\n}\nstatic void distinctPrimes(int m, int k)\n{\n\tVector<Integer> result = new Vector<Integer>();\n\tfor (int i = 14; i < m + k; i++)\n\t{\n\t\tlong count = prime_factors(i);\n\t\tif (count == k)\n\t\t{\n\t\t\tresult.add(i);\n\t\t}\n\t}\n\tint p = result.size();\n\tfor(int index = 0; index < p - 1; index++)\n\t{\n\t\tlong element = result.get(index);\n\t\tint count = 1, z = index;\n\t\twhile (z < p - 1 && count <= k &&\n\t\t\t\t\tresult.get(z) + 1 ==\n\t\t\t\t\tresult.get(z + 1))\n\t\t{\n\t\t\tcount++;\n\t\t\tz++;\n\t\t}\n\t\tif (count >= k)\n\t\t\tSystem.out.print(element + \" \");\n\t}\n}", "10325": "static void print_product(int a, int b, int c, int d)\n{\n\tint prod1 = a * c;\n\tint prod2 = b * d;\n\tint prod3 = (a + b) * (c + d);\n\tint real = prod1 - prod2;\n\tint imag = prod3 - (prod1 + prod2);\n\tSystem.out.println(real + \" + \" + imag + \"i\");\n}", "10330": "static int reverse(int num)\n{\n\tint rev_num = 0;\n\twhile(num > 0)\n\t{\n\t\trev_num = rev_num * 10 + num % 10;\n\t\tnum = num / 10;\n\t}\n\treturn rev_num;\n}\nstatic int properDivSum(int num)\n{\n\tint result = 0;\n\tfor (int i = 2; i<= Math.sqrt(num); i++)\n\t{\n\t\tif (num % i == 0)\n\t\t{\n\t\t\tif (i == (num / i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + num / i);\n\t\t}\n\t}\n\treturn (result + 1);\n}\nstatic boolean isTcefrep(int n)\n{\n\treturn properDivSum(n) == reverse(n);\n}", "10335": "static boolean isInsolite(int n)\n{\n\tint N = n;\n\tint sum = 0;\n\tint product = 1;\n\twhile (n != 0)\n\t{\n\t\tint r = n % 10;\n\t\tsum = sum + r * r;\n\t\tproduct = product * r * r;\n\t\tn = n / 10;\n\t}\n\treturn (N % sum == 0) &&\n\t\t(N % product == 0);\n}", "10337": "static int sigma(int n)\n{\n\tif (n == 1)\n\t\treturn 1;\n\tint result = 0;\n\tfor(int i = 2; i <= Math.sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (i == (n / i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + n / i);\n\t\t}\n\t}\n\treturn (result + n + 1);\n}\nstatic boolean isSuperabundant(int N)\n{\n\tfor(double i = 1; i < N; i++)\n\t{\n\t\tdouble x = sigma((int)(i)) / i;\n\t\tdouble y = sigma((int)(N)) / (N * 1.0);\n\t\tif (x > y)\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "10345": "static boolean isDNum(int n)\n{\n\tif (n < 4)\n\t\treturn false;\n\tint numerator = 0, hcf = 0;\n\tfor(int k = 2; k <= n; k++)\n\t{\n\tnumerator = (int)(Math.pow(k, n - 2) - k);\n\thcf = __gcd(n, k);\n\t}\n\tif (hcf == 1 && (numerator % n) != 0)\n\t\treturn false;\n\treturn true;\n}\nstatic int __gcd(int a, int b)\n{\n\treturn b == 0 ? a : __gcd(b, a % b);\t\n}", "10367": "static boolean isPrime(int n)\n{\n\tif (n == 1)\n\t\treturn true;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor(int i = 5; i * i <= n; i = i + 6)\n\tif (n % i == 0 || n % (i + 2) == 0)\n\t\treturn false;\n\treturn true;\n}\nstatic void checkExpression(int n)\n{\n\tif (isPrime(n))\n\t\tSystem.out.println(\"Yes\");\n\telse\n\t\tSystem.out.println(\"No\");\n}", "10377": "static int Sum(int N)\n{\n\tint SumOfPrimeDivisors[] = new int[N + 1];\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tif (SumOfPrimeDivisors[i] == 1)\n\t\t{\n\t\t\tfor (int j = i; j <= N; j += i)\n\t\t\t{\n\t\t\t\tSumOfPrimeDivisors[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\treturn SumOfPrimeDivisors[N];\n}\nstatic boolean RuthAaronNumber(int n)\n{\n\tif (Sum(n) == Sum(n + 1))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "10394": "static void Is_possible(long N)\n{\n\tlong C = 0;\n\tlong D = 0;\n\twhile (N % 10 == 0)\n\t{\n\t\tN = N / 10;\n\t\tC += 1;\n\t}\n\tif(Math.pow(2, (long)(Math.log(N) /\n\t\t\t\t\t\t(Math.log(2)))) == N)\n\t{\n\t\tD = (long)(Math.log(N) / (Math.log(2)));\n\t\tif (C >= D)\n\t\t\tSystem.out.print(\"YES\");\n\t\telse\n\t\t\tSystem.out.print(\"NO\");\n\t}\n\telse\n\t\tSystem.out.print(\"NO\");\n}", "10406": "static int maxAdjacentDifference(int N, int K)\n{\n\tif (N == 1)\n\t{\n\t\treturn 0;\n\t}\n\tif (N == 2) \n\t{\n\t\treturn K;\n\t}\n\treturn 2 * K;\n}", "10408": "public static int linearSum(int n)\n{\n\treturn (n * (n + 1) / 2) % mod;\n}\npublic static int rangeSum(int b, int a)\n{\n\treturn (linearSum(b) -\n\t\t\tlinearSum(a)) % mod;\n}\npublic static int totalSum(int n)\n{\n\tint result = 0;\n\tint i = 1;\n\twhile(true)\n\t{\n\t\tresult += rangeSum(n / i,\n\t\t\t\t\t\tn / (i + 1)) *\n\t\t\t\t\t\t(i % mod) % mod;\n\t\tresult %= mod;\n\t\tif (i == n)\n\t\t\tbreak;\n\t\ti = n / (n / (i + 1));\n\t}\n\treturn result;\n}", "10423": "static boolean isDouble(int num)\n{\n\tString s = Integer.toString(num);\n\tint l = s.length();\n\tif(s.charAt(0) == s.charAt(1))\n\treturn false;\n\tif(l % 2 == 1)\n\t{\n\t\ts = s + s.charAt(1);\n\t\tl++;\n\t}\n\tString s1 = s.substring(0, l / 2);\n\tString s2 = s.substring(l / 2);\n\treturn s1.equals(s2);\n}\nstatic boolean isNontrivialUndulant(int N)\n{\n\treturn N > 100 && isDouble(N);\n}", "10434": "static void findNthTerm(int n)\n{\n\tSystem.out.println(n * n - n + 1);\n}", "10438": "static int rev(int num)\n{\n\tint rev_num = 0;\n\twhile (num > 0)\n\t{\n\t\trev_num = rev_num * 10 +\n\t\t\t\t\tnum % 10;\n\t\tnum = num / 10;\n\t}\n\treturn rev_num;\n}\nstatic int divSum(int num)\n{\n\tint result = 0;\n\tfor(int i = 2; i <= Math.sqrt(num); i++)\n\t{\n\tif (num % i == 0)\n\t{\n\t\tif (i == (num / i))\n\t\t\tresult += rev(i);\n\t\telse\n\t\t\tresult += (rev(i) +\n\t\t\t\t\t\trev(num / i));\n\t}\n\t}\n\treturn (result + 1);\n}\nstatic boolean isAntiPerfect(int n)\n{\n\treturn divSum(n) == n;\n}", "10445": "static void printSeries(int n, int a, int b, int c)\n{\n\tint d;\n\tif (n == 1)\n\t{\n\t\tSystem.out.print(a + \" \");\n\t\treturn;\n\t}\n\tif (n == 2)\n\t{\n\t\tSystem.out.print(a + \" \" + b + \" \");\n\t\treturn;\n\t}\n\tSystem.out.print(a + \" \" + b + \" \" + c + \" \");\n\tfor (int i = 4; i <= n; i++)\n\t{\n\t\td = a + b + c;\n\t\tSystem.out.print(d + \" \");\n\t\ta = b;\n\t\tb = c;\n\t\tc = d;\n\t}\n}", "10452": "static boolean checkArray(int n, int k, int arr[])\n{\n\tint cnt = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tif ((arr[i] & 1) != 0)\n\t\tcnt += 1;\n\t}\n\tif (cnt >= k && cnt % 2 == k % 2)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "10462": "static long func(int arr[], int n)\n{\n\tdouble ans = 0;\n\tint maxx = 0;\n\tdouble freq[] = new double[100005];\n\tint temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\ttemp = arr[i];\n\tfreq[temp]++;\n\tmaxx = Math.max(maxx, temp);\n\t}\n\tfor(int i = 1; i <= maxx; i++)\n\t{\n\tfreq[i] += freq[i - 1];\n\t}\n\tfor(int i = 1; i <= maxx; i++)\n\t{\n\tif (freq[i] != 0)\n\t{\n\t\tdouble j;\n\t\tdouble cur = Math.ceil(0.5 * i) - 1.0;\n\t\tfor(j = 1.5;; j++)\n\t\t{\n\t\t\tint val = Math.min(maxx,\n\t\t\t\t(int)(Math.ceil(i * j) - 1.0));\n\t\t\tint times = (int)(freq[i] - freq[i - 1]),\n\t\t\t\t\tcon = (int)(j - 0.5);\n\t\t\tans += times * con * (freq[(int)val] -\n\t\t\t\t\t\t\t\t\tfreq[(int)cur]);\n\t\t\tcur = val;\n\t\t\tif (val == maxx)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t}\n\treturn (long)ans;\n}", "10474": "static int enneacontahexagonNum(int n)\n{\n\treturn (94 * n * n - 92 * n) / 2;\n}", "10475": "static int MegagonNum(int n)\n{\n\treturn (999998 * n * n - 999996 * n) / 2;\n}", "10492": "static void insert_element(int a[], int n)\n{\n\tint Xor = 0;\n\tint Sum = 0;\n\tfor(int i = 0; i < n; i++)\n\t{ \n\t\tXor ^= a[i];\n\t\tSum += a[i];\n\t}\n\tif(Sum == 2 * Xor)\n\t{\n\t\tSystem.out.println(\"0\");\n\t\treturn;\n\t}\n\tif(Xor == 0)\n\t{\n\t\tSystem.out.println(\"1\");\n\t\tSystem.out.println(Sum);\n\t\treturn;\n\t}\n\tint num1 = Sum + Xor;\n\tint num2 = Xor;\n\tSystem.out.print(\"2\");\n\tSystem.out.println(num1 + \" \" + num2);\n}", "10502": "static void checkSolution(int a, int b, int c)\n{\n\tif (a == c)\n\t\tSystem.out.print(\"Yes\");\n\telse\n\t\tSystem.out.print(\"No\");\n}", "10539": "static int productPairs(int arr[], int n)\n{\n\tint product = 1;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tfor(int j = 0; j < n; j++)\n\t{\n\t\tproduct *= (arr[i] % mod * arr[j] % mod) % mod;\n\t\tproduct = product % mod;\n\t}\n\t}\n\treturn product % mod;\n}", "10540": "static int power(int x, int y)\n{\n\tint p = 1000000007;\n\tint res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif (y % 2 == 1)\n\t\t\tres = (res * x) % p;\n\t\ty = y >> 1;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nstatic int productPairs(int arr[], int n)\n{\n\tint product = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tproduct = (product % mod *\n\t\t\t\t(int)power(arr[i],\n\t\t\t\t\t\t\t(2 * n)) % mod) % mod;\n\t}\n\treturn product % mod;\n}", "10546": "static void constructArray(int N)\n{\n\tint arr[] = new int[N];\n\tfor(int i = 1; i <= N; i++)\n\t{\n\tarr[i - 1] = i;\n\t}\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tSystem.out.print(arr[i] + \", \");\n\t}\n}", "10568": "static boolean isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (int i = 2; i < n; i++)\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nstatic int countSubsequences(int arr[], int n)\n{\n\tint totalSubsequence = (int)(Math.pow(2, n) - 1);\n\tint countPrime = 0, countOnes = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] == 1)\n\t\t\tcountOnes++;\n\t\telse if (isPrime(arr[i]))\n\t\t\tcountPrime++;\n\t}\n\tint compositeSubsequence;\n\tint onesSequence = (int)(Math.pow(2, countOnes) - 1);\n\tcompositeSubsequence = totalSubsequence -\n\t\t\t\t\t\t\t\tcountPrime -\n\t\t\t\t\t\t\tonesSequence -\n\t\t\t\t\t\t\tonesSequence *\n\t\t\t\t\t\t\tcountPrime;\n\treturn compositeSubsequence;\n}", "10569": "static int nCr(int n, int r)\n{\n\treturn fact(n) / (fact(r) * fact(n - r));\n}\nstatic int fact(int n)\n{\n\tint res = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tres = res * i;\n\treturn res;\n}\nstatic int sumSubsequences(int arr[], int n, int k)\n{\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) \n\t{\n\t\tsum += arr[i];\n\t}\n\tint kLengthSubSequence;\n\tkLengthSubSequence = nCr(n, k);\n\tint ans = sum * ((k * kLengthSubSequence) / n);\n\treturn ans;\n}", "10573": "static Vector<Integer> getFactorization(int x)\n{\n int count = 0;\n Vector<Integer> v = new Vector<>();\n while (x % 2 == 0)\n {\n\tcount++;\n\tx = x / 2;\n }\n if (count != 0)\n\tv.add(count);\n for (int i = 3;\n\t\ti <= Math.sqrt(x); i += 2)\n {\n\tcount = 0;\n\twhile (x % i == 0)\n\t{\n\tcount++;\n\tx /= i;\n\t}\n\tif (count != 0)\n\tv.add(count);\n }\n if (x > 1)\n {\n\tv.add(1);\n }\n return v;\n}\nstatic int nonPrimeDivisors(int N)\n{\n Vector<Integer> v = getFactorization(N);\n int ret = 1;\n for (int i = 0; i < v.size(); i++)\n\tret = ret * (v.get(i) + 1);\n ret = ret - v.size();\n return ret;\n}", "10653": "static void checksum(int n, int k)\n{\n\tfloat first_term = (float) (((2 * n) / k +\n\t\t\t\t\t\t\t\t(1 - k)) / 2.0);\n\tif (first_term - (int)(first_term) == 0)\n\t{\n\t\tfor(int i = (int)first_term; i <= first_term + k - 1; i++)\n\t\t{\n\t\tSystem.out.print(i + \" \");\n\t\t}\n\t}\n\telse\n\t\tSystem.out.print(\"-1\");\n}", "10668": "static void sumEvenNumbers(int N, int K)\n{\n\tint check = N - 2 * (K - 1);\n\tif (check > 0 && check % 2 == 0)\n\t{\n\t\tfor(int i = 0; i < K - 1; i++)\n\t\t{\n\t\tSystem.out.print(\"2 \");\n\t\t}\n\t\tSystem.out.println(check);\n\t}\n\telse\n\t{\n\t\tSystem.out.println(\"-1\");\n\t}\n}", "10677": "static boolean isPerfectSquare(double x)\n{\n\tdouble sr = Math.sqrt(x);\n\treturn((sr - Math.floor(sr)) == 0);\n}\nstatic void checkSunnyNumber(int N)\n{\n\tif (isPerfectSquare(N + 1))\n\t{\n\t\tSystem.out.println(\"Yes\");\n\t}\n\telse\n\t{\n\t\tSystem.out.println(\"No\");\n\t}\n}", "10694": "public static int[] calculateWays(int n)\n{\n\tint x = 0;\n\tint[]v = new int[n];\n\tfor(int i = 0; i < n; i++)\n\tv[i] = 0;\n\tfor(int i = 0; i < n / 2; i++)\n\t{\n\t\tif(n % 2 == 0 && i == n / 2)\n\t\tbreak;\n\t\tx = n * (i + 1) - (i + 1) * i;\n\t\tv[i] = x;\n\t\tv[n - i - 1] = x;\n\t}\n\treturn v;\n}\npublic static void printArray(int[]v)\n{\n\tfor(int i = 0; i < v.length; i++)\n\tSystem.out.print(v[i] + \" \");\n}", "10703": "static int sumOfDigits(int n)\n{\n\tint sum = 0;\n\twhile (n > 0)\n\t{\n\t\tsum += n % 10;\n\t\tn /= 10;\n\t}\n\treturn sum;\n}\nstatic int smallestNum(int X, int Y)\n{\n\tint res = -1;\n\tfor (int i = X; i < MAXN; i++)\n\t{\n\t\tint sum_of_digit = sumOfDigits(i);\n\t\tif (sum_of_digit % Y == 0)\n\t\t{\n\t\t\tres = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}", "10706": "static int countValues(int n)\n{\n\tint answer = 0;\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tint k = n;\n\t\twhile (k >= i)\n\t\t{\n\t\t\tif (k % i == 0)\n\t\t\t\tk /= i;\n\t\t\telse\n\t\t\t\tk -= i;\n\t\t}\n\t\tif (k == 1)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "10707": "static int countValues(int N)\n{\n\tVector<Integer> div = new Vector<>();\n\tfor(int i = 2; i * i <= N; i++)\n\t{\n\t\tif (N % i == 0)\n\t\t{\n\t\t\tdiv.add(i);\n\t\t\tif (N != i * i)\n\t\t\t{\n\t\t\t\tdiv.add(N / i);\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tfor(int i = 1; i * i <= N - 1; i++)\n\t{\n\t\tif ((N - 1) % i == 0)\n\t\t{\n\t\t\tif (i * i == N - 1)\n\t\t\t\tanswer++;\n\t\t\telse\n\t\t\t\tanswer += 2;\n\t\t}\n\t}\n\tfor(int d : div)\n\t{\n\t\tint K = N;\n\t\twhile (K % d == 0)\n\t\t\tK /= d;\n\t\tif ((K - 1) % d == 0)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "10719": "static void findMaxPrimeDivisor(int n)\n{\n\tint max_possible_prime = 0;\n\twhile (n % 2 == 0)\n\t{\n\t\tmax_possible_prime++;\n\t\tn = n / 2;\n\t}\n\tfor(int i = 3; i * i <= n; i = i + 2)\n\t{\n\twhile (n % i == 0)\n\t{\n\t\tmax_possible_prime++;\n\t\tn = n / i;\n\t}\n\t}\n\tif (n > 2)\n\t{\n\t\tmax_possible_prime++;\n\t}\n\tSystem.out.print(max_possible_prime + \"\\n\");\n}", "10721": "static void printKNumbers(int N, int K)\n{\n\tfor(int i = 0; i < K - 1; i++)\n\t\tSystem.out.print(1 + \" \");\n\tSystem.out.print(N - K + 1);\n}", "10751": "static int CountWays(int n)\n{\n\tint ans = (n - 1) / 2;\n\treturn ans;\n}", "10753": "static void Solve(int arr[], int size, int n)\n {\n\tint[] v = new int[n + 1];\n\tfor (int i = 0; i < size; i++)\n\tv[arr[i]]++;\n\tint max1 = -1, mx = -1;\n\tfor (int i = 0; i < v.length; i++)\n\t{\n\tif (v[i] > mx)\n\t{\n\t\tmx = v[i];\n\t\tmax1 = i;\n\t}\n\t}\n\tint cnt = 0;\n\tfor (int i : v)\n\t{\n\tif (i == 0)\n\t\t++cnt;\n\t}\n\tint diff1 = n + 1 - cnt;\n\tint max_size = Math.max(Math.min(v[max1] - 1, diff1),\n\t\t\t\t\t\t\tMath.min(v[max1], diff1 - 1));\n\tSystem.out.println(\"Maximum size is: \" + max_size);\n\tSystem.out.println(\"First Array is\");\n\tfor (int i = 0; i < max_size; i++)\n\t{\n\tSystem.out.print(max1 + \" \");\n\tv[max1] -= 1;\n\t}\n\tSystem.out.println();\n\tSystem.out.println(\"The Second Array Is :\");\n\tfor (int i = 0; i < (n + 1); i++)\n\t{\n\tif (v[i] > 0)\n\t{\n\t\tSystem.out.print(i + \" \");\n\t\tmax_size--;\n\t}\n\tif (max_size < 1)\n\t\tbreak;\n\t}\n\tSystem.out.println();\n }", "10768": "static int power(int x, int y, int p)\n{\n\tint res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif ((y & 1) == 1)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nstatic int modInverse(int n, int p)\n{\n\treturn power(n, p - 2, p);\n}\nstatic int nCrModPFermat(int n, int r, int p)\n{\n\tif (r == 0)\n\t\treturn 1;\n\tif (n < r)\n\t\treturn 0;\n\tint fac[] = new int[n + 1];\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tfac[i] = fac[i - 1] * i % p;\n\treturn (fac[n] * modInverse(fac[r], p) % p *\n\t\t\t\t\tmodInverse(fac[n - r], p) % p) % p;\n}\nstatic int SumOfXor(int a[], int n)\n{\n\tint mod = 10037;\n\tint answer = 0;\n\tfor(int k = 0; k < 32; k++)\n\t{\n\t\tint x = 0, y = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif ((a[i] & (1 << k)) != 0)\n\t\t\t\tx++;\n\t\t\telse\n\t\t\t\ty++;\n\t\t}\n\t\tanswer += ((1 << k) % mod *\n\t\t\t\t(nCrModPFermat(x, 3, mod) + x *\n\t\t\t\t\tnCrModPFermat(y, 2, mod)) % mod) % mod;\n\t}\n\treturn answer;\n}", "10801": "static int NthSmallest(int K)\n{\n\tQueue<Integer> Q = new LinkedList<>();\n\tint x = 0;\n\tfor (int i = 1; i < 10; i++)\n\t\tQ.add(i);\n\tfor (int i = 1; i <= K; i++) {\n\t\tx = Q.peek();\n\t\tQ.remove();\n\t\tif (x % 10 != 0) {\n\t\t\tQ.add(x * 10 + x % 10 - 1);\n\t\t}\n\t\tQ.add(x * 10 + x % 10);\n\t\tif (x % 10 != 9) {\n\t\t\tQ.add(x * 10 + x % 10 + 1);\n\t\t}\n\t}\n\treturn x;\n}", "10812": "public static float round(float var, int digit)\n{\n\tfloat value = (int)(var *\n\t\t\t\tMath.pow(10, digit) + .5);\n\treturn (float)value /\n\t\t(float)Math.pow(10, digit);\n}\npublic static int probability(int N)\n{\n\tint a = 2;\n\tint b = 3;\n\tif (N == 1)\n\t{\n\t\treturn a;\n\t}\n\telse if (N == 2)\n\t{\n\t\treturn b;\n\t}\n\telse\n\t{\n\t\tfor(int i = 3; i <= N; i++)\n\t\t{\n\t\t\tint c = a + b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn b;\n\t}\n}\npublic static float operations(int N)\n{\n\tint x = probability(N);\n\tint y = (int)Math.pow(2, N);\n\treturn round((float)x /\n\t\t\t\t(float)y, 2);\n}", "10874": "static boolean isPerfectCube(int x)\n\t{\n\t\tlong cr = Math.round(Math.cbrt(x));\n\t\treturn (cr * cr * cr == x);\n\t}\nstatic void checkCube(int a, int b)\n\t{\n\t\tString s1 = Integer.toString(a);\n\t\tString s2 = Integer.toString(b);\n\t\tint c = Integer.parseInt(s1 + s2);\n\t\tif (isPerfectCube(c)) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t}\n\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}", "10885": "static int largest_sum(int arr[], int n)\n\t{\n\t\tint maximum = -1;\n\t\tHashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (m.containsKey(arr[i])){\n\t\t\tm.put(arr[i], m.get(arr[i]) + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tm.put(arr[i], 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif (m.get(arr[i]) > 1) {\n\t\t\t\tif (m.containsKey(2*arr[i]))\n\t\t\t\t{\n\t\t\t\t\tm.put(2*arr[i],m.get(2 * arr[i])+ m.get(arr[i]) / 2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm.put(2*arr[i],m.get(arr[i]) / 2);\n\t\t\t\t}\n\t\t\t\tif (2 * arr[i] > maximum)\n\t\t\t\t\tmaximum = 2 * arr[i];\n\t\t\t}\n\t\t\t}\n\t\treturn maximum;\n\t}", "10897": "static void canBeReduced(int x, int y)\n{\n\tint maxi = Math.max(x, y);\n\tint mini = Math.min(x, y);\n\tif (((x + y) % 3) == 0 && maxi <= 2*mini)\n\t\tSystem.out.print(\"YES\" +\"\\n\");\n\telse\n\t\tSystem.out.print(\"NO\" +\"\\n\");\n}", "10921": "static void isPrime(int N)\n{\n\tboolean isPrime = true;\n\tint []arr = { 7, 11, 13, 17,19, 23, 29, 31 };\n\tif (N < 2) {\n\t\tisPrime = false;\n\t}\n\tif (N % 2 == 0 N % 3 == 0 N % 5 == 0) {\n\t\tisPrime = false;\n\t}\n\tfor (int i = 0; i < Math.sqrt(N); i += 30) {\n\t\tfor (int c : arr) {\n\t\t\tif (c > Math.sqrt(N)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (N % (c + i) == 0) {\n\t\t\t\t\tisPrime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isPrime)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (isPrime)\n\t\tSystem.out.println(\"Prime Number\");\n\telse\n\t\tSystem.out.println(\"Not a Prime Number\");\n}", "10932": "static void printPairs(int arr[], int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tSystem.out.print(\"(\" + arr[i]+ \", \" + arr[j]+ \")\" + \", \");\n\t\t}\n\t}\n}", "10936": "static int nearest(int n)\n\t{\n\t\tint prevSquare = (int)Math.sqrt(n);\n\t\tint nextSquare = prevSquare + 1;\n\t\tprevSquare = prevSquare * prevSquare;\n\t\tnextSquare = nextSquare * nextSquare;\n\t\tint ans = (n - prevSquare) < (nextSquare - n)? (prevSquare - n): (nextSquare - n);\n\t\treturn ans;\n\t}", "10937": "static int nearest(int n) \n\t{ \n\t\tint prevCube = (int)Math.cbrt(n); \n\t\tint nextCube = prevCube + 1; \n\t\tprevCube = prevCube * prevCube * prevCube; \n\t\tnextCube = nextCube * nextCube * nextCube; \n\t\tint ans = (n - prevCube) < (nextCube - n) ? \n\t\t\t\t\t(prevCube - n) : (nextCube - n); \n\t\treturn ans; \n\t}", "10951": "static void printValueOfPi(int N)\n\t{\n\t\tdouble pi = 2 * Math.acos(0.0);\n\t\tSystem.out.println(pi);\n\t}", "10952": "static int powOfPositive(int n)\n\t{\n\t\tint pos = (int)Math.floor((Math.log(n)/Math.log(2)));\n\t\treturn (int)Math.pow(2, pos);\n\t}\nstatic int powOfNegative(int n)\n\t{\n\t\tint pos = (int)Math.ceil((Math.log(n)/Math.log(2)));\n\t\treturn (int)(-1 * Math.pow(2, pos));\n\t}\nstatic void highestPowerOf2(int n)\n\t{\n\t\tif (n > 0)\n\t\t{\n\t\t\tSystem.out.println(powOfPositive(n));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tn = -n;\n\t\t\tSystem.out.println(powOfNegative(n));\n\t\t}\n\t}", "10960": "public static int noOfCards(int n)\n\t{\n\t\treturn n * (3 * n + 1) / 2;\n\t}", "10974": "static String smallestPoss(String s, int n)\n{\n\tString ans = \"\";\n\tint arr[] = new int[10];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tarr[s.charAt(i) - 48]++;\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfor (int j = 0; j < arr[i]; j++)\n\t\t\tans = ans + String.valueOf(i);\n\t}\n\treturn ans;\n}", "11014": "static int Count_subarray(int arr[], int n)\n{\n\tint subarray_sum, remaining_sum, count = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i; j < n; j++)\n\t\t{\n\t\t\tsubarray_sum = 0;\n\t\t\tremaining_sum = 0;\n\t\t\tfor (int k = i; k <= j; k++)\n\t\t\t{\n\t\t\t\tsubarray_sum += arr[k];\n\t\t\t}\n\t\t\tfor (int l = 0; l < i; l++)\n\t\t\t{\n\t\t\t\tremaining_sum += arr[l];\n\t\t\t}\n\t\t\tfor (int l = j + 1; l < n; l++)\n\t\t\t{\n\t\t\t\tremaining_sum += arr[l];\n\t\t\t}\n\t\t\tif (subarray_sum > remaining_sum)\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "11015": "static int Count_subarray(int arr[], int n)\n{\n\tint total_sum = 0, subarray_sum,\n\t\tremaining_sum, count = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ttotal_sum += arr[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tsubarray_sum = 0;\n\t\tfor (int j = i; j < n; j++)\n\t\t{\n\t\t\tsubarray_sum += arr[j];\n\t\t\tremaining_sum = total_sum - subarray_sum;\n\t\t\tif (subarray_sum > remaining_sum)\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "11045": "static void decBinary(int arr[], int n)\n\t{\n\t\tint k = (int)(Math.log(n) /\n\t\t\t\t\tMath.log(2));\n\t\twhile (n > 0)\n\t\t{\n\t\t\tarr[k--] = n % 2;\n\t\t\tn /= 2;\n\t\t}\n\t}\nstatic int binaryDec(int arr[], int n)\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans += arr[i] << (n - i - 1);\n\t\treturn ans;\n\t}\nstatic int getNum(int n, int k)\n\t{\n\t\tint l = (int)(Math.log(n) /\n\t\t\t\t\tMath.log(2)) + 1;\n\t\tint a[] = new int[l];\n\t\tdecBinary(a, n);\n\t\tif (k > l)\n\t\t\treturn n;\n\t\ta[k - 1] = (a[k - 1] == 0) ? 1 : 0;\n\t\treturn binaryDec(a, l);\n\t}", "11051": "static void find_composite_nos(int n)\n\t{\n\t\tSystem.out.println(9 * n + \" \" + 8 * n);\n\t}", "11052": "static int maxXOR(int arr[], int n)\n\t{\n\t\tint xorArr = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\txorArr ^= arr[i];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans = Math.max(ans, (xorArr ^ arr[i]));\n\t\treturn ans;\n\t}", "11060": "static boolean digitDividesK(int num, int k)\n\t{\n\t\twhile (num != 0)\n\t\t{\n\t\t\tint d = num % 10;\n\t\t\tif (d != 0 && k % d == 0)\n\t\t\t\treturn true;\n\t\t\tnum = num / 10;\n\t\t}\n\t\treturn false;\n\t}\nstatic int findCount(int l, int r, int k)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = l; i <= r; i++)\n\t\t{\n\t\t\tif (digitDividesK(i, k))\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "11088": "static boolean isFactorial(int n)\n\t{\n\t\tfor (int i = 1;; i++)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}", "11094": "static int lcm(int a, int b)\n{\n\tint GCD = __gcd(a, b);\n\treturn (a * b) / GCD;\n}\nstatic int MinLCM(int a[], int n)\n{\n\tint []Prefix = new int[n + 2];\n\tint []Suffix = new int[n + 2];\n\tPrefix[1] = a[0];\n\tfor (int i = 2; i <= n; i += 1)\n\t{\n\t\tPrefix[i] = lcm(Prefix[i - 1], a[i - 1]);\n\t}\n\tSuffix[n] = a[n - 1];\n\tfor (int i = n - 1; i >= 1; i -= 1)\n\t{\n\t\tSuffix[i] = lcm(Suffix[i + 1], a[i - 1]);\n\t}\n\tint ans = Math.min(Suffix[2], Prefix[n - 1]);\n\tfor (int i = 2; i < n; i += 1)\n\t{\n\t\tans = Math.min(ans, lcm(Prefix[i - 1], Suffix[i + 1]));\n\t}\n\treturn ans;\n}\nstatic int __gcd(int a, int b)\n{\n\treturn b == 0 ? a : __gcd(b, a % b);\t\n}", "11102": "static int diameter(int n)\n{\n\tint L, H, templen;\n\tL = 1;\n\tH = 0;\n\tif (n == 1) {\n\t\treturn 1;\n\t}\n\tif (n == 2) {\n\t\treturn 2;\n\t}\n\tif (n == 3) {\n\t\treturn 3;\n\t}\n\twhile (L * 2 <= n) {\n\t\tL *= 2;\n\t\tH++;\n\t}\n\tif (n >= L * 2 - 1)\n\t\treturn 2 * H + 1;\n\telse if (n >= L + (L / 2) - 1)\n\t\treturn 2 * H;\n\treturn 2 * H - 1;\n}", "11139": "static int count(int n)\n{\n\treturn n * (3 * n - 1) / 2;\n}", "11180": "static int findMinValue(int arr[], int n)\n\t{\n\t\tlong sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += arr[i];\n\t\treturn ((int)(sum / n) + 1);\n\t}", "11182": "static int modFact(int n, int m)\n\t{\n\t\tint result = 1;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tresult = (result * i) % MOD;\n\t\treturn result;\n\t}", "11194": "static void preCompute()\n{\n\tfact[0] = 1;\n\tresult[0] = 1;\n\tfor (int i = 1; i <= MAX; i++)\n\t{\n\t\tfact[i] = ((fact[i - 1] % MOD) * i) % MOD;\n\t\tresult[i] = ((result[i - 1] % MOD) *\n\t\t\t\t(fact[i] % MOD)) % MOD;\n\t}\n}\nstatic void performQueries(int q[], int n)\n{\n\tpreCompute();\n\tfor (int i = 0; i < n; i++)\n\t\tSystem.out.println (result[q[i]]);\n}", "11196": "static long gcd(long a, long b)\n\t{\n\t\tif (a == 0)\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t\treturn gcd(b % a, a);\n\t}\nstatic long divTermCount(long a, long b, long c, long num)\n\t{\n\t\treturn ((num / a) + (num / b) + (num / c) -\n\t\t\t\t(num / ((a * b) / gcd(a, b))) -\n\t\t\t\t(num / ((c * b) / gcd(c, b))) -\n\t\t\t\t(num / ((a * c) / gcd(a, c))) +\n\t\t\t\t(num / ((a * b * c) / gcd(gcd(a, b), c))));\n\t}\nstatic long findNthTerm(int a, int b, int c, long n)\n\t{\n\t\tlong low = 1, high = Long.MAX_VALUE, mid;\n\t\twhile (low < high)\n\t\t{\n\t\t\tmid = low + (high - low) / 2;\n\t\t\tif (divTermCount(a, b, c, mid) < n)\n\t\t\t{\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn low;\n\t}", "11199": "static double calculate_angle(int n, int i, int j, int k)\n{\n\tint x, y;\n\tif (i < j)\n\t\tx = j - i;\n\telse\n\t\tx = j + n - i;\n\tif (j < k)\n\t\ty = k - j;\n\telse\n\t\ty = k + n - j;\n\tdouble ang1 = (180 * x) / n;\n\tdouble ang2 = (180 * y) / n;\n\tdouble ans = 180 - ang1 - ang2;\n\treturn ans;\n}", "11204": "static long power(int p)\n\t{\n\t\tlong res = 1;\n\t\tfor (int i = 1; i <= p; ++i)\n\t\t{\n\t\t\tres *= 2;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res % mod;\n\t}\nstatic long subset_square_sum(int A[])\n\t{\n\t\tint n = A.length;\n\t\tlong ans = 0;\n\t\tfor (int i : A)\n\t\t{\n\t\t\tans += (1 * i * i) % mod;\n\t\t\tans %= mod;\n\t\t}\n\t\treturn (1 * ans * power(n - 1)) % mod;\n\t}", "11217": "static void least_prime_factor()\n{\n\tfor (int i = 2; i < N; i++)\n\t\tif (lpf[i] == 0)\n\t\t\tfor (int j = i; j < N; j += i)\n\t\t\t\tif (lpf[j] == 0)\n\t\t\t\t\tlpf[j] = i;\n}\nstatic void Mobius()\n{\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (i == 1)\n\t\t\tmobius[i] = 1;\n\t\telse\n\t\t{\n\t\t\tif (lpf[i / lpf[i]] == lpf[i])\n\t\t\t\tmobius[i] = 0;\n\t\t\telse\n\t\t\t\tmobius[i] = -1 * mobius[i / lpf[i]];\n\t\t}\n\t}\n}\nstatic int gcd_pairs(int a[], int n)\n{\n\tint maxi = 0;\n\tint []fre = new int[N];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfre[a[i]]++;\n\t\tmaxi = Math.max(a[i], maxi);\n\t}\n\tleast_prime_factor();\n\tMobius();\n\tint ans = 0;\n\tfor (int i = 1; i <= maxi; i++)\n\t{\n\t\tif (mobius[i] == 0)\n\t\t\tcontinue;\n\t\tint temp = 0;\n\t\tfor (int j = i; j <= maxi; j += i)\n\t\t\ttemp += fre[j];\n\t\tans += temp * (temp - 1) / 2 * mobius[i];\n\t}\n\treturn ans;\n}", "11253": "static void compareVal(int x, int y)\n{\n\tdouble a = y * Math.log(x);\n\tdouble b = x * Math.log(y);\n\tif (a > b)\n\t\tSystem.out.print(x + \"^\" + y + \" > \" + y + \"^\" + x);\n\telse if (a < b)\n\t\tSystem.out.print(x + \"^\" + y + \" < \" + y + \"^\" + x);\n\telse if (a == b)\n\t\tSystem.out.print(x + \"^\" + y + \" = \" + y + \"^\" + x );\n}", "11283": "static void compareValues(int a, int b, int c, int d)\n\t{\n\t\tdouble log1 = Math.log10(a);\n\t\tdouble num1 = log1 * b;\n\t\tdouble log2 = Math.log10(c);\n\t\tdouble num2 = log2 * d;\n\t\tif (num1 > num2)\n\t\t\tSystem.out.println(a + \"^\" + b);\n\t\telse\n\t\t\tSystem.out.println(c + \"^\" + d);\n\t}", "11294": "static void ZigZag(int n)\n{\n\tlong[] fact= new long[n + 1];\n\tlong[] zig = new long[n + 1];\n\tfor (int i = 0; i < n + 1; i++)\n\t\tzig[i] = 0;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfact[i] = fact[i - 1] * i;\n\tzig[0] = 1;\n\tzig[1] = 1;\n\tSystem.out.print(\"zig zag numbers: \");\n\tSystem.out.print(zig[0] + \" \" + zig[1] + \" \");\n\tfor (int i = 2; i < n; i++)\n\t{\n\t\tlong sum = 0;\n\t\tfor (int k = 0; k <= i - 1; k++)\n\t\t{\n\t\t\tsum += (fact[i - 1] / (fact[i - 1 - k] * fact[k])) * zig[k] * zig[i - 1 - k];\n\t\t}\n\t\tzig[i] = sum / 2;\n\t\tSystem.out.print(sum / 2 + \" \" );\n\t}\n}", "11302": "static int find_count(Vector<Integer> ele)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < ele.size(); i++)\n\t\t{\n\t\t\tVector<Integer> p = new Vector<Integer>();\n\t\t\tint c = 0;\n\t\t\tfor (int j = ele.size() - 1;\n\t\t\t\t\tj >= (ele.size() - 1 - i) && j >= 0; j--)\n\t\t\t{\n\t\t\t\tp.add(ele.get(j));\n\t\t\t}\n\t\t\tint j = ele.size() - 1, k = 0;\n\t\t\twhile (j >= 0)\n\t\t\t{\n\t\t\t\tif (ele.get(j) != p.get(k))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj--;\n\t\t\t\tk++;\n\t\t\t\tif (k == p.size())\n\t\t\t\t{\n\t\t\t\t\tc++;\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = Math.max(count, c);\n\t\t}\n\t\treturn count;\n\t}\nstatic void solve(int n)\n\t{\n\t\tint count = 1;\n\t\tVector<Integer> ele = new Vector<Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tSystem.out.print(count + \", \");\n\t\t\tele.add(count);\n\t\t\tcount = find_count(ele);\n\t\t}\n\t}", "11306": "static Vector<Integer> addPrimes()\n{\n\tint n = MAX;\n\tboolean []prime = new boolean[n + 1];\n\tArrays.fill(prime, true);\n\tfor (int p = 2; p * p <= n; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tVector<Integer> ans = new Vector<Integer>();\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tans.add(p);\n\treturn ans;\n}\nstatic boolean is_prime(int n)\n{\n\treturn (n == 3 n == 5 n == 7);\n}\nstatic int find_Sum(int n)\n{\n\tint sum = 0;\n\tVector<Integer> v = addPrimes();\n\tfor (int i = 0; i < v.size() && n > 0; i++)\n\t{\n\t\tint flag = 1;\n\t\tint a = v.get(i);\n\t\twhile (a != 0)\n\t\t{\n\t\t\tint d = a % 10;\n\t\t\ta = a / 10;\n\t\t\tif (is_prime(d))\n\t\t\t{\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == 1)\n\t\t{\n\t\t\tn--;\n\t\t\tsum = sum + v.get(i);\n\t\t}\n\t}\n\treturn sum;\n}", "11315": "static int Wedderburn(int n)\n{\n\tif (n <= 2)\n\t\treturn store.get(n);\n\telse if (n % 2 == 0)\n\t{\n\t\tint x = n / 2, ans = 0;\n\t\tfor (int i = 1; i < x; i++)\n\t\t{\n\t\t\tans += store.get(i) * store.get(n - i);\n\t\t}\n\t\tans += (store.get(x) * (store.get(x) + 1)) / 2;\n\t\tstore. put(n, ans);\n\t\treturn ans;\n\t}\n\telse\n\t{\n\t\tint x = (n + 1) / 2, ans = 0;\n\t\tfor (int i = 1; i < x; i++)\n\t\t{\n\t\t\tans += store.get(i) * store.get(n - i);\n\t\t}\n\t\tstore. put(n, ans);\n\t\treturn ans;\n\t}\n}\nstatic void Wedderburn_Etherington(int n)\n{\n\tstore. put(0, 0);\n\tstore. put(1, 1);\n\tstore. put(2, 1);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tSystem.out.print(Wedderburn(i));\n\t\tif(i != n - 1)\n\t\t\tSystem.out.print(\" \");\n\t}\n}", "11331": "static int Max_sum(int a[], int n)\n{\n\tint pos = 0, neg = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(a[i] > 0)\n\t\t\tpos = 1;\n\t\telse if(a[i] < 0)\n\t\t\tneg = 1;\n\t\tif((pos == 1) && (neg == 1))\n\t\t\tbreak;\n\t}\n\tint sum = 0;\n\tif((pos == 1) && (neg == 1))\n\t{\n\t\tfor(int i = 0; i < n ; i++)\n\t\t\tsum += Math.abs(a[i]);\n\t}\n\telse if(pos == 1)\n\t{\n\t\tint mini = a[0];\n\t\tsum = a[0];\n\t\tfor(int i = 1; i < n; i++)\n\t\t{\n\t\t\tmini = Math.min(mini, a[i]);\n\t\t\tsum += a[i];\n\t\t}\n\t\tsum -= 2*mini;\n\t}\n\telse if(neg == 1)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t\ta[i] = Math.abs(a[i]);\n\t\tint mini = a[0];\n\t\tsum = a[0];\n\t\tfor(int i = 1; i < n; i++)\n\t\t{\n\t\t\tmini = Math.min(mini, a[i]);\n\t\t\tsum += a[i];\n\t\t}\n\t\tsum -= 2*mini;\n\t}\n\treturn sum;\n}", "11342": "static void decimalToBinary(int n)\n{\n\tif (n == 0)\n\t{\n\t\tSystem.out.print(\"0\");\n\t\treturn;\n\t}\n\tdecimalToBinary(n / 2);\n\tSystem.out.print( n % 2);\n}", "11343": "static void MinimumValue(int x, int y)\n{\n\tif (x > y)\n\t{\n\t\tint temp = x;\n\t\t\tx = y;\n\t\t\ty = temp;\n\t}\n\tint a = 1;\n\tint b = x - 1;\n\tint c = y - b;\n\tSystem.out.print( a + \" \" + b + \" \" + c);\n}", "11370": "static boolean canConvert(int a, int b)\n\t{\n\t\twhile (b > a)\n\t\t{\n\t\t\tif (b % 10 == 1)\n\t\t\t{\n\t\t\t\tb /= 10;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b % 2 == 0)\n\t\t\t{\n\t\t\t\tb /= 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (b == a)\n\t\t\treturn true;\n\t\treturn false;\n\t}", "11387": "static int count(int N)\n\t{\n\t\tint a = 0;\n\t\ta = (N * (N + 1)) / 2;\n\t\treturn a;\n\t}", "11404": "static int numberOfDays(int a, int b, int n)\n{\n\tint Days = b * (n + a) / (a + b);\n\treturn Days;\n}", "11418": "static int getAverage(int x, int y)\n\t{\n\t\tint avg = (x & y) + ((x ^ y) >> 1);\n\t\treturn avg;\n\t}", "11435": "static int max_element(int a[])\n{\n\tint m = a[0];\n\tfor(int i = 0; i < a.length; i++)\n\t\tm = Math.max(a[i], m);\n\treturn m;\n}\nstatic int primeCount(int arr[], int n)\n{\n\tint max_val = max_element(arr);\n\tboolean prime[] = new boolean[max_val + 1];\n\tfor (int p = 0; p <= max_val; p++)\n\t\tprime[p] = true;\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (int p = 2; p * p <= max_val; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * 2; i <= max_val; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tint count = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (prime[arr[i]])\n\t\t\tcount++;\n\treturn count;\n}\nstatic int[] getPrefixArray(int arr[], int n, int pre[])\n{\n\tpre[0] = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tpre[i] = pre[i - 1] + arr[i];\n\t}\n\treturn pre;\n}", "11510": "static int smallestIndex(int []a, int n)\n{\n\tint right1 = 0, right0 = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] == 1)\n\t\t\tright1 = i;\n\t\telse\n\t\t\tright0 = i;\n\t}\n\treturn Math.min(right1, right0);\n}", "11523": "static int freqPairs(int arr[], int n)\n\t{\n\t\tint max = Arrays.stream(arr).max().getAsInt();\n\t\tint freq[] = new int[max + 1];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfreq[arr[i]]++;\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 2 * arr[i]; j <= max; j += arr[i])\n\t\t\t{\n\t\t\t\tif (freq[j] >= 1)\n\t\t\t\t{\n\t\t\t\t\tcount += freq[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (freq[arr[i]] > 1)\n\t\t\t{\n\t\t\t\tcount += freq[arr[i]] - 1;\n\t\t\t\tfreq[arr[i]]--;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "11533": "static int countSquares(int r, int c, int m)\n\t{\n\t\tint squares = 0;\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tif (Math.max(Math.abs(i - r), Math.abs(j - c)) <= m)\n\t\t\t\t\tsquares++;\n\t\t\t}\n\t\t}\n\t\treturn squares;\n\t}", "11549": "static void Loss(int SP, int P)\n{\n\tfloat loss = 0;\n\tloss = (float)(2 * P * P * SP) / (100 * 100 - P * P);\n\tSystem.out.println(\"Loss = \" + loss);\n}", "11611": "static void sieve()\n{\n\tspf[1] = 1;\n\tfor (int i = 2; i < MAXN; i++)\n\t\tspf[i] = i;\n\tfor (int i = 4; i < MAXN; i += 2)\n\t\tspf[i] = 2;\n\tfor (int i = 3; i * i < MAXN; i++)\n\t{\n\t\tif (spf[i] == i)\n\t\t{\n\t\t\tfor (int j = i * i; j < MAXN; j += i)\n\t\t\t\tif (spf[j] == j)\n\t\t\t\t\tspf[j] = i;\n\t\t}\n\t}\n}\nstatic void getFactorization(int x)\n{\n\tint temp;\n\twhile (x != 1)\n\t{\n\t\ttemp = spf[x];\n\t\tif (x % temp == 0)\n\t\t{\n\t\t\thash1[spf[x]]++;\n\t\t\tx = x / spf[x];\n\t\t}\n\t\twhile (x % temp == 0)\n\t\t\tx = x / temp;\n\t}\n}\nstatic boolean check(int x)\n{\n\tint temp;\n\twhile (x != 1)\n\t{\n\t\ttemp = spf[x];\n\t\tif (x % temp == 0 && hash1[temp] > 1)\n\t\t\treturn false;\n\t\twhile (x % temp == 0)\n\t\t\tx = x / temp;\n\t}\n\treturn true;\n}\nstatic boolean hasValidNum(int []arr, int n)\n{\n\tsieve();\n\tfor (int i = 0; i < n; i++)\n\t\tgetFactorization(arr[i]);\n\tfor (int i = 0; i < n; i++)\n\t\tif (check(arr[i]))\n\t\t\treturn true;\n\treturn false;\n}", "11613": "static int countQuadruples(int a[], int n)\n\t{\n\t\tHashMap<Integer, Integer> mp = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (mp.containsKey(a[i]))\n\t\t\t{\n\t\t\t\tmp.put(a[i], mp.get(a[i]) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.put(a[i], 1);\n\t\t\t}\n\t\tint count = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tmp.put(a[j], mp.get(a[j]) - 1);\n\t\t\t\tmp.put(a[k], mp.get(a[k]) - 1);\n\t\t\t\tint first = a[j] - (a[k] - a[j]);\n\t\t\t\tint fourth = (a[k] * a[k]) / a[j];\n\t\t\t\tif ((a[k] * a[k]) % a[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (a[j] != a[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mp.containsKey(first) && mp.containsKey(fourth))\n\t\t\t\t\t\t\tcount += mp.get(first) * mp.get(fourth);\n\t\t\t\t\t}\n\t\t\t\t\telse if (mp.containsKey(first) && mp.containsKey(fourth))\n\t\t\t\t\t\tcount += mp.get(first) * (mp.get(fourth) - 1);\n\t\t\t\t}\n\t\t\t\tif (mp.containsKey(a[j]))\n\t\t\t\t{\n\t\t\t\t\tmp.put(a[j], mp.get(a[j]) + 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp.put(a[j], 1);\n\t\t\t\t}\n\t\t\t\tif (mp.containsKey(a[k]))\n\t\t\t\t{\n\t\t\t\t\tmp.put(a[k], mp.get(a[k]) + 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp.put(a[k], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "11626": "static int countNumbers(int L, int R, int K) {\n\t\tif (K == 9) {\n\t\t\tK = 0;\n\t\t}\n\t\tint totalnumbers = R - L + 1;\n\t\tint factor9 = totalnumbers / 9;\n\t\tint rem = totalnumbers % 9;\n\t\tint ans = factor9;\n\t\tfor (int i = R; i > R - rem; i--) {\n\t\t\tint rem1 = i % 9;\n\t\t\tif (rem1 == K) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}", "11627": "static int countWays(int N)\n{\n\tint E = (N * (N - 1)) / 2;\n\tif (N == 1)\n\t\treturn 0;\n\treturn (int)Math.pow(2, E - 1);\n}", "11628": "static int EvenSum(int [] A, int index, int value)\n\t{\n\t\tA[index] = A[index] + value;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < A.length; i++)\n\t\t\tif (A[i] % 2 == 0)\n\t\t\t\tsum = sum + A[i];\n\t\treturn sum;\n\t}\nstatic void BalanceArray(int [] A, int [][] Q)\n\t{\n\t\tint [] ANS = new int[Q.length];\n\t\tint i, sum;\n\t\tfor (i = 0; i < Q.length; i++)\n\t\t{\n\t\t\tint index = Q[i][0];\n\t\t\tint value = Q[i][1];\n\t\t\tsum = EvenSum(A, index, value);\n\t\t\tANS[i] = sum;\n\t\t}\n\t\tfor (i = 0; i < ANS.length; i++)\n\t\t\tSystem.out.print(ANS[i] + \" \");\n\t}", "11629": "static void BalanceArray(int [] A, int [][] Q)\n\t{\n\t\tint [] ANS = new int [A.length];\n\t\tint i, sum = 0;\n\t\tfor (i = 0; i < A.length; i++)\n\t\t\tif (A[i] % 2 == 0)\n\t\t\t\tsum = sum + A[i];\n\t\tfor (i = 0; i < Q.length; i++)\n\t\t{\n\t\t\tint index = Q[i][0];\n\t\t\tint value = Q[i][1];\n\t\t\tif (A[index] % 2 == 0)\n\t\t\t\tsum = sum - A[index];\n\t\t\tA[index] = A[index] + value;\n\t\t\tif (A[index] % 2 == 0)\n\t\t\t\tsum = sum + A[index];\n\t\t\tANS[i]= sum;\n\t\t}\n\t\tfor (i = 0; i < ANS.length; i++)\n\t\t\tSystem.out.print(ANS[i] + \" \");\n\t}", "11658": "static int Cycles(int N)\n{\n\tint fact = 1, result = 0;\n\tresult = N - 1;\n\tint i = result;\n\twhile (i > 0)\n\t{\n\t\tfact = fact * i;\n\t\ti--;\n\t}\n\treturn fact / 2;\n}", "11667": "static int findAndSum(int []arr, int n)\n{\n\tint sum = 0;\n\tint mul = 1;\n\tfor (int i = 0; i < 30; i++)\n\t{\n\t\tboolean count_on = false;\n\t\tint l = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif ((arr[j] & (1 << i)) > 0)\n\t\t\t\tif (count_on)\n\t\t\t\t\tl++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount_on = true;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\telse if (count_on)\n\t\t\t{\n\t\t\t\tsum += ((mul * l * (l + 1)) / 2);\n\t\t\t\tcount_on = false;\n\t\t\t\tl = 0;\n\t\t\t}\n\t\t}\n\t\tif (count_on)\n\t\t{\n\t\t\tsum += ((mul * l * (l + 1)) / 2);\n\t\t\tcount_on = false;\n\t\t\tl = 0;\n\t\t}\n\t\tmul *= 2;\n\t}\n\treturn sum;\n}", "11677": "static void initialize()\n\t{\n\t\tl[0][0] = 1;\n\t\tfor (int i = 1; i < 1001; i++) {\n\t\t\tl[i][0] = 1;\n\t\t\tfor (int j = 1; j < i + 1; j++) {\n\t\t\t\tl[i][j] = (l[i - 1][j - 1] + l[i - 1][j]);\n\t\t\t}\n\t\t}\n\t}\nstatic int nCr(int n, int r)\n\t{\n\t\treturn l[n][r];\n\t}", "11687": "static int minValue(int n, int x, int y)\n{\n\tfloat val = (y * n) / 100;\n\tif (x >= val)\n\t\treturn 0;\n\telse\n\t\treturn (int)(Math.ceil(val)-x);\n}", "11707": "static boolean digitWell(int n, int m, int k)\n{\n\tint cnt = 0;\n\twhile (n > 0)\n\t{\n\t\tif (n % 10 == m)\n\t\t\t++cnt;\n\t\tn /= 10;\n\t}\n\treturn cnt == k;\n}\nstatic int findInt(int n, int m, int k)\n{\n\tint i = n + 1;\n\twhile (true)\n\t{\n\t\tif (digitWell(i, m, k))\n\t\t\treturn i;\n\t\ti++;\n\t}\n}", "11709": "static int minAbsDiff(int n)\n\t{\n\t\tint mod = n % 4;\n\t\tif (mod == 0 mod == 3)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}", "11722": "static int countOdd(int [] arr, int n)\n\t{\n\t\tint odd = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] % 2 == 1)\n\t\t\t\todd++;\n\t\t}\n\t\treturn odd;\n\t}\nstatic int countValidPairs(int [] arr, int n)\n\t{\n\t\tint odd = countOdd(arr, n);\n\t\treturn (odd * (odd - 1)) / 2;\n\t}", "11748": "static int gcd(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\nstatic int lcmOfArray(int arr[], int n)\n{\n\tif (n < 1)\n\t\treturn 0;\n\tint lcm = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\treturn lcm;\n}\nstatic int minPerfectCube(int arr[], int n)\n{\n\tint minPerfectCube;\n\tint lcm = lcmOfArray(arr, n);\n\tminPerfectCube = lcm;\n\tint cnt = 0;\n\twhile (lcm > 1 && lcm % 2 == 0)\n\t{\n\t\tcnt++;\n\t\tlcm /= 2;\n\t}\n\tif (cnt % 3 == 2)\n\t\tminPerfectCube *= 2;\n\telse if (cnt % 3 == 1)\n\t\tminPerfectCube *= 4;\n\tint i = 3;\n\twhile (lcm > 1)\n\t{\n\t\tcnt = 0;\n\t\twhile (lcm % i == 0)\n\t\t{\n\t\t\tcnt++;\n\t\t\tlcm /= i;\n\t\t}\n\t\tif (cnt % 3 == 1)\n\t\t\tminPerfectCube *= i * i;\n\t\telse if (cnt % 3 == 2)\n\t\t\tminPerfectCube *= i;\n\t\ti += 2;\n\t}\n\treturn minPerfectCube;\n}", "11772": "static boolean isPrime(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nstatic boolean isStrongPrime(int n)\n\t{\n\t\tif (!isPrime(n) n == 2)\n\t\t\treturn false;\n\t\tint previous_prime = n - 1;\n\t\tint next_prime = n + 1;\n\t\twhile (!isPrime(next_prime))\n\t\t\tnext_prime++;\n\t\twhile (!isPrime(previous_prime))\n\t\t\tprevious_prime--;\n\t\tint mean = (previous_prime + next_prime) / 2;\n\t\tif (n > mean)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "11774": "static boolean isPrime(long n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nstatic boolean isFactorialPrime(long n)\n\t{\n\t\tif (!isPrime(n))\n\t\t\treturn false;\n\t\tlong fact = 1;\n\t\tint i = 1;\n\t\twhile (fact <= n + 1) {\n\t\t\tfact = fact * i;\n\t\t\tif (n + 1 == fact n - 1 == fact)\n\t\t\t\treturn true;\n\t\t\ti++;\n\t\t}\n\t\treturn false;\n\t}", "11815": "static int countDigitsToBeRemoved(int N, int K)\n\t{\n\t\tString s = Integer.toString(N);\n\t\tint res = 0;\n\t\tint f_zero = 0;\n\t\tfor (int i = s.length() - 1; i >= 0; i--) {\n\t\t\tif (K == 0)\n\t\t\t\treturn res;\n\t\t\tif (s.charAt(i) == '0') {\n\t\t\t\tf_zero = 1;\n\t\t\t\tK--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tres++;\n\t\t}\n\t\tif (K == 0)\n\t\t\treturn res;\n\t\telse if (f_zero == 1)\n\t\t\treturn s.length() - 1;\n\t\treturn -1;\n\t}", "11906": "public static float getSum(int a, int n)\n\t{\n\t\tfloat sum = 0;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tsum += (i / Math.pow(a, i));\n\t\t}\n\t\treturn sum;\n\t}", "11948": "static boolean check(int s)\n{\n\tint[] freq = new int[10];\n\tint r,i;\n\tfor(i=0;i<10;i++)\n\t{\n\t\tfreq[i]= 0;\n\t}\n\twhile(s != 0)\n\t{\n\t\tr = s % 10;\n\t\ts = (int)(s / 10);\n\t\tfreq[r] += 1;\n\t}\n\tint xor__ = 0;\n\tfor ( i=0;i<10;i++)\n\t{\n\txor__ = xor__ ^ freq[i];\n\tif(xor__ == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n\t}\n\treturn true;\n}", "11998": "static int largestPrimeFactor(int n)\n\t{\n\t\tint max = -1;\n\t\twhile (n % 2 == 0) {\n\t\t\tmax = 2;\n\t\t}\n\t\tfor (int i = 3; i <= Math.sqrt(n); i += 2) {\n\t\t\twhile (n % i == 0) {\n\t\t\t\tmax = i;\n\t\t\t\tn = n / i;\n\t\t\t}\n\t\t}\n\t\tif (n > 2)\n\t\t\tmax = n;\n\t\treturn max;\n\t}\nstatic boolean checkUnusual(int n)\n\t{\n\t\tint factor = largestPrimeFactor(n);\n\t\tif (factor > Math.sqrt(n)) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}", "12002": "static double Nth_Term(int n)\n{\n\treturn (2 * Math.pow(n, 3) - 3 *\n\t\t\t\tMath.pow(n, 2) + n + 6) / 6;\n}", "12035": "static void isHalfReducible(int arr[], int n, int m)\n\t{\n\t\tint frequencyHash[] = new int[m + 1];\n\t\tint i;\n\t\tfor(i = 0 ; i < frequencyHash.length ; i++)\n\t\t\tfrequencyHash[i] = 0 ;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfrequencyHash[arr[i] % (m + 1)]++;\n\t\t}\n\t\tfor (i = 0; i <= m; i++) {\n\t\t\tif (frequencyHash[i] >= n / 2)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i <= m)\n\t\t\tSystem.out.println(\"Yes\") ;\n\t\telse\n\t\t\tSystem.out.println(\"No\") ;\n\t}", "12037": "static void generateDivisors(int n)\n\t{\n\t\tfor (int i = 1; i <= Math.sqrt(n); i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tif (n / i == i)\n\t\t\t\t\tarr.add(i);\n\t\t\t\t{\n\t\t\t\t\tarr.add(i);\n\t\t\t\t\tarr.add(n / i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nstatic double harmonicMean(int n)\n\t{\n\t\tgenerateDivisors(n);\n\t\tdouble sum = 0.0;\n\t\tint len = arr.size();\n\t\tfor (int i = 0; i < len; i++)\n\t\t\tsum = sum + n / arr.get(i);\n\t\tsum = sum / n;\n\t\treturn arr.size() / sum;\n\t}\nstatic boolean isOreNumber(int n)\n\t{\n\t\tdouble mean = harmonicMean(n);\n\t\tif (mean - Math.floor(mean) == 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "12058": "", "12070": "static void printLines(int n, int k)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tSystem.out.println ( k * (6 * i + 1) + \" \"\n\t\t\t+ k * (6 * i + 2) + \" \"\n\t\t\t+ k * (6 * i + 3) + \" \"\n\t\t\t+ k * (6 * i + 5) );\n\t}\n}", "12076": "static void SieveOfEratosthenes()\n\t{\n\t\tboolean[] prime = new boolean[MAX];\n\t\tfor (int i = 0; i < MAX; i++)\n\t\t\tprime[i] = true;\n\t\tfor (int p = 2; p * p < MAX; p++) {\n\t\t\tif (prime[p] == true) {\n\t\t\t\tfor (int i = p * 2; i < MAX; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int p = 2; p < MAX; p++)\n\t\t\tif (prime[p])\n\t\t\t\tarr.add(p);\n\t}\nstatic boolean isEuclid(long n)\n\t{\n\t\tlong product = 1;\n\t\tint i = 0;\n\t\twhile (product < n) {\n\t\t\tproduct = product * arr.get(i);\n\t\t\tif (product + 1 == n)\n\t\t\t\treturn true;\n\t\t\ti++;\n\t\t}\n\t\treturn false;\n\t}", "12077": "static void SieveOfEratosthenes()\n{\n\tboolean []prime = new boolean[MAX];\n\tArrays.fill(prime, true);\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (int p = 2; p * p < MAX; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * 2; i < MAX; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tint product = 1;\n\tfor (int p = 2; p < MAX; p++)\n\t{\n\t\tif (prime[p])\n\t\t{\n\t\t\tproduct = product * p;\n\t\t\ts.add(product + 1);\n\t\t}\n\t}\n}\nstatic boolean isEuclid(int n)\n{\n\tif (s.contains(n))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "12078": "static boolean isPrime(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (int i = 5; i * i <= n; i = i + 6) {\n\t\t\tif (n % i == 0 || n % (i + 2) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\nstatic boolean isPowerOfTwo(int n)\n\t{\n\t\treturn n != 0 && ((n & (n - 1)) == 0);\n\t}", "12117": "static float area(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat area = (float)Math.pow((a * Math.sqrt(3)) / (Math.sqrt(2)), 2);\n\treturn area;\n}", "12147": "static int nthTerm(int n)\n\t{\n\t\treturn 3 * (int) Math.pow(n, 2) - 4 * n + 2;\n\t}", "12157": "static int calculateSum(int n)\n\t{\n\t\treturn n * (n + 1) / 2 \n\t\t\t+ (int)Math.pow((n * (n + 1) / 2), 2);\n\t}", "12170": "static String findNthNo(int n)\n\t{\n\t\tString res = \"\";\n\t\twhile (n >= 1) {\n\t\t\tif ((n & 1) == 1) {\n\t\t\t\tres = res + \"3\";\n\t\t\t\tn = (n - 1) / 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = res + \"5\";\n\t\t\t\tn = (n - 2) / 2;\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder(res);\n\t\tsb.reverse();\n\t\treturn new String(sb);\n\t}", "12180": "static int printNthElement(int n)\n\t{\n\t\tint arr[] = new int[n + 1];\n\t\tarr[1] = 3;\n\t\tarr[2] = 5;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tif (i % 2 != 0)\n\t\t\t\tarr[i] = arr[i / 2] * 10 + 3;\n\t\t\telse\n\t\t\t\tarr[i] = arr[(i / 2) - 1] * 10 + 5;\n\t\t}\n\t\treturn arr[n];\n\t}", "12185": "static boolean arePermutations(int a[], int b[], int n, int m)\n{\n\tint sum1 = 0, sum2 = 0, mul1 = 1, mul2 = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tsum1 += a[i];\n\t\tmul1 *= a[i];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tsum2 += b[i];\n\t\tmul2 *= b[i];\n\t}\n\treturn ((sum1 == sum2) && (mul1 == mul2));\n}", "12191": "static int nextPerfectCube(int N)\n{\n\tint nextN = (int)Math.floor(Math.cbrt(N)) + 1;\n\treturn nextN * nextN * nextN;\n}", "12192": "public int nthTerm(int N)\n\t{\n\t\treturn (N * ((N / 2) + ((N % 2) * 2) + N));\n\t}", "12225": "static int Race(int B, int C)\n{\n\tint result = 0;\n\tresult = ((C * 100) / B);\n\treturn 100 - result;\n}", "12228": "static int calculateSum(int n)\n{\n\treturn ((int)Math.pow(2, n + 1) + n - 2);\n}", "12239": "static float Time(float arr[], int n, float Emptypipe)\n{\n\tfloat fill = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfill += 1 / arr[i];\n\tfill = fill - (1 / (float)Emptypipe);\n\treturn 1 / fill;\n}", "12261": "static boolean isPrime(int n)\n{\n\tint i, c = 0;\n\tfor (i = 1; i < n / 2; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t\tc++;\n\t}\n\tif (c == 1)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nstatic void findMinNum(int arr[], int n)\n{\n\tint first = 0, last = 0, num, rev, i;\n\tint hash[] = new int[10];\n\tfor ( i = 0; i < n; i++)\n\t{\n\t\thash[arr[i]]++;\n\t}\n\tSystem.out.print(\"Minimum number: \");\n\tfor ( i = 0; i <= 9; i++)\n\t{\n\t\tfor (int j = 0; j < hash[i]; j++)\n\t\t\tSystem.out.print(i);\n\t}\n\tSystem.out.println();\n\tSystem.out.println();\n\tfor (i = 0; i <= 9; i++)\n\t{\n\t\tif (hash[i] != 0)\n\t\t{\n\t\t\tfirst = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 9; i >= 0; i--)\n\t{\n\t\tif (hash[i] != 0)\n\t\t{\n\t\t\tlast = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnum = first * 10 + last;\n\trev = last * 10 + first;\n\tSystem.out.print( \"Prime combinations: \");\n\tif (isPrime(num) && isPrime(rev))\n\t{\n\t\tSystem.out.println(num + \" \" + rev);\n\t} \n\telse if (isPrime(num))\n\t{\n\t\tSystem.out.println(num);\n\t} \n\telse if (isPrime(rev))\n\t{\n\t\tSystem.out.println(rev);\n\t} \n\telse\n\t{\n\t\tSystem.out.println(\"No combinations exist\");\n\t}\n}", "12264": "static int check(int n)\n{\n\tint sum = 0;\n\twhile (n != 0)\n\t{\n\t\tsum += n % 10;\n\t\tn = n / 10;\n\t}\n\tif (sum % 7 == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "12314": "static boolean isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 ||\n\t\t\tn % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nstatic int SumOfPrimeDivisors(int n)\n{\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (isPrime(i))\n\t\t\t\tsum += i;\n\t\t}\n\t}\n\treturn sum;\n}", "12315": "static int Sum(int N)\n{\n\tint SumOfPrimeDivisors[] = new int[N + 1];\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tif (SumOfPrimeDivisors[i] == 0)\n\t\t{\n\t\t\tfor (int j = i; j <= N; j += i)\n\t\t\t{\n\t\t\t\tSumOfPrimeDivisors[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\treturn SumOfPrimeDivisors[N];\n}", "12316": "static boolean isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor(int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nstatic int SumOfPrimeDivisors(int n)\n{\n\tint sum = 0;\n\tint root_n = (int)Math.sqrt(n);\n\tfor(int i = 1; i <= root_n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (i == n / i && isPrime(i))\n\t\t\t{\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isPrime(i))\n\t\t\t\t{\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\tif (isPrime(n / i))\n\t\t\t\t{\n\t\t\t\t\tsum += (n / i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "12333": "static int findNthNonSquare(int n)\n{\n\tdouble x = (double)n;\n\tdouble ans = x + Math.floor(0.5 +\n\t\t\t\t\tMath.sqrt(x));\n\treturn (int)ans;\n}", "12340": "static long power(long x, long y, long p)\n{\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif ((y & 1) > 0)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}", "12422": "static String find_Square_369(String num)\n\t{\n\t\tchar a, b, c, d;\n\t\tif (num.charAt(0) == '3')\n\t\t\t{a = '1'; b = '0'; c = '8'; d = '9';}\n\t\telse if (num.charAt(0) == '6')\n\t\t\t{a = '4'; b = '3'; c = '5'; d = '6';}\n\t\telse\n\t\t\t{a = '9'; b = '8'; c = '0'; d = '1';}\n\t\tString result = \"\";\n\t\tint size = num.length();\n\t\tfor (int i = 1; i < size; i++)\n\t\t\tresult += a;\n\t\tresult += b;\n\t\tfor (int i = 1; i < size; i++)\n\t\t\tresult += c;\n\t\tresult += d;\n\t\treturn result;\n\t}", "12430": "", "12439": "static int findpos(String n)\n{\n\tint pos = 0;\n\tfor (int i = 0; i < n.length(); i++)\n\t{\n\t\tswitch (n.charAt(i))\n\t\t{\n\t\tcase '2':\n\t\t\tpos = pos * 4 + 1;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tpos = pos * 4 + 2;\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tpos = pos * 4 + 3;\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tpos = pos * 4 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn pos;\n}", "12462": "static int fact(int n)\n{\n\tif (n == 0 n == 1)\n\t\treturn 1 ;\n\tint ans = 1;\n\tfor (int i = 1 ; i <= n; i++)\n\t\tans = ans * i ;\n\treturn ans ;\n}\nstatic int nCr(int n, int r)\n{\n\tint Nr = n , Dr = 1 , ans = 1;\n\tfor (int i = 1 ; i <= r ; i++ )\n\t{\n\t\tans = ( ans * Nr ) / ( Dr ) ;\n\t\tNr-- ;\n\t\tDr++ ;\n\t}\n\treturn ans ;\n}\nstatic int solve ( int n )\n{\n\tint N = 2 * n - 2 ;\n\tint R = n - 1 ;\n\treturn nCr (N, R) * fact(n - 1) ;\n}", "12485": "static int gcd(int a, int b)\n\t{\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\nstatic boolean coprime(int a, int b)\n\t{\n\t\treturn (gcd(a, b) == 1);\n\t}\nstatic void possibleTripletInRange(int L, int R)\n\t{\n\t\tboolean flag = false;\n\t\tint possibleA = 0, possibleB = 0,\n\t\t\t\t\t\tpossibleC = 0;\n\t\tfor (int a = L; a <= R; a++) {\n\t\t\tfor (int b = a + 1; b <= R; b++) {\n\t\t\t\tfor (int c = b + 1; c <= R; c++)\n\t\t\t\t{\n\t\t\t\t\tif (coprime(a, b) && coprime(b, c)\n\t\t\t\t\t\t\t\t\t&& !coprime(a, c))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tpossibleA = a;\n\t\t\t\t\t\tpossibleB = b;\n\t\t\t\t\t\tpossibleC = c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag == true) {\n\t\t\tSystem.out.println(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible triplet \" + \"between \" + L + \" and \" + R);\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"No Such Triplet exists\" + \"between \" + L + \" and \" + R);\n\t\t}\n\t}", "12486": "static void possibleTripletInRange(int L, int R)\n{\n\tboolean flag = false;\n\tint possibleA = 0,\n\t\tpossibleB = 0,\n\t\tpossibleC = 0;\n\tint numbersInRange = (R - L + 1);\n\tif (numbersInRange < 3)\n\t{\n\t\tflag = false;\n\t}\n\telse if (numbersInRange > 3)\n\t{\n\t\tflag = true;\n\t\tif (L % 2 > 0)\n\t\t{\n\t\t\tL++;\n\t\t}\n\t\tpossibleA = L;\n\t\tpossibleB = L + 1;\n\t\tpossibleC = L + 2;\n\t}\n\telse\n\t{\n\t\tif (!(L % 2 > 0))\n\t\t{\n\t\t\tflag = true;\n\t\t\tpossibleA = L;\n\t\t\tpossibleB = L + 1;\n\t\t\tpossibleC = L + 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t}\n\tif (flag == true)\n\t{\n\t\tSystem.out.println(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible\" + \" triplet between \" + L + \" and \" + R );\n\t}\n\telse {\n\t\tSystem.out.println(\"No Such Triplet\" + \" exists between \" + L + \" and \" + R);\n\t}\n}", "12496": "static boolean possibleToReach(int a, int b)\n\t{\n\t\tint c = (int)Math.cbrt(a * b);\n\t\tint re1 = a / c;\n\t\tint re2 = b / c;\n\t\tif ((re1 * re1 * re2 == a) &&\n\t\t\t\t\t\t(re2 * re2 * re1 == b))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "12520": "public static boolean isUndulating(String n)\n\t{\n\t\t\tif (n.length() <= 2)\n\t\t\t\treturn false;\n\t\tfor (int i = 2; i < n.length(); i++)\n\t\t\tif (n.charAt(i-2) != n.charAt(i))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "12523": "static void pythagoreanTriplet(int n)\n\t{\n\t\tfor (int i = 1; i <= n / 3; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j <= n / 2; j++)\n\t\t\t{\n\t\t\t\tint k = n - i - j;\n\t\t\t\tif (i * i + j * j == k * k)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(i + \", \"+ j + \", \" + k);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(\"No Triplet\");\n\t}", "12532": "static int factorial(int n)\n\t{\n\t\tint f = 1;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tf *= i;\n\t\treturn f;\n\t}\nstatic void series(int A, int X, int n)\n\t{\n\t\tint nFact = factorial(n);\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\tint niFact = factorial(n - i);\n\t\t\tint iFact = factorial(i);\n\t\t\tint aPow = (int)Math.pow(A, n - i);\n\t\t\tint xPow = (int)Math.pow(X, i);\n\t\t\tSystem.out.print((nFact * aPow * xPow)\n\t\t\t\t\t\t/ (niFact * iFact) + \" \");\n\t\t}\n\t}", "12533": "static void series(int A, int X, int n)\n\t{\n\t\tint term = (int)Math.pow(A, n);\n\t\tSystem.out.print(term + \" \");\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tterm = term * X * (n - i + 1)\n\t\t\t\t\t\t\t\t/ (i * A);\n\t\t\tSystem.out.print(term + \" \");\n\t\t}\n\t}", "12547": "static int seiresSum(int n, int[] a)\n\t{\n\t\tint res = 0, i;\n\t\tfor (i = 0; i < 2 * n; i++)\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t\tres += a[i] * a[i];\n\t\t\telse\n\t\t\t\tres -= a[i] * a[i];\n\t\t}\n\t\treturn res;\n\t}", "12548": "static int seiresSum(int n, int[] a)\n\t{\n\treturn n * (a[0] * a[0] - a[2 * n - 1] * a[2 * n - 1]) / (2 * n - 1);\n\t}", "12550": "public static boolean checkdigit(int n, int k)\n\t{\n\t\twhile (n != 0)\n\t\t{\n\t\t\tint rem = n % 10;\n\t\t\tif (rem == k)\n\t\t\t\treturn true;\n\t\t\tn = n / 10;\n\t\t}\n\t\treturn false;\n\t}\npublic static int findNthNumber(int n, int k)\n\t{\n\t\tfor (int i = k + 1, count = 1; count < n; i++)\n\t\t{\n\t\tif (checkdigit(i, k) || (i % k == 0))\n\t\t\tcount++;\n\t\tif (count == n)\n\t\treturn i;\n\t\t}\n\treturn -1;\n\t}", "12561": "static int power(int n, int r) {\n\tint count = 0;\n\tfor (int i = r; (n / i) >= 1; i = i * r)\n\tcount += n / i;\n\treturn count;\n}", "12564": "static int digitNumber(long n) {\n\tif (n == 0)\n\treturn 1;\n\tif (n == 1)\n\treturn 9;\n\tif (n % 2 != 0) {\n\tint temp = digitNumber((n - 1) / 2) % mod;\n\treturn (9 * (temp * temp) % mod) % mod;\n\t}\n\telse {\n\tint temp = digitNumber(n / 2) % mod;\n\treturn (temp * temp) % mod;\n\t}\n}\nstatic int countExcluding(int n, int d) {\n\tif (d == 0)\n\treturn (9 * digitNumber(n - 1)) % mod;\n\telse\n\treturn (8 * digitNumber(n - 1)) % mod;\n}", "12587": "static boolean Div_by_8(int n)\n\t{\n\t\treturn (((n >> 3) << 3) == n);\n\t}", "12603": "static int avg_of_odd_num(int n)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += (2 * i + 1);\n\t\treturn sum / n;\n\t}", "12604": "static int avg_of_odd_num(int n)\n\t{\n\t\treturn n;\n\t}", "12615": "static void fib(int f[], int N)\n\t{\n\t\tf[1] = 1;\n\t\tf[2] = 1;\n\t\tfor (int i = 3; i <= N; i++)\n\t\t\tf[i] = f[i - 1] + f[i - 2];\n\t}\nstatic void fiboTriangle(int n)\n\t{\n\t\tint N = n * (n + 1) / 2;\n\t\tint f[] = new int[N + 1];\n\t\tfib(f, N);\n\t\tint fiboNum = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tSystem.out.print(f[fiboNum++] + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "12638": "static int averageEven(int n)\n\t{\n\t\tif (n % 2 != 0) {\n\t\tSystem.out.println(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\tint sum = 0, count = 0;\n\t\twhile (n >= 2) {\n\t\tcount++;\n\t\tsum += n;\n\t\tn = n - 2;\n\t\t}\n\t\treturn sum / count;\n\t}", "12639": "static int averageEven(int n)\n\t{\n\t\tif (n % 2 != 0) {\n\t\tSystem.out.println(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn (n + 2) / 2;\n\t}", "12645": "static int averageOdd(int n)\n\t{\n\t\tif (n % 2 == 0) {\n\t\t\tSystem.out.println(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\tint sum = 0, count = 0;\n\t\twhile (n >= 1) {\n\t\t\tcount++;\n\t\t\tsum += n;\n\t\t\tn = n - 2;\n\t\t}\n\t\treturn sum / count;\n\t}", "12646": "static int averageOdd(int n)\n\t{\n\t\tif (n % 2 == 0)\n\t\t{\n\t\t\tSystem.out.println(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn (n + 1) / 2;\n\t}", "12686": "static int lcm(int a, int b)\n{\n\treturn (a * b) / (__gcd(a, b));\n}\nstatic Rational maxRational(Rational first, Rational sec)\n{\n\tint k = lcm(first.deno, sec.deno);\n\tint nume1 = first.nume;\n\tint nume2 = sec.nume;\n\tnume1 *= k / (first.deno);\n\tnume2 *= k / (sec.deno);\n\treturn (nume2 < nume1)? first : sec;\n}\nstatic int __gcd(int a, int b)\n{\n\treturn b == 0 ? a:__gcd(b, a % b);\t\n}", "12714": "public static int TrinomialValue(int n, int k)\n\t{\n\t\tif (n == 0 && k == 0)\n\t\t\treturn 1;\n\t\tif (k < -n k > n)\n\t\t\treturn 0;\n\t\treturn TrinomialValue(n - 1, k - 1)\n\t\t\t+ TrinomialValue(n - 1, k)\n\t\t\t+ TrinomialValue(n - 1, k + 1);\n\t}\npublic static void printTrinomial(int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = -i; j <= 0; j++)\n\t\t\t\tSystem.out.print(TrinomialValue(i, j) + \" \");\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tSystem.out.print(TrinomialValue(i, j) + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "12715": "public static int TrinomialValue(int dp[][], int n, int k)\n\t{\n\t\tif (k < 0)\n\t\t\tk = -k;\n\t\tif (dp[n][k] != 0)\n\t\t\treturn dp[n][k];\n\t\tif (n == 0 && k == 0)\n\t\t\treturn 1;\n\t\tif (k < -n k > n)\n\t\t\treturn 0;\n\t\treturn (dp[n][k] = TrinomialValue(dp, n - 1, k - 1)\n\t\t\t\t\t\t+ TrinomialValue(dp, n - 1, k)\n\t\t\t\t\t\t+ TrinomialValue(dp, n - 1, k + 1));\n\t}\npublic static void printTrinomial(int n)\n\t{\n\t\tint[][] dp = new int[MAX][MAX];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = -i; j <= 0; j++)\n\t\t\t\tSystem.out.print(TrinomialValue(dp, i, j) + \" \");\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tSystem.out.print(TrinomialValue(dp, i, j) + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}", "12716": "static int Series(int n)\n\t{\n\t\tint i;\n\t\tint sums = 0;\n\t\tfor (i = 1; i <= n; i++)\n\t\t\tsums += (i * i);\n\t\treturn sums;\n\t}", "12745": "public static boolean isPrime(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tfor (int i = 2; i < n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\npublic static boolean isEmirp(int n)\n\t{\n\t\tif (isPrime(n) == false)\n\t\t\treturn false;\n\t\tint rev = 0;\n\t\twhile (n != 0) {\n\t\t\tint d = n % 10;\n\t\t\trev = rev * 10 + d;\n\t\t\tn /= 10;\n\t\t}\n\t\treturn isPrime(rev);\n\t}", "12747": "static int sumOfLargePrimeFactor(int n)\n\t{\n\t\tint prime[] = new int[n + 1], sum = 0;\n\t\tArrays.fill(prime, 0);\n\t\tint max = n / 2;\n\t\tfor (int p = 2; p <= max; p++)\n\t\t{\n\t\t\tif (prime[p] == 0)\n\t\t\t{\n\t\t\t\tfor (int i = p * 2; i <= n; i += p)\n\t\t\t\t\tprime[i] = p;\n\t\t\t}\n\t\t}\n\t\tfor (int p = 2; p <= n; p++)\n\t\t{\n\t\t\tif (prime[p] != 0)\n\t\t\t\tsum += prime[p];\n\t\t\telse\n\t\t\t\tsum += p;\n\t\t}\n\t\treturn sum;\t\n\t}", "12750": "static int gcd(int a, int b)\n\t{\n\t\tif (a == 0 b == 0)\n\t\t\treturn 0;\n\t\tif (a == b)\n\t\t\treturn a;\n\t\tif (a > b)\n\t\t\treturn gcd(a - b, b);\n\t\treturn gcd(a, b - a);\n\t}\nstatic int cpFact(int x, int y)\n\t{\n\t\twhile (gcd(x, y) != 1) {\n\t\t\tx = x / gcd(x, y);\n\t\t}\n\t\treturn x;\n\t}", "12764": "public static int counLastDigitK(int low, int high, int k)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = low; i <= high; i++)\n\t\t\tif (i % 10 == k)\n\t\t\t\tcount++;\n\t\treturn count;\n\t}", "12765": "public static int counLastDigitK(int low, int high, int k)\n\t{\n\t\tint mlow = 10 * (int)\n\t\t\t\t\tMath.ceil(low/10.0);\n\t\tint mhigh = 10 * (int)\n\t\t\t\t\tMath.floor(high/10.0);\n\t\tint count = (mhigh - mlow)/10;\n\t\tif (high % 10 >= k)\n\t\t\tcount++;\n\t\tif (low % 10 <= k && (low%10) > 0)\n\t\t\tcount++;\n\t\treturn count;\n\t}", "12794": "static double Convert(double radian){\n\t\tdouble pi = 3.14159;\n\t\treturn(radian * (180/pi));\n\t}", "12799": "static int sn(int n, int an)\n\t{\n\t\treturn (n * (1 + an)) / 2;\n\t}\nstatic int trace(int n, int m)\n\t{\n\t\tint an = 1 + (n - 1) * (m + 1);\n\t\tint rowmajorSum = sn(n, an);\n\t\tan = 1 + (n - 1) * (n + 1);\n\t\tint colmajorSum = sn(n, an);\n\t\treturn rowmajorSum + colmajorSum;\n\t}", "12810": "static float avgOfFirstN(int n)\n\t{\n\t\treturn (float)(1 + n) / 2;\n\t}", "12842": "static int sum(int L, int R)\n{\n\tint p = R / 6;\n\tint q = (L - 1) / 6;\n\tint sumR = 3 * (p * (p + 1));\n\tint sumL = (q * (q + 1)) * 3;\n\treturn sumR - sumL;\n}", "12844": "static void max_area(int n, int m, int k)\n\t{\n\t\tif (k > (n + m - 2))\n\t\t\tSystem.out.println(\"Not possible\");\n\t\telse {\n\t\t\tint result;\n\t\t\tif (k < Math.max(m, n) - 1)\n\t\t\t{\n\t\t\t\tresult = Math.max(m * (n / (k + 1)),\n\t\t\t\t\t\tn * (m / (k + 1)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = Math.max(m / (k - n + 2),\n\t\t\t\t\t\tn / (k - m + 2));\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}", "12855": "static String prevNum(String str)\n\t{\n\t\tint len = str.length();\n\t\tint index = -1;\n\t\tfor (int i = len - 2; i >= 0; i--)\n\t\t{\n\t\t\tif (str.charAt(i) > str.charAt(i + 1))\n\t\t\t{\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint smallGreatDgt = -1;\n\t\tfor (int i = len - 1; i > index; i--)\n\t\t{\n\t\t\tif (str.charAt(i) < str.charAt(index))\n\t\t\t{\n\t\t\t\tif (smallGreatDgt == -1)\n\t\t\t\t{\n\t\t\t\t\tsmallGreatDgt = i;\n\t\t\t\t}\n\t\t\t\telse if (str.charAt(i) >=\n\t\t\t\t\t\tstr.charAt(smallGreatDgt))\n\t\t\t\t{\n\t\t\t\t\tsmallGreatDgt = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (index == -1)\n\t\t{\n\t\t\treturn \"-1\";\n\t\t}\n\t\tif (smallGreatDgt != -1)\n\t\t{\n\t\t\tstr = swap(str, index, smallGreatDgt);\n\t\t\treturn str;\n\t\t}\n\t\treturn \"-1\";\n\t}\nstatic String swap(String str, int i, int j)\n\t{\n\t\tchar ch[] = str.toCharArray();\n\t\tchar temp = ch[i];\n\t\tch[i] = ch[j];\n\t\tch[j] = temp;\n\t\treturn String.valueOf(ch);\n\t}", "12891": "static int calculate_sum(int a, int N) {\n\tint m = N / a;\n\tint sum = m * (m + 1) / 2;\n\tint ans = a * sum;\n\treturn ans;\n}", "12895": "static int horner(int poly[], int n, int x)\n\t{\n\t\tint result = poly[0];\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tresult = result * x + poly[i];\n\t\treturn result;\n\t}\nstatic int findSign(int poly[], int n, int x)\n\t{\n\t\tint result = horner(poly, n, x);\n\t\tif (result > 0)\n\t\t\treturn 1;\n\t\telse if (result < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}", "12905": "static int isPowerOf2(String s)\n{\n\tchar []str = s.toCharArray();\n\tint len_str = s.length();\n\tint num = 0;\n\tif (len_str == 1 && str[len_str - 1] == '1')\n\t\treturn 0;\n\twhile (len_str != 1 str[len_str - 1] != '1')\n\t{\n\t\tif ((str[len_str - 1] - '0') % 2 == 1)\n\t\t\treturn 0;\n\t\tint j = 0;\n\t\tfor (int i = 0; i < len_str; i++)\n\t\t{\n\t\t\tnum = num * 10 + (int)str[i] - (int)'0';\n\t\t\tif (num < 2)\n\t\t\t{\n\t\t\t\tif (i != 0)\n\t\t\t\t\tstr[j++] = '0';\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstr[j++] = (char)((int)(num / 2) + (int)'0');\n\t\t\tnum = (num) - (num / 2) * 2;\n\t\t}\n\t\tstr[j] = '\\0';\n\t\tlen_str = j;\n\t}\n\treturn 1;\n}", "12906": "static long ispowerof2 ( long num )\n{\n\tif ((num & (num - 1)) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "12970": "static int counDivisors(int X)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= X; ++i)\n\t\t{\n\t\t\tif (X % i == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\nstatic int countDivisorsMult(int arr[], int n)\n\t{\n\t\tint mul = 1;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tmul *= arr[i];\n\t\treturn counDivisors(mul);\n\t}", "12971": "static void SieveOfEratosthenes(int largest, ArrayList<Integer> prime)\n {\n\tboolean[] isPrime = new boolean[largest + 1];\n\tArrays.fill(isPrime, true);\n\tfor (int p = 2; p * p <= largest; p++)\n\t{\n\tif (isPrime[p] == true)\n\t{\n\t\tfor (int i = p * 2; i <= largest; i += p)\n\t\tisPrime[i] = false;\n\t}\n\t}\n\tfor (int p = 2; p <= largest; p++)\n\tif (isPrime[p])\n\t\tprime.add(p);\n }\nstatic long countDivisorsMult(int[] arr, int n)\n {\n\tint largest = 0;\n\tfor(int a : arr )\n\t{\n\tlargest=Math.max(largest, a);\n\t}\n\tArrayList<Integer> prime = new ArrayList<Integer>();\n\tSieveOfEratosthenes(largest, prime);\n\tMap<Integer,Integer> mp = new HashMap<>();\n\tfor (int i = 0; i < n; i++)\n\t{\n\tfor (int j = 0; j < prime.size(); j++)\n\t{\n\t\twhile(arr[i] > 1 && arr[i]%prime.get(j) == 0)\n\t\t{\n\t\tarr[i] /= prime.get(j);\n\t\tif(mp.containsKey(prime.get(j)))\n\t\t{\n\t\t\tmp.put(prime.get(j), mp.get(prime.get(j)) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.put(prime.get(j), 1);\n\t\t}\n\t\t}\n\t}\n\tif (arr[i] != 1)\n\t{\n\t\tif(mp.containsKey(arr[i]))\n\t\t{\n\t\tmp.put(arr[i], mp.get(arr[i]) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\tmp.put(arr[i], 1);\n\t\t}\n\t}\n\t}\n\tlong res = 1;\n\tfor (int it : mp.keySet())\n\tres *= (mp.get(it) + 1L);\n\treturn res;\n }", "12983": "public static void printTaxicab2(int N)\n\t{\n\t\tint i = 1, count = 0;\n\t\twhile (count < N)\n\t\t{\n\t\tint int_count = 0;\n\t\tfor (int j = 1; j <= Math.pow(i, 1.0/3); j++)\n\t\t\tfor (int k = j + 1; k <= Math.pow(i, 1.0/3); k++)\n\t\t\t\tif (j * j * j + k * k * k == i)\n\t\t\t\t\tint_count++;\n\t\tif (int_count == 2)\n\t\t{\n\t\t\tcount++;\n\t\t\tSystem.out.println(count + \" \" + i); \n\t\t}\n\t\ti++;\n\t\t}\n\t}", "12991": "static boolean isComposite(int n)\n\t{\n\t\tif (n <= 1)\n\t\tSystem.out.println(\"False\");\n\t\tif (n <= 3)\n\t\tSystem.out.println(\"False\");\n\t\tif (n % 2 == 0 n % 3 == 0) return true;\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}", "13022": "static int area_fun(int side)\n{\nint area = side * side;\nreturn area;\n}", "13040": "static int countConsecutive(int N)\n\t{\n\t\tint count = 0;\n\t\tfor (int L = 1; L * (L + 1) < 2 * N; L++) {\n\t\t\tdouble a = (double)((1.0 * N - (L * (L + 1)) / 2) / (L + 1));\n\t\t\tif (a - (int)a == 0.0)\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "13048": "static boolean isPrime(int n)\n\t\t{\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tfor (int i = 2; i < n; i++)\n\t\t\t\tif (n % i == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\nstatic int findPrime(int n)\n\t\t{\n\t\t\tint num = n + 1;\n\t\t\twhile (num > 0)\n\t\t\t\t{\n\t\t\t\t\tif (isPrime(num))\n\t\t\t\t\t\treturn num;\n\t\t\t\t\tnum = num + 1;\n\t\t\t\t}\n\t\t\treturn 0;\n\t\t}\nstatic int minNumber(int arr[], int n)\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tsum += arr[i];\n\t\t\tif (isPrime(sum))\n\t\t\t\treturn 0;\n\t\t\tint num = findPrime(sum);\n\t\t\treturn num - sum;\n\t\t}", "13049": "static void sieveOfEratostheneses()\n{\n\tisPrime[1] = true;\n\tfor (int i = 2; i * i < MAX; i++)\n\t{\n\t\tif (!isPrime[i])\n\t\t{\n\t\t\tfor (int j = 2 * i; j < MAX; j += i)\n\t\t\t\tisPrime[j] = true;\n\t\t}\n\t}\n}\nstatic int findPrime(int n)\n{\n\tint num = n + 1;\n\twhile (num > 0)\n\t{\n\t\tif (!isPrime[num])\n\t\t\treturn num;\n\t\tnum = num + 1;\n\t}\n\treturn 0;\n}\nstatic int minNumber(int arr[], int n)\n{\n\tsieveOfEratostheneses();\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += arr[i];\n\tif (!isPrime[sum])\n\t\treturn 0;\n\tint num = findPrime(sum);\n\treturn num - sum;\n}", "13140": "static int fact(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\treturn n*fact(n-1);\n\t}\nstatic int div(int x)\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 1; i<= x; i++)\n\t\t\tif (x%i == 0)\n\t\t\t\tans += i;\n\t\treturn ans;\n\t}\nstatic int sumFactDiv(int n)\n\t{\n\t\treturn div(fact(n));\n\t}", "13141": "static void sieve(int n)\n{\n\tboolean[] prime=new boolean[n+1];\n\tfor (int p = 2; p*p <= n; p++)\n\t{\n\t\tif (prime[p] == false)\n\t\t{\n\t\t\tfor (int i = p*2; i <= n; i += p)\n\t\t\t\tprime[i] = true;\n\t\t}\n\t}\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p]==false)\n\t\t\tallPrimes.add(p);\n}\nstatic int factorialDivisors(int n)\n{\n\tint result = 1;\n\tfor (int i = 0; i < allPrimes.size(); i++)\n\t{\n\t\tint p = allPrimes.get(i);\n\t\tint exp = 0;\n\t\twhile (p <= n)\n\t\t{\n\t\t\texp = exp + (n/p);\n\t\t\tp = p*allPrimes.get(i);\n\t\t}\n\t\tresult = result*((int)Math.pow(allPrimes.get(i), exp+1)-1)/\n\t\t\t\t\t\t\t\t\t(allPrimes.get(i)-1);\n\t}\n\treturn result;\n}", "13144": "static boolean isAutomorphic(int N)\n\t{\n\t\tint sq = N * N;\n\t\twhile (N > 0) {\n\t\t\tif (N % 10 != sq % 10)\n\t\t\t\treturn false;\n\t\t\tN /= 10;\n\t\t\tsq /= 10;\n\t\t}\n\t\treturn true;\n\t}", "13179": "static boolean checkPandigital(int b, String n) {\n\tif (n.length() < b)\n\treturn false;\n\tboolean hash[] = new boolean[b];\n\tArrays.fill(hash, false);\n\tfor (int i = 0; i < n.length(); i++) {\n\tif (n.charAt(i) >= '0' && n.charAt(i) <= '9')\n\t\thash[n.charAt(i) - '0'] = true;\n\telse if (n.charAt(i) - 'A' <= b - 11)\n\t\thash[n.charAt(i) - 'A' + 10] = true;\n\t}\n\tfor (int i = 0; i < b; i++)\n\tif (hash[i] == false)\n\t\treturn false;\n\treturn true;\n}", "13180": "static int convert(int m, int n)\n\t{\n\t\tif (m == n)\n\t\t\treturn 0;\n\t\tif (m > n)\n\t\t\treturn m - n;\n\t\tif (m <= 0 && n > 0)\n\t\t\treturn -1;\n\t\tif (n % 2 == 1)\n\t\t\treturn 1 + convert(m, n + 1);\n\t\telse\n\t\t\treturn 1 + convert(m, n / 2);\n\t}", "13236": "static int getDigitProduct(int x)\n{\n\tif (x < 10)\n\treturn x;\n\tif (prodDig[x] != 0)\n\treturn prodDig[x];\n\tint prod = (x % 10) * getDigitProduct(x/10);\n\treturn (prodDig[x] = prod);\n}\nstatic void findSeed(int n)\n{\n\tList<Integer> res = new ArrayList<Integer>();\n\tfor (int i=1; i<=n/2; i++)\n\t\tif (i*getDigitProduct(i) == n)\n\t\t\tres.add(i);\n\tif (res.size() == 0)\n\t{\n\t\tSystem.out.println(\"NO seed exists\");\n\t\treturn;\n\t}\n\tfor (int i=0; i<res.size(); i++)\n\t\tSystem.out.print(res.get(i)+\" \");\n}", "13240": "static int maxPrimefactorNum(int N) {\n\t\tint arr[] = new int[N + 5];\n\t\tArrays.fill(arr, 0);\n\t\tfor (int i = 2; i * i <= N; i++) {\n\t\t\tif (arr[i] == 0) {\n\t\t\t\tfor (int j = 2 * i; j <= N; j += i) {\n\t\t\t\t\tarr[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr[i] = 1;\n\t\t}\n\t\tint maxval = 0, maxint = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (arr[i] > maxval) {\n\t\t\t\tmaxval = arr[i];\n\t\t\t\tmaxint = i;\n\t\t\t}\n\t\t}\n\t\treturn maxint;\n\t}", "13241": "static int maxPrimefactorNum(int N) {\n\t\tboolean arr[] = new boolean[N + 5];\n\t\tfor (int i = 3; i * i <= N; i += 2) {\n\t\t\tif (!arr[i]) {\n\t\t\t\tfor (int j = i * i; j <= N; j += i) {\n\t\t\t\t\tarr[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tVector<Integer> prime = new Vector<>();\n\t\tprime.add(prime.size(), 2);\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (!arr[i]) {\n\t\t\t\tprime.add(prime.size(), i);\n\t\t\t}\n\t\t}\n\t\tint i = 0, ans = 1;\n\t\twhile (ans * prime.get(i) <= N && i < prime.size()) {\n\t\t\tans *= prime.get(i);\n\t\t\ti++;\n\t\t}\n\t\treturn ans;\n\t}", "13250": "public static long SubArraySum(int arr[], int n)\n\t{\n\t\tlong result = 0,temp=0;\n\t\tfor (int i = 0; i < n; i ++)\n\t\t{\n\t\t\ttemp=0;\n\t\t\tfor (int j = i; j < n; j ++)\n\t\t\t{\n\t\t\t\ttemp+=arr[j];\n\t\t\t\tresult += temp ;\n\t\t\t}\n\t\t}\n\t\treturn result ;\n\t}", "13251": "public static long SubArraySum( int arr[] , int n )\n\t{\n\t\tlong result = 0;\n\t\tfor (int i=0; i<n; i++)\n\t\t\tresult += (arr[i] * (i+1) * (n-i));\n\t\treturn result ;\n\t}", "13288": "static int highestPowerof2(int n)\n{\n\tint res = 0;\n\tfor(int i = n; i >= 1; i--)\n\t{\n\t\tif ((i & (i-1)) == 0)\n\t\t{\n\t\t\tres = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}", "13290": "static int highestPowerof2(int n)\n{\n\tint p = (int)(Math.log(n) /\n\t\t\t\tMath.log(2));\n\treturn (int)Math.pow(2, p);\n}", "13291": "static int highestPowerof2(int x)\n\t{\n\t\tx |= x >> 1;\n\t\tx |= x >> 2;\n\t\tx |= x >> 4;\n\t\tx |= x >> 8;\n\t\tx |= x >> 16;\n\t\treturn x ^ (x >> 1); \n\t}", "13307": "static int aModM(String s, int mod)\n\t{\n\t\tint number = 0;\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t{\n\t\t\tnumber = (number * 10 );\n\t\t\tint x = Character.getNumericValue(s.charAt(i));\n\t\t\tnumber = number + x;\n\t\t\tnumber %= mod;\n\t\t}\n\t\treturn number;\n\t}\nstatic int ApowBmodM(String a, int b, int m)\n\t{\n\t\tint ans = aModM(a, m);\n\t\tint mul = ans;\n\t\tfor (int i = 1; i < b; i++)\n\t\t\tans = (ans * mul) % m;\n\t\treturn ans;\n\t}", "13352": "static int divSum(int num)\n\t{\n\t\tint result = 0;\n\t\tfor (int i = 2; i <= Math.sqrt(num); i++)\n\t\t{\n\t\t\tif (num % i == 0)\n\t\t\t{\n\t\t\t\tif (i == (num / i))\n\t\t\t\t\tresult += i;\n\t\t\t\telse\n\t\t\t\t\tresult += (i + num / i);\n\t\t\t}\n\t\t}\n\t\treturn (result + 1);\n\t}", "13400": "static void findPairs(int n)\n{\n\tint cubeRoot = (int)Math.pow( n, 1.0 / 3.0);\n\tint cube[] = new int[cubeRoot + 1];\n\tfor (int i = 1; i <= cubeRoot; i++)\n\t\tcube[i] = i * i * i;\n\tint l = 1;\n\tint r = cubeRoot;\n\twhile (l < r)\n\t{\n\t\tif (cube[l] + cube[r] < n)\n\t\t\tl++;\n\t\telse if(cube[l] + cube[r] > n)\n\t\t\tr--;\n\t\telse {\n\t\t\tSystem.out.println(\"(\" + l + \", \" + r + \")\" );\n\t\t\tl++; r--;\n\t\t}\n\t}\n}", "13401": "static void findPairs(int n)\n{\n\tint cubeRoot = (int) Math.pow(n, 1.0/3.0);\n\tHashMap<Integer, pair> s = new HashMap<Integer, pair>();\n\tfor (int x = 1; x < cubeRoot; x++)\n\t{\n\t\tfor (int y = x + 1; y <= cubeRoot; y++)\n\t\t{\n\t\t\tint sum = x*x*x + y*y*y;\n\t\t\tif (sum != n)\n\t\t\t\tcontinue;\n\t\t\tif (s.containsKey(sum))\n\t\t\t{\n\t\t\t\tSystem.out.print(\"(\" + s.get(sum).first+ \", \"\n\t\t\t\t\t+ s.get(sum).second+ \") and (\" + x+ \", \" + y+ \")\" +\"\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\ts.put(sum, new pair(x, y));\n\t\t}\n\t}\n}", "13409": "static int gcd(int a, int b)\n{\n\twhile (b != 0)\n\t{\n\t\tint t = b;\n\t\tb = a % b;\n\t\ta = t;\n\t}\n\treturn a;\n}\nstatic int findMinDiff(int a, int b, int x, int y)\n{\n\tint g = gcd(a,b);\n\tint diff = Math.abs(x - y) % g;\n\treturn Math.min(diff, g - diff);\n}", "13429": "static void printDivisors(int n)\n\t{\n\t\tVector<Integer> v = new Vector<>();\n\t\tfor (int i = 1; i <= Math.sqrt(n); i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tif (n / i == i)\n\t\t\t\t\tSystem.out.printf(\"%d \", i);\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.printf(\"%d \", i);\n\t\t\t\t\tv.add(n / i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = v.size() - 1; i >= 0; i--)\n\t\t\tSystem.out.printf(\"%d \", v.get(i));\n\t}", "13430": "public static void printDivisors(int n)\n{ int i;\n\tfor( i = 1; i * i < n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t\tSystem.out.print(i + \" \");\n\t}\n\tif(i-(n/i)==1)\n\t{\n\ti--;\n\t}\n\tfor(; i >= 1; i--)\n\t{\n\t\tif (n % i == 0)\n\t\t\tSystem.out.print(n / i + \" \");\n\t}\n}", "13431": "static void printDivisors(int n)\n\t{\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tif (n%i==0)\n\t\t\t\tSystem.out.print(i+\" \");\n\t}", "13432": "static void printDivisors(int n)\n\t{\n\t\tfor (int i=1; i<=Math.sqrt(n); i++)\n\t\t{\n\t\t\tif (n%i==0)\n\t\t\t{\n\t\t\t\tif (n/i == i)\n\t\t\t\t\tSystem.out.print(\" \"+ i);\n\t\t\t\t\tSystem.out.print(i+\" \" + n/i + \" \" );\n\t\t\t}\n\t\t}\n\t}", "13448": "static double interpolate(Data f[], int xi, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble term = f[i].y;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (j != i)\n\t\t\t\tterm = term*(xi - f[j].x) / (f[i].x - f[j].x);\n\t\t}\n\t\tresult += term;\n\t}\n\treturn result;\n}", "13453": "static int SieveOfAtkin(int limit)\n\t{\n\t\tif (limit > 2)\n\t\t\tSystem.out.print(2 + \" \");\n\t\tif (limit > 3)\n\t\t\tSystem.out.print(3 + \" \");\n\t\tboolean sieve[] = new boolean[limit];\n\t\tfor (int i = 0; i < limit; i++)\n\t\t\tsieve[i] = false;\n\t\tfor (int x = 1; x * x < limit; x++) {\n\t\t\tfor (int y = 1; y * y < limit; y++) {\n\t\t\t\tint n = (4 * x * x) + (y * y);\n\t\t\t\tif (n <= limit && (n % 12 == 1 n % 12 == 5))\n\t\t\t\t\tsieve[n] ^= true;\n\t\t\t\tn = (3 * x * x) + (y * y);\n\t\t\t\tif (n <= limit && n % 12 == 7)\n\t\t\t\t\tsieve[n] ^= true;\n\t\t\t\tn = (3 * x * x) - (y * y);\n\t\t\t\tif (x > y && n <= limit && n % 12 == 11)\n\t\t\t\t\tsieve[n] ^= true;\n\t\t\t}\n\t\t}\n\t\tfor (int r = 5; r * r < limit; r++) {\n\t\t\tif (sieve[r]) {\n\t\t\t\tfor (int i = r * r; i < limit; i += r * r)\n\t\t\t\t\tsieve[i] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int a = 5; a < limit; a++)\n\t\t\tif (sieve[a])\n\t\t\t\tSystem.out.print(a + \" \");\n\t\treturn 0;\n\t}", "13454": "static int SieveOfSundaram(int n) {\n\tint nNew = (n - 1) / 2;\n\tboolean marked[] = new boolean[nNew + 1];\n\tArrays.fill(marked, false);\n\tfor (int i = 1; i <= nNew; i++)\n\tfor (int j = i; (i + j + 2 * i * j) <= nNew; j++)\n\t\tmarked[i + j + 2 * i * j] = true;\n\tif (n > 2)\n\tSystem.out.print(2 + \" \");\n\tfor (int i = 1; i <= nNew; i++)\n\tif (marked[i] == false)\n\t\tSystem.out.print(2 * i + 1 + \" \");\n\treturn -1;\n}", "13460": "static int power(int x, int y, int p)\n{\n\twhile (y > 0) {\n\t\tif (y %2== 1)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nstatic void squareRoot(int n, int p)\n{\n\tif (p % 4 != 3) {\n\t\tSystem.out.print(\"Invalid Input\");\n\t\treturn;\n\t}\n\tn = n % p;\n\tint x = power(n, (p + 1) / 4, p);\n\tif ((x * x) % p == n) {\n\t\tSystem.out.print(\"Square root is \" + x);\n\t\treturn;\n\t}\n\tx = p - x;\n\tif ((x * x) % p == n) {\n\t\tSystem.out.print(\"Square root is \" + x);\n\t\treturn;\n\t}\n\tSystem.out.print(\"Square root doesn't exist \");\n}", "13468": "static int power(int x, int y, int p) {\n\t\tint res = 1;\n\t\tx = x % p;\n\t\twhile (y > 0) {\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\nstatic boolean miillerTest(int d, int n) {\n\t\tint a = 2 + (int)(Math.random() % (n - 4));\n\t\tint x = power(a, d, n);\n\t\tif (x == 1 x == n - 1)\n\t\t\treturn true;\n\t\twhile (d != n - 1) {\n\t\t\tx = (x * x) % n;\n\t\t\td *= 2;\n\t\t\tif (x == 1)\n\t\t\t\treturn false;\n\t\t\tif (x == n - 1)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\nstatic boolean isPrime(int n, int k) {\n\t\tif (n <= 1 n == 4)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tint d = n - 1;\n\t\twhile (d % 2 == 0)\n\t\t\td /= 2;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tif (!miillerTest(d, n))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "13489": "static boolean isInside(int circle_x, int circle_y, int rad, int x, int y)\n\t{\n\t\tif ((x - circle_x) * (x - circle_x) +\n\t\t\t(y - circle_y) * (y - circle_y) <= rad * rad)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "13501": "static int eval(int a, char op, int b)\n\t{\n\t\tif (op == '+')\n\t\t{\n\t\t\treturn a + b;\n\t\t}\n\t\tif (op == '-')\n\t\t{\n\t\t\treturn a - b;\n\t\t}\n\t\tif (op == '*')\n\t\t{\n\t\t\treturn a * b;\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\nstatic Vector<Integer> evaluateAll(String expr, int low, int high)\n\t{\n\t\tVector<Integer> res = new Vector<Integer>();\n\t\tif (low == high)\n\t\t{\n\t\t\tres.add(expr.charAt(low) - '0');\n\t\t\treturn res;\n\t\t}\n\t\tif (low == (high - 2))\n\t\t{\n\t\t\tint num = eval(expr.charAt(low) - '0',\n\t\t\t\t\t\texpr.charAt(low + 1),\n\t\t\t\t\t\texpr.charAt(low + 2) - '0');\n\t\t\tres.add(num);\n\t\t\treturn res;\n\t\t}\n\t\tfor (int i = low + 1; i <= high; i += 2)\n\t\t{\n\t\t\tVector<Integer> l = evaluateAll(expr, low, i - 1);\n\t\t\tVector<Integer> r = evaluateAll(expr, i + 1, high);\n\t\t\tfor (int s1 = 0; s1 < l.size(); s1++)\n\t\t\t{\n\t\t\t\tfor (int s2 = 0; s2 < r.size(); s2++)\n\t\t\t\t{\n\t\t\t\t\tint val = eval(l.get(s1), expr.charAt(i), r.get(s2));\n\t\t\t\t\tres.add(val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}", "13504": "static boolean isLucky(int n)\n\t{\n\t\tboolean arr[]=new boolean[10];\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tarr[i] = false;\n\t\twhile (n > 0)\n\t\t{\n\t\t\tint digit = n % 10;\n\t\t\tif (arr[digit])\n\t\t\treturn false;\n\t\t\tarr[digit] = true;\n\t\t\tn = n / 10;\n\t\t}\n\t\treturn true;\n\t}", "13535": "static void printSquares(int n)\n{\n\tint square = 0, odd = 1;\n\tfor (int x = 0; x < n; x++)\n\t{\n\t\tSystem.out.print(square + \" \" );\n\t\tsquare = square + odd;\n\t\todd = odd + 2;\n\t}\n}", "13575": "static int reversDigits(int num)\n\t{\n\t\tif (num > 0) {\n\t\t\treversDigits(num / 10);\n\t\t\trev_num += (num % 10) * base_pos;\n\t\t\tbase_pos *= 10;\n\t\t}\n\t\treturn rev_num;\n\t}", "13606": "static void constructArray(int A[], int N, int K)\n{\n\tint B[] = new int[N];\n\tint totalXOR = A[0] ^ K;\n\tfor(int i = 0; i < N; i++)\n\t\tB[i] = totalXOR ^ A[i];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tSystem.out.print(B[i] + \" \");\n\t}\n}", "13633": "static int RecursiveFunction(ArrayList<Integer> ref, int bit)\n{\n\tif (ref.size() == 0 bit < 0)\n\t\treturn 0;\n\tArrayList<Integer> curr_on = new ArrayList<>();\n\tArrayList<Integer> curr_off = new ArrayList<>();\n\tfor(int i = 0; i < ref.size(); i++)\n\t{\n\t\tif (((ref.get(i) >> bit) & 1) == 0)\n\t\t\tcurr_off.add(ref.get(i));\n\t\telse\n\t\t\tcurr_on.add(ref.get(i));\n\t}\n\tif (curr_off.size() == 0)\n\t\treturn RecursiveFunction(curr_on, bit - 1);\n\tif (curr_on.size() == 0)\n\t\treturn RecursiveFunction(curr_off, bit - 1);\n\treturn Math.min(RecursiveFunction(curr_off, bit - 1),\n\t\t\t\t\tRecursiveFunction(curr_on, bit - 1)) +\n\t\t\t\t\t\t\t\t\t(1 << bit);\n}\nstatic void PrintMinimum(int a[], int n)\n{\n\tArrayList<Integer> v = new ArrayList<>();\n\tfor(int i = 0; i < n; i++)\n\t\tv.add(a[i]);\n\tSystem.out.println(RecursiveFunction(v, 30));\n}", "13660": "static int extraElement(int A[], int B[], int n)\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans ^= A[i];\n\t\tfor (int i = 0; i < n + 1; i++)\n\t\t\tans ^= B[i];\n\t\treturn ans;\n\t}", "13671": "static int cntElements(int arr[], int n)\n{\n\tint cnt = 0;\n\tfor (int i = 0; i < n - 2; i++)\n\t{\n\t\tif (arr[i] == (arr[i + 1] ^ arr[i + 2]))\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}", "13672": "static int xor_triplet(int arr[], int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tfor (int k = j; k < n; k++)\n\t\t\t{\n\t\t\t\tint xor1 = 0, xor2 = 0;\n\t\t\t\tfor (int x = i; x < j; x++)\n\t\t\t\t{\n\t\t\t\t\txor1 ^= arr[x];\n\t\t\t\t}\n\t\t\t\tfor (int x = j; x <= k; x++)\n\t\t\t\t{\n\t\t\t\t\txor2 ^= arr[x];\n\t\t\t\t}\n\t\t\t\tif (xor1 == xor2)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}", "13673": "static void insert(TrieNode node, int num, int index)\n{\n\tfor (int bits = lg; bits >= 0; bits--)\n\t{\n\t\tint curr_bit = (num >> bits) & 1;\n\t\tif (node.children[curr_bit] == null)\n\t\t{\n\t\t\tnode.children[curr_bit]\n\t\t\t\t= new TrieNode();\n\t\t}\n\t\tnode = node.children[curr_bit];\n\t}\n\tnode.sum_of_indexes += index;\n\tnode.number_of_indexes++;\n}\nstatic int query(TrieNode node, int num, int index)\n{\n\tfor (int bits = lg; bits >= 0; bits--)\n\t{\n\t\tint curr_bit = (num >> bits) & 1;\n\t\tif (node.children[curr_bit] == null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tnode = node.children[curr_bit];\n\t}\n\tint sz = node.number_of_indexes;\n\tint sum = node.sum_of_indexes;\n\tint ans = (sz * index) - (sum);\n\treturn ans;\n}\nstatic int no_of_triplets(int arr[], int n)\n{\n\tint curr_xor = 0;\n\tint number_of_triplets = 0;\n\tTrieNode root = new TrieNode();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x = arr[i];\n\t\tinsert(root, curr_xor, i);\n\t\tcurr_xor ^= x;\n\t\tnumber_of_triplets\n\t\t\t+= query(root, curr_xor, i);\n\t}\n\treturn number_of_triplets;\n}", "13684": "static long bit_q(int i, int j)\n{\n\tlong sum = 0;\n\twhile (j > 0)\n\t{\n\t\tsum += bit[j];\n\t\tj -= (j & (j * -1));\n\t}\n\ti--;\n\twhile (i > 0)\n\t{\n\t\tsum -= bit[i];\n\t\ti -= (i & (i * -1));\n\t}\n\treturn sum;\n}\nstatic void bit_up(int i, long diff)\n{\n\twhile (i <= n)\n\t{\n\t\tbit[i] += diff;\n\t\ti += i & -i;\n\t}\n}\nstatic void dfs(int node)\n{\n\tIdeal_pair += bit_q(Math.max(1, node - k),\n\t\t\t\t\t\tMath.min(n, node + k));\n\tbit_up(node, 1);\n\tfor(int i = 0; i < al[node].size(); i++)\n\t\tdfs(al[node].get(i));\n\tbit_up(node, -1);\n}\nstatic void initialise()\n{\n\tIdeal_pair = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\troot_node[i] = true;\n\t\tbit[i] = 0;\n\t}\n}\nstatic void Add_Edge(int x, int y)\n{\n\tal[x].add(y);\n\troot_node[y] = false;\n}\nstatic long Idealpairs()\n{\n\tint r = -1;\n\tfor(int i = 1; i <= n; i++)\n\t\tif (root_node[i])\n\t\t{\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\tdfs(r);\n\treturn Ideal_pair;\n}", "13757": "static int hammingDistance(int n1, int n2)\n{\n\tint x = n1 ^ n2;\n\tint setBits = 0;\n\twhile (x > 0)\n\t{\n\t\tsetBits += x & 1;\n\t\tx >>= 1;\n\t}\n\treturn setBits;\n}", "13829": "static void printSubsets(int n)\n\t{\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tif ((n & i) == i)\n\t\t\t\tSystem.out.print(i + \" \");\n\t}", "13830": "static void printSubsets(int n)\n\t{\n\tfor (int i = n; i > 0; i = (i - 1) & n)\n\t\tSystem.out.print(i + \" \");\n\t\tSystem.out.print(\" 0 \");\n\t}", "13875": "static boolean isDivisibleby17(int n)\n\t{\n\t\tif (n == 0 n == 17)\n\t\t\treturn true;\n\t\tif (n < 17)\n\t\t\treturn false;\n\t\treturn isDivisibleby17((int)(n >> 4)\n\t\t\t\t\t\t\t- (int)(n & 15));\n\t}", "13876": "static long answer(long n)\n\t{\n\t\tlong m = 2;\n\t\tlong ans = 1;\n\t\tlong r = 1;\n\t\twhile (r < n) {\n\t\t\tr = ((long)Math.pow(2, m) - 1) *\n\t\t\t\t((long)Math.pow(2, m - 1));\n\t\t\tif (r < n)\n\t\t\t\tans = r;\n\t\t\tm++;\n\t\t}\n\t\treturn ans;\n\t}", "13897": "static int setBitNumber(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn 0;\n\t\tint msb = 0;\n\t\tn = n / 2;\n\t\twhile (n != 0) {\n\t\t\tn = n / 2;\n\t\t\tmsb++;\n\t\t}\n\t\treturn (1 << msb);\n\t}", "13898": "static int setBitNumber(int n)\n\t{\n\t\tn |= n >> 1;\n\t\tn |= n >> 2;\n\t\tn |= n >> 4;\n\t\tn |= n >> 8;\n\t\tn |= n >> 16;\n\t\tn = n + 1;\n\t\treturn (n >> 1);\n\t}", "13899": "static int setBitNumber(int n)\n\t{\n\t\tint k = (int)(Math.log(n) / Math.log(2));\n\t\treturn 1 << k;\n\t}", "13966": "public static int countTrailingZero(int x)\n\t{\n\t\tint count = 0;\n\t\twhile ((x & 1) == 0)\n\t\t{\n\t\t\tx = x >> 1;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "13967": "static int countTrailingZero(int x)\n{\n\tint lookup[] = {32, 0, 1, 26, 2, 23, \n\t\t\t\t\t27, 0, 3, 16, 24, 30,\n\t\t\t\t\t28, 11, 0, 13, 4, 7,\n\t\t\t\t\t17, 0, 25, 22, 31, 15,\n\t\t\t\t\t29, 10, 12, 6, 0, 21,\n\t\t\t\t\t14, 9, 5, 20, 8, 19, 18};\n\treturn lookup[(-x & x) % 37];\n}", "13987": "private static int maxConsecutiveOnes(int x)\n\t{\n\t\tint count = 0;\n\t\twhile (x!=0)\n\t\t{\n\t\t\tx = (x & (x << 1));\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "14020": "static int multiplyBySevenByEight(int n)\n\t{\n\t\treturn (n - (n >> 3));\n\t}", "14021": "static int multiplyBySevenByEight(int n)\n\t{\n\t\treturn ((n << 3) -n) >> 3;\n\t}", "14022": "static int subtract(int x, int y)\n\t{\n\twhile (y != 0)\n\t{\n\t\tint borrow = (~x) & y;\n\t\tx = x ^ y;\n\t\ty = borrow << 1;\n\t}\n\treturn x;\n}", "14023": "static int subtract(int x, int y)\n\t{\n\t\tif (y == 0)\n\t\t\treturn x;\n\t\treturn subtract(x ^ y, (~x & y) << 1);\n\t}"}, "Python": {"451": "def minCost(cost):\n\tdist=[0 for i in range(N)]\n\tfor i in range(N):\n\t\tdist[i] = INF\n\tdist[0] = 0\n\tfor i in range(N):\n\t\tfor j in range(i+1,N):\n\t\t\tif (dist[j] > dist[i] + cost[i][j]):\n\t\t\t\tdist[j] = dist[i] + cost[i][j]\n\treturn dist[N-1]", "455": "def numOfways(n,k):\n\tp = 1\n\tif (k % 2):\n\t\tp = -1\n\treturn (pow(n - 1, k) +\n\t\t\t\tp * (n - 1)) / n", "496": "def fib(n):\n\tif n <= 1:\n\t\treturn n\n\treturn fib(n - 1) + fib(n - 2)\ndef findVertices(n):\n\treturn fib(n + 2)", "617": "def reverse( head_ref):\n\ttemp = None\n\tcurrent = head_ref\n\twhile (current != None):\n\t\ttemp = current.prev\n\t\tcurrent.prev = current.next\n\t\tcurrent.next = temp\n\t\tcurrent = current.prev\n\tif (temp != None):\n\t\thead_ref = temp.prev\n\t\treturn head_ref\ndef merge( first, second):\n\tif (first == None):\n\t\treturn second\n\tif (second == None):\n\t\treturn first\n\tif (first.data < second.data):\n\t\tfirst.next = merge(first.next, second)\n\t\tfirst.next.prev = first\n\t\tfirst.prev = None\n\t\treturn first\n\telse:\n\t\tsecond.next = merge(first, second.next)\n\t\tsecond.next.prev = second\n\t\tsecond.prev = None\n\t\treturn second\ndef sort( head):\n\tif (head == None or head.next == None):\n\t\treturn head\n\tcurrent = head.next\n\twhile (current != None) :\n\t\tif (current.data < current.prev.data):\n\t\t\tbreak\n\t\tcurrent = current.next\n\tif (current == None):\n\t\treturn head\n\tcurrent.prev.next = None\n\tcurrent.prev = None\n\tcurrent = reverse(current)\n\treturn merge(head, current)\ndef push( head_ref, new_data):\n\tnew_node =Node()\n\tnew_node.data = new_data\n\tnew_node.prev = None\n\tnew_node.next = (head_ref)\n\tif ((head_ref) != None):\n\t\t(head_ref).prev = new_node\n\t(head_ref) = new_node\n\treturn head_ref\ndef printList( head):\n\tif (head == None):\n\t\tprint(\"Doubly Linked list empty\")\n\twhile (head != None):\n\t\tprint(head.data, end= \" \")\n\t\thead = head.next\ndef __init__(self, next = None, prev = None, data = None):\n\t\tself.next = next\n\t\tself.prev = prev\n\t\tself.data = data", "647": "def printlist(head):\n\tif (not head):\n\t\tprint(\"Empty List\")\n\t\treturn\n\twhile (head != None):\n\t\tprint(head.data, end = \" \")\n\t\tif (head.next):\n\t\t\tprint(end = \"-> \")\n\t\thead = head.next\n\tprint()\ndef isVowel(x):\n\treturn (x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U')\ndef arrange(head):\n\tnewHead = head\n\tlatestVowel = None\n\tcurr = head\n\tif (head == None):\n\t\treturn None\n\tif (isVowel(head.data)):\n\t\tlatestVowel = head\n\telse:\n\t\twhile (curr.next != None and\n\t\t\tnot isVowel(curr.next.data)):\n\t\t\tcurr = curr.next\n\t\tif (curr.next == None):\n\t\t\treturn head\n\t\tlatestVowel = newHead = curr.next\n\t\tcurr.next = curr.next.next\n\t\tlatestVowel.next = head\n\twhile (curr != None and curr.next != None):\n\t\tif (isVowel(curr.next.data)):\n\t\t\tif (curr == latestVowel):\n\t\t\t\tlatestVowel = curr = curr.next\n\t\t\telse:\n\t\t\t\ttemp = latestVowel.next\n\t\t\t\tlatestVowel.next = curr.next\n\t\t\t\tlatestVowel = latestVowel.next\n\t\t\t\tcurr.next = curr.next.next\n\t\t\t\tlatestVowel.next = temp\n\t\telse:\n\t\t\tcurr = curr.next\n\treturn newHead\ndef __init__(self, x):\n\t\tself.data = x\n\t\tself.next = None", "694": "def KthLargestUsingMorrisTraversal(root, k):\n\tcurr = root\n\tKlargest = None\n\tcount = 0\n\twhile (curr != None):\n\t\tif (curr.right == None):\n\t\t\tcount += 1\n\t\t\tif (count == k):\n\t\t\t\tKlargest = curr\n\t\t\tcurr = curr.left\n\t\telse:\n\t\t\tsucc = curr.right\n\t\t\twhile (succ.left != None and succ.left != curr):\n\t\t\t\tsucc = succ.left\n\t\t\tif (succ.left == None):\n\t\t\t\tsucc.left = curr\n\t\t\t\tcurr = curr.right\n\t\t\telse:\n\t\t\t\tsucc.left = None\n\t\t\t\tcount += 1\n\t\t\t\tif (count == k):\n\t\t\t\t\tKlargest = curr\n\t\t\t\tcurr = curr.left\n\treturn Klargest\ndef __init__(self, data):\n\t\tself.data = data\n\t\tself.right = self.left = None", "803": "def sortByRow(mat, n, ascending):\n\tfor i in range(n):\n\t\tif (ascending): \n\t\t\tmat[i].sort()\n\t\telse:\n\t\t\tmat[i].sort(reverse=True)\ndef transpose(mat, n):\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\ttemp = mat[i][j]\n\t\t\tmat[i][j] = mat[j][i]\n\t\t\tmat[j][i] = temp\ndef sortMatRowAndColWise(mat, n):\n\tsortByRow(mat, n, True)\n\ttranspose(mat, n)\n\tsortByRow(mat, n, False)\n\ttranspose(mat, n)\ndef printMat(mat, n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tprint(mat[i][j] , \" \", end=\"\")\n\t\tprint()", "815": "def sortByRow(mat, n):\n\tfor i in range (n):\n\t\tfor j in range(n-1):\n\t\t\tif mat[i][j] > mat[i][j + 1]:\n\t\t\t\ttemp = mat[i][j]\n\t\t\t\tmat[i][j] = mat[i][j + 1]\n\t\t\t\tmat[i][j + 1] = temp\ndef transpose(mat, n):\n\tfor i in range (n):\n\t\tfor j in range(i + 1, n):\n\t\t\tt = mat[i][j]\n\t\t\tmat[i][j] = mat[j][i]\n\t\t\tmat[j][i] = t\ndef sortMatRowAndColWise(mat, n):\n\tsortByRow(mat, n)\n\ttranspose(mat, n)\n\tsortByRow(mat, n)\n\ttranspose(mat, n)\ndef printMat(mat, n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tprint(str(mat[i][j] ), end = \" \")\n\t\tprint();", "818": "def DoublyEven(n):\n\tarr = [[(n*y)+x+1 for x in range(n)]for y in range(n)]\n\tfor i in range(0,n/4):\n\t\tfor j in range(0,n/4):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor i in range(0,n/4):\n\t\tfor j in range(3 * (n/4),n):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor i in range(3 * (n/4),n):\n\t\tfor j in range(0,n/4):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor i in range(3 * (n/4),n):\n\t\tfor j in range(3 * (n/4),n):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor i in range(n/4,3 * (n/4)):\n\t\tfor j in range(n/4,3 * (n/4)):\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tprint '%2d ' %(arr[i][j]),\n\t\tprint", "821": "def Kroneckerproduct( A , B ):\n\tC = [[0 for j in range(cola * colb)] for i in range(rowa * rowb)]\n\tfor i in range(0, rowa):\n\t\tfor k in range(0, rowb):\n\t\t\tfor j in range(0, cola):\n\t\t\t\tfor l in range(0, colb):\n\t\t\t\t\tC[i + l + 1][j + k + 1] = A[i][j] * B[k][l]\n\t\t\t\t\tprint (C[i + l + 1][j + k + 1],end=' ')\n\t\t\tprint (\"\\n\")", "832": "def islowertriangular(M):\n\tfor i in range(0, len(M)):\n\t\tfor j in range(i + 1, len(M)):\n\t\t\tif(M[i][j] != 0):\n\t\t\t\t\treturn False\n\treturn True", "833": "def isuppertriangular(M):\n\tfor i in range(1, len(M)):\n\t\tfor j in range(0, i):\n\t\t\tif(M[i][j] != 0):\n\t\t\t\t\treturn False\n\treturn True", "846": "def countSets(a):\n\tres = 0\n\tfor i in range(n):\n\t\tu = 0\n\t\tv = 0\n\t\tfor j in range(m):\n\t\t\tif a[i][j]:\n\t\t\t\tu += 1\n\t\t\telse:\n\t\t\t\tv += 1\n\t\tres += pow(2, u) - 1 + pow(2, v) - 1\n\tfor i in range(m):\n\t\tu = 0\n\t\tv = 0\n\t\tfor j in range(n):\n\t\t\tif a[j][i]:\n\t\t\t\tu += 1\n\t\t\telse:\n\t\t\t\tv += 1\n\t\tres += pow(2, u) - 1 + pow(2, v) - 1\n\treturn res - (n*m)", "861": "def transpose(mat, tr, N):\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\ttr[i][j] = mat[j][i]\ndef isSymmetric(mat, N):\n\ttr = [ [0 for j in range(len(mat[0])) ] for i in range(len(mat)) ]\n\ttranspose(mat, tr, N)\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\tif (mat[i][j] != tr[i][j]):\n\t\t\t\treturn False\n\treturn True", "862": "def isSymmetric(mat, N):\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\tif (mat[i][j] != mat[j][i]):\n\t\t\t\treturn False\n\treturn True", "883": "def findNormal(mat, n):\n\tsum = 0;\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tsum += mat[i][j] * mat[i][j];\n\treturn math.floor(math.sqrt(sum));\ndef findTrace(mat, n):\n\tsum = 0;\n\tfor i in range(n):\n\t\tsum += mat[i][i];\n\treturn sum;", "895": "def maxDet(n):\n\treturn 2 * n * n * n\ndef resMatrix(n):\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\tif i == 0 and j == 2:\n\t\t\t\tprint(\"0\", end = \" \")\n\t\t\telif i == 1 and j == 0:\n\t\t\t\tprint(\"0\", end = \" \")\n\t\t\telif i == 2 and j == 1:\n\t\t\t\tprint(\"0\", end = \" \")\n\t\t\telse:\n\t\t\t\tprint(n, end = \" \")\n\t\tprint(\"\\n\")", "918": "def countNegative(M, n, m):\n\tcount = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif M[i][j] < 0:\n\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tbreak\n\treturn count", "919": "def countNegative(M, n, m):\n\tcount = 0 \n\ti = 0\n\tj = m - 1 \n\twhile j >= 0 and i < n:\n\t\tif M[i][j] < 0:\n\t\t\tcount += (j + 1)\n\t\t\ti += 1\n\t\telse:\n\t\t\tj -= 1\n\treturn count", "920": "def getLastNegativeIndex(array, start, end, n):\n\tif (start == end):\n\t\treturn start\n\tmid = start + (end - start) // 2\n\tif (array[mid] < 0):\n\t\tif (mid + 1 < n and array[mid + 1] >= 0):\n\t\t\treturn mid\n\t\treturn getLastNegativeIndex(array, mid + 1, end, n)\n\telse:\n\t\treturn getLastNegativeIndex(array, start, mid - 1, n)\ndef countNegative(M, n, m):\n\tcount = 0\n\tnextEnd = m - 1\n\tfor i in range(n):\n\t\tif (M[i][0] >= 0):\n\t\t\tbreak\n\t\tnextEnd = getLastNegativeIndex(M[i], 0, nextEnd, 4)\n\t\tcount += nextEnd + 1\n\treturn count", "926": "def findMaxValue(mat):\n\tmaxValue = 0\n\tfor a in range(N - 1):\n\t\tfor b in range(N - 1):\n\t\t\tfor d in range(a + 1, N):\n\t\t\t\tfor e in range(b + 1, N):\n\t\t\t\t\tif maxValue < int (mat[d][e] - mat[a][b]):\n\t\t\t\t\t\tmaxValue = int(mat[d][e] - mat[a][b]);\n\treturn maxValue;", "927": "def findMaxValue(mat):\n\tmaxValue = -sys.maxsize -1\n\tmaxArr = [[0 for x in range(N)] for y in range(N)]\n\tmaxArr[N - 1][N - 1] = mat[N - 1][N - 1]\n\tmaxv = mat[N - 1][N - 1];\n\tfor j in range (N - 2, -1, -1):\n\t\tif (mat[N - 1][j] > maxv):\n\t\t\tmaxv = mat[N - 1][j]\n\t\tmaxArr[N - 1][j] = maxv\n\tmaxv = mat[N - 1][N - 1];\n\tfor i in range (N - 2, -1, -1):\n\t\tif (mat[i][N - 1] > maxv):\n\t\t\tmaxv = mat[i][N - 1]\n\t\tmaxArr[i][N - 1] = maxv\n\tfor i in range (N - 2, -1, -1):\n\t\tfor j in range (N - 2, -1, -1):\n\t\t\tif (maxArr[i + 1][j + 1] - mat[i][j] > maxValue):\n\t\t\t\tmaxValue = (maxArr[i + 1][j + 1] - mat[i][j])\n\t\t\tmaxArr[i][j] = max(mat[i][j],\n\t\t\t\t\t\tmax(maxArr[i][j + 1], maxArr[i + 1][j]))\n\treturn maxValue", "953": "def youngify(mat, i, j):\n\tdownVal = mat[i + 1][j] if (i + 1 < N) else INF\n\trightVal = mat[i][j + 1] if (j + 1 < N) else INF\n\tif (downVal == INF and rightVal == INF):\n\t\treturn\n\tif (downVal < rightVal):\n\t\tmat[i][j] = downVal\n\t\tmat[i + 1][j] = INF\n\t\tyoungify(mat, i + 1, j)\n\telse:\n\t\tmat[i][j] = rightVal\n\t\tmat[i][j + 1] = INF\n\t\tyoungify(mat, i, j + 1)\ndef extractMin(mat):\n\tret = mat[0][0]\n\tmat[0][0] = INF\n\tyoungify(mat, 0, 0)\n\treturn ret\ndef printSorted(mat):\n\tprint(\"Elements of matrix in sorted order n\")\n\ti = 0\n\twhile i < N * N:\n\t\tprint(extractMin(mat), end = \" \")\n\t\ti += 1", "955": "def printSumSimple(mat, k):\n\tif (k > n):\n\t\treturn\n\tfor i in range(n - k + 1):\n\t\tfor j in range(n - k + 1):\n\t\t\tsum = 0\n\t\t\tfor p in range(i, k + i):\n\t\t\t\tfor q in range(j, k + j):\n\t\t\t\t\tsum += mat[p][q]\n\t\t\tprint(sum, end = \" \")\n\t\tprint()", "956": "def printSumTricky(mat, k):\n\tglobal n\n\tif k > n:\n\t\treturn\n\tstripSum = [[None] * n for i in range(n)]\n\tfor j in range(n):\n\t\tSum = 0\n\t\tfor i in range(k):\n\t\t\tSum += mat[i][j]\n\t\tstripSum[0][j] = Sum\n\t\tfor i in range(1, n - k + 1):\n\t\t\tSum += (mat[i + k - 1][j] - mat[i - 1][j])\n\t\t\tstripSum[i][j] = Sum\n\tfor i in range(n - k + 1):\n\t\tSum = 0\n\t\tfor j in range(k):\n\t\t\tSum += stripSum[i][j]\n\t\tprint(Sum, end = \" \")\n\t\tfor j in range(1, n - k + 1):\n\t\t\tSum += (stripSum[i][j + k - 1] - stripSum[i][j - 1])\n\t\t\tprint(Sum, end = \" \")\n\t\tprint()", "958": "def transpose(A, B):\n\tfor i in range(N):\n\t\tfor j in range(M):\n\t\t\tB[i][j] = A[j][i]", "959": "def transpose(A):\n\tfor i in range(N):\n\t\tfor j in range(i+1, N):\n\t\t\tA[i][j], A[j][i] = A[j][i], A[i][j]", "965": "def pathCountRec(mat, m, n, k):\n\tif m < 0 or n < 0:\n\t\treturn 0\n\telif m == 0 and n == 0:\n\t\treturn k == mat[m][n]\n\treturn (pathCountRec(mat, m-1, n, k-mat[m][n])\n\t\t+ pathCountRec(mat, m, n-1, k-mat[m][n]))\ndef pathCount(mat, k):\n\treturn pathCountRec(mat, R-1, C-1, k)", "966": "def pathCountDPRecDP(mat, m, n, k):\n\tif m < 0 or n < 0:\n\t\treturn 0\n\telif m == 0 and n == 0:\n\t\treturn k == mat[m][n]\n\tif (dp[m][n][k] != -1):\n\t\treturn dp[m][n][k]\n\tdp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n\t\t\t\tpathCountDPRecDP(mat, m, n - 1, k - mat[m][n]))\n\treturn dp[m][n][k]\ndef pathCountDP(mat, k):\n\treturn pathCountDPRecDP(mat, R - 1, C - 1, k)", "1064": "def countMinReversals(expr):\n\tlenn = len(expr)\n\tif (lenn % 2) :\n\t\treturn -1\n\ts = []\n\tfor i in range(lenn):\n\t\tif (expr[i] =='' and len(s)):\n\t\t\tif (s[0] == '') :\n\t\t\t\ts.pop(0)\n\t\t\telse:\n\t\t\t\ts.insert(0, expr[i])\n\t\telse:\n\t\t\ts.insert(0, expr[i])\n\tred_len = len(s)\n\tn = 0\n\twhile (len(s)and s[0] == '') :\n\t\t\ts.pop(0)\n\t\t\tn += 1\n\treturn (red_len // 2 + n % 2)", "1072": "def PrintMinNumberForPattern(arr):\n\tcurr_max = 0\n\tlast_entry = 0\n\ti = 0\n\twhile i < len(arr):\n\t\tnoOfNextD = 0\n\t\tif arr[i] == \"I\":\n\t\t\tj = i + 1\n\t\t\twhile j < len(arr) and arr[j] == \"D\":\n\t\t\t\tnoOfNextD += 1\n\t\t\t\tj += 1\n\t\t\tif i == 0:\n\t\t\t\tcurr_max = noOfNextD + 2\n\t\t\t\tlast_entry += 1\n\t\t\t\tprint(\"\", last_entry, end = \"\")\n\t\t\t\tprint(\"\", curr_max, end = \"\")\n\t\t\t\tlast_entry = curr_max\n\t\t\telse:\n\t\t\t\tcurr_max += noOfNextD + 1\n\t\t\t\tlast_entry = curr_max\n\t\t\t\tprint(\"\", last_entry, end = \"\")\n\t\t\tfor k in range(noOfNextD):\n\t\t\t\tlast_entry -= 1\n\t\t\t\tprint(\"\", last_entry, end = \"\")\n\t\t\t\ti += 1\n\t\telif arr[i] == \"D\":\n\t\t\tif i == 0:\n\t\t\t\tj = i + 1\n\t\t\t\twhile j < len(arr) and arr[j] == \"D\":\n\t\t\t\t\tnoOfNextD += 1\n\t\t\t\t\tj += 1\n\t\t\t\tcurr_max = noOfNextD + 2\n\t\t\t\tprint(\"\", curr_max, curr_max - 1, end = \"\")\n\t\t\t\tlast_entry = curr_max - 1\n\t\t\telse:\n\t\t\t\tprint(\"\", last_entry - 1, end = \"\")\n\t\t\t\tlast_entry -= 1\n\t\ti += 1\n\tprint()", "1073": "def printLeast(arr):\n\tmin_avail = 1\n\tpos_of_I = 0\n\tv = []\n\tif (arr[0] == 'I'):\n\t\tv.append(1)\n\t\tv.append(2)\n\t\tmin_avail = 3\n\t\tpos_of_I = 1\n\telse:\n\t\tv.append(2)\n\t\tv.append(1)\n\t\tmin_avail = 3\n\t\tpos_of_I = 0\n\tfor i in range(1, len(arr)):\n\t\tif (arr[i] == 'I'):\n\t\t\tv.append(min_avail)\n\t\t\tmin_avail += 1\n\t\t\tpos_of_I = i + 1\n\t\telse:\n\t\t\tv.append(v[i])\n\t\t\tfor j in range(pos_of_I, i + 1):\n\t\t\t\tv[j] += 1\n\t\t\tmin_avail += 1\n\tprint(*v, sep = ' ')", "1074": "def PrintMinNumberForPattern(Strr):\n\tres = ''\n\tstack = []\n\tfor i in range(len(Strr) + 1):\n\t\tstack.append(i + 1)\n\t\tif (i == len(Strr) or Strr[i] == 'I'):\n\t\t\twhile len(stack) > 0:\n\t\t\t\tres += str(stack.pop())\n\t\t\t\tres += ' '\n\tprint(res)", "1075": "def getMinNumberForPattern(seq):\n\tn = len(seq)\n\tif (n >= 9):\n\t\treturn \"-1\"\n\tresult = [None] * (n + 1)\n\tcount = 1\n\tfor i in range(n + 1):\n\t\tif (i == n or seq[i] == 'I'):\n\t\t\tfor j in range(i - 1, -2, -1):\n\t\t\t\tresult[j + 1] = int('0' + str(count))\n\t\t\t\tcount += 1\n\t\t\t\tif(j >= 0 and seq[j] == 'I'):\n\t\t\t\t\tbreak\n\treturn result", "1252": "def subset(ar, n):\n\tres = 0\n\tar.sort()\n\tfor i in range(0, n) :\n\t\tcount = 1\n\t\tfor i in range(n - 1):\n\t\t\tif ar[i] == ar[i + 1]:\n\t\t\t\tcount+=1\n\t\t\telse:\n\t\t\t\tbreak\n\t\tres = max(res, count)\n\treturn res", "1253": "def subset(arr, n):\n\tmp = {i:0 for i in range(10)}\n\tfor i in range(n):\n\t\tmp[arr[i]] += 1\n\tres = 0\n\tfor key, value in mp.items():\n\t\tres = max(res, value)\n\treturn res", "1344": "def areElementsContiguous(arr, n):\n\tarr.sort()\n\tfor i in range(1,n):\n\t\tif (arr[i] - arr[i-1] > 1) :\n\t\t\treturn 0\n\treturn 1", "1345": "def areElementsContiguous(arr, n):\n\tmax1 = max(arr)\n\tmin1 = min(arr)\n\tm = max1 - min1 + 1\n\tif (m > n):\n\t\treturn False\n\tvisited = [0] * m\n\tfor i in range(0,n) :\n\t\tvisited[arr[i] - min1] = True\n\tfor i in range(0, m):\n\t\tif (visited[i] == False):\n\t\t\treturn False\n\treturn True", "1346": "def areElementsContiguous(arr):\n\tus = set()\n\tfor i in arr: us.add(i)\n\tcount = 1\n\tcurr_ele = arr[0] - 1\n\twhile curr_ele in us:\n\t\tcount += 1\n\t\tcurr_ele -= 1\n\tcurr_ele = arr[0] + 1\n\twhile curr_ele in us:\n\t\tcount += 1\n\t\tcurr_ele += 1\n\treturn (count == len(us))", "1366": "def longest(a, n, k):\n\tfreq = collections.defaultdict(int)\n\tstart = 0\n\tend = 0\n\tnow = 0\n\tl = 0\n\tfor i in range(n):\n\t\tfreq[a[i]] += 1\n\t\tif (freq[a[i]] == 1):\n\t\t\tnow += 1\n\t\twhile (now > k) :\n\t\t\tfreq[a[l]] -= 1\n\t\t\tif (freq[a[l]] == 0):\n\t\t\t\tnow -= 1\n\t\t\tl += 1\n\t\tif (i - l + 1 >= end - start + 1):\n\t\t\tend = i\n\t\t\tstart = l\n\tfor i in range(start, end + 1):\n\t\tprint(a[i], end = \" \")", "1390": "def findSmallestRange(arr, n, k):\n\ti, minval, maxval, minrange, minel, maxel, flag, minind = 0, 0, 0, 0, 0, 0, 0, 0\n\tfor i in range(k + 1):\n\t\tptr[i] = 0\n\tminrange = 10**9\n\twhile(1): \n\t\tminind = -1\n\t\tminval = 10**9\n\t\tmaxval = -10**9\n\t\tflag = 0\n\t\tfor i in range(k):\n\t\t\tif(ptr[i] == n):\n\t\t\t\tflag = 1 \n\t\t\t\tbreak\n\t\t\tif(ptr[i] < n and arr[i][ptr[i]] < minval):\n\t\t\t\tminind = i \n\t\t\t\tminval = arr[i][ptr[i]]\n\t\t\tif(ptr[i] < n and arr[i][ptr[i]] > maxval):\n\t\t\t\tmaxval = arr[i][ptr[i]]\n\t\tif(flag):\n\t\t\tbreak\n\t\tptr[minind] += 1\n\t\tif((maxval-minval) < minrange):\n\t\t\tminel = minval\n\t\t\tmaxel = maxval\n\t\t\tminrange = maxel - minel\n\tprint(\"The smallest range is [\", minel, maxel, \"]\")", "1405": "def findLargestd(S, n) :\n\tfound = False\n\tS.sort()\n\tfor i in range(n-1, -1, -1) :\n\t\tfor j in range(0, n) :\n\t\t\tif (i == j) :\n\t\t\t\tcontinue\n\t\t\tfor k in range(j + 1, n) :\n\t\t\t\tif (i == k) :\n\t\t\t\t\tcontinue\n\t\t\t\tfor l in range(k+1, n) :\n\t\t\t\t\tif (i == l) :\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l]) :\n\t\t\t\t\t\tfound = True\n\t\t\t\t\t\treturn S[i]\t\t\t\t\n\tif (found == False) :\n\t\treturn -1", "1406": "def findFourElements(arr, n):\n\tmp = dict()\n\tfor i in range(n - 1):\n\t\tfor j in range(i + 1, n):\n\t\t\tmp[arr[i] + arr[j]] =(i, j)\n\td = -10**9\n\tfor i in range(n - 1):\n\t\tfor j in range(i + 1, n):\n\t\t\tabs_diff = abs(arr[i] - arr[j])\n\t\t\tif abs_diff in mp.keys():\n\t\t\t\tp = mp[abs_diff]\n\t\t\t\tif (p[0] != i and p[0] != j and p[1] != i and p[1] != j):\n\t\t\t\t\td = max(d, max(arr[i], arr[j]))\n\treturn d", "1428": "def leftRotatebyOne(arr, n):\n\ttemp = arr[0]\n\tfor i in range(n-1):\n\t\tarr[i] = arr[i + 1]\n\tarr[n-1] = temp\ndef leftRotate(arr, d, n):\n\tfor i in range(d):\n\t\tleftRotatebyOne(arr, n)\ndef printArray(arr, size):\n\tfor i in range(size):\n\t\tprint (\"% d\"% arr[i], end =\" \")", "1468": "def pushZerosToEnd(arr, n):\n\tcount = 0 \n\tfor i in range(n):\n\t\tif arr[i] != 0:\n\t\t\tarr[count] = arr[i]\n\t\t\tcount+=1\n\twhile count < n:\n\t\tarr[count] = 0\n\t\tcount += 1", "1469": "def moveZerosToEnd (arr, n):\n\tcount = 0;\n\tfor i in range(0, n):\n\t\tif (arr[i] != 0):\n\t\t\tarr[count], arr[i] = arr[i], arr[count]\n\t\t\tcount+=1\ndef printArray(arr, n):\n\tfor i in range(0, n):\n\t\tprint(arr[i],end=\" \")", "1473": "def pushZerosToEnd(arr, n):\n\tcount = 0\n\tfor i in range(0, n):\n\t\tif arr[i] != 0:\n\t\t\tarr[count] = arr[i]\n\t\t\tcount+=1\n\twhile (count < n):\n\t\tarr[count] = 0\n\t\tcount+=1\ndef modifyAndRearrangeArr(ar, n):\n\tif n == 1:\n\t\treturn\n\tfor i in range(0, n - 1):\n\t\tif (arr[i] != 0) and (arr[i] == arr[i + 1]):\n\t\t\tarr[i] = 2 * arr[i]\n\t\t\tarr[i + 1] = 0\n\t\t\ti+=1\n\tpushZerosToEnd(arr, n)\ndef printArray(arr, n):\n\tfor i in range(0, n):\n\t\tprint(arr[i],end=\" \")", "1474": "def shiftAllZeroToLeft(arr, n):\n\tlastSeenNonZero = 0\n\tfor index in range(0, n):\n\t\tif (array[index] != 0):\n\t\t\tarray[index], array[lastSeenNonZero] = array[lastSeenNonZero], array[index]\n\t\t\tlastSeenNonZero+=1", "1478": "def printArray(arr, n):\n\tfor i in range(n):\n\t\tprint(arr[i], end = \" \")\n\tprint()\ndef RearrangePosNeg(arr, n):\n\tfor i in range(1, n):\n\t\tkey = arr[i]\n\t\tif (key > 0):\n\t\t\tcontinue\n\t\tj = i - 1\n\t\twhile (j >= 0 and arr[j] > 0):\n\t\t\tarr[j + 1] = arr[j]\n\t\t\tj = j - 1\n\t\tarr[j + 1] = key", "1480": "def printArray(A, size):\n\tfor i in range(0, size):\n\t\tprint(A[i], end = \" \")\n\tprint()\ndef reverse(arr, l, r):\n\tif l < r:\n\t\tarr[l], arr[r] = arr[r], arr[l]\n\t\tl, r = l + 1, r - 1\n\t\treverse(arr, l, r)\ndef merge(arr, l, m, r):\n\ti = l \n\tj = m + 1 \n\twhile i <= m and arr[i] < 0:\n\t\ti += 1\n\twhile j <= r and arr[j] < 0:\n\t\tj += 1\n\treverse(arr, i, m)\n\treverse(arr, m + 1, j - 1)\n\treverse(arr, i, j - 1)\ndef RearrangePosNeg(arr, l, r):\n\tif l < r:\n\t\tm = l + (r - l) // 2\n\t\tRearrangePosNeg(arr, l, m)\n\t\tRearrangePosNeg(arr, m + 1, r)\n\t\tmerge(arr, l, m, r)", "1481": "def RearrangePosNeg(arr,n):\n\ti=0\n\tj = n - 1\n\twhile(True):\n\t\twhile (arr[i] < 0 and i < n):\n\t\t\ti+=1\n\t\twhile (arr[j] > 0 and j >= 0):\n\t\t\tj-=1\n\t\tif (i < j):\n\t\t\tarr[i],arr[j] = arr[j],arr[i]\n\t\telse:\n\t\t\tbreak", "1515": "def findElements( arr, n):\n\tfor i in range(n):\n\t\tcount = 0\n\t\tfor j in range(0, n):\n\t\t\tif arr[j] > arr[i]:\n\t\t\t\tcount = count + 1\n\t\tif count >= 2 :\n\t\t\tprint(arr[i], end=\" \")", "1516": "def findElements(arr, n):\n\tarr.sort()\n\tfor i in range(0, n-2):\n\t\tprint(arr[i], end =\" \")", "1517": "def findElements(arr, n):\n\tfirst = -sys.maxsize\n\tsecond = -sys.maxsize\n\tfor i in range(0, n):\n\t\tif (arr[i] > first):\n\t\t\tsecond = first\n\t\t\tfirst = arr[i]\n\t\telif (arr[i] > second):\n\t\t\tsecond = arr[i]\n\tfor i in range(0, n):\n\t\tif (arr[i] < second):\n\t\t\tprint(arr[i], end =\" \")", "1535": "def findFirstMissing(array, start, end):\n\tif (start > end):\n\t\treturn end + 1\n\tif (start != array[start]):\n\t\treturn start;\n\tmid = int((start + end) / 2)\n\tif (array[mid] == mid):\n\t\treturn findFirstMissing(array, mid+1, end)\n\treturn findFirstMissing(array, start, mid)", "1536": "def findFirstMissing(arr, start, end, first):\n\tif (start < end):\n\t\tmid = int((start + end) / 2)\n\t\tif (arr[mid] != mid + first):\n\t\t\treturn findFirstMissing(arr, start, mid, first)\n\t\telse:\n\t\t\treturn findFirstMissing(arr, mid + 1, end, first)\n\treturn start + first\ndef findSmallestMissinginSortedArray(arr):\n\tif (arr[0] != 0):\n\t\treturn 0\n\tif (arr[-1] == len(arr) - 1):\n\t\treturn len(arr)\n\tfirst = arr[0]\n\treturn findFirstMissing(arr, 0,\n\t\t\tlen(arr) - 1, first)", "1537": "def find_max_sum(arr):\n\tincl = 0\n\texcl = 0\n\tfor i in arr:\n\t\tnew_excl = excl if excl>incl else incl\n\t\tincl = excl + i\n\t\texcl = new_excl\n\treturn (excl if excl>incl else incl)", "1545": "def buildSparseTable(arr, n):\n\tfor i in range(0, n):\n\t\tlookup[i][0] = arr[i]\n\tj = 1\n\twhile (1 << j) <= n:\n\t\ti = 0\n\t\twhile (i + (1 << j) - 1) < n:\n\t\t\tif (lookup[i][j - 1] <\n\t\t\t\tlookup[i + (1 << (j - 1))][j - 1]):\n\t\t\t\tlookup[i][j] = lookup[i][j - 1]\n\t\t\telse:\n\t\t\t\tlookup[i][j] = \\\n\t\t\t\t\t\tlookup[i + (1 << (j - 1))][j - 1]\n\t\t\ti += 1\n\t\tj += 1\ndef query(L, R):\n\tj = int(math.log2(R - L + 1))\n\tif lookup[L][j] <= lookup[R - (1 << j) + 1][j]:\n\t\treturn lookup[L][j]\n\telse:\n\t\treturn lookup[R - (1 << j) + 1][j]", "1546": "def buildSparseTable(arr, n):\n\tfor i in range(0, n):\n\t\ttable[i][0] = arr[i]\n\tj = 1\n\twhile (1 << j) <= n:\n\t\ti = 0\n\t\twhile i <= n - (1 << j):\n\t\t\ttable[i][j] = math.gcd(table[i][j - 1],\n\t\t\t\t\t\t\t\ttable[i + (1 << (j - 1))][j - 1])\n\t\t\ti += 1\n\t\tj += 1\ndef query(L, R):\n\tj = int(math.log2(R - L + 1))\n\treturn math.gcd(table[L][j],\n\t\t\t\t\ttable[R - (1 << j) + 1][j])", "1590": "def findMaxAverage(arr, n, k):\n\tif k > n:\n\t\treturn -1\n\tcsum = [0]*n\n\tcsum[0] = arr[0]\n\tfor i in range(1, n):\n\t\tcsum[i] = csum[i-1] + arr[i];\n\tmax_sum = csum[k-1]\n\tmax_end = k-1\n\tfor i in range(k, n):\n\t\tcurr_sum = csum[i] - csum[i-k]\n\t\tif curr_sum > max_sum:\n\t\t\tmax_sum = curr_sum\n\t\t\tmax_end = i\n\treturn max_end - k + 1", "1591": "def findMaxAverage(arr, n, k):\n\tif (k > n):\n\t\treturn -1\n\tsum = arr[0]\n\tfor i in range(1, k):\n\t\tsum += arr[i]\n\tmax_sum = sum\n\tmax_end = k - 1\n\tfor i in range(k, n):\n\t\tsum = sum + arr[i] - arr[i - k]\n\t\tif (sum > max_sum):\n\t\t\tmax_sum = sum\n\t\t\tmax_end = i\n\treturn max_end - k + 1", "1694": "def isMajority(arr, n, x):\n\tlast_index = (n//2 + 1) if n % 2 == 0 else (n//2)\n\tfor i in range(last_index):\n\t\tif arr[i] == x and arr[i + n//2] == x:\n\t\t\treturn 1", "1695": "def _binarySearch(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn _binarySearch(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn _binarySearch(arr, low, (mid -1), x)\n\treturn -1\ndef isMajority(arr, n, x):\n\ti = _binarySearch(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False", "1696": "def isMajorityElement(arr, n, key):\n if (arr[n // 2] == key):\n\t\treturn True\n return False", "1730": "def sortMat(mat, n) :\n\ttemp = [0] * (n * n)\n\tk = 0\n\tfor i in range(0, n) :\n\t\tfor j in range(0, n) :\n\t\t\ttemp[k] = mat[i][j]\n\t\t\tk += 1\n\ttemp.sort()\n\tk = 0\n\tfor i in range(0, n) :\n\t\tfor j in range(0, n) :\n\t\t\tmat[i][j] = temp[k]\n\t\t\tk += 1\ndef printMat(mat, n) :\n\tfor i in range(0, n) :\n\t\tfor j in range( 0, n ) :\n\t\t\tprint(mat[i][j] , end = \" \")\n\t\tprint()", "1797": "def bubbleSort(arr):\n\tn = len(arr)\n\tfor i in range(n):\n\t\tswapped = False\n\t\tfor j in range(0, n-i-1):\n\t\t\tif arr[j] > arr[j+1] :\n\t\t\t\tarr[j], arr[j+1] = arr[j+1], arr[j]\n\t\t\t\tswapped = True\n\t\tif swapped == False:\n\t\t\tbreak", "1813": "def findCrossOver(arr, low, high, x) :\n\tif (arr[high] <= x) : \n\t\t\treturn high\n\tif (arr[low] > x) : \n\t\t\treturn low\n\tmid = (low + high) // 2 \n\tif (arr[mid] <= x and arr[mid + 1] > x) :\n\t\treturn mid\n\tif(arr[mid] < x) :\n\t\treturn findCrossOver(arr, mid + 1, high, x)\n\treturn findCrossOver(arr, low, mid - 1, x)\ndef printKclosest(arr, x, k, n) :\n\tl = findCrossOver(arr, 0, n - 1, x)\n\tr = l + 1 \n\tcount = 0 \n\tif (arr[l] == x) :\n\t\tl -= 1\n\twhile (l >= 0 and r < n and count < k) :\n\t\tif (x - arr[l] < arr[r] - x) :\n\t\t\tprint(arr[l], end = \" \")\n\t\t\tl -= 1\n\t\telse :\n\t\t\tprint(arr[r], end = \" \")\n\t\t\tr += 1\n\t\tcount += 1\n\twhile (count < k and l >= 0) :\n\t\tprint(arr[l], end = \" \")\n\t\tl -= 1\n\t\tcount += 1\n\twhile (count < k and r < n) :\n\t\tprint(arr[r], end = \" \")\n\t\tr += 1\n\t\tcount += 1", "1822": "def push( head_ref, new_data):\n\tnew_node = Node(0)\n\tnew_node.data = new_data\n\tnew_node.next = (head_ref)\n\t(head_ref) = new_node\n\treturn head_ref\ndef insertionSort(head_ref):\n\tsorted = None\n\tcurrent = head_ref\n\twhile (current != None):\n\t\tnext = current.next\n\t\tsorted = sortedInsert(sorted, current)\n\t\tcurrent = next\n\thead_ref = sorted\n\treturn head_ref\ndef sortedInsert(head_ref, new_node):\n\tcurrent = None\n\tif (head_ref == None or (head_ref).data >= new_node.data):\n\t\tnew_node.next = head_ref\n\t\thead_ref = new_node\n\telse:\n\t\tcurrent = head_ref\n\t\twhile (current.next != None and current.next.data < new_node.data):\n\t\t\tcurrent = current.next\n\t\tnew_node.next = current.next\n\t\tcurrent.next = new_node\n\treturn head_ref\ndef printList(head):\n\ttemp = head\n\twhile(temp != None):\n\t\tprint( temp.data, end = \" \")\n\t\ttemp = temp.next\ndef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None", "1847": "def count(S, m, n ):\n\tif (n == 0):\n\t\treturn 1\n\tif (n < 0):\n\t\treturn 0;\n\tif (m <=0 and n >= 1):\n\t\treturn 0\n\treturn count( S, m - 1, n ) + count( S, m, n-S[m-1] );", "1849": "def count(S, m, n):\n\ttable = [0 for k in range(n+1)]\n\ttable[0] = 1\n\tfor i in range(0,m):\n\t\tfor j in range(S[i],n+1):\n\t\t\ttable[j] += table[j-S[i]]\n\treturn table[n]", "1852": "def matrixChainMemoised(p, i, j):\n\tif(i == j):\n\t\treturn 0\n\tif(dp[i][j] != -1):\n\t\treturn dp[i][j]\n\tdp[i][j] = sys.maxsize\n\tfor k in range(i,j):\n\t\tdp[i][j] = min(dp[i][j], matrixChainMemoised(p, i, k) + matrixChainMemoised(p, k + 1, j)+ p[i - 1] * p[k] * p[j])\n\treturn dp[i][j]\ndef MatrixChainOrder(p,n):\n\ti = 1\n\tj = n - 1 \n\treturn matrixChainMemoised(p, i, j)", "1853": "def MatrixChainOrder(p, n):\n\tm = [[0 for x in range(n)] for x in range(n)]\n\tfor i in range(1, n):\n\t\tm[i][i] = 0\n\tfor L in range(2, n):\n\t\tfor i in range(1, n-L + 1):\n\t\t\tj = i + L-1\n\t\t\tm[i][j] = sys.maxint\n\t\t\tfor k in range(i, j):\n\t\t\t\tq = m[i][k] + m[k + 1][j] + p[i-1]*p[k]*p[j]\n\t\t\t\tif q < m[i][j]:\n\t\t\t\t\tm[i][j] = q\n\treturn m[1][n-1]", "1869": "def max(a, b):\n\treturn a if (a > b) else b\ndef cutRod(price, n):\n\tif(n <= 0):\n\t\treturn 0\n\tmax_val = -sys.maxsize-1\n\tfor i in range(0, n):\n\t\tmax_val = max(max_val, price[i] +\n\t\t\t\t\tcutRod(price, n - i - 1))\n\treturn max_val", "1870": "def cutRod(price, n):\n\tval = [0 for x in range(n+1)]\n\tval[0] = 0\n\tfor i in range(1, n+1):\n\t\tmax_val = INT_MIN\n\t\tfor j in range(i):\n\t\t\tmax_val = max(max_val, price[j] + val[i-j-1])\n\t\tval[i] = max_val\n\treturn val[n]", "1998": "def multiply(x,y):\n\tif(y == 0):\n\t\treturn 0\n\tif(y > 0 ):\n\t\treturn (x + multiply(x, y - 1))\n\tif(y < 0 ):\n\t\treturn -multiply(x, -y)", "2013": "def SieveOfEratosthenes(n):\n\tprime = [True for i in range(n+1)]\n\tp = 2\n\twhile (p * p <= n):\n\t\tif (prime[p] == True):\n\t\t\tfor i in range(p * p, n+1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\tfor p in range(2, n+1):\n\t\tif prime[p]:\n\t\t\tprint p,", "2024": "def binomialCoeff(n, k) :\n\tres = 1\n\tif (k > n - k) :\n\t\tk = n - k\n\tfor i in range(0 , k) :\n\t\tres = res * (n - i)\n\t\tres = res // (i + 1)\n\treturn res\ndef printPascal(n) :\n\tfor line in range(0, n) :\n\t\tfor i in range(0, line + 1) :\n\t\t\tprint(binomialCoeff(line, i), \" \", end = \"\")\n\t\tprint()", "2025": "def printPascal(n:int):\n\tarr = [[0 for x in range(n)] for y in range(n)]\n\tfor line in range (0, n):\n\t\tfor i in range (0, line + 1):\n\t\t\tif(i==0 or i==line):\n\t\t\t\tarr[line][i] = 1\n\t\t\t\tprint(arr[line][i], end = \" \")\n\t\t\telse:\n\t\t\t\tarr[line][i] = (arr[line - 1][i - 1] + arr[line - 1][i])\n\t\t\t\tprint(arr[line][i], end = \" \")\t\t\t\n\t\tprint(\"\\n\", end = \"\")", "2026": "def printPascal(n):\n\tfor line in range(1, n + 1):\n\t\tC = 1; \n\t\tfor i in range(1, line + 1):\n\t\t\tprint(C, end = \" \");\n\t\t\tC = int(C * (line - i) / i);\n\t\tprint(\"\");", "2079": "def Add(x, y):\n\twhile (y != 0):\n\t\tcarry = x & y\n\t\tx = x ^ y\n\t\ty = carry << 1\n\treturn x", "2080": "def Add(x, y):\n\tif (y == 0):\n\t\treturn x\n\telse:\n\t\treturn Add( x ^ y, (x & y) << 1)", "2101": "def getModulo(n, d):\n\treturn ( n & (d-1) )", "2114": "def countSetBits(n):\n\tcount = 0\n\twhile (n):\n\t\tcount += n & 1\n\t\tn >>= 1\n\treturn count", "2117": "def countSetBits(n):\n\tif (n == 0):\n\t\treturn 0\n\telse:\n\t\treturn 1 + countSetBits(n & (n - 1))", "2118": "def initialize():\n\tBitsSetTable256[0] = 0\n\tfor i in range(256):\n\t\tBitsSetTable256[i] = (i & 1) + BitsSetTable256[i // 2]\ndef countSetBits(n):\n\treturn (BitsSetTable256[n & 0xff] +\n\t\t\tBitsSetTable256[(n >> 8) & 0xff] +\n\t\t\tBitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24])", "2119": "", "2120": "def countSetBitsRec(num):\n\tnibble = 0;\n\tif(0 == num):\n\t\treturn num_to_bits[0];\n\tnibble = num & 0xf;\n\treturn num_to_bits[nibble] + countSetBitsRec(num >> 4);", "2121": "def countSetBits(N):\n count = 0\n for i in range(4*8):\n\tif(N & (1 << i)):\n\tcount += 1\n\treturn count\n\tN = 15\n\tprint(countSetBits(N))", "2127": "def getParity( n ):\n\tparity = 0\n\twhile n:\n\t\tparity = ~parity\n\t\tn = n & (n - 1)\n\treturn parity", "2129": "def Log2(x):\n\tif x == 0:\n\t\treturn false;\n\treturn (math.log10(x) /\n\t\t\tmath.log10(2));\ndef isPowerOfTwo(n):\n\treturn (math.ceil(Log2(n)) ==\n\t\t\tmath.floor(Log2(n)));", "2130": "def isPowerOfTwo(n):\n\tif (n == 0):\n\t\treturn False\n\twhile (n != 1):\n\t\t\tif (n % 2 != 0):\n\t\t\t\treturn False\n\t\t\tn = n // 2\n\treturn True", "2131": "def powerof2(n):\n\tif n == 1:\n\t\treturn True\n\telif n%2 != 0 or n == 0:\n\t\treturn False\n\treturn powerof2(n/2)", "2132": "def isPowerOfTwo (x):\n\treturn (x and (not(x & (x - 1))) )", "2210": "def maxRepeating(arr, n, k):\n\tfor i in range(0, n):\n\t\tarr[arr[i]%k] += k\n\tmax = arr[0]\n\tresult = 0\n\tfor i in range(1, n):\n\t\tif arr[i] > max:\n\t\t\tmax = arr[i]\n\t\t\tresult = i\n\treturn result", "2226": "def fun(x):\n\ty = (x // 4) * 4\n\tans = 0\n\tfor i in range(y, x + 1):\n\t\tans ^= i\n\treturn ans\ndef query(x):\n\tif (x == 0):\n\t\treturn 0\n\tk = (x + 1) // 2\n\tif x % 2 == 0:\n\t\treturn((fun(k - 1) * 2) ^ (k & 1))\n\telse:\n\t\treturn(2 * fun(k))\ndef allQueries(q, l, r):\n\tfor i in range(q):\n\t\tprint(query(r[i]) ^ query(l[i] - 1))", "2243": "def prefixXOR(arr, preXOR, n):\n\tfor i in range(0, n, 1):\n\t\twhile (arr[i] % 2 != 1):\n\t\t\tarr[i] = int(arr[i] / 2)\n\t\tpreXOR[i] = arr[i]\n\tfor i in range(1, n, 1):\n\t\tpreXOR[i] = preXOR[i - 1] ^ preXOR[i]\ndef query(preXOR, l, r):\n\tif (l == 0):\n\t\treturn preXOR[r]\n\telse:\n\t\treturn preXOR[r] ^ preXOR[l - 1]", "2258": "def findMinSwaps(arr, n) :\n\tnoOfZeroes = [0] * n\n\tcount = 0\n\tnoOfZeroes[n - 1] = 1 - arr[n - 1]\n\tfor i in range(n-2, -1, -1) :\n\t\tnoOfZeroes[i] = noOfZeroes[i + 1]\n\t\tif (arr[i] == 0) :\n\t\t\tnoOfZeroes[i] = noOfZeroes[i] + 1\n\tfor i in range(0, n) :\n\t\tif (arr[i] == 1) :\n\t\t\tcount = count + noOfZeroes[i]\n\treturn count", "2259": "def minswaps(arr):\n\tcount = 0\n\tnum_unplaced_zeros = 0\n\tfor index in range(len(arr)-1, -1, -1):\n\t\tif arr[index] == 0:\n\t\t\tnum_unplaced_zeros += 1\n\t\telse:\n\t\t\tcount += num_unplaced_zeros\n\treturn count", "2281": "def arraySortedOrNot(arr, n):\n\tif (n == 0 or n == 1):\n\t\treturn True\n\tfor i in range(1, n):\n\t\tif (arr[i-1] > arr[i]):\n\t\t\treturn False\n\treturn True", "2308": "def printTwoOdd(arr, size):\n\txor2 = arr[0]\n\tset_bit_no = 0 \n\tn = size - 2\n\tx, y = 0, 0\n\tfor i in range(1, size):\n\t\txor2 = xor2 ^ arr[i]\n\tset_bit_no = xor2 & ~(xor2 - 1)\n\tfor i in range(size):\n\t\tif(arr[i] & set_bit_no):\n\t\t\tx = x ^ arr[i]\n\t\telse:\n\t\t\ty = y ^ arr[i]\n\tprint(\"The two ODD elements are\", x, \"&\", y)", "2310": "def findPair(arr,n):\n\tsize = len(arr)\n\ti,j = 0,1\n\twhile i < size and j < size:\n\t\tif i != j and arr[j]-arr[i] == n:\n\t\t\tprint \"Pair found (\",arr[i],\",\",arr[j],\")\"\n\t\t\treturn True\n\t\telif arr[j] - arr[i] < n:\n\t\t\tj+=1\n\t\telse:\n\t\t\ti+=1\n\tprint \"No pair found\"\n\treturn False", "2360": "def printMax(arr, k, n):\n\tbrr = arr.copy()\n\tbrr.sort(reverse = True)\n\tfor i in range(n):\n\t\tif (arr[i] in brr[0:k]):\n\t\t\tprint(arr[i], end = \" \")", "2372": "def binary_search(arr, low, high, ele):\n\twhile low < high:\n\t\tmid = (low + high) // 2\n\t\tif arr[mid] == ele:\n\t\t\treturn mid\n\t\telif arr[mid] > ele:\n\t\t\thigh = mid\n\t\telse:\n\t\t\tlow = mid + 1\n\treturn -1\ndef printSmall(arr, asize, n):\n\tcopy_arr = arr.copy()\n\tcopy_arr.sort()\n\tfor i in range(asize):\n\t\tif binary_search(copy_arr, low = 0, high = n, ele = arr[i]) > -1:\n\t\t\tprint(arr[i], end = \" \")", "2379": "def checkIsAP(arr, n):\n\tif (n == 1): return True\n\tarr.sort()\n\td = arr[1] - arr[0]\n\tfor i in range(2, n):\n\t\tif (arr[i] - arr[i-1] != d):\n\t\t\treturn False\n\treturn True", "2380": "def checkIsAP(arr, n):\n\thm = {}\n\tsmallest = float('inf')\n\tsecond_smallest = float('inf')\n\tfor i in range(n):\n\t\tif (arr[i] < smallest):\n\t\t\tsecond_smallest = smallest\n\t\t\tsmallest = arr[i]\n\t\telif (arr[i] != smallest and arr[i] < second_smallest):\n\t\t\tsecond_smallest = arr[i]\n\t\tif arr[i] not in hm:\n\t\t\thm[arr[i]] = 1\n\t\telse:\n\t\t\treturn False\n\tdiff = second_smallest - smallest\n\tfor i in range(n-1):\n\t\tif (second_smallest) not in hm:\n\t\t\treturn False\n\t\tsecond_smallest += diff\n\treturn True", "2382": "def countPairs(a, n):\n\tmn = +2147483647\n\tmx = -2147483648\n\tfor i in range(n):\n\t\tmn = min(mn, a[i])\n\t\tmx = max(mx, a[i])\n\tc1 = 0\n\tc2 = 0 \n\tfor i in range(n):\n\t\tif (a[i] == mn):\n\t\t\tc1+= 1\n\t\tif (a[i] == mx):\n\t\t\tc2+= 1\n\tif (mn == mx):\n\t\treturn n*(n - 1) // 2\n\telse:\n\t\treturn c1 * c2", "2437": "def rearrange(head):\n\tif (head == None):\n\t\treturn head\n\tprev, curr = head, head.next\n\twhile (curr):\n\t\tif (prev.data > curr.data):\n\t\t\tprev.data, curr.data = curr.data, prev.data\n\t\tif (curr.next and curr.next.data > curr.data):\n\t\t\tcurr.next.data, curr.data = curr.data, curr.next.data\n\t\tprev = curr.next\n\t\tif (not curr.next):\n\t\t\tbreak\n\t\tcurr = curr.next.next\n\treturn head\ndef push(head, k):\n\ttem = Node(k)\n\ttem.data = k\n\ttem.next = head\n\thead = tem\n\treturn head\ndef display(head):\n\tcurr = head\n\twhile (curr != None):\n\t\tprint(curr.data, end=\" \")\n\t\tcurr = curr.next\ndef __init__(self, x):\n\t\tself.data = x\n\t\tself.next = None", "2438": "def printlist(head):\n\twhile (head != None):\n\t\tprint(head.data, end = \" \")\n\t\tif (head.next != None):\n\t\t\tprint(\"->\", end = \"\")\n\t\thead = head.next\n\tprint()\ndef rearrange(head):\n\tglobal left\n\tif (head != None):\n\t\tleft = head\n\t\treorderListUtil(left)\ndef reorderListUtil(right):\n\tglobal left\n\tif (right == None):\n\t\treturn\n\treorderListUtil(right.next)\n\tif (left == None):\n\t\treturn\n\tif (left != right and left.next != right):\n\t\ttemp = left.next\n\t\tleft.next = right\n\t\tright.next = temp\n\t\tleft = temp\n\telse:\n\t\tif (left.next == right):\n\t\t\tleft.next.next = None\n\t\t\tleft = None\n\t\telse:\n\t\t\tleft.next = None\n\t\t\tleft = None\ndef __init__(self, key):\n\t\tself.data = key\n\t\tself.next = None", "2464": "def newNode(data):\n\ttemp = Node(0)\n\ttemp.data = data\n\ttemp.next = None\n\treturn temp\ndef getLength(Node):\n\tsize = 0\n\twhile (Node != None):\n\t\tNode = Node.next\n\t\tsize = size + 1\n\treturn size\ndef paddZeros( sNode, diff):\n\tif (sNode == None):\n\t\treturn None\n\tzHead = newNode(0)\n\tdiff = diff - 1\n\ttemp = zHead\n\twhile (diff > 0):\n\t\tdiff = diff - 1\n\t\ttemp.next = newNode(0)\n\t\ttemp = temp.next\n\ttemp.next = sNode\n\treturn zHead\ndef subtractLinkedListHelper(l1, l2):\n\tglobal borrow\n\tif (l1 == None and l2 == None and not borrow ):\n\t\treturn None\n\tl3 = None\n\tl4 = None\n\tif(l1 != None):\n\t\tl3 = l1.next\n\tif(l2 != None):\n\t\tl4 = l2.next\n\tprevious = subtractLinkedListHelper(l3, l4)\n\td1 = l1.data\n\td2 = l2.data\n\tsub = 0\n\tif (borrow):\n\t\td1 = d1 - 1\n\t\tborrow = False\n\tif (d1 < d2):\n\t\tborrow = True\n\t\td1 = d1 + 10\n\tsub = d1 - d2\n\tcurrent = newNode(sub)\n\tcurrent.next = previous\n\treturn current\ndef subtractLinkedList(l1, l2):\n\tif (l1 == None and l2 == None):\n\t\treturn None\n\tlen1 = getLength(l1)\n\tlen2 = getLength(l2)\n\tlNode = None\n\tsNode = None\n\ttemp1 = l1\n\ttemp2 = l2\n\tif (len1 != len2):\n\t\tif(len1 > len2):\n\t\t\tlNode = l1\n\t\telse:\n\t\t\tlNode = l2\n\t\tif(len1 > len2):\n\t\t\tsNode = l2\n\t\telse:\n\t\t\tsNode = l1\n\t\tsNode = paddZeros(sNode, abs(len1 - len2))\n\telse:\n\t\twhile (l1 != None and l2 != None):\n\t\t\tif (l1.data != l2.data):\n\t\t\t\tif(l1.data > l2.data ):\n\t\t\t\t\tlNode = temp1\n\t\t\t\telse:\n\t\t\t\t\tlNode = temp2\n\t\t\t\tif(l1.data > l2.data ):\n\t\t\t\t\tsNode = temp2\n\t\t\t\telse:\n\t\t\t\t\tsNode = temp1\n\t\t\t\tbreak\n\t\t\tl1 = l1.next\n\t\t\tl2 = l2.next\n\tglobal borrow\n\tborrow = False\n\treturn subtractLinkedListHelper(lNode, sNode)\ndef printList(Node):\n\twhile (Node != None):\n\t\tprint (Node.data, end =\" \")\n\t\tNode = Node.next\n\tprint(\" \")\ndef __init__(self, new_data):\n\t\tself.data = new_data\n\t\tself.next = None", "2501": "def insertAtMid(head, x):\n\tif(head == None): \n\t\thead = Node(x)\n\telse:\n\t\tnewNode = Node(x)\n\t\tptr = head\n\t\tlength = 0\n\t\twhile(ptr != None):\n\t\t\tptr = ptr.next\n\t\t\tlength += 1\n\t\tif(length % 2 == 0):\n\t\t\tcount = length / 2\n\t\telse:\n\t\t\t(length + 1) / 2\n\t\tptr = head\n\t\twhile(count > 1):\n\t\t\tcount -= 1\n\t\t\tptr = ptr.next\n\t\tnewNode.next = ptr.next\n\t\tptr.next = newNode\ndef display(head):\n\ttemp = head\n\twhile(temp != None):\n\t\tprint(str(temp.data), end = \" \")\n\t\ttemp = temp.next\ndef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None", "2518": "def getNode(data):\n\tnewNode = Node(0)\n\tnewNode.data = data\n\tnewNode.prev = newNode.next = None\n\treturn newNode\ndef sortedInsert(head_ref, newNode):\n\tcurrent = None\n\tif (head_ref == None):\n\t\thead_ref = newNode\n\telif ((head_ref).data >= newNode.data) :\n\t\tnewNode.next = head_ref\n\t\tnewNode.next.prev = newNode\n\t\thead_ref = newNode\n\telse :\n\t\tcurrent = head_ref\n\t\twhile (current.next != None and current.next.data < newNode.data):\n\t\t\tcurrent = current.next\n\t\tnewNode.next = current.next\n\t\tif (current.next != None):\n\t\t\tnewNode.next.prev = newNode\n\t\tcurrent.next = newNode\n\t\tnewNode.prev = current\n\treturn head_ref;\ndef insertionSort( head_ref):\n\tsorted = None\n\tcurrent = head_ref\n\twhile (current != None) :\n\t\tnext = current.next\n\t\tcurrent.prev = current.next = None\n\t\tsorted = sortedInsert(sorted, current)\n\t\tcurrent = next\n\thead_ref = sorted\n\treturn head_ref\ndef printList(head):\n\twhile (head != None) :\n\t\tprint( head.data, end = \" \")\n\t\thead = head.next\ndef push(head_ref, new_data):\n\tnew_node = Node(0)\n\tnew_node.data = new_data\n\tnew_node.next = (head_ref)\n\tnew_node.prev = None\n\tif ((head_ref) != None):\n\t\t(head_ref).prev = new_node\n\t(head_ref) = new_node\n\treturn head_ref\ndef __init__(self, data):\n\t\tself.data = data\n\t\tself.prev = None\n\t\tself.next = None", "2575": "def reverse(arr, s, e):\n\twhile s < e:\n\t\ttem = arr[s]\n\t\tarr[s] = arr[e]\n\t\tarr[e] = tem\n\t\ts = s + 1\n\t\te = e - 1\ndef fun(arr, k):\n\tn = len(arr)-1\n\tv = n - k\n\tif v>= 0:\n\t\treverse(arr, 0, v)\n\t\treverse(arr, v + 1, n)\n\t\treverse(arr, 0, n)\n\t\treturn arr", "2578": "def build(node, l, r, a):\n\tif (l == r):\n\t\tseg[node] = a[l]\n\telse:\n\t\tmid = (l + r) // 2\n\t\tbuild(2 * node, l, mid, a)\n\t\tbuild(2 * node + 1, mid + 1, r, a)\n\t\tseg[node] = (seg[2 * node] seg[2 * node + 1])\ndef query(node, l, r, start, end, a):\n\tif (l > end or r < start):\n\t\treturn 0\n\tif (start <= l and r <= end):\n\t\treturn seg[node]\n\tmid = (l + r) // 2\n\treturn ((query(2 * node, l, mid, start, end, a)) |\n\t\t\t(query(2 * node + 1, mid + 1, r, start, end, a)))\ndef orsum(a, n, q, k):\n\tbuild(1, 0, n - 1, a)\n\tfor j in range(q):\n\t\ti = k[j] % (n // 2)\n\t\tsec = query(1, 0, n - 1, n // 2 - i, n - i - 1, a)\n\t\tfirst = (query(1, 0, n - 1, 0, n // 2 - 1 - i, a) |\n\t\t\t\tquery(1, 0, n - 1, n - i, n - 1, a))\n\t\ttemp = sec + first\n\t\tprint(temp)", "2579": "def maximumEqual(a, b, n):\n\tstore = [0] * 10 ** 5\n\tfor i in range(n):\n\t\tstore[b[i]] = i + 1\n\tans = [0] * 10 ** 5\n\tfor i in range(n):\n\t\td = abs(store[a[i]] - (i + 1))\n\t\tif (store[a[i]] < i + 1):\n\t\t\td = n - d\n\t\tans[d] += 1\n\tfinalans = 0\n\tfor i in range(10 ** 5):\n\t\tfinalans = max(finalans, ans[i])\n\tprint(finalans)", "2583": "def RightRotate(a, n, k):\n\tk = k % n;\n\tfor i in range(0, n):\n\t\tif(i < k):\n\t\t\tprint(a[n + i - k], end = \" \");\n\t\telse:\n\t\t\tprint(a[i - k], end = \" \");\n\tprint(\"\\n\");", "2615": "def restoreSortedArray(arr, n):\n\tfor i in range(n):\n\t\tif (arr[i] > arr[i + 1]):\n\t\t\treverse(arr, 0, i);\n\t\t\treverse(arr, i + 1, n);\n\t\t\treverse(arr, 0, n);\ndef reverse(arr, i, j):\n\twhile (i < j):\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t\ti += 1;\n\t\tj -= 1;\ndef printArray(arr, size):\n\tfor i in range(size):\n\t\tprint(arr[i], end=\"\");", "2616": "def findStartIndexOfArray(arr, low, high):\n\tif (low > high):\n\t\treturn -1;\n\tif (low == high):\n\t\treturn low;\n\tmid = low + (high - low) / 2;\n\tif (arr[mid] > arr[mid + 1]):\n\t\treturn mid + 1;\n\tif (arr[mid - 1] > arr[mid]):\n\t\treturn mid;\n\tif (arr[low] > arr[mid]):\n\t\treturn findStartIndexOfArray(arr, low, mid - 1);\n\telse:\n\t\treturn findStartIndexOfArray(arr, mid + 1, high);\ndef restoreSortedArray(arr, n):\n\tif (arr[0] < arr[n - 1]):\n\t\treturn;\n\tstart = findStartIndexOfArray(arr, 0, n - 1);\n\treverse(arr, 0, start);\n\treverse(arr, start, n);\n\treverse(arr);\ndef printArray(arr, size):\n\tfor i in range(size):\n\t\tprint(arr[i], end=\"\");\ndef reverse(arr, i, j):\n\twhile (i < j):\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t\ti += 1;\n\t\tj -= 1;", "2623": "def leftrotate(s, d):\n\ttmp = s[d : ] + s[0 : d]\n\treturn tmp\ndef rightrotate(s, d):\n return leftrotate(s, len(s) - d)", "2673": "def insertNode(start, value):\n\tif (start == None) :\n\t\tnew_node = Node(value)\n\t\tnew_node.data = value\n\t\tnew_node.next = new_node\n\t\tnew_node.prev = new_node\n\t\tstart = new_node\n\t\treturn new_node\n\tlast = start.prev\n\tnew_node = Node(value)\n\tnew_node.data = value\n\tnew_node.next = start\n\t(start).prev = new_node\n\tnew_node.prev = last\n\tlast.next = new_node\n\treturn start\ndef displayList(start):\n\ttemp = start\n\twhile (temp.next != start):\n\t\tprint(temp.data, end = \" \")\n\t\ttemp = temp.next\n\tprint(temp.data)\ndef searchList(start, search):\n\ttemp = start\n\tcount = 0\n\tflag = 0\n\tvalue = 0\n\tif(temp == None):\n\t\treturn -1\n\telse:\n\t\twhile(temp.next != start):\n\t\t\tcount = count + 1\n\t\t\tif(temp.data == search):\n\t\t\t\tflag = 1\n\t\t\t\tcount = count - 1\n\t\t\t\tbreak\n\t\t\ttemp = temp.next\n\t\tif(temp.data == search):\n\t\t\tcount = count + 1\n\t\t\tflag = 1\n\t\tif(flag == 1):\n\t\t\tprint(search,\"found at location \", count)\n\t\telse:\n\t\t\tprint(search, \" not found\")\n\treturn -1\ndef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None", "2675": "def getNode(data):\n\tnewNode = Node(data)\n\tnewNode.data = data\n\treturn newNode\ndef insertEnd(head, new_node):\n\tif (head == None) :\n\t\tnew_node.next = new_node\n\t\tnew_node.prev = new_node\n\t\thead = new_node\n\t\treturn head\n\tlast = head.prev\n\tnew_node.next = head\n\thead.prev = new_node\n\tnew_node.prev = last\n\tlast.next = new_node\n\treturn head\ndef reverse(head):\n\tif (head == None):\n\t\treturn None\n\tnew_head = None\n\tlast = head.prev\n\tcurr = last\n\twhile (curr.prev != last):\n\t\tprev = curr.prev\n\t\tnew_head = insertEnd(new_head, curr)\n\t\tcurr = prev\n\tnew_head = insertEnd(new_head, curr)\n\treturn new_head\ndef display(head):\n\tif (head == None):\n\t\treturn\n\ttemp = head\n\tprint(\"Forward direction: \", end = \"\")\n\twhile (temp.next != head):\n\t\tprint(temp.data, end = \" \")\n\t\ttemp = temp.next\n\tprint(temp.data)\n\tlast = head.prev\n\ttemp = last\n\tprint(\"Backward direction: \", end = \"\")\n\twhile (temp.prev != last):\n\t\tprint(temp.data, end = \" \")\n\t\ttemp = temp.prev\n\tprint(temp.data)\ndef __init__(self, data):\n\t\tself.data = data\n\t\tself.next = None", "2696": "def addEdge(u, v):\n\tadj[u].append(v);\n\tadj[v].append(u);\ndef dfs(cur, prev):\n\tparent[cur] = prev;\n\tdepth[cur] = depth[prev] + 1;\n\tfor i in range(len(adj[cur])): \n\t\tif (adj[cur][i] != prev):\n\t\t\tdfs(adj[cur][i], cur);\ndef preprocess():\n\tdepth[0] = -1;\n\tdfs(1, 0);\ndef LCANaive(u, v):\n\tif (u == v):\n\t\treturn u;\n\tif (depth[u] > depth[v]):\n\t\tu, v = v, u\n\tv = parent[v]; \n\treturn LCANaive(u, v);", "2740": "def find_permutations(arr):\n\tcnt = 0\n\tmax_ind = -1\n\tmin_ind = 10000000;\n\tn = len(arr)\n\tindex_of = {}\n\tfor i in range(n):\n\t\tindex_of[arr[i]] = i + 1\n\tfor i in range(1, n + 1):\n\t\tmax_ind = max(max_ind, index_of[i])\n\t\tmin_ind = min(min_ind, index_of[i])\n\t\tif (max_ind - min_ind + 1 == i):\n\t\t\tcnt += 1\n\treturn cnt", "2753": "", "2773": "def countOfNum(n, a, b):\n\tcnt_of_a, cnt_of_b, cnt_of_ab, sum = 0, 0, 0, 0\n\tcnt_of_a = n // a\n\tcnt_of_b = n // b\n\tsum = cnt_of_b + cnt_of_a\n\tcnt_of_ab = n // (a * b)\n\tsum = sum - cnt_of_ab\n\treturn sum\ndef sumOfNum(n, a, b):\n\ti = 0\n\tsum = 0\n\tans = dict()\n\tfor i in range(a, n + 1, a):\n\t\tans[i] = 1\n\tfor i in range(b, n + 1, b):\n\t\tans[i] = 1\n\tfor it in ans:\n\t\tsum = sum + it\n\treturn sum", "2783": "def maximumArea(l, b,x, y):\n\tleft, right, above, below = 0, 0, 0, 0\n\tleft = x * b\n\tright = (l - x - 1) * b\n\tabove = l * y\n\tbelow = (b - y - 1) * l\n\tprint(max(max(left, right),max(above, below)))", "2802": "def precompute():\n\tF[1] = 2;\n\tF[2] = 3;\n\tF[3] = 4;\n\tfor i in range(4,N):\n\t\tF[i] = (F[i - 1] + F[i - 2]) % MOD;", "2804": "def get(L, R) :\n\tx = 1.0 / L;\n\ty = 1.0 / (R + 1.0);\n\treturn (x - y);", "2809": "def consecutiveOnes(x):\n\tp = 0\n\twhile (x > 0):\n\t\tif (x % 2 == 1 and p == 1):\n\t\t\treturn True\n\t\tp = x % 2\n\t\tx //= 2\n\treturn False\ndef preCompute():\n\tfor i in range(MAX + 1):\n\t\tif (consecutiveOnes(i) == 0):\n\t\t\tv.append(i)\ndef nextValid(n):\n\tit = upper_bound(v, n)\n\tval = v[it]\n\treturn val\ndef performQueries(queries, q):\n\tfor i in range(q):\n\t\tprint(nextValid(queries[i]))", "2816": "def changeToOnes(string) :\n\tctr = 0;\n\tl = len(string);\n\tfor i in range(l - 1, -1, -1) :\n\t\tif (string[i] == '1') :\n\t\t\tctr += 1;\n\t\telse :\n\t\t\tbreak;\n\treturn l - ctr;\ndef removeZeroesFromFront(string) :\n\ts = \"\";\n\ti = 0;\n\twhile (i < len(string) and string[i] == '0') :\n\t\ti += 1;\n\tif (i == len(string)) :\n\t\ts = \"0\";\n\telse :\n\t\ts = string[i: len(string) - i];\n\treturn s;", "2818": "def getCount(a, n):\n\tgcd = 0\n\tfor i in range(n):\n\t\tgcd = __gcd(gcd, a[i])\n\tcnt = 0\n\tfor i in range(1, gcd + 1):\n\t\tif i * i > gcd:\n\t\t\tbreak\n\t\tif (gcd % i == 0):\n\t\t\tif (i * i == gcd):\n\t\t\t\tcnt += 1\n\t\t\telse:\n\t\t\t\tcnt += 2\n\treturn cnt", "2827": "def MinDeletion(a, n) :\n\tmap = dict.fromkeys(a, 0);\n\tfor i in range(n) :\n\t\tmap[a[i]] += 1;\n\tans = 0;\n\tfor key,value in map.items() :\n\t\tx = key;\n\t\tfrequency = value;\n\t\tif (x <= frequency) :\n\t\t\tans += (frequency - x);\n\t\telse :\n\t\t\tans += frequency;\n\treturn ans;", "2831": "def maxCountAB(s,n):\n\tA = 0\n\tB = 0\n\tBA = 0\n\tans = 0\n\tfor i in range(n):\n\t\tS = s[i]\n\t\tL = len(S)\n\t\tfor j in range(L-1):\n\t\t\tif (S[j] == 'A' and S[j + 1] == 'B'):\n\t\t\t\tans += 1\n\t\tif (S[0] == 'B' and S[L - 1] == 'A'):\n\t\t\tBA += 1", "2832": "def MinOperations(n, x, arr):\n\ttotal = 0\n\tfor i in range(n):\n\t\tif (arr[i] > x):\n\t\t\tdifference = arr[i] - x\n\t\t\ttotal = total + difference\n\t\t\tarr[i] = x\n\tfor i in range(n):\n\t\tLeftNeigbouringSum = arr[i] + arr[i - 1]\n\t\tif (LeftNeigbouringSum > x):\n\t\t\tcurrent_diff = LeftNeigbouringSum - x\n\t\t\tarr[i] = max(0, arr[i] - current_diff)\n\t\t\ttotal = total + current_diff\n\treturn total", "2847": "def findNumbers(arr, n):\n\t\tsumN = (n * (n + 1)) / 2;\n\t\tsumSqN = (n * (n + 1) * (2 * n + 1)) / 6;\n\t\tsum = 0;\n\t\tsumSq = 0;\n\t\tfor i in range(0,n):\n\t\t\tsum = sum + arr[i];\n\t\t\tsumSq = sumSq + (math.pow(arr[i], 2));\n\t\tB = (((sumSq - sumSqN) / (sum - sumN)) + sumN - sum) / 2;\n\t\tA = sum - sumN + B;\n\t\tprint(\"A = \",int(A)) ;\n\t\tprint(\"B = \",int(B));", "2883": "def is_prefix(temp, str):\n\tif (len(temp) < len(str)):\n\t\treturn 0\n\telse:\n\t\tfor i in range(len(str)):\n\t\t\tif (str[i] != temp[i]):\n\t\t\t\treturn 0\n\t\treturn 1\ndef lexicographicallyString(input, n, str):\n\tinput.sort()\n\tfor i in range(n):\n\t\ttemp = input[i]\n\t\tif (is_prefix(temp, str)):\n\t\t\treturn temp\n\treturn \"-1\"", "2892": "def Rearrange(arr, K, N):\n\tans = [0]*(N + 1)\n\tf = -1\n\tfor i in range(N):\n\t\tans[i] = -1\n\tK = arr.index(K)\n\tsmaller = []\n\tgreater = []\n\tfor i in range(N):\n\t\tif (arr[i] < arr[K]):\n\t\t\tsmaller.append(arr[i])\n\t\telif (arr[i] > arr[K]):\n\t\t\tgreater.append(arr[i])\n\tlow = 0\n\thigh = N - 1\n\twhile (low <= high):\n\t\tmid = (low + high) // 2\n\t\tif (mid == K):\n\t\t\tans[mid] = arr[K]\n\t\t\tf = 1\n\t\t\tbreak\n\t\telif (mid < K):\n\t\t\tif (len(smaller) == 0):\n\t\t\t\tbreak\n\t\t\tans[mid] = smaller[-1]\n\t\t\tsmaller.pop()\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\tif (len(greater) == 0):\n\t\t\t\tbreak\n\t\t\tans[mid] = greater[-1]\n\t\t\tgreater.pop()\n\t\t\thigh = mid - 1\n\tif (f == -1):\n\t\tprint(-1)\n\t\treturn\n\tfor i in range(N):\n\t\tif (ans[i] == -1):\n\t\t\tif (len(smaller)):\n\t\t\t\tans[i] = smaller[-1]\n\t\t\t\tsmaller.pop()\n\t\t\telif (len(greater)):\n\t\t\t\tans[i] = greater[-1]\n\t\t\t\tgreater.pop()\n\tfor i in range(N):\n\t\tprint(ans[i], end=\" \")\n\tprint()", "2923": "def minimumK(arr, M, N):\n\tgood = math.ceil((N * 1.0) / ((M + 1) * 1.0))\n\tfor i in range(1, N + 1):\n\t\tK = i\n\t\tcandies = N\n\t\ttaken = 0\n\t\twhile (candies > 0):\n\t\t\ttaken += min(K, candies)\n\t\t\tcandies -= min(K, candies)\n\t\t\tfor j in range(M):\n\t\t\t\tconsume = (arr[j] * candies) / 100\n\t\t\t\tcandies -= consume\n\t\tif (taken >= good):\n\t\tprint(i)\n\t\treturn", "2940": "def calcTotalTime(path):\n\ttime = 0\n\tx = 0\n\ty = 0\n\ts = set([])\n\tfor i in range(len(path)):\n\t\tp = x\n\t\tq = y\n\t\tif (path[i] == 'N'):\n\t\t\ty += 1\n\t\telif (path[i] == 'S'):\n\t\t\ty -= 1\n\t\telif (path[i] == 'E'):\n\t\t\tx += 1\n\t\telif (path[i] == 'W'):\n\t\t\tx -= 1\n\t\tif (p + x, q + y) not in s:\n\t\t\ttime += 2\n\t\t\ts.add((p + x, q + y))\n\t\telse:\n\t\t\ttime += 1\n\tprint(time)", "2950": "def calcPsquare(N):\n\tfor i in range(1, N):\n\t\tif i * i > N:\n\t\t\tbreak\n\t\tpsquare.append(i * i)\ndef countWays(index, target):\n\tif (target == 0):\n\t\treturn 1\n\tif (index < 0 or target < 0):\n\t\treturn 0\n\tinc = countWays(index, target - psquare[index])\n\texc = countWays(index - 1, target)\n\treturn inc + exc", "2983": "def findCost(A, N):\n\ttotalCost = 0\n\tfor i in range(N):\n\t\tif (A[i] == 0):\n\t\t\tA[i] = 1\n\t\t\ttotalCost += i\n\treturn totalCost", "3003": "def countNumbers(L, R, K):\n\tlist = []\n\tfor i in range(L, R + 1):\n\t\tif (isPalindrome(i)):\n\t\t\tlist.append(i)\n\tcount = 0\n\tfor i in range(len(list)):\n\t\tright_index = search(list, list[i] + K - 1)\n\t\tif (right_index != -1):\n\t\t\tcount = max(count, right_index - i + 1)\n\treturn count\ndef search(list, num):\n\tlow, high = 0, len(list) - 1\n\tans = -1\n\twhile (low <= high):\n\t\tmid = low + (high - low) // 2\n\t\tif (list[mid] <= num):\n\t\t\tans = mid\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid - 1\n\treturn ans\ndef isPalindrome(n):\n\trev = 0\n\ttemp = n\n\twhile (n > 0):\n\t\trev = rev * 10 + n % 10\n\t\tn //= 10\n\treturn rev == temp", "3010": "def peakIndex(arr):\n\tN = len(arr)\n\tif (len(arr) < 3):\n\t\treturn -1\n\ti = 0\n\twhile (i + 1 < N):\n\t\tif (arr[i + 1] < arr[i] or arr[i] == arr[i + 1]):\n\t\t\tbreak\n\t\ti += 1\n\tif (i == 0 or i == N - 1):\n\t\treturn -1\n\tans = i\n\twhile (i < N - 1):\n\t\tif (arr[i] < arr[i + 1] or arr[i] == arr[i + 1]):\n\t\t\tbreak\n\t\ti += 1\n\tif (i == N - 1):\n\t\treturn ans\n\treturn -1", "3053": "def hasArrayTwoPairs(nums, n, target):\n\tnums = sorted(nums)\n\tfor i in range(n):\n\t\tx = target - nums[i]\n\t\tlow, high = 0, n - 1\n\t\twhile (low <= high):\n\t\t\tmid = low + ((high - low) // 2)\n\t\t\tif (nums[mid] > x):\n\t\t\t\thigh = mid - 1\n\t\t\telif (nums[mid] < x):\n\t\t\t\tlow = mid + 1\n\t\t\telse:\n\t\t\t\tif (mid == i):\n\t\t\t\t\tif ((mid - 1 >= 0) and nums[mid - 1] == x):\n\t\t\t\t\t\tprint(nums[i], end = \", \")\n\t\t\t\t\t\tprint(nums[mid - 1])\n\t\t\t\t\t\treturn\n\t\t\t\t\tif ((mid + 1 < n) and nums[mid + 1] == x):\n\t\t\t\t\t\tprint(nums[i], end = \", \")\n\t\t\t\t\t\tprint(nums[mid + 1])\n\t\t\t\t\t\treturn\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tprint(nums[i], end = \", \")\n\t\t\t\t\tprint(nums[mid])\n\t\t\t\t\treturn\n\tprint (-1)", "3096": "def sumofsubtree(root):\n\tp = [1, 0]\n\tif (root.left):\n\t\tptemp = sumofsubtree(root.left)\n\t\tp[1] += ptemp[0] + ptemp[1]\n\t\tp[0] += ptemp[0]\n\tif (root.right):\n\t\tptemp = sumofsubtree(root.right)\n\t\tp[1] += ptemp[0] + ptemp[1]\n\t\tp[0] += ptemp[0]\n\troot.size = p[0]\n\treturn p\ndef distance(root, target, distancesum, n):\n\tglobal sum\n\tif (root.data == target):\n\t\tsum = distancesum\n\tif (root.left):\n\t\ttempsum = (distancesum - root.left.size +\n\t\t\t\t\t\t\t(n - root.left.size))\n\t\tdistance(root.left, target, tempsum, n)\n\tif (root.right):\n\t\ttempsum = (distancesum - root.right.size +\n\t\t\t\t\t\t\t(n - root.right.size))\n\t\tdistance(root.right, target, tempsum, n)\ndef __init__(self, data):\n\t\tself.data = data\n\t\tself.size = 0\n\t\tself.left = None\n\t\tself.right = None", "3120": "def delCost(s, cost):\n\tvisited = [False]*len(s)\n\tans = 0\n\tfor i in range(len(s)):\n\t\tif visited[i]: \n\t\t\tcontinue\n\t\tmaxDel = 0\n\t\ttotCost = 0\n\t\tvisited[i] = True\n\t\tfor j in range(i, len(s)):\n\t\t\tif s[i] == s[j]: \n\t\t\t\tmaxDel = max(maxDel, cost[j])\n\t\t\t\ttotCost += cost[j]\n\t\t\t\tvisited[j] = True\n\t\tans += totCost - maxDel\n\treturn ans", "3121": "def delCost(s, cost):\n\tans = 0\n\tforMax = {}\n\tforTot = {}\n\tfor i in range(len(s)):\n\t\tif s[i] not in forMax: \n\t\t\tforMax[s[i]] = cost[i]\n\t\telse:\n\t\t\tforMax[s[i]] = max(cost[i], forMax[s[i]])\n\t\tif s[i] not in forTot: \n\t\t\tforTot[s[i]] = cost[i]\n\t\telse:\n\t\t\tforTot[s[i]] += cost[i]\n\tfor i in forMax:\n\t\tans += forTot[i] - forMax[i]\n\treturn ans", "3128": "def findClosest(N, target):\n\tclosest = -1\n\tdiff = 10**18\n\tfor i in range(1, ceil(sqrt(N)) + 1):\n\t\tif (N % i == 0):\n\t\t\tif (N // i == i):\n\t\t\t\tif (abs(target - i) < diff):\n\t\t\t\t\tdiff = abs(target - i)\n\t\t\t\t\tclosest = i\n\t\t\telse:\n\t\t\t\tif (abs(target - i) < diff):\n\t\t\t\t\tdiff = abs(target - i)\n\t\t\t\t\tclosest = i\n\t\t\t\tif (abs(target - N // i) < diff):\n\t\t\t\t\tdiff = abs(target - N // i)\n\t\t\t\t\tclosest = N // i\n\tprint(closest)", "3129": "def computeDivisors():\n\tglobal divisors\n\tglobal MAX\n\tfor i in range(1, MAX + 1, 1):\n\t\tfor j in range(i, MAX + 1, i):\n\t\t\tdivisors[j].append(i)\ndef getClosest(val1, val2, target):\n\tif (target - val1 >= val2 - target):\n\t\treturn val2\n\telse:\n\t\treturn val1\ndef findClosest(arr, n, target):\n\tif (target <= arr[0]):\n\t\treturn arr[0]\n\tif (target >= arr[n - 1]):\n\t\treturn arr[n - 1]\n\ti = 0\n\tj = n\n\tmid = 0\n\twhile (i < j):\n\t\tmid = (i + j) // 2\n\t\tif (arr[mid] == target):\n\t\t\treturn arr[mid]\n\t\tif (target < arr[mid]):\n\t\t\tif (mid > 0 and target > arr[mid - 1]):\n\t\t\t\treturn getClosest(arr[mid - 1], arr[mid],target)\n\t\t\tj = mid\n\t\telse:\n\t\t\tif (mid < n - 1 and target < arr[mid + 1]):\n\t\t\t\treturn getClosest(arr[mid], arr[mid + 1], target)\n\t\t\ti = mid + 1\n\treturn arr[mid]\ndef printClosest(N, X):\n\tglobal divisors\n\tcomputeDivisors()\n\tans = findClosest(divisors[N],\n\t\t\t\tlen(divisors[N]), X)\n\tprint(ans)", "3135": "def countTriplets(arr, N):\n\tzero_i = []\n\tone_i = []\n\tmp = {}\n\tfor i in range(N):\n\t\tif (arr[i] == 0):\n\t\t\tzero_i.append(i + 1)\n\t\telif (arr[i] == 1):\n\t\t\tone_i.append(i + 1)\n\t\telse:\n\t\t\tmp[i + 1] = 1\n\ttotal = len(zero_i) * len(one_i) * len(mp)\n\tfor i in range(len(zero_i)):\n\t\tfor j in range(len(one_i)):\n\t\t\tp = zero_i[i]\n\t\t\tq = one_i[j]\n\t\t\tr = 2 * p - q\n\t\t\tif (r in mp):\n\t\t\t\ttotal -= 1\n\t\t\tr = 2 * q - p\n\t\t\tif (r in mp):\n\t\t\t\ttotal -= 1\n\t\t\tr = (p + q) // 2\n\t\t\tif ((r in mp) and abs(r - p) == abs(r - q)):\n\t\t\t\ttotal -= 1\n\tprint (total)", "3138": "def power(A, N):\n\tcount = 0;\n\tif (A == 1):\n\t\treturn 0;\n\twhile (N > 0):\n\t\tcount += 1;\n\t\tN //= A;\n\treturn int(count);\ndef Pairs(N, A, B):\n\tpowerA, powerB = 0, 0;\n\tpowerA = power(A, N);\n\tpowerB = power(B, N);\n\tintialB = B;\n\tintialA = A;\n\tA = 1;\n\tfor i in range(powerA + 1):\n\t\tB = 1;\n\t\tfor j in range(powerB + 1):\n\t\t\tif (B == N - A):\n\t\t\t\tprint(i , \" \" , j);\n\t\t\t\treturn;\n\t\t\tB *= intialB;\n\t\tA *= intialA;\n\tprint(\"-1\");\n\treturn;", "3142": "def findNonMultiples(arr, n, k):\n\tmultiples = set([])\n\tfor i in range(n):\n\t\tif (arr[i] not in multiples):\n\t\t\tfor j in range(1, k // arr[i] + 1):\n\t\t\t\tmultiples.add(arr[i] * j)\n\treturn k - len(multiples)\ndef countValues(arr, N, L, R):\n\treturn (findNonMultiples(arr, N, R) -\n\t\t\tfindNonMultiples(arr, N, L - 1))", "3163": "def maxMatch(A, B):\n\tAindex = {}\n\tdiff = {}\n\tfor i in range(len(A)):\n\t\tAindex[A[i]] = i\n\tfor i in range(len(B)):\n\t\tif i-Aindex[B[i]] < 0:\n\t\t\tif len(A)+i-Aindex[B[i]] not in diff:\n\t\t\t\tdiff[len(A)+i-Aindex[B[i]]] = 1\n\t\t\telse:\n\t\t\t\tdiff[len(A)+i-Aindex[B[i]]] += 1\n\t\telse:\n\t\t\tif i-Aindex[B[i]] not in diff:\n\t\t\t\tdiff[i-Aindex[B[i]]] = 1\n\t\t\telse:\n\t\t\t\tdiff[i-Aindex[B[i]]] += 1\n\treturn max(diff.values())", "3176": "def checkXOR(arr, N):\n\tif (N % 2 == 0):\n\t\txro = 0;\n\t\tfor i in range(N):\n\t\t\txro ^= arr[i];\n\t\tif (xro != 0):\n\t\t\tprint(-1);\n\t\t\treturn;\n\t\tfor i in range(0, N - 3, 2):\n\t\t\tprint(i, \" \", (i + 1), \" \", (i + 2), end=\" \");\n\t\tfor i in range(0, N - 3, 2):\n\t\t\tprint(i, \" \", (i + 1), \" \", (N - 1), end=\" \");\n\telse:\n\t\tfor i in range(0, N - 2, 2):\n\t\t\tprint(i, \" \", (i + 1), \" \", (i + 2));\n\t\tfor i in range(0, N - 2, 2):\n\t\t\tprint(i, \" \", (i + 1), \" \", (N - 1));", "3179": "def make_array_element_even(arr, N):\n\tres = 0\n\todd_cont_seg = 0\n\tfor i in range(0, N):\n\t\tif (arr[i] % 2 == 1):\n\t\t\todd_cont_seg+=1\n\t\telse:\n\t\t\tif (odd_cont_seg > 0):\n\t\t\t\tif (odd_cont_seg % 2 == 0):\n\t\t\t\t\tres += odd_cont_seg // 2\n\t\t\t\telse:\n\t\t\t\t\tres += (odd_cont_seg // 2) + 2\n\t\t\t\todd_cont_seg = 0\n\tif (odd_cont_seg > 0):\n\t\tif (odd_cont_seg % 2 == 0):\n\t\t\tres += odd_cont_seg // 2\n\t\telse:\n\t\t\tres += odd_cont_seg // 2 + 2\n\treturn res", "3183": "def minCollectingSpeed(piles, H):\n\tans = -1\n\tlow = 1\n\thigh = max(piles)\n\twhile (low <= high):\n\t\tK = low + (high - low) // 2\n\t\ttime = 0\n\t\tfor ai in piles:\n\t\ttime += (ai + K - 1) // K\n\t\tif (time <= H):\n\t\t\tans = K\n\t\t\thigh = K - 1\n\t\telse:\n\t\t\tlow = K + 1\n\tprint(ans)", "3198": "def cntDisPairs(arr, N, K):\n\tcntPairs = 0\n\tarr = sorted(arr)\n\ti = 0\n\tj = N - 1\n\twhile (i < j):\n\t\tif (arr[i] + arr[j] == K):\n\t\t\twhile (i < j and arr[i] == arr[i + 1]):\n\t\t\t\ti += 1\n\t\t\twhile (i < j and arr[j] == arr[j - 1]):\n\t\t\t\tj -= 1\n\t\t\tcntPairs += 1\n\t\t\ti += 1\n\t\t\tj -= 1\n\t\telif (arr[i] + arr[j] < K):\n\t\t\ti += 1\n\t\telse:\n\t\t\tj -= 1\n\treturn cntPairs", "3199": "def cntDisPairs(arr, N, K):\n\tcntPairs = 0\n\tcntFre = {}\n\tfor i in arr:\n\t\tif i in cntFre:\n\t\t\tcntFre[i] += 1\n\t\telse:\n\t\t\tcntFre[i] = 1\n\tfor key, value in cntFre.items():\n\t\ti = key\n\t\tif (2 * i == K):\n\t\t\tif (cntFre[i] > 1):\n\t\t\t\tcntPairs += 2\n\t\telse:\n\t\t\tif (cntFre[K - i]):\n\t\t\t\tcntPairs += 1\n\tcntPairs = cntPairs / 2\n\treturn cntPairs", "3234": "def longestSubsequence(N, Q, arr, Queries):\n\tfor i in range(Q):\n\t\tx = Queries[i][0]\n\t\ty = Queries[i][1]\n\t\tarr[x - 1] = y\n\t\tcount = 1\n\t\tfor j in range(1, N):\n\t\t\tif (arr[j] != arr[j - 1]):\n\t\t\t\tcount += 1\n\t\tprint(count, end = ' ')", "3235": "def longestSubsequence(N, Q, arr, Queries):\n\tcount = 1\n\tfor i in range(1, N):\n\t\tif (arr[i] != arr[i - 1]):\n\t\t\tcount += 1\n\tfor i in range(Q):\n\t\tx = Queries[i][0]\n\t\ty = Queries[i][1]\n\t\tif (x > 1):\n\t\t\tif (arr[x - 1] != arr[x - 2]):\n\t\t\t\tcount -= 1\n\t\t\tif (arr[x - 2] != y):\n\t\t\t\tcount += 1\n\t\tif (x < N):\n\t\t\tif (arr[x] != arr[x - 1]):\n\t\t\t\tcount -= 1\n\t\t\tif (y != arr[x]):\n\t\t\t\tcount += 1\n\t\tprint(count, end = ' ')\n\t\tarr[x - 1] = y", "3253": "def sum_i(arr, n):\n\tmp = defaultdict(lambda : [])\n\tfor i in range(n):\n\t\tmp[arr[i]].append(i)\n\tans = [0] * n\n\tfor i in range(n):\n\t\tsum = 0\n\t\tfor it in mp[arr[i]]:\n\t\t\tsum += abs(it - i)\n\t\t\tans[i] = sum\n\tfor i in range(n):\n\t\tprint(ans[i], end = \" \")", "3270": "def rearrangeArray(A, B, N, K):\n\tB.sort(reverse = True)\n\tflag = True\n\tfor i in range(N):\n\t\tif (A[i] + B[i] > K):\n\t\t\tflag = False\n\t\t\tbreak\n\tif (flag == False):\n\t\tprint(\"-1\")\n\telse:\n\t\tfor i in range(N):\n\t\t\tprint(B[i], end = \" \")", "3311": "def isinRange(board):\n N = 9\n for i in range(0, N):\n\tfor j in range(0, N):\n\tif ((board[i][j] <= 0) or\n\t\t(board[i][j] > 9)):\n\t\treturn False\n return True\ndef isValidSudoku(board):\n N = 9\n if (isinRange(board) == False):\n\treturn False\n unique = [False] * (N + 1)\n for i in range(0, N):\n\tfor m in range(0, N + 1):\n\tunique[m] = False\n\tfor j in range(0, N):\n\tZ = board[i][j]\n\tif (unique[Z] == True):\n\t\treturn False\n\tunique[Z] = True\n for i in range(0, N):\n\tfor m in range(0, N + 1):\n\tunique[m] = False\n\tfor j in range(0, N):\n\tZ = board[j][i]\n\tif (unique[Z] == True):\n\t\treturn False\n\tunique[Z] = True\n for i in range(0, N - 2, 3):\n\tfor j in range(0, N - 2, 3):\n\tfor m in range(0, N + 1):\n\t\tunique[m] = False\n\tfor k in range(0, 3):\n\t\tfor l in range(0, 3):\n\t\tX = i + k\n\t\tY = j + l\n\t\tZ = board[X][Y]\n\t\tif (unique[Z] == True):\n\t\t\treturn False\n\t\tunique[Z] = True\n return True", "3332": "def conVowUpp(str):\n\tN = len(str)\n\tstr1 =\"\"\n\tfor i in range(N):\n\t\tif (str[i] == 'a' or str[i] == 'e' or str[i] == 'i' or str[i] == 'o' or str[i] == 'u'):\n\t\t\tc = (str[i]).upper()\n\t\t\tstr1 += c\n\t\telse:\n\t\t\tstr1 += str[i]\n\tprint(str1)", "3337": "def zvalue(nums):\n\tm = max(nums)\n\tcnt = 0\n\tfor i in range(0, m + 1, 1):\n\t\tcnt = 0\n\t\tfor j in range(0, len(nums), 1):\n\t\t\tif (nums[j] >= i):\n\t\t\t\tcnt += 1\n\t\tif (cnt == i):\n\t\t\treturn i\n\treturn -1", "3345": "def palindrome(a, i, j):\n\twhile(i < j):\n\t\tif (a[i] != a[j]):\n\t\t\treturn False\n\t\ti += 1\n\t\tj -= 1\n\treturn True\ndef findSubArray(arr, k):\n\tn = len(arr)\n\tfor i in range(n - k + 1):\n\t\tif (palindrome(arr, i, i + k - 1)):\n\t\t\treturn i\n\treturn -1", "3346": "def helper(mid):\n\tcnt = 0;\n\tfor i in mp:\n\t\ttemp = mp[i]\n\t\twhile (temp >= mid):\n\t\t\ttemp -= mid\n\t\t\tcnt += 1\n\treturn cnt >= N\ndef findMaximumDays(arr):\n\tfor i in range(P):\n\t\tmp[arr[i]] = mp.get(arr[i], 0) + 1\n\tstart = 0\n\tend = P\n\tans = 0\n\twhile (start <= end):\n\t\tmid = start + ((end - start) // 2)\n\t\tif (mid != 0 and helper(mid)):\n\t\t\tans = mid\n\t\t\tstart = mid + 1\n\t\telif (mid == 0):\n\t\t\tstart = mid + 1\n\t\telse:\n\t\t\tend = mid - 1\n\treturn ans", "3374": "def countSubarrays(a, n, k):\n\tans = 0\n\tpref = []\n\tpref.append(0)\n\tfor i in range(n):\n\t\tpref.append((a[i] + pref[i]) % k)\n\tfor i in range(1, n + 1, 1):\n\t\tfor j in range(i, n + 1, 1):\n\t\t\tif ((pref[j] - pref[i - 1] + k) % k == j - i + 1):\n\t\t\t\tans += 1\n\tprint(ans, end = ' ')", "3375": "def countSubarrays(a, n, k):\n\tcnt = {}\n\tans = 0\n\tpref = []\n\tpref.append(0)\n\tfor i in range(n):\n\t\tpref.append((a[i] + pref[i]) % k)\n\tcnt[0] = 1\n\tfor i in range(1, n + 1):\n\t\tremIdx = i - k\n\t\tif (remIdx >= 0):\n\t\t\tif ((pref[remIdx] - remIdx % k + k) % k in cnt):\n\t\t\t\tcnt[(pref[remIdx] - remIdx % k + k) % k] -= 1\n\t\t\telse:\n\t\t\t\tcnt[(pref[remIdx] - remIdx % k + k) % k] = -1\n\t\tif (pref[i] - i % k + k) % k in cnt:\n\t\t\tans += cnt[(pref[i] - i % k + k) % k]\n\t\tif (pref[i] - i % k + k) % k in cnt:\n\t\t\tcnt[(pref[i] - i % k + k) % k] += 1\n\t\telse:\n\t\t\tcnt[(pref[i] - i % k + k) % k] = 1\n\tprint(ans, end = ' ')", "3398": "def countRows(mat):\n\tn = len(mat)\n\tm = len(mat[0])\n\tcount = 0\n\ttotalSum = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\ttotalSum += mat[i][j]\n\tfor i in range(n):\n\t\tcurrSum = 0\n\t\tfor j in range(m):\n\t\t\tcurrSum += mat[i][j]\n\t\tif (currSum > totalSum - currSum):\n\t\t\tcount += 1\n\tprint(count)", "3417": "def isCrossed(path):\n\tif (len(path) == 0):\n\t\treturn bool(False)\n\tans = bool(False)\n\tSet = set()\n\tx, y = 0, 0\n\tSet.add((x, y))\n\tfor i in range(len(path)):\n\t\tif (path[i] == 'N'):\n\t\t\tSet.add((x, y))\n\t\t\ty = y + 1\n\t\tif (path[i] == 'S'):\n\t\t\tSet.add((x, y))\n\t\t\ty = y - 1\n\t\tif (path[i] == 'E'):\n\t\t\tSet.add((x, y))\n\t\t\tx = x + 1\n\t\tif (path[i] == 'W'):\n\t\t\tSet.add((x, y))\n\t\t\tx = x - 1\n\t\tif (x, y) in Set:\n\t\t\tans = bool(True)\n\t\t\tbreak\n\tif (ans):\n\t\tprint(\"Crossed\")\n\telse:\n\t\tprint(\"Not Crossed\")", "3427": "def maxWidth(N, M, cost, s):\n\tadj = [[] for i in range(N)]\n\tfor i in range(M):\n\t\tadj[s[i][0]].append(s[i][1])\n\tresult = 0\n\tq = deque()\n\tq.append(0)\n\twhile (len(q) > 0):\n\t\tcount = len(q)\n\t\tresult = max(count, result)\n\t\twhile (count > 0):\n\t\t\ttemp = q.popleft()\n\t\t\tfor i in adj[temp]:\n\t\t\t\tq.append(i)\n\t\t\tcount -= 1\n\treturn result", "3463": "def SieveOfEratosthenes():\n\tglobal isPrime\n\tp = 2\n\twhile p * p <= MAX:\n\t\tif (isPrime[p] == True):\n\t\t\tfor i in range (p * p, MAX + 1, p):\n\t\t\t\tisPrime[i] = False\n\t\tp += 1\n\tfor p in range (2, MAX + 1):\n\t\tif (isPrime[p]):\n\t\t\tprimes.append(p)\ndef prime_search(primes, diff):\n\tlow = 0\n\thigh = len(primes) - 1\n\twhile (low <= high):\n\t\tmid = (low + high) // 2\n\t\tif (primes[mid] == diff):\n\t\t\treturn primes[mid]\n\t\telif (primes[mid] < diff):\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\tres = primes[mid]\n\t\t\thigh = mid - 1\n\treturn res\ndef minCost(arr, n):\n\tSieveOfEratosthenes()\n\tres = 0\n\tfor i in range (1, n):\n\t\tif (arr[i] < arr[i - 1]):\n\t\t\tdiff = arr[i - 1] - arr[i]\n\t\t\tclosest_prime = prime_search(primes, diff)\n\t\t\tres += closest_prime\n\t\t\tarr[i] += closest_prime\n\treturn res", "3464": "def lexico_smallest(s1, s2):\n\tM = {}\n\tS = []\n\tpr = {}\n\tfor i in range(len(s1)):\n\t\tif s1[i] not in M:\n\t\t\tM[s1[i]] = 1\n\t\telse:\n\t\t\tM[s1[i]] += 1\n\t\tS.append(s1[i])\n\tS = list(set(S))\n\tS.sort()\n\tfor i in range(len(s2)):\n\t\tif s2[i] in M:\n\t\t\tM[s2[i]] -= 1\n\tc = s2[0]\n\tindex = 0\n\tres = \"\"\n\tfor x in S:\n\t\tif(x != c):\n\t\t\tfor i in range(1, M[x] + 1):\n\t\t\t\tres += x\n\t\telse:\n\t\t\tj = 0\n\t\t\tindex = len(res)\n\t\t\twhile(s2[j] == x):\n\t\t\t\tj += 1\n\t\t\tif(s2[j] < c):\n\t\t\t\tres += s2\n\t\t\t\tfor i in range(1, M[x] + 1):\n\t\t\t\t\tres += x\n\t\t\telse:\n\t\t\t\tfor i in range(1, M[x] + 1):\n\t\t\t\t\tres += x\n\t\t\t\tindex += M[x]\n\t\t\t\tres += s2\t\n\tpr[res] = index\n\treturn pr\ndef lexico_largest(s1, s2):\n\tPr = dict(lexico_smallest(s1, s2))\n\td1 = \"\"\n\tkey = [*Pr][0]\n\tfor i in range(Pr.get(key) - 1, -1, -1):\n\t\td1 += key[i]\n\td2 = \"\"\n\tfor i in range(len(key) - 1, Pr[key] + len(s2) - 1, -1):\n\t\td2 += key[i]\n\tres = d2 + s2 + d1\n\treturn res", "3468": "def addEdge(v, x, y):\n\tv[x].append(y)\n\tv[y].append(x)\ndef dfs(tree, temp, ancestor, u, parent, k):\n\ttemp.append(u)\n\tfor i in tree[u]:\n\t\tif (i == parent):\n\t\t\tcontinue\n\t\tdfs(tree, temp, ancestor, i, u, k)\n\ttemp.pop()\n\tif (len(temp) < k):\n\t\tancestor[u] = -1\n\telse:\n\t\tancestor[u] = temp[len(temp) - k]\ndef KthAncestor(N, K, E, edges):\n\ttree = [[] for i in range(N + 1)]\n\tfor i in range(E):\n\t\taddEdge(tree, edges[i][0], edges[i][1])\n\ttemp = []\n\tancestor = [0] * (N + 1)\n\tdfs(tree, temp, ancestor, 1, 0, K)\n\tfor i in range(1, N + 1):\n\t\tprint(ancestor[i], end = \" \")", "3471": "def build(sum, a, l, r, rt):\n\tif (l == r):\n\t\tsum[rt] = a[l - 1]\n\t\treturn\n\tm = (l + r) >> 1\n\tbuild(sum, a, l, m, rt << 1)\n\tbuild(sum, a, m + 1, r, rt << 1 1)\ndef pushDown(sum, add, rt, ln, rn):\n\tif (add[rt]):\n\t\tadd[rt << 1] += add[rt]\n\t\tadd[rt << 1 1] += add[rt]\n\t\tsum[rt << 1] += add[rt] * ln\n\t\tsum[rt << 1 1] += add[rt] * rn\n\t\tadd[rt] = 0\ndef update(sum, add, L, R, C, l, r, rt):\n\tif (L <= l and r <= R):\n\t\tsum[rt] += C * (r - l + 1)\n\t\tadd[rt] += C\n\t\treturn\n\tm = (l + r) >> 1\n\tpushDown(sum, add, rt, m - l + 1, r - m)\n\tif (L <= m):\n\t\tupdate(sum, add, L, R, C, l, m, rt << 1)\n\tif (R > m):\n\t\tupdate(sum, add, L, R, C, m + 1, r, rt << 1 1)\ndef queryy(sum, add, L, R, l, r, rt):\n\tif (L <= l and r <= R):\n\t\treturn sum[rt]\n\tm = (l + r) >> 1\n\tpushDown(sum, add, rt, m - l + 1, r - m)\n\tans = 0\n\tif (L <= m):\n\t\tans += queryy(sum, add, L, R, l, m, rt << 1)\n\tif (R > m):\n\t\tans += queryy(sum, add, L, R, m + 1,\n\t\t\t\t\tr, (rt << 1 1))\n\treturn ans\ndef sequenceMaintenance(n, q, a, b, m):\n\ta = sorted(a)\n\tsum = [0] * (4 * n)\n\tadd = [0] * (4 * n)\n\tans = []\n\tbuild(sum, a, 1, n, 1)\n\tfor i in range(q):\n\t\tl = 1\n\t\tr = n\n\t\tpos = -1\n\t\twhile (l <= r):\n\t\t\tm = (l + r) >> 1\n\t\t\tif (queryy(sum, add, m, m, 1, n, 1) >= b[i]):\n\t\t\t\tr = m - 1\n\t\t\t\tpos = m\n\t\t\telse:\n\t\t\t\tl = m + 1\n\t\tif (pos == -1):\n\t\t\tans.append(0)\n\t\telse:\n\t\t\tans.append(n - pos + 1)\n\t\t\tupdate(sum, add, pos, n, -m, 1, n, 1)\n\tfor i in ans:\n\t\tprint(i, end = \" \")", "3487": "def count(s):\n\tcnt = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tcnt += 1\n\tif (cnt % 3 != 0):\n\t\treturn 0\n\tres = 0\n\tk = cnt // 3\n\tsum = 0\n\tmp = {}\n\tfor i in range(len(s)):\n\t\tif s[i] == '0':\n\t\t\tsum += 1\n\t\tif (sum == 2 * k and k in mp and\n\t\t\ti < len(s) - 1 and i > 0):\n\t\t\tres += mp[k]\n\t\tif sum in mp:\n\t\t\tmp[sum] += 1\n\t\telse:\n\t\t\tmp[sum] = 1\n\treturn res", "3488": "def splitstring(s):\n\tn = len(s)\n\tzeros = 0\n\tfor i in range(n):\n\t\tif s[i] == '0':\n\t\t\tzeros += 1\n\tif zeros % 3 != 0:\n\t\treturn 0\n\tif zeros == 0:\n\t\treturn ((n - 1) *\n\t\t\t\t(n - 2)) // 2\n\tzerosInEachSubstring = zeros // 3\n\twaysOfFirstCut, waysOfSecondCut = 0, 0\n\tcount = 0\n\tfor i in range(n):", "3495": "def check(s, k):\n\tn = len(s)\n\tfor i in range(k):\n\t\tfor j in range(i, n, k):\n\t\t\tif (s[i] != s[j]):\n\t\t\t\treturn False\n\tc = 0\n\tfor i in range(k):\n\t\tif (s[i] == '0'):\n\t\t\tc += 1\n\t\telse:\n\t\t\tc -= 1\n\tif (c == 0):\n\t\treturn True\n\telse:\n\t\treturn False", "3503": "def addEdge(a, b):\n\tglobal tree\n\ttree[a].append(b)\n\ttree[b].append(a)\ndef dfs(x):\n\tglobal vis\n\tglobal subtreeSize\n\tglobal tree\n\tvis[x] = True\n\tsubtreeSize[x] = 1\n\tfor i in tree[x]:\n\t\tif (vis[i] == False):\n\t\t\tdfs(i)\n\t\t\tsubtreeSize[x] += subtreeSize[i]\ndef countPairs(a, b):\n\tglobal subtreeSize\n\tsub = min(subtreeSize[a], subtreeSize[b])\n\tprint(sub * (n - sub))", "3516": "def revNum(N):\n\tx = 0\n\twhile (N):\n\t\tx = x * 10 + N % 10\n\t\tN = N // 10\n\treturn x\ndef ctNonPalin(arr, N):\n\tRes = 0\n\tfor i in range(N):\n\t\tx = revNum(arr[i])\n\t\tif (x == arr[i]):\n\t\t\tcontinue\n\t\telse:\n\t\t\tRes += (arr[i] % 10 == N % 10)\n\treturn Res", "3520": "def isSame(str, n):\n\tmp = defaultdict(lambda : 0)\n\tfor i in range(len(str)):\n\t\tmp[ord(str[i]) - ord('a')] += 1\n\tfor it in mp.keys():\n\t\tif(mp[it] >= n):\n\t\t\treturn True\n\treturn False", "3531": "def canTransform(str1, str2):\n\ts1 = \"\"\n\ts2 = \"\"\n\tfor c in str1:\n\t\tif (c != 'C'):\n\t\t\ts1 += c\n\tfor c in str2:\n\t\tif (c != 'C'):\n\t\t\ts2 += c\n\tif (s1 != s2):\n\t\treturn False\n\ti = 0\n\tj = 0\n\tn = len(str1)\n\twhile (i < n and j < n):\n\t\tif (str1[i] == 'C'):\n\t\t\ti += 1\n\t\telif (str2[j] == 'C'):\n\t\t\tj += 1\n\t\telse:\n\t\t\tif ((str1[i] == 'A' and i < j) or\n\t\t\t\t(str1[i] == 'B' and i > j)):\n\t\t\t\treturn False\n\t\t\ti += 1\n\t\t\tj += 1\n\treturn True", "3540": "def func(a ,b , c , x):\n\treturn a * x * x + b * x + c\ndef findRoot( a, b, c, low, high):\n\tx = -1\n\twhile abs(high - low) > eps:\n\t\tx = (low + high) / 2\n\t\tif (func(a, b, c, low) *\n\t\t\tfunc(a, b, c, x) <= 0):\n\t\t\thigh = x\n\t\telse:\n\t\t\tlow = x\n\treturn x\ndef solve(a, b, c, A, B):\n\tif (func(a, b, c, A) *\n\t\tfunc(a, b, c, B) > 0):\n\t\tprint(\"No solution\")\n\telse:\n\t\tprint(\"{:.4f}\".format(findRoot( a, b, c, A, B)))", "3550": "def hasCoprimePair(arr, n):\n\tfor i in range(n - 1):\n\t\tfor j in range(i + 1, n):\n\t\t\tif (math.gcd(arr[i], arr[j]) == 1):\n\t\t\t\treturn True\n\treturn False", "3555": "def findPermutation(arr, N):\n\tpos = len(arr) + 1\n\tif(pos > N):\n\t\treturn 1\n\tres = 0\n\tfor i in range(1, N + 1):\n\t\tif(i not in arr):\n\t\t\tif(i % pos == 0 or pos % i == 0):\n\t\t\t\tarr.add(i)\n\t\t\t\tres += findPermutation(arr, N)\n\t\t\t\tarr.remove(i)\n\treturn res", "3562": "def solve(arr, n, X, Y):\n\tdiff = Y - X\n\tfor i in range(n):\n\t\tif(arr[i] != 1):\n\t\t\tdiff = diff % (arr[i] - 1)\n\tif(diff == 0):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "3564": "def Numberofways(n):\n\tcount = 0\n\tfor a in range(1, n):\n\t\tfor b in range(1, n):\n\t\t\tc = n - (a + b)\n\t\t\tif(a < b + c and b < a + c and c < a + b):\n\t\t\t\tcount += 1\n\treturn count;", "3567": "def maxsubstringLength(S, N):\n\tarr = [0] * N\n\tfor i in range(N):\n\t\tif(S[i] == 'a' or S[i] == 'e' or S[i] == 'i' or S[i] == 'o' or S[i] == 'u'):\n\t\t\tarr[i] = 1\n\t\telse:\n\t\t\tarr[i] = -1\n\tmaxLen = 0\n\tcurr_sum = 0\n\thash = {}\n\tfor i in range(N):\n\t\tcurr_sum += arr[i]\n\t\tif(curr_sum == 0):\n\t\t\tmaxLen = max(maxLen, i + 1)\n\t\tif(curr_sum in hash.keys()):\n\t\t\tmaxLen = max(maxLen, i - hash[curr_sum])\n\t\telse:\n\t\t\thash[curr_sum] = i\n\treturn maxLen", "3584": "def findMaximumSum(a, n):\n\tprev_smaller = findPrevious(a, n)\n\tnext_smaller = findNext(a, n)\n\tmax_value = 0\n\tfor i in range(n):\n\t\tmax_value = max(max_value, a[i] *\n\t\t\t\t\t(next_smaller[i] - prev_smaller[i] - 1))\n\treturn max_value\ndef findPrevious(a, n):\n\tps = [0] * n\n\tps[0] = -1\n\tstack = []\n\tstack.append(0)\n\tfor i in range(1, n):\n\t\twhile len(stack) > 0 and a[stack[-1]] >= a[i]:\n\t\t\tstack.pop()\n\t\tps[i] = stack[-1] if len(stack) > 0 else -1\n\t\tstack.append(i)\n\treturn ps\ndef findNext(a, n):\n\tns = [0] * n\n\tns[n - 1] = n\n\tstack = []\n\tstack.append(n - 1)\n\tfor i in range(n - 2, -1, -1):\n\t\twhile (len(stack) > 0 and a[stack[-1]] >= a[i]):\n\t\t\tstack.pop()\n\t\tns[i] = stack[-1] if len(stack) > 0 else n\n\t\tstack.append(i)\n\treturn ns", "3601": "def possible(mid, a):\n\tn = len(a);\n\ttotal = (n * (n - 1)) // 2;\n\tneed = (total + 1) // 2;\n\tcount = 0;\n\tstart = 0; end = 1;\n\twhile (end < n):\n\t\tif (a[end] - a[start] <= mid):\n\t\t\tend += 1;\n\t\telse:\n\t\t\tcount += (end - start - 1);\n\t\t\tstart += 1;\n\tif (end == n and start < end and a[end - 1] - a[start] <= mid):\n\t\tt = end - start - 1;\n\t\tcount += (t * (t + 1) // 2);\n\tif (count >= need):\n\t\treturn True;\n\telse:\n\t\treturn False;\ndef findMedian(a):\n\tn = len(a);\n\tlow = 0; high = a[n - 1] - a[0];\n\twhile (low <= high):\n\t\tmid = (low + high) // 2;\n\t\tif (possible(mid, a)):\n\t\t\thigh = mid - 1;\n\t\telse :\n\t\t\tlow = mid + 1;\n\treturn high + 1;", "3605": "def FindMinimumDistance():\n\tglobal x, y, r, c\n\tq = []\n\tq.append([x, y])\n\tmat[x][y] = 0\n\twhile(len(q) != 0):\n\t\tx = q[0][0]\n\t\ty = q[0][1]\n\t\tq.pop(0)\n\t\tfor i in range(8):\n\t\t\ta = x + dx[i]\n\t\t\tb = y + dy[i]\n\t\t\tif(a < 0 or a >= r or b >= c or b < 0):\n\t\t\t\tcontinue\n\t\t\tif(mat[a][b] == 0):\n\t\t\t\tmat[a][b] = mat[x][y] + 1\n\t\t\t\tq.append([a, b])", "3629": "def addEdge(u, v):\n\tadj[u].append(v)\n\tadj[v].append(u)\ndef dfs1(cur, par):\n\tfor u in adj[cur]:\n\t\tif (u != par):\n\t\t\tdfs1(u, cur)\n\t\t\theight[cur] = max(height[cur], height[u])\n\theight[cur] += 1\ndef dfs2(cur, par):\n\tmax1 = 0\n\tmax2 = 0\n\tfor u in adj[cur]:\n\t\tif (u != par):\n\t\t\tif (height[u] >= max1):\n\t\t\t\tmax2 = max1\n\t\t\t\tmax1 = height[u]\n\t\t\telif (height[u] > max2):\n\t\t\t\tmax2 = height[u]\n\tsum = 0\n\tfor u in adj[cur]:\n\t\tif (u != par):\n\t\t\tsum = (max2 if (max1 == height[u]) else max1)\n\t\t\tif (max1 == height[u]):\n\t\t\t\tdist[u] = 1 + max(1 + max2, dist[cur])\n\t\t\telse:\n\t\t\t\tdist[u] = 1 + max(1 + max1, dist[cur])\n\t\t\tdfs2(u, cur)", "3644": "def countPairs(N, arr):\n\tcount = 0\n\tfor i in range(N):\n\t\tif (i == arr[arr[i] - 1] - 1):\n\t\t\tcount += 1\n\tprint(count // 2)", "3664": "def minOperations(S, K):\n\tans = 0\n\tfor i in range(K):\n\t\tzero, one = 0, 0\n\t\tfor j in range(i, len(S), K):\n\t\t\tif(S[j] == '0'):\n\t\t\t\tzero += 1\n\t\t\telse:\n\t\t\t\tone += 1\n\t\tans += min(zero, one)\n\treturn ans", "3678": "def UniversalSubset(A, B):\n\tn1 = len(A)\n\tn2 = len(B)\n\tres = []\n\tA_freq = [[0 for x in range(26)] for y in range(n1)]\n\tfor i in range(n1):\n\t\tfor j in range(len(A[i])):\n\t\t\tA_freq[i][ord(A[i][j]) - ord('a')] += 1\n\tB_freq = [0] * 26\n\tfor i in range(n2):\n\t\tarr = [0] * 26\n\t\tfor j in range(len(B[i])):\n\t\t\tarr[ord(B[i][j]) - ord('a')] += 1\n\t\t\tB_freq[ord(B[i][j]) - ord('a')] = max(\n\t\t\tB_freq[ord(B[i][j]) - ord('a')],\n\t\t\tarr[ord(B[i][j]) - ord('a')])\n\tfor i in range(n1):\n\t\tflag = 0\n\t\tfor j in range(26):\n\t\t\tif(A_freq[i][j] < B_freq[j]):\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\tif(flag == 0):\n\t\t\tres.append(A[i])\n\tif(len(res)):\n\t\tfor i in range(len(res)):\n\t\t\tfor j in range(len(res[i])):\n\t\t\t\tprint(res[i][j], end = \"\")\n\telse:\n\t\tprint(-1, end = \"\")", "3692": "def findPair(a, n):\n\tmin_dist = sys.maxsize\n\tindex_a = -1\n\tindex_b = -1\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\tif (j - i < min_dist):\n\t\t\t\tif ((a[i] % a[j] == 0) or\n\t\t\t\t\t(a[j] % a[i] == 0)):\n\t\t\t\t\tmin_dist = j - i\n\t\t\t\t\tindex_a = i\n\t\t\t\t\tindex_b = j\n\tif (index_a == -1):\n\t\tprint(\"-1\")\n\telse:\n\t\tprint(\"(\", a[index_a], \", \", a[index_b], \")\")", "3704": "def printNum(L, R):\n\tfor i in range(L, R + 1):\n\t\ttemp = i\n\t\tc = 10\n\t\tflag = 0\n\t\twhile (temp > 0):\n\t\t\tif (temp % 10 >= c):\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tc = temp % 10\n\t\t\ttemp //= 10\n\t\tif (flag == 0):\n\t\t\tprint(i, end = \" \")", "3742": "def findMissing(arr, left, right, diff):\n\tif (right <= left):\n\t\treturn sys.maxsize\n\tmid = left + (right - left) // 2\n\tif (arr[mid + 1] - arr[mid] != diff):\n\t\treturn (arr[mid] + diff)\n\tif (mid > 0 and arr[mid] - arr[mid - 1] != diff):\n\t\treturn (arr[mid - 1] + diff)\n\tif (arr[mid] == arr[0] + mid * diff):\n\t\treturn findMissing(arr, mid + 1, right, diff)\n\treturn findMissing(arr, left, mid - 1, diff)\ndef missingElement(arr, n):\n\tarr.sort()\n\tdiff = (arr[n - 1] - arr[0]) // n\n\treturn findMissing(arr, 0, n - 1, diff)", "3743": "def missingElement(arr, n):\n\tmax_ele = arr[0]\n\tmin_ele = arr[0]\n\tx = 0\n\td = 0\n\tfor i in range(n):\n\t\tif (arr[i] > max_ele):\n\t\t\tmax_ele = arr[i]\n\t\tif (arr[i] < min_ele):\n\t\t\tmin_ele = arr[i]\n\td = (max_ele - min_ele) // n\n\tfor i in range(n):\n\t\tx = x ^ arr[i]\n\tfor i in range(n + 1):\n\t\tx = x ^ (min_ele + (i * d))\n\treturn x", "3752": "def power(x, y):\n\tif (y == 0):\n\t\treturn 1;\n\ttemp = power(x, y // 2);\n\tif (y % 2 == 0):\n\t\treturn temp * temp;\n\telse:\n\t\treturn x * temp * temp;\ndef nthRootSearch(low, high, N, K):\n\tif (low <= high):\n\t\tmid = (low + high) // 2;\n\t\tif ((power(mid, K) <= N) and\n\t\t\t(power(mid + 1, K) > N)):\n\t\t\treturn mid;\n\t\telif (power(mid, K) < N):\n\t\t\treturn nthRootSearch(mid + 1, high, N, K);\n\t\telse:\n\t\t\treturn nthRootSearch(low, mid - 1, N, K);\n\treturn low;", "3755": "def get_subset_count(arr, K, N):\n\tarr.sort()\n\tleft = 0;\n\tright = N - 1;\n\tans = 0;\n\twhile (left <= right):\n\t\tif (arr[left] + arr[right] < K):\n\t\t\tans += 1 << (right - left);\n\t\t\tleft += 1;\n\t\telse:\n\t\t\tright -= 1;\n\treturn ans;", "3765": "def minMaxDiff(arr, n, k):\n\tmax_adj_dif = float('-inf');\n\tfor i in range(n - 1):\n\t\tmax_adj_dif = max(max_adj_dif,\n\t\t\t\t\t\tabs(arr[i] - arr[i + 1]));\n\tif (max_adj_dif == 0):\n\t\treturn 0;\n\tbest = 1;\n\tworst = max_adj_dif;\n\twhile (best < worst):\n\t\tmid = (best + worst) // 2;\n\t\trequired = 0\n\t\tfor i in range(n - 1):\n\t\t\trequired += (abs(arr[i] - arr[i + 1]) - 1) // mid\n\t\tif (required > k):\n\t\t\tbest = mid + 1;\n\t\telse:\n\t\t\tworst = mid\n\treturn worst", "3773": "def checkMin(arr, n):\n\tsmallest = math.inf\n\tsecondSmallest = math.inf\n\tfor i in range(n):\n\t\tif(arr[i] < smallest):\n\t\t\tsecondSmallest = smallest\n\t\t\tsmallest = arr[i]\n\t\telif(arr[i] < secondSmallest):\n\t\t\tsecondSmallest = arr[i]\n\tif(2 * smallest <= secondSmallest):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "3798": "def createHash(hash, maxElement):\n\tprev = 0\n\tcurr = 1\n\thash.add(prev)\n\thash.add(curr)\n\twhile (curr <= maxElement):\n\t\ttemp = curr + prev\n\t\thash.add(temp)\n\t\tprev = curr\n\t\tcurr = temp\ndef fibonacci(arr, n):\n\tmax_val = max(arr)\n\thash = set()\n\tcreateHash(hash, max_val)\n\tminimum = sys.maxsize\n\tmaximum = -sys.maxsize-1\n\tfor i in range(n):\n\t\tif (arr[i] in hash):\n\t\t\tminimum = min(minimum, arr[i])\n\t\t\tmaximum = max(maximum, arr[i])\n\tprint(minimum,end = \", \")\n\tprint(maximum)", "3814": "def isValidLen(s, lenn, k):\n\tn = len(s)\n\tmp = dict()\n\tright = 0\n\twhile (right < lenn):\n\t\tmp[s[right]] = mp.get(s[right], 0) + 1\n\t\tright += 1\n\tif (len(mp) <= k):\n\t\treturn True\n\twhile (right < n):\n\t\tmp[s[right]] = mp.get(s[right], 0) + 1\n\t\tmp[s[right - lenn]] -= 1\n\t\tif (mp[s[right - lenn]] == 0):\n\t\t\tdel mp[s[right - lenn]]\n\t\tif (len(mp) <= k):\n\t\t\treturn True\n\t\tright += 1\n\treturn len(mp)<= k\ndef maxLenSubStr(s, k):\n\tuni = dict()\n\tfor x in s:\n\t\tuni[x] = 1\n\tif (len(uni) < k):\n\t\treturn -1\n\tn = len(s)\n\tlo = -1\n\thi = n + 1\n\twhile (hi - lo > 1):\n\t\tmid = lo + hi >> 1\n\t\tif (isValidLen(s, mid, k)):\n\t\t\tlo = mid\n\t\telse:\n\t\t\thi = mid\n\treturn lo", "3822": "def isSquarePossible(arr, n, l) :\n\tcnt = 0\n\tfor i in range(n) :\n\t\tif arr[i] >= l :\n\t\t\tcnt += 1\n\t\tif cnt >= l :\n\t\t\treturn True\n\treturn False\ndef maxArea(arr, n) :\n\tl , r = 0, n\n\tlen = 0\n\twhile l <= r :\n\t\tm = l + ((r - l) // 2)\n\t\tif isSquarePossible(arr, n, m) :\n\t\t\tlen = m\n\t\t\tl = m + 1\n\t\telse :\n\t\t\tr = m - 1\n\treturn (len * len)", "3825": "def kOverlap(pairs: list, k):\n\tvec = list()\n\tfor i in range(len(pairs)):\n\t\tvec.append((pairs[0], -1))\n\t\tvec.append((pairs[1], 1))\n\tvec.sort(key = lambda a: a[0])\n\tst = list()\n\tfor i in range(len(vec)):\n\t\tcur = vec[i]\n\t\tif cur[1] == -1:\n\t\t\tst.append(cur)\n\t\telse:\n\t\t\tst.pop()\n\t\tif len(st) >= k:\n\t\t\treturn True\n\treturn False", "3829": "def insertNames(arr, n) :\n\tstring = set();\n\tfor i in range(n) :\n\t\tif arr[i] not in string :\n\t\t\tprint(\"No\");\n\t\t\tstring.add(arr[i]);\n\t\telse :\n\t\t\tprint(\"Yes\");", "3871": "def countLessThan(arr, n, key):\n\tl = 0\n\tr = n - 1\n\tindex = -1\n\twhile (l <= r):\n\t\tm = (l + r) // 2\n\t\tif (arr[m] < key) :\n\t\t\tl = m + 1\n\t\t\tindex = m\n\t\telse :\n\t\t\tr = m - 1\n\treturn (index + 1)\ndef countGreaterThan(arr, n, key):\n\tl = 0\n\tr = n - 1\n\tindex = -1\n\twhile (l <= r) :\n\t\tm = (l + r) // 2\n\t\tif (arr[m] <= key) :\n\t\t\tl = m + 1\n\t\telse :\n\t\t\tr = m - 1\n\t\t\tindex = m\n\tif (index == -1):\n\t\treturn 0\n\treturn (n - index)\ndef countTriplets(n, a, b, c):\n\ta.sort\n\tb.sort()\n\tc.sort()\n\tcount = 0\n\tfor i in range(n):\n\t\tcurrent = b[i]\n\t\ta_index = -1\n\t\tc_index = -1\n\t\tlow = countLessThan(a, n, current)\n\t\thigh = countGreaterThan(c, n, current)\n\t\tcount += (low * high)\n\treturn count", "3885": "def Printksubstring(str1, n, k):\n\ttotal = int((n * (n + 1)) / 2)\n\tif (k > total):\n\t\tprint(\"-1\")\n\t\treturn\n\tsubstring = [0 for i in range(n + 1)]\n\tsubstring[0] = 0\n\ttemp = n\n\tfor i in range(1, n + 1, 1):\n\t\tsubstring[i] = substring[i - 1] + temp\n\t\ttemp -= 1\n\tl = 1\n\th = n\n\tstart = 0\n\twhile (l <= h):\n\t\tm = int((l + h) / 2)\n\t\tif (substring[m] > k):\n\t\t\tstart = m\n\t\t\th = m - 1\n\t\telif (substring[m] < k):\n\t\t\tl = m + 1\n\t\telse:\n\t\t\tstart = m\n\t\t\tbreak\n\tend = n - (substring[start] - k)\n\tfor i in range(start - 1, end):\n\t\tprint(str1[i], end = \"\")", "3932": "def LowerInsertionPoint(arr, n, X) :\n\tif (X < arr[0]) :\n\t\treturn 0;\n\telif (X > arr[n - 1]) :\n\t\treturn n\n\tlowerPnt = 0\n\ti = 1\n\twhile (i < n and arr[i] < X) :\n\t\tlowerPnt = i\n\t\ti = i * 2\n\twhile (lowerPnt < n and arr[lowerPnt] < X) :\n\t\tlowerPnt += 1\n\treturn lowerPnt", "3967": "def LongestFibSubseq(A, n):\n\tS = set(A)\n\tmaxLen = 0\n\tfor i in range(0, n):\n\t\tfor j in range(i + 1, n):\n\t\t\tx = A[j]\n\t\t\ty = A[i] + A[j]\n\t\t\tlength = 2\n\t\t\twhile y in S:\n\t\t\t\tz = x + y\n\t\t\t\tx = y\n\t\t\t\ty = z\n\t\t\t\tlength += 1\n\t\t\t\tmaxLen = max(maxLen, length)\n\treturn maxLen if maxLen >= 3 else 0", "4039": "def getCount(M, N):\n\tcount = 0;\n\tif (M == 1):\n\t\treturn N;\n\tif (N == 1):\n\t\treturn M;\n\tif (N > M):\n\t\tfor i in range(1, M + 1):\n\t\t\tnumerator = N * i - N + M - i;\n\t\t\tdenominator = M - 1;\n\t\t\tif (numerator % denominator == 0):\n\t\t\t\tj = numerator / denominator;\n\t\t\t\tif (j >= 1 and j <= N):\n\t\t\t\t\tcount += 1;\n\telse:\n\t\tfor j in range(1, N + 1):\n\t\t\tnumerator = M * j - M + N - j;\n\t\t\tdenominator = N - 1;\n\t\t\tif (numerator % denominator == 0):\n\t\t\t\ti = numerator / denominator;\n\t\t\t\tif (i >= 1 and i <= M):\n\t\t\t\t\tcount += 1;\n\treturn count;", "4048": "def swapElement(arr1, arr2, n) :\n\twrongIdx = 0;\n\tfor i in range(1, n) :\n\t\tif (arr1[i] < arr1[i - 1]) :\n\t\t\twrongIdx = i\n\tmaximum = -(sys.maxsize - 1)\n\tmaxIdx = -1\n\tres = False\n\tfor i in range(n) :\n\t\tif (arr2[i] > maximum and arr2[i] >= arr1[wrongIdx - 1]) :\n\t\t\tif (wrongIdx + 1 <= n - 1 and arr2[i] <= arr1[wrongIdx + 1]) :\n\t\t\t\tmaximum = arr2[i]\n\t\t\t\tmaxIdx = i\n\t\t\t\tres = True\n\tif (res) :\n\t\t(arr1[wrongIdx], arr2[maxIdx]) = (arr2[maxIdx], arr1[wrongIdx])\n\treturn res\ndef getSortedArray(arr1, arr2, n) :\n\tif (swapElement(arr1, arr2, n)) :\n\t\tfor i in range(n) :\n\t\t\tprint(arr1[i], end = \" \")\n\telse :\n\t\tprint(\"Not Possible\")", "4052": "def costToBalance(s):\n\tif (len(s) == 0):\n\t\tprint(0)\n\tans = 0", "4079": "def middleOfThree(a, b, c):\n def middleOfThree(a, b, c):\n\tif ((a < b and b < c) or (c < b and b < a)) :\n\t\treturn b;\n\tif ((b < a and a < c) or (c < a and a < b)) :\n\t\treturn a;\n\telse :\n\t\treturn c\ndef middleOfThree(a, b, c):\n\tif ((a < b and b < c) or (c < b and b < a)) :\n\t\treturn b;\n\tif ((b < a and a < c) or (c < a and a < b)) :\n\t\treturn a;\n\telse :\n\t\treturn c", "4080": "def middleOfThree(a, b, c) :\n\tif a > b :\n\t\tif (b > c):\n\t\t\treturn b\n\t\telif (a > c) :\n\t\t\treturn c\n\t\telse :\n\t\t\treturn a\n\telse:\n\t\tif (a > c) :\n\t\t\treturn a\n\t\telif (b > c) :\n\t\t\treturn c\n\t\telse :\n\t\t\treturn b", "4081": "def middleOfThree(a, b, c) :\n\tx = a - b\n\ty = b - c\n\tz = a - c\n\tif x * y > 0:\n\t\treturn b\n\telif (x * z > 0) :\n\t\treturn\n\telse :\n\t\treturn a", "4099": "def missing4( arr) :\n\thelper = [0]*4\n\tfor i in range(0,len(arr)) :\n\t\ttemp = abs(arr[i])\n\t\tif (temp <= len(arr)) :\n\t\t\tarr[temp - 1] = arr[temp - 1] * (-1)\n\t\telif (temp > len(arr)) :\n\t\t\tif (temp % len(arr)) :\n\t\t\t\thelper[temp % len(arr) - 1] = -1\n\t\t\telse :\n\t\t\t\thelper[(temp % len(arr)) +len(arr) - 1] = -1\n\tfor i in range(0, len(arr) ) :\n\t\tif (arr[i] > 0) :\n\t\t\tprint((i + 1) , end=\" \")\n\tfor i in range(0, len(helper)) :\n\t\tif (helper[i] >= 0) :\n\t\t\tprint((len(arr) + i + 1) , end=\" \")", "4129": "def lexiMiddleSmallest(K, N):\n\tif (K % 2 == 0):\n\t\tprint(K // 2,end=\" \")\n\t\tfor i in range(N - 1):\n\t\t\tprint(K, end = \" \")\n\t\tprint()\n\t\treturn\n\ta = [(K + 1) // 2]*(N)\n\tfor i in range(N//2):\n\t\tif (a[-1] == 1):\n\t\t\tdel a[-1]\n\t\telse:\n\t\t\ta[-1] -= 1\n\t\t\twhile (len(a) < N):\n\t\t\t\ta.append(K)\n\tfor i in a:\n\t\tprint(i, end = \" \")\n\tprint()", "4155": "def transpose(mat, row, col):\n\ttr = [[0 for i in range(row)] for i in range(col)]\n\tfor i in range(row):\n\t\tfor j in range(col):\n\t\t\ttr[j][i] = mat[i][j]\n\treturn tr\ndef RowWiseSort(B):\n\tfor i in range(len(B)):\n\t\tB[i] = sorted(B[i])\n\treturn B\ndef sortCol(mat, N, M):\n\tB = transpose(mat, N, M)\n\tB = RowWiseSort(B)\n\tmat = transpose(B, M, N)\n\tfor i in range(N):\n\t\tfor j in range(M):\n\t\t\tprint(mat[i][j], end = \" \")\n\t\tprint()", "4169": "def largestArea(N, M, H, V, h, v):\n s1 = set([]);\n s2 = set([]);\n for i in range(1, N + 2):\n\ts1.add(i);\n for i in range(1, M + 2):\n\ts2.add(i);\n for i in range(h):\n\ts1.remove(H[i]);\n for i in range( v ):\n\ts2.remove(V[i]);\n list1 = [0] * len(s1)\n list2 = [0]*len(s2);\n i = 0;\n for it1 in s1:\n\tlist1[i] = it1;\n\ti += 1\n i = 0;\n for it2 in s2:\n\tlist2[i] = it2\n\ti += 1\n list1.sort();\n list2.sort();\n maxH = 0\n p1 = 0\n maxV = 0\n p2 = 0;\n for j in range(len(s1)):\n\tmaxH = max(maxH, list1[j] - p1);\n\tp1 = list1[j];\n for j in range(len(s2)):\n\tmaxV = max(maxV, list2[j] - p2);\n\tp2 = list2[j];\n print((maxV * maxH))", "4179": "def findLastElement(arr, N):\n\tarr.sort();\n\ti = 0;\n\tfor i in range(1, N):\n\t\tif (arr[i] - arr[i - 1] != 0\\ and arr[i] - arr[i - 1] != 2):\n\t\t\tprint(\"-1\");\n\t\t\treturn;\n\tprint(arr[N - 1]);", "4185": "def checkifSorted(A, B, N):\n flag = False\n for i in range( N - 1):\n\tif (A[i] > A[i + 1]):\n\tflag = True\n\tbreak\n if (not flag):\n\treturn True\n count = 0\n for i in range(N):\n\tif (B[i] == 0):\n\tcount += 1\n\tbreak\n for i in range(N):\n\tif B[i]:\n\tcount += 1\n\tbreak\n if (count == 2):\n\treturn True\n return False", "4186": "def maxDivisions(arr, N, X) :\n\tarr.sort(reverse = True)\n\tmaxSub = 0;\n\tsize = 0;\n\tfor i in range(N) :\n\t\tsize += 1;\n\t\tif (arr[i] * size >= X) :\n\t\t\tmaxSub += 1;\n\t\t\tsize = 0;\n\tprint(maxSub);", "4194": "def maxPossibleSum(arr, N):\n\tarr.sort()\n\tsum = 0\n\tj = N - 3\n\twhile (j >= 0):\n\t\tsum += arr[j]\n\t\tj -= 3\n\tprint(sum)", "4197": "def minSteps(A, B, M, N):\n\tif (A[0] > B[0]):\n\t\treturn 0\n\tif (B[0] > A[0]):\n\t\treturn 1\n\tif (M <= N and A[0] == B[0] and\n\t\tA.count(A[0]) == M and\n\t\tB.count(B[0]) == N):\n\t\treturn -1\n\tfor i in range(1, N):\n\t\tif (B[i] > B[0]):\n\t\t\treturn 1\n\tfor i in range(1, M):\n\t\tif (A[i] < A[0]):\n\t\t\treturn 1\n\tfor i in range(1, M):\n\t\tif (A[i] > A[0]):\n\t\t\tA[0], B[i] = B[i], A[0]\n\t\t\tA[0], B[0] = B[0], A[0]\n\t\t\treturn 2\n\tfor i in range(1, N):\n\t\tif (B[i] < B[0]):\n\t\t\tA[0], B[i] = B[i], A[0]\n\t\t\tA[0], B[0] = B[0], A[0]\n\t\t\treturn 2\n\treturn 0", "4209": "def CountMaximum(arr, n, k) :\n\tarr.sort()\n\tSum, count = 0, 0\n\tfor i in range(0, n) :\n\t\tSum += arr[i]\n\t\tif (Sum > k) :\n\t\t\tbreak\n\t\tcount += 1\n\treturn count", "4210": "def CountMaximum(arr, n, k) :\n\tarr.sort()\n\tSum, count = 0, 0\n\tfor i in range(0, n) :\n\t\tSum += arr[i]\n\t\tif (Sum > k) :\n\t\t\tbreak\n\t\tcount += 1\n\treturn count", "4219": "def insertionSort(arr, n):\n\ti = 0\n\tkey = 0\n\tj = 0\n\tfor i in range(1,n,1):\n\t\tkey = arr[i]\n\t\tj = i - 1\n\t\twhile (j >= 0 and arr[j] > key):\n\t\t\tarr[j + 1] = arr[j]\n\t\t\tj = j - 1\n\t\tarr[j + 1] = key\ndef printArray(arr, n):\n\ti = 0\n\tfor i in range(n):\n\t\tprint(arr[i],end = \" \")\n\tprint(\"\\n\",end = \"\")", "4220": "def selectionSort(arr, n):\n\tfor i in range(n - 1):\n\t\tmin_idx = i\n\t\tfor j in range(i + 1, n):\n\t\t\tif (arr[j] < arr[min_idx]):\n\t\t\t\tmin_idx = j\n\t\tarr[min_idx], arr[i] = arr[i], arr[min_idx]\ndef printArray(arr, size):\n\tfor i in range(size):\n\t\tprint(arr[i], end = \" \")\n\tprint()", "4237": "def getPairs(arr, N, K):\n\tcount = 0\n\tfor i in range(N):\n\t\tfor j in range(i + 1, N):\n\t\t\tif (arr[i] > K * arr[i + 1]):\n\t\t\t\tcount += 1\n\tprint(count)", "4238": "def merge(arr, temp, l, m, r, K) :\n\ti = l\n\tj = m + 1\n\tcnt = 0\n\tfor l in range(m + 1) :\n\t\tfound = False\n\t\twhile (j <= r) :\n\t\t\tif (arr[i] >= K * arr[j]) :\n\t\t\t\tfound = True\t\t\n\t\t\telse :\n\t\t\t\tbreak\n\t\t\tj += 1\n\t\tif (found) :\n\t\t\tcnt += j - (m + 1)\n\t\t\tj -= 1\n\tk = l\n\ti = l\n\tj = m + 1\n\twhile (i <= m and j <= r) :\n\t\tif (arr[i] <= arr[j]) :\n\t\t\ttemp[k] = arr[i]\n\t\t\tk += 1\n\t\t\ti += 1\n\t\telse :\n\t\t\ttemp[k] = arr[j]\n\t\t\tk += 1\n\t\t\tj += 1\n\twhile (i <= m) :\n\t\ttemp[k] = arr[i]\n\t\tk += 1\n\t\ti += 1\n\twhile (j <= r) :\n\t\ttemp[k] = arr[j]\n\t\tk += 1\n\t\tj += 1\n\tfor i in range(l, r + 1) :\n\t\tarr[i] = temp[i]\n\treturn cnt\ndef mergeSortUtil(arr, temp, l, r, K) :\n\tcnt = 0\n\tif (l < r) :\n\t\tm = (l + r) // 2\n\t\tcnt += mergeSortUtil(arr, temp, l, m, K)\n\t\tcnt += mergeSortUtil(arr, temp, m + 1, r, K)\n\t\tcnt += merge(arr, temp, l, m, r, K)\n\treturn cnt\ndef mergeSort(arr, N, K) :\n\ttemp = [0]*N\n\tprint(mergeSortUtil(arr, temp, 0, N - 1, K))", "4249": "def minRemovals(A, N):\n\tA.sort()\n\tmx = A[N - 1]\n\tsum = 1\n\tfor i in range(0, N):\n\t\tsum += A[i]\n\tif ((sum - mx) >= mx):\n\t\tprint(0, end = \"\")\n\telse:\n\t\tprint(2 * mx - sum, end = \"\")", "4250": "def rearrangeArray(a, n):\n\ta = sorted(a)\n\tfor i in range(n - 1):\n\t\tif (a[i] == i + 1):\n\t\t\ta[i], a[i + 1] = a[i + 1], a[i]\n\tif (a[n - 1] == n):\n\t\ta[n - 1], a[n - 2] = a[n - 2], a[n - 1]\n\tfor i in range(n):\n\t\tprint(a[i], end = \" \")", "4256": "def checkStr1CanConStr2(str1, str2):\n\tN = len(str1)\n\tM = len(str2)\n\tst1 = set([])\n\tst2 = set([])\n\thash1 = [0] * 256\n\tfor i in range(N):\n\t\thash1[ord(str1[i])] += 1\n\tfor i in range(N):\n\t\tst1.add(str1[i])\n\tfor i in range(M):\n\t\tst2.add(str2[i])\n\tif (st1 != st2):\n\t\treturn False\n\thash2 = [0] * 256\n\tfor i in range(M):\n\t\thash2[ord(str2[i])] += 1\n\thash1.sort()\n\thash2.sort()\n\tfor i in range(256):\n\t\tif (hash1[i] != hash2[i]):\n\t\t\treturn False\n\treturn True", "4305": "def minOperations(arr1, arr2, i, j):\n\tif arr1 == arr2:\n\t\treturn 0\n\tif i >= len(arr1) or j >= len(arr2):\n\t\treturn 0\n\tif arr1[i] < arr2[j]:\n\t\treturn 1 \\\n\t\t+ minOperations(arr1, arr2, i + 1, j + 1)\n\treturn max(minOperations(arr1, arr2, i, j + 1),\n\t\t\tminOperations(arr1, arr2, i + 1, j))\ndef minOperationsUtil(arr):\n\tbrr = sorted(arr);\n\tif(arr == brr):\n\t\tprint(\"0\")\n\telse:\n\t\tprint(minOperations(arr, brr, 0, 0))", "4310": "def canTransform(s, t):\n\tn = len(s)\n\toccur = [[] for i in range(26)]\n\tfor x in range(n):\n\t\tch = ord(s[x]) - ord('a')\n\t\toccur[ch].append(x)\n\tidx = [0] * (26)\n\tposs = True\n\tfor x in range(n):\n\t\tch = ord(t[x]) - ord('a')\n\t\tif (idx[ch] >= len(occur[ch])):\n\t\t\tposs = False\n\t\t\tbreak\n\t\tfor small in range(ch):\n\t\t\tif (idx[small] < len(occur[small]) and occur[small][idx[small]] < occur[ch][idx[ch]]):\n\t\t\t\tposs = False\n\t\t\t\tbreak\n\t\tidx[ch] += 1\n\tif (poss):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "4326": "def getMaxSum(i, j, k, arr1, arr2, arr3):\n\tcnt = 0;\n\tif (i >= n1):\n\t\tcnt += 1;\n\tif (j >= n2):\n\t\tcnt += 1;\n\tif (k >= n3):\n\t\tcnt += 1;\n\tif (cnt >= 2):\n\t\treturn 0;\n\tif (dp[i][j][k] != -1):\n\t\treturn dp[i][j][k];\n\tans = 0;\n\tif (i < n1 and j < n2):\n\t\tans = max(ans, getMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j]);\n\tif (i < n1 and k < n3):\n\t\tans = max(ans, getMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k]);\n\tif (j < n2 and k < n3):\n\t\tans = max(ans, getMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k]);\n\tdp[i][j][k] = ans;\n\treturn dp[i][j][k];\ndef reverse(tmp):\n\ti, k, t = 0, 0, 0;\n\tn = len(tmp);\n\tfor i in range(n // 2):\n\t\tt = tmp[i];\n\t\ttmp[i] = tmp[n - i - 1];\n\t\ttmp[n - i - 1] = t;\ndef maxProductSum(arr1, arr2, arr3):\n\tfor i in range(len(dp)):\n\t\tfor j in range(len(dp[0])):\n\t\t\tfor k in range(len(dp[j][0])):\n\t\t\t\tdp[i][j][k] = -1;\n\tarr1.sort();\n\treverse(arr1);\n\tarr2.sort();\n\treverse(arr2);\n\tarr3.sort();\n\treverse(arr3);\n\treturn getMaxSum(0, 0, 0, arr1, arr2, arr3);", "4347": "def findTriplet(arr, N):\n\tarr.sort()\n\ti = N - 1\n\twhile i - 2 >= 0:\n\t\tif(arr[i - 2] + arr[i - 1] > arr[i]):\n\t\t\tflag = 1\n\t\t\tbreak\n\t\ti -= 1\n\tif(flag):\n\t\tprint(arr[i - 2], arr[i - 1], arr[i])\n\telse:\n\t\tprint(-1)", "4354": "def inversionCount(s):\n\tfreq = [0 for _ in range(26)]\n\tinv = 0\n\tfor i in range(len(s)):\n\t\ttemp = 0\n\t\tfor j in range(ord(s[i]) - ord('a')):\n\t\t\ttemp += freq[j]\n\t\tinv += (i - temp)\n\t\tfreq[ord(s[i]) - ord('a')] += 1\n\treturn inv\ndef haveRepeated(S1, S2):\n\tfreq = [0 for _ in range(26)]\n\tfor i in range(len(S1)):\n\t\tif freq[ord(S1[i]) - ord('a')] > 0:\n\t\t\treturn 1\n\t\tfreq[ord(S1[i]) - ord('a')] += 1\n\tfor i in range(26):\n\t\tfreq[i] = 0\n\tfor i in range(len(S2)):\n\t\tif freq[ord(S2[i]) - ord('a')] > 0:\n\t\t\treturn 1\n\t\tfreq[ord(S2[i]) - ord('a')] += 1\n\treturn 0\ndef checkToMakeEqual(S1, S2):\n\tfreq = [0 for _ in range(26)]\n\tfor i in range(len(S1)):\n\t\tfreq[ord(S1[i]) - ord('a')] += 1\n\tflag = 0\n\tfor i in range(len(S2)):\n\t\tif freq[ord(S2[i]) - ord('a')] == 0:\n\t\t\tflag = 1\n\t\t\tbreak\n\t\tfreq[ord(S2[i]) - ord('a')] -= 1\n\tif flag == 1:\n\t\tprint(\"No\")\n\t\treturn\n\tinvCount1 = inversionCount(S1)\n\tinvCount2 = inversionCount(S2)\n\tif ((invCount1 == invCount2) or\n\t((invCount1 % 2) == (invCount2 % 2)) or\n\t\thaveRepeated(S1, S2) == 1):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "4357": "def numberofpairs(arr, N):\n\tanswer = 0\n\tarr.sort()\n\tminDiff = 10000000\n\tfor i in range(0, N - 1):\n\t\tminDiff = min(minDiff, arr[i + 1] - arr[i])\n\tfor i in range(0, N - 1):\n\t\tif arr[i + 1] - arr[i] == minDiff:\n\t\t\tanswer += 1\n\treturn answer", "4360": "def sortArr(a, n):\n\tk = int(math.log(n, 2))\n\tk = int(pow(2, k))\n\twhile(k > 0):\n\t\ti = 0\n\t\twhile i + k < n:\n\t\t\tif a[i] > a[i + k]:\n\t\t\t\ta[i], a[i + k] = a[i + k], a[i]\n\t\t\ti = i + 1\n\t\tk = k // 2\n\tfor i in range(n):\n\t\tprint(a[i], end = \" \")", "4362": "def maximumSum(arr, n, k):\n\telt = n // k;\n\tsum = 0;\n\tarr.sort();\n\tcount = 0;\n\ti = n - 1;\n\twhile (count < k):\n\t\tsum += arr[i];\n\t\ti -= 1;\n\t\tcount += 1;\n\tcount = 0;\n\ti = 0;\n\twhile (count < k):\n\t\tsum += arr[i];\n\t\ti += elt - 1;\n\t\tcount += 1;\n\tprint(sum);", "4369": "def findMinSum(arr, K, L, size):\n\tif (K * L > size):\n\t\treturn -1\n\tminsum = 0\n\tarr.sort()\n\tfor i in range(K):\n\t\tminsum += arr[i]\n\treturn minsum", "4371": "def find_max_length(arr, index, sum, k): \n\tglobal max_length\n\tsum = sum + arr[index]\n\tstore.append(arr[index])\n\tif (sum == k):\n\t\tif (max_length < len(store)):\n\t\t\tmax_length = len(store)\n\t\t\tans = store\n\tfor i in range ( index + 1, len(arr)):\n\t\tif (sum + arr[i] <= k):\n\t\t\tfind_max_length(arr, i, sum, k)\n\t\t\tstore.pop()\n\t\telse:\n\t\t\treturn\n\treturn\ndef longestSubsequence(arr, n, k):\n\tarr.sort()\n\tfor i in range (n):\n\t\tif (max_length >= n - i):\n\t\t\tbreak\n\t\tstore.clear()\n\t\tfind_max_length(arr, i, 0, k)\n\treturn max_length", "4378": "def findKthSmallest(arr, n, k):\n\tmax = 0\n\tfor i in range(n):\n\t\tif (arr[i] > max):\n\t\t\tmax = arr[i]\n\tcounter = [0] * (max + 1)\n\tsmallest = 0\n\tfor i in range(n):\n\t\tcounter[arr[i]] += 1\n\tfor num in range(1, max + 1):\n\t\tif (counter[num] > 0):\n\t\t\tsmallest += counter[num]\n\t\tif (smallest >= k):\n\t\t\treturn num", "4385": "def lexNumbers(n):\n\ts = []\n\tfor i in range(1, n + 1):\n\t\ts.append(str(i))\n\ts.sort()\n\tans = []\n\tfor i in range(n):\n\t\tans.append(int(s[i]))\n\tfor i in range(n):\n\t\tprint(ans[i], end = ' ')", "4386": "def lexNumbers(n):\n\tsol = []\n\tdfs(1, n, sol)\n\tprint(\"[\", sol[0], end= \"\", sep =\"\")\n\tfor i in range(1,n):\n\t\tprint(\", \", sol[i], end= \"\", sep =\"\") print(\"]\")\ndef dfs(temp, n, sol):\n\tif (temp > n):\n\t\treturn\n\tsol.append(temp)\n\tdfs(temp * 10, n, sol)\n\tif (temp % 10 != 9):\n\t\tdfs(temp + 1, n, sol)", "4392": "def func(a):\n\tfor i in range(N):\n\t\tif i % 2 == 0:\n\t\t\tfor j in range(N):\n\t\t\t\tfor k in range(j + 1, N):\n\t\t\t\t\tif a[i][j] > a[i][k]:\n\t\t\t\t\t\ttemp = a[i][j]\n\t\t\t\t\t\ta[i][j] = a[i][k]\n\t\t\t\t\t\ta[i][k] = temp\n\t\telse :\n\t\t\tfor j in range(N):\n\t\t\t\tfor k in range(j + 1, N):\n\t\t\t\t\tif a[i][j] < a[i][k]:\n\t\t\t\t\t\ttemp = a[i][j]\n\t\t\t\t\t\ta[i][j] = a[i][k]\n\t\t\t\t\t\ta[i][k] = temp\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\tprint(a[i][j], end = \" \")\n\t\tprint()", "4400": "def partition(arr, l, h):\n\tpivot = arr[l]\n\ti = l + 1\n\tj = h\n\twhile (i <= j):\n\t\twhile (i <= h and arr[i] < pivot):\n\t\t\ti += 1\n\t\twhile (j > l and arr[j] > pivot):\n\t\t\tj -= 1\n\t\tif (i < j):\n\t\t\ttemp = arr[i]\n\t\t\tarr[i] = arr[j]\n\t\t\tarr[j] = temp\n\t\t\ti += 1\n\t\t\tj -= 1\n\t\telse:\n\t\t\ti += 1\n\tarr[l] = arr[j]\n\tarr[j] = pivot\n\treturn j\ndef sortArray(arr, l, h):\n\tif (l >= h):\n\t\treturn\n\tpivot = partition(arr, l, h)\n\tsortArray(arr, l, pivot - 1)\n\tsortArray(arr, pivot + 1, h)\ndef findMaxIntervals(start, end, n, R):\n\tans = 0\n\tprev = 0\n\tcurrActive = 0\n\ti = 0\n\tj = 0\n\tif (start[0] > 0):\n\t\tans += 1\n\twhile (i < n and j < n):\n\t\tif (start[i] < end[j]):\n\t\t\ti += 1\n\t\t\tcurrActive += 1\n\t\telif (start[i] > end[j]):\n\t\t\tj += 1\n\t\t\tcurrActive -= 1\n\t\telse:\n\t\t\ti += 1\n\t\t\tj += 1\n\t\tif (currActive == 0):\n\t\t\tans += 1\n\tif (end[n - 1] < R):\n\t\tans += 1\n\treturn ans", "4401": "def sortArray(A, N):\n\tif (N % 4 == 0 or N % 4 == 1):\n\t\tfor i in range(N // 2):\n\t\t\tx = i\n\t\t\tif (i % 2 == 0):\n\t\t\t\ty = N - i - 2\n\t\t\t\tz = N - i - 1\n\t\t\tA[z] = A[y]\n\t\t\tA[y] = A[x]\n\t\t\tA[x] = x + 1\n\t\tprint(\"Sorted Array: \", end = \"\")\n\t\tfor i in range(N):\n\t\t\tprint(A[i], end = \" \")\n\telse:\n\t\tprint(\"-1\")", "4412": "def dfs(x):\n\tglobal s, g, ns\n\tv = []\n\tv.clear();\n\tns.clear();\n\tfor it in s:\n\t\tif (x in g and not g[x][it]):\n\t\t\tv.append(it);\n\t\telse:\n\t\t\tns.add(it);\n\ts = ns;\n\tfor i in v:\n\t\tdfs(i);\ndef weightOfMST( N):\n\tcnt = 0;\n\tfor i in range(1,N + 1):\n\t\ts.add(i);\n\twhile(len(s) != 0):\n\t\tcnt += 1\n\t\tt = list(s)[0]\n\t\ts.discard(t);\n\t\tdfs(t);\n\tprint(cnt)", "4420": "def countPairs(A, B):\n\tn = len(A)\n\tA.sort()\n\tB.sort()\n\tans = 0\n\tfor i in range(n):\n\t\tif(A[i] > B[ans]):\n\t\t\tans += 1\n\treturn ans", "4455": "def compare(arr1, arr2):\n\tglobal MAX\n\tfor i in range(MAX):\n\t\tif (arr1[i] != arr2[i]):\n\t\t\treturn False\n\treturn True\ndef search(pat, txt):\n\tM = len(pat)\n\tN = len(txt)\n\tcountP = [0 for i in range(MAX)]\n\tcountTW = [0 for i in range(MAX)]\n\tfor i in range(M):\n\t\tcountP[ord(pat[i])] += 1\n\t\tcountTW[ord(txt[i])] += 1\n\tfor i in range(M, N):\n\t\tif (compare(countP, countTW)):\n\t\t\treturn True\n\t\tcountTW[ord(txt[i])] += 1\n\t\tcountTW[ord(txt[i - M])] -= 1\n\tif(compare(countP, countTW)):\n\t\treturn True\n\t\treturn False", "4459": "def findK(arr, size, N):\n\tarr = sorted(arr)\n\ttemp_sum = 0\n\tfor i in range(size):\n\t\ttemp_sum += arr[i]\n\t\tif (N - temp_sum == arr[i] * (size - i - 1)):\n\t\t\treturn arr[i]\n\treturn -1", "4460": "def minimumSwaps(arr):\n\tcount = 0;\n\ti = 0;\n\twhile (i < len(arr)):\n\t\tif (arr[i] != i + 1):\n\t\t\twhile (arr[i] != i + 1):\n\t\t\t\ttemp = 0;\n\t\t\t\ttemp = arr[arr[i] - 1];\n\t\t\t\tarr[arr[i] - 1] = arr[i];\n\t\t\t\tarr[i] = temp;\n\t\t\t\tcount += 1;\n\t\ti += 1;\n\treturn count;", "4482": "def maxMod(arr, n):\n\tmaxVal = max(arr)\n\tsecondMax = 0\n\tfor i in range(0, n):\n\t\tif (arr[i] < maxVal and arr[i] > secondMax):\n\t\t\tsecondMax = arr[i]\n\treturn secondMax", "4493": "def isPossible(A, B, n, m, x, y) :\n\tif (x > n or y > m) :\n\t\treturn False\n\tA.sort()\n\tB.sort()\n\tif (A[x - 1] < B[m - y]) :\n\t\treturn True\n\telse :\n\t\treturn False", "4507": "def Min_Replace(arr, n, k):\n\tarr.sort(reverse = False)\n\tfreq = [0 for i in range(MAX)]\n\tp = 0\n\tfreq[p] = 1\n\tfor i in range(1, n, 1):\n\t\tif (arr[i] == arr[i - 1]):\n\t\t\tfreq[p] += 1\n\t\telse:\n\t\t\tp += 1\n\t\t\tfreq[p] += 1\n\tfreq.sort(reverse = True)\n\tans = 0\n\tfor i in range(k, p + 1, 1):\n\t\tans += freq[i]\n\treturn ans", "4508": "def append(head_ref, new_data):\n\tnew_node = Node(0)\n\tlast = head_ref\n\tnew_node.data = new_data\n\tnew_node.next = None\n\tif (head_ref == None) :\n\t\tnew_node.prev = None\n\t\thead_ref = new_node\n\t\treturn head_ref\n\twhile (last.next != None):\n\t\tlast = last.next\n\tlast.next = new_node\n\tnew_node.prev = last\n\treturn head_ref\ndef printList(node):\n\tlast = None\n\twhile (node != None) :\n\t\tprint( node.data, end = \" \")\n\t\tlast = node\n\t\tnode = node.next\ndef mergeList(p, q):\n\ts = None\n\tif (p == None or q == None) :\n\t\tif (p == None ):\n\t\t\treturn q\n\t\telse:\n\t\t\treturn p\n\tif (p.data < q.data):\n\t\tp.prev = s\n\t\ts = p\n\t\tp = p.next\n\telse:\n\t\tq.prev = s\n\t\ts = q\n\t\tq = q.next\n\thead = s\n\twhile (p != None and q != None) :\n\t\tif (p.data < q.data) :\n\t\t\ts.next = p\n\t\t\tp.prev = s\n\t\t\ts = s.next\n\t\t\tp = p.next\n\t\telse:\n\t\t\ts.next = q\n\t\t\tq.prev = s\n\t\t\ts = s.next\n\t\t\tq = q.next\n\tif (p == None):\n\t\ts.next = q\n\t\tq.prev = s\n\tif (q == None):\n\t\ts.next = p\n\t\tp.prev = s\n\treturn head\ndef mergeAllList(head,k):\n\tfinalList = None\n\ti = 0\n\twhile ( i < k ) :\n\t\tfinalList = mergeList(finalList, head[i])\n\t\ti = i + 1\n\treturn finalList\ndef __init__(self, new_data):\n\t\tself.data = new_data\n\t\tself.next = None\n\t\tself.prev = None", "4510": "def Segment(x, l, n):\n\tif (n == 1):\n\t\treturn 1\n\tans = 2\n\tfor i in range(1, n - 1):\n\t\tif (x[i] - l[i] > x[i - 1]):\n\t\t\tans += 1\n\t\telif (x[i] + l[i] < x[i + 1]):\n\t\t\tx[i] = x[i] + l[i]\n\t\t\tans += 1\n\treturn ans", "4529": "def existsTriplet(a, b,c, x, l1,l2, l3):\n\tif (l2 <= l1 and l2 <= l3):\n\t\tl1, l2 = l2,l1\n\t\ta, b = b,a\n\telif (l3 <= l1 and l3 <= l2):\n\t\tl1, l3 = l3,l1\n\t\ta, c = c,a\n\tfor i in range(l1):\n\t\tj = 0\n\t\tk = l3 - 1\n\t\twhile (j < l2 and k >= 0):\n\t\t\tif (a[i] + b[j] + c[k] == x):\n\t\t\t\treturn True\n\t\t\tif (a[i] + b[j] + c[k] < x):\n\t\t\t\tj += 1\n\t\t\telse:\n\t\t\t\tk -= 1\n\treturn False", "4570": "def MinimizeleftOverSum(a, n) :\n\tv1, v2 = [], [];\n\tfor i in range(n) :\n\t\tif (a[i] % 2) :\n\t\t\tv1.append(a[i]);\n\t\telse :\n\t\t\tv2.append(a[i]);\n\tif (len(v1) > len(v2)) :\n\t\tv1.sort();\n\t\tv2.sort();\n\t\tx = len(v1) - len(v2) - 1;\n\t\tsum = 0;\n\t\ti = 0;\n\t\twhile (i < x) :\n\t\t\tsum += v1[i];\n\t\t\ti += 1\n\t\treturn sum;\n\telif (len(v2) > len(v1)) :\n\t\tv1.sort();\n\t\tv2.sort();\n\t\tx = len(v2) - len(v1) - 1;\n\t\tsum = 0;\n\t\ti = 0;\n\t\twhile (i < x) :\n\t\t\tsum += v2[i];\n\t\t\ti += 1\n\t\treturn sum;\n\telse :\n\t\treturn 0;", "4578": "def printArr(arr, n):\n\tfor i in range(0, n):\n\t\tprint(arr[i], end = \"\")\ndef compare(num1, num2):\n\tA = str(num1)\n\tB = str(num2)\n\treturn int(A + B) <= int(B + A)\ndef sort(arr):\n\tfor i in range(len(arr)):\n\t\tfor j in range(i + 1, len(arr)):\n\t\t\tif compare(arr[i], arr[j]) == False:\n\t\t\t\tarr[i], arr[j] = arr[j], arr[i]\ndef printSmallest(N, arr):\n\tsort(arr)\n\tprintArr(arr, N)", "4585": "def getMaxMedian(arr, n, k):\n\tsize = n + k\n\tarr.sort(reverse = False)\n\tif (size % 2 == 0):\n\t\tmedian = (arr[int(size / 2) - 1] +\n\t\t\t\tarr[int(size / 2)]) / 2\n\t\treturn median\n\tmedian = arr[int(size / 2)]\n\treturn median", "4591": "def minOperation(S, N, K):\n\tif N % K:\n\t\tprint(\"Not Possible\")\n\t\treturn\n\tcount = [0] * 26\n\tfor i in range(0, N):\n\t\tcount[ord(S[i]) - 97] += 1\n\tE = N // K\n\tgreaterE = []\n\tlessE = []\n\tfor i in range(0, 26):\n\t\tif count[i] < E:\n\t\t\tlessE.append(E - count[i])\n\t\telse:\n\t\t\tgreaterE.append(count[i] - E)\n\tgreaterE.sort()\n\tlessE.sort()\n\tmi = float('inf')\n\tfor i in range(0, K + 1):\n\t\tset1, set2 = i, K - i\n\t\tif (len(greaterE) >= set1 and\n\t\t\tlen(lessE) >= set2):\n\t\t\tstep1, step2 = 0, 0\n\t\t\tfor j in range(0, set1):\n\t\t\t\tstep1 += greaterE[j]\n\t\t\tfor j in range(0, set2):\n\t\t\t\tstep2 += lessE[j]\n\t\t\tmi = min(mi, max(step1, step2))\n\tprint(mi)", "4620": "def partSort(arr, N, a, b):\n\tl = min(a, b)\n\tr = max(a, b)\n\ttemp = [0 for i in range(r - l + 1)]\n\tj = 0\n\tfor i in range(l, r + 1, 1):\n\t\ttemp[j] = arr[i]\n\t\tj += 1\n\ttemp.sort(reverse = False)\n\tj = 0\n\tfor i in range(l, r + 1, 1):\n\t\t\tarr[i] = temp[j]\n\t\t\tj += 1\n\tfor i in range(0, N, 1):\n\t\t\tprint(arr[i], end = \" \")", "4621": "def partSort(arr, N, a, b):\n\tl = min(a, b)\n\tr = max(a, b)\n\tarr = (arr[0 : l] +\n\tsorted(arr[l : r + 1]) + arr[r : N])\n\tfor i in range(0, N, 1):\n\t\t\tprint(arr[i], end = \" \")", "4622": "def minMovesToSort(arr, n) :\n\tmoves = 0\n\tmn = arr[n - 1]\n\tfor i in range(n - 1, -1, -1) :\n\t\tif (arr[i] > mn) :\n\t\t\tmoves += arr[i] - mn\n\treturn moves", "4624": "def sortByRow(mat, n, descending):\n\tfor i in range(n):\n\t\tif (descending == True):\n\t\t\tmat[i].sort(reverse = True)\n\t\telse:\n\t\t\tmat[i].sort()\ndef transpose(mat, n):\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\tmat[i][j], mat[j][i] = mat[j][i], mat[i][j]\ndef sortMatRowAndColWise(mat, n):\n\tsortByRow(mat, n, True)\n\ttranspose(mat, n)\n\tsortByRow(mat, n, False)\n\ttranspose(mat, n);\ndef printMat(mat, n):\n\tfor i in range(n):\n\t\tfor j in range( n):\n\t\t\tprint(mat[i][j], end = \" \")\n\t\tprint()", "4648": "def SieveOfEratosthenes(n):\n\tprime[1] = False\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p]:\n\t\t\tfor i in range(p * 2, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\ndef sortPrimes(arr, n):\n\tSieveOfEratosthenes(100005)\n\tv = []\n\tfor i in range(0, n):\n\t\tif prime[arr[i]]:\n\t\t\tv.append(arr[i])\n\tv.sort(reverse = True)\n\tj = 0\n\tfor i in range(0, n):\n\t\tif prime[arr[i]]:\n\t\t\tarr[i] = v[j]\n\t\t\tj += 1\n\treturn arr", "4701": "def findOptimalPairs(arr, N):\n\tarr.sort(reverse = False)\n\ti = 0\n\tj = N - 1\n\twhile(i <= j):\n\t\tprint(\"(\", arr[i], \",\", arr[j], \")\", end = \" \")\n\t\ti += 1\n\t\tj -= 1", "4740": "def stableSelectionSort(a, n):\n\tfor i in range(n):\n\t\tmin_idx = i\n\t\tfor j in range(i + 1, n):\n\t\t\tif a[min_idx] > a[j]:\n\t\t\t\tmin_idx = j\n\t\tkey = a[min_idx]\n\t\twhile min_idx > i:\n\t\t\ta[min_idx] = a[min_idx - 1]\n\t\t\tmin_idx -= 1\n\t\ta[i] = key\ndef printArray(a, n):\n\tfor i in range(n):\n\t\tprint(\"%d\" %a[i], end = \" \")", "4762": "def minIndex( a , i , j ):\n\tif i == j:\n\t\treturn i\n\tk = minIndex(a, i + 1, j)\n\treturn (i if a[i] < a[k] else k)\ndef recurSelectionSort(a, n, index = 0):\n\tif index == n:\n\t\treturn -1\n\tk = minIndex(a, index, n-1)\n\tif k != index:\n\t\ta[k], a[index] = a[index], a[k]\n\t\t\ta[k], a[index] = a[index], a[k]\n\trecurSelectionSort(a, n, index + 1)", "4783": "def printSorted(a, b, c):\n\tget_max = max(a, max(b, c))\n\tget_min = -max(-a, max(-b, -c))\n\tget_mid = (a + b + c) - (get_max + get_min)\n\tprint(get_min, \" \" , get_mid, \" \" , get_max)", "4786": "def insertionSortRecursive(arr,n):\n\tif n<=1:\n\t\treturn\n\tinsertionSortRecursive(arr,n-1)\n\tlast = arr[n-1]\n\tj = n-2\n\twhile (j>=0 and arr[j]>last):\n\t\tarr[j+1] = arr[j]\n\t\tj = j-1\n\tarr[j+1]=last\ndef printArray(arr,n):\n\tfor i in range(n):\n\t\tprint arr[i],", "4793": "def __init__(self, array):\n\t\tself.array = array\n\t\tself.length = len(array)\ndef __str__(self):\n\t\treturn \" \".join([str(x) for x in self.array])\ndef bubbleSortRecursive(self, n=None):\n\t\tif n is None:\n\t\t\tn = self.length\n\t\tif n == 1:\n\t\t\treturn\n\t\tfor i in range(n - 1):\n\t\t\tif self.array[i] > self.array[i + 1]:\n\t\tself.array[i], self.array[i + 1] = self.array[i + 1], self.array[i]\n\t\tself.bubbleSortRecursive(n - 1)", "4804": "def isPossible(a,b,n,k):\n\ta.sort(reverse=True)\n\tb.sort()\n\tfor i in range(n):\n\t\tif (a[i] + b[i] < k):\n\t\t\treturn False\n\treturn True", "4817": "def countBits(a):\n\tcount = 0\n\twhile (a):\n\t\tif (a & 1):\n\t\t\tcount+= 1\n\t\ta = a>>1\n\treturn count\ndef insertionSort(arr,aux, n):\n\tfor i in range(1,n,1):\n\t\tkey1 = aux[i]\n\t\tkey2 = arr[i]\n\t\tj = i-1\n\t\twhile (j >= 0 and aux[j] < key1):\n\t\t\taux[j+1] = aux[j]\n\t\t\tarr[j+1] = arr[j]\n\t\t\tj = j-1\n\t\taux[j+1] = key1\n\t\tarr[j+1] = key2\ndef sortBySetBitCount(arr, n):\n\taux = [0 for i in range(n)]\n\tfor i in range(0,n,1):\n\t\taux[i] = countBits(arr[i])\n\tinsertionSort(arr, aux, n)\ndef printArr(arr, n):\n\tfor i in range(0,n,1):\n\t\tprint(arr[i],end = \" \")", "4819": "def countBits(a):\n\tcount = 0\n\twhile (a):\n\t\tif (a & 1 ):\n\t\t\tcount += 1\n\t\ta = a>>1\n\treturn count\ndef sortBySetBitCount(arr,n):\n\tcount = [[] for i in range(32)]\n\tsetbitcount = 0\n\tfor i in range(n):\n\t\tsetbitcount = countBits(arr[i])\n\t\tcount[setbitcount].append(arr[i])\n\tfor i in range(31, -1, -1):\n\t\tv1 = count[i]\n\t\tfor i in range(len(v1)):\n\t\t\tarr[j] = v1[i]\n\t\t\tj += 1\ndef printArr(arr, n):\n\tprint(*arr)", "4820": "def setBitCount(num):\n\tcount = 0\n\twhile (num):\n\t\tif (num & 1):\n\t\t\tcount += 1\n\t\tnum = num >> 1\n\treturn count\ndef sortBySetBitCount(arr, n):\n\tcount = []\n\tfor i in range(n):\n\t\tcount.append([(-1) *\n\t\tsetBitCount(arr[i]), arr[i]])\n\tcount.sort(key = lambda x:x[0])\n\tfor i in range(len(count)):\n\t\tprint(count[i][1], end = \" \")", "4847": "def binarySearch(a, item, low, high):\n\twhile (low <= high):\n\t\tmid = low + (high - low) // 2\n\t\tif (item == a[mid]):\n\t\t\treturn mid + 1\n\t\telif (item > a[mid]):\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid - 1\n\treturn low\ndef insertionSort(a, n):\n\tfor i in range (n):\n\t\tj = i - 1\n\t\tselected = a[i]\n\t\tloc = binarySearch(a, selected, 0, j)\n\t\twhile (j >= loc):\n\t\t\ta[j + 1] = a[j]\n\t\t\tj-=1\n\t\ta[j + 1] = selected", "4855": "def insertionSort(arr):\n\tfor i in range(1, len(arr)):\n\t\tkey = arr[i]\n\t\tj = i-1\n\t\twhile j >= 0 and key < arr[j] :\n\t\t\t\tarr[j + 1] = arr[j]\n\t\t\t\tj -= 1\n\t\tarr[j + 1] = key", "4859": "def canReach(s, L, R):\n\tdp = [0 for _ in range(len(s))]\n\tdp[0] = 1\n\tpre = 0\n\tfor i in range(1, len(s)):\n\t\tif (i >= L):\n\t\t\tpre += dp[i - L]\n\t\tif (i > R):\n\t\t\tpre -= dp[i - R - 1]\n\t\tdp[i] = (pre > 0) and (s[i] == '0')\n\treturn dp[len(s) - 1]", "4889": "def generateString(k1, k2, s):\n\ts = list(s)\n\tC1s = 0\n\tC0s = 0\n\tflag = 0\n\tpos = []\n\tfor i in range(len(s)):\n\t\tif (s[i] == '0'):\n\t\t\tC0s += 1\n\t\t\tif ((i + 1) % k1 != 0 and (i + 1) % k2 != 0):\n\t\t\t\tpos.append(i)\n\t\telse:\n\t\t\tC1s += 1\n\t\tif (C0s >= C1s):\n\t\t\tif (len(pos) == 0):\n\t\t\t\tprint(-1)\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tk = pos[len(pos)-1]\n\t\t\t\ts[k] = '1'\n\t\t\t\tC0s -= 1\n\t\t\t\tC1s += 1\n\t\t\t\tpos = pos[:-1]\n\ts = ''.join(s)\n\tif (flag == 0):\n\t\tprint(s)", "4893": "def maximizeProduct(N):\n\tMSB = (int)(math.log2(N))\n\tX = 1 << MSB\n\tY = N - (1 << MSB)\n\tfor i in range(MSB):\n\t\tif (not (N & (1 << i))):\n\t\t\tX += 1 << i\n\t\t\tY += 1 << i\n\tprint(X, Y)", "4899": "def check(num):\n\tsm = 0\n\tnum2 = num * num\n\twhile (num):\n\t\tsm += num % 10\n\t\tnum //= 10\n\tsm2 = 0\n\twhile (num2):\n\t\tsm2 += num2 % 10\n\t\tnum2 //= 10\n\treturn ((sm * sm) == sm2)\ndef convert(s):\n\tval = 0\n\ts = s[::-1]\n\tcur = 1\n\tfor i in range(len(s)):\n\t\tval += (ord(s[i]) - ord('0')) * cur\n\t\tcur *= 10\n\treturn val\ndef generate(s, len1, uniq):\n\tif (len(s) == len1):\n\t\tif(check(convert(s))):\n\t\t\tuniq.add(convert(s))\n\t\treturn\n\tfor i in range(4):\n\t\tgenerate(s + chr(i + ord('0')), len1, uniq)\ndef totalNumbers(L, R):\n\tans = 0\n\tmax_len = int(log10(R)) + 1\n\tuniq = set()\n\tfor i in range(1,max_len+1,1):\n\t\tgenerate(\"\", i, uniq)\n\tfor x in uniq:\n\t\tif (x >= L and x <= R):\n\t\t\tans += 1\n\treturn ans", "4906": "def maxSumAfterPartition(arr, n):\n\tpos = []\n\tneg = []\n\tzero = 0\n\tpos_sum = 0\n\tneg_sum = 0\n\tfor i in range(n):\n\t\tif (arr[i] > 0):\n\t\t\tpos.append(arr[i])\n\t\t\tpos_sum += arr[i]\n\t\telif(arr[i] < 0):\n\t\t\tneg.append(arr[i])\n\t\t\tneg_sum += arr[i]\n\t\telse:\n\t\t\tzero += 1\n\tans = 0\n\tpos.sort()\n\tneg.sort(reverse=True)\n\tif (len(pos) > 0 and len(neg) > 0):\n\t\tans = (pos_sum - neg_sum)\n\telif(len(pos) > 0):\n\t\tif (zero > 0):\n\t\t\tans = (pos_sum)\n\t\telse:\n\t\t\tans = (pos_sum - 2 * pos[0])\n\telse:\n\t\tif (zero > 0):\n\t\t\tans = (-1 * neg_sum)\n\t\telse:\n\t\t\tans = (neg[0] - (neg_sum - neg[0]))\n\treturn ans", "4916": "def validPermutations(str):\n\tm = {}\n\tcount = len(str)\n\tans = 0\n\tfor i in range(len(str)):\n\t\tif(str[i] in m):\n\t\t\tm[str[i]] += 1\n\t\telse:\n\t\t\tm[str[i]] = 1\n\tfor i in range(len(str)):\n\t\tans += count - m[str[i]]\n\t\tm[str[i]] -= 1\n\t\tcount -= 1\n\treturn ans + 1", "4961": "def num_candyTypes(candies):\n\ts = set()\n\tfor i in range(len(candies)):\n\t\ts.add(candies[i])\n\treturn len(s)\ndef distribute_candies(candies):\n\tallowed = len(candies)/2\n\ttypes = num_candyTypes(candies)\n\tif (types < allowed):\n\t\tprint(int(types))\n\telse:\n\t\tprint(int(allowed))", "4962": "def convertXintoY(X, Y):\n\twhile (Y > X):\n\t\tif (Y % 2 == 0):\n\t\t\tY //= 2\n\t\telif (Y % 10 == 1):\n\t\t\tY //= 10\n\t\telse:\n\t\t\tbreak\n\tif (X == Y):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "4964": "def maxXORUtil(arr, N, xrr, orr):\n\tif (N == 0):\n\t\treturn xrr ^ orr\n\tx = maxXORUtil(arr, N - 1, xrr ^ orr, arr[N - 1])\n\ty = maxXORUtil(arr, N - 1, xrr, orr arr[N - 1])\n\treturn max(x, y)\ndef maximumXOR(arr, N):\n\treturn maxXORUtil(arr, N, 0, 0)", "4965": "def MaxXOR(arr, N):\n\tres = 0\n\tfor i in range(N):\n\t\tres |= arr[i]\n\treturn res", "4989": "def generateString(K):\n\ts = \"\"\n\tfor i in range(97,97 + K,1):\n\t\ts = s + chr(i);\n\t\tfor j in range(i + 1,97 + K,1):\n\t\t\ts += chr(i)\n\t\t\ts += chr(j)\n\ts += chr(97)\n\tprint(s)", "4990": "def countEqual(A, B, N) :\n\tfirst = 0\n\tsecond = N - 1\n\tcount = 0\n\twhile (first < N and second >= 0) :\n\t\tif (A[first] < B[second]) :\n\t\t\tfirst += 1\n\t\telif (B[second] < A[first]) :\n\t\t\tsecond -= 1\n\t\telse :\n\t\t\tcount += 1\n\t\t\tfirst += 1\n\t\t\tsecond -= 1\n\treturn count", "5016": "def findEquation(S, M):\n\tprint(\"1 \", ((-1) * S), \" \" , M)", "5030": "def isPalindrome(N):\n\ttemp = N\n\tres = 0\n\twhile (temp != 0):\n\t\trem = temp % 10\n\t\tres = res * 10 + rem\n\t\ttemp //= 10\n\tif (res == N):\n\t\treturn True\n\telse:\n\t\treturn False\ndef sumOfDigits(N):\n\tsum = 0\n\twhile (N != 0):\n\t\tsum += N % 10\n\t\tN //= 10\n\treturn sum\ndef isPrime(n):\n\tif (n <= 1):\n\t\treturn False\n\tfor i in range(2, (n//2) + 1, 1):\n\t\tif (n % i == 0):\n\t\t\treturn False\n\treturn True\ndef precompute():\n\tfor i in range(1, 100001, 1):\n\t\tif (isPalindrome(i)):\n\t\t\tsum = sumOfDigits(i)\n\t\t\tif (isPrime(sum)):\n\t\t\t\tarr[i] = 1\n\t\t\telse:\n\t\t\t\tarr[i] = 0\n\t\telse:\n\t\t\tarr[i] = 0\n\tfor i in range(1,100001,1):\n\t\tarr[i] = arr[i] + arr[i - 1]\ndef countNumbers(Q, N):\n\tprecompute()\n\tfor i in range(N):\n\t\tprint(arr[Q[i][1]] - arr[Q[i][0] - 1])", "5038": "def minSteps(a, n):\n\tprefix_sum = a[:]\n\tfor i in range(1, n):\n\t\tprefix_sum[i] += prefix_sum[i-1]\n\tmx = -1\n\tfor subgroupsum in prefix_sum:\n\t\tsum = 0\n\t\ti = 0\n\t\tgrp_count = 0\n\t\twhile i < n:\n\t\t\tsum += a[i]\n\t\t\tif sum == subgroupsum:\n\t\t\t\tgrp_count += 1\n\t\t\t\tsum = 0\n\t\t\telif sum > subgroupsum:\n\t\t\t\tgrp_count = -1\n\t\t\t\tbreak\n\t\t\ti += 1\n\t\tif grp_count > mx:\n\t\t\tmx = grp_count\n\treturn n - mx", "5056": "def maxOccuringCharacter(s):\n count0 = 0\n count1 = 0\n for i in range(len(s)):\n\tif (s[i] == '1') :\n\tcount1 += 1\n\telif (s[i] == '0') :\n\tcount0 += 1\n prev = -1\n for i in range(len(s)):\n\tif (s[i] == '1') :\n\tprev = i\n\tbreak\n for i in range(prev + 1, len(s)):\n\tif (s[i] != 'X') :\n\tif (s[i] == '1') :\n\t\tcount1 += i - prev - 1\n\t\tprev = i\n\telse :\n\t\tflag = True\n\t\tfor j in range(i+1, len(s)):\n\t\tif (s[j] == '1') :\n\t\t\tflag = False\n\t\t\tprev = j\n\t\t\tbreak\n\t\tif (flag == False) :\n\t\ti = prev\n\t\telse :\n\t\ti = len(s)\n prev = -1\n for i in range(0, len(s)):\n\tif (s[i] == '0') :\n\tprev = i\n\tbreak\n for i in range(prev + 1, len(s)):\n\tif (s[i] != 'X') :\n\tif (s[i] == '0') :\n\t\tcount0 += i - prev - 1\n\t\tprev = i\n\telse :\n\t\tflag = True\n\t\tfor j in range(i + 1, len(s)):\n\t\tif (s[j] == '0') :\n\t\t\tprev = j\n\t\t\tflag = False\n\t\t\tbreak\n\t\tif (flag == False) :\n\t\ti = prev\n\t\telse :\n\t\ti = len(s)\n if (s[0] == 'X') :\n\tcount = 0\n\ti = 0\n\twhile (s[i] == 'X') :\n\tcount += 1\n\ti += 1\n\tif (s[i] == '1') :\n\tcount1 += count\n if (s[(len(s) - 1)] == 'X') :\n\tcount = 0\n\ti = len(s) - 1\n\twhile (s[i] == 'X') :\n\tcount += 1\n\ti -= 1\n\tif (s[i] == '0') :\n\tcount0 += count\n if (count0 == count1) :\n\tprint(\"X\")\n elif (count0 > count1) :\n\tprint( 0 )\n else:\n\tprint(1)", "5062": "def winner(arr, N):\n\tif (N % 2 == 1):\n\t\tprint (\"A\")\n\telse:\n\t\tprint (\"B\")", "5090": "def maxSheets( A, B):\n\tarea = A * B\n\tcount = 1\n\twhile (area % 2 == 0):\n\t\tarea //= 2\n\t\tcount *= 2\n\treturn count", "5093": "def findMinMoves(a, b):\n\tans = 0\n\tif (a == b or abs(a - b) == 1):\n\t\tans = a + b\n\telse:\n\t\tk = min(a, b)\n\t\tj = max(a, b)\n\t\tans = 2 * k + 2 * (j - k) - 1\n\tprint (ans)", "5102": "def cntEvenSumPairs(X, Y):\n\tcntXEvenNums = X / 2\n\tcntXOddNums = (X + 1) / 2\n\tcntYEvenNums = Y / 2\n\tcntYOddNums = (Y + 1) / 2\n\tcntPairs = ((cntXEvenNums * cntYEvenNums) +\n\t\t\t\t(cntXOddNums * cntYOddNums))\n\treturn cntPairs", "5118": "def minMoves(arr):\n\tN = len(arr)\n\tif (N <= 2):\n\t\treturn 0\n\tans = sys.maxsize\n\tfor i in range(-1, 2):\n\t\tfor j in range(-1, 2):\n\t\t\tnum1 = arr[0] + i\n\t\t\tnum2 = arr[1] + j\n\t\t\tflag = 1\n\t\t\tmoves = abs(i) + abs(j)\n\t\t\tfor idx in range(2, N):\n\t\t\t\tnum = num1 + num2\n\t\t\t\tif (abs(arr[idx] - num) > 1):\n\t\t\t\t\tflag = 0\n\t\t\t\telse:\n\t\t\t\t\tmoves += abs(arr[idx] - num)\n\t\t\t\tnum1 = num2\n\t\t\t\tnum2 = num\n\t\t\tif (flag):\n\t\t\t\tans = min(ans, moves)\n\tif (ans == sys.maxsize):\n\t\treturn -1\n\treturn ans", "5119": "def querySum(arr, N, Q, M):\n\tfor i in range(M):\n\t\tx = Q[i][0]\n\t\ty = Q[i][1]\n\t\tsum = 0\n\t\twhile (x < N):\n\t\t\tsum += arr[x]\n\t\t\tx += y\n\t\tprint(sum, end=\" \")", "5120": "def precomputeExpressionForAllVal(arr, N, dp):\n\tfor i in range(N - 1, -1, -1) :\n\t\tfor j in range (1,int(math.sqrt(N)) + 1):\n\t\t\tif (i + j < N):\n\t\t\t\tdp[i][j] = arr[i] + dp[i + j][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = arr[i]\ndef querySum(arr, N, Q, M):\n\tdp = [ [0 for x in range(sz)]for x in range(sqr)]\n\tprecomputeExpressionForAllVal(arr, N, dp)\n\tfor i in range (0,M):\n\t\tx = Q[i][0]\n\t\ty = Q[i][1]\n\t\tif (y <= math.sqrt(N)):\n\t\t\tprint(dp[x][y])\n\t\t\tcontinue\n\t\tsum = 0\n\t\twhile (x < N):\n\t\t\tsum += arr[x]\n\t\t\tx += y\n\t\tprint(sum)", "5167": "def construct_tree(weights, n):\n\tminimum = min(weights)\n\tmaximum = max(weights)\n\tif (minimum == maximum):\n\t\tprint(\"No\")\n\t\treturn\n\telse:\n\t\tprint(\"Yes\")\n\troot = weights[0]\n\tvisited[1] = 1\n\tfor i in range(n):\n\t\tif (weights[i] != root and visited[i + 1] == 0):\n\t\t\tprint(1,i+1)\n\t\t\tvisited[i + 1] = 1\n\tnotroot = 0\n\tfor i in range(n):\n\t\tif (weights[i] != root):\n\t\t\tnotroot = i + 1\n\t\t\tbreak\n\tfor i in range(n):\n\t\tif (weights[i] == root and visited[i + 1] == 0):\n\t\t\tprint(notroot,i + 1)\n\t\t\tvisited[i + 1] = 1", "5170": "def findBitwiseORGivenXORAND(X, Y):\n\treturn X + Y", "5198": "def GCD(a, b):\n\tif (b == 0):\n\t\treturn a\n\treturn GCD(b, a % b)\ndef canReach(N, A, B, K):\n\tgcd = GCD(N, K)\n\tif (abs(A - B) % gcd == 0):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "5199": "def sum(n):\n\tsm = 0\n\twhile(n > 0):\n\t\tsm += n % 10\n\t\tn //= 10\n\treturn sm\ndef smallestNumber(n, s):\n\tif(sum(n) <= s):\n\t\treturn n\n\tans, k = n, 1\n\tfor i in range(9):\n\t\tdigit = (ans // k) % 10\n\t\tadd = k * ((10 - digit) % 10)\n\t\tans += add\n\t\tif(sum(ans) <= s):\n\t\t\tbreak\n\t\tk *= 10\n\treturn ans", "5218": "def countOfSubarray(arr, N):\n\tmp = defaultdict(lambda : 0)\n\tanswer = 0\n\tsum = 0\n\tmp[1] += 1\n\tfor i in range(N):\n\t\tsum += arr[i]\n\t\tanswer += mp[sum - i]\n\t\tmp[sum - i] += 1\n\tprint(answer)", "5227": "def minCost(s, k):\n\tn = len(s)\n\tans = 0\n\tfor i in range(k):\n\t\ta = [0] * 26\n\t\tfor j in range(i, n, k):\n\t\t\ta[ord(s[j]) - ord('a')] += 1\n\t\tmin_cost = sys.maxsize - 1\n\t\tfor ch in range(26):\n\t\t\tcost = 0\n\t\t\tfor tr in range(26):\n\t\t\t\tcost += abs(ch - tr) * a[tr]\n\t\t\tmin_cost = min(min_cost, cost)\n\t\tans += min_cost\n\tprint(ans)", "5233": "def minAbsDiff(N):\n\tsumSet1 = 0\n\tsumSet2 = 0\n\tfor i in reversed(range(N + 1)):\n\t\tif sumSet1 <= sumSet2:\n\t\tsumSet1 = sumSet1 + i\n\t\telse:\n\t\tsumSet2 = sumSet2 + i\n\treturn abs(sumSet1 - sumSet2)", "5234": "def minAbsDiff(N):\n\tif (N % 4 == 0 or N % 4 == 3):\n\t\treturn 0\n\treturn 1", "5250": "def checkDigits(n):\n\twhile True:\n\t\tr = n % 10\n\t\tif (r == 3 or r == 4 or r == 6 or r == 7 or r == 9):\n\t\t\treturn False\n\t\tn //= 10\n\t\tif n == 0:\n\t\t\tbreak\n\treturn True\ndef isPrime(n):\n\tif (n <= 1):\n\t\treturn False\n\tfor i in range(2, n + 1):\n\t\tif i * i > n:\n\t\t\tbreak\n\t\tif (n % i == 0):\n\t\t\treturn False\n\treturn True\ndef isAllPrime(n):\n\treturn isPrime(n) and checkDigits(n)", "5262": "def maximumSubarrays(arr, N, target):\n\tans = 0\n\tavailIdx = -1\n\tcur_sum = 0\n\tmp = {}\n\tmp[0] = -1\n\tfor i in range(N):\n\t\tcur_sum += arr[i]\n\t\tif ((cur_sum - target) in mp and mp[cur_sum - target] >= availIdx):\n\t\t\tans += 1\n\t\t\tavailIdx = i\n\t\tmp[cur_sum] = i\n\treturn ans", "5291": "def getMinOps(arr):\n\tres = 0\n\tfor i in range(len(arr) - 1):\n\t\tres += max(arr[i + 1] - arr[i], 0)\n\treturn res", "5310": "def minCost(str, a, b):\n\topenUnbalanced = 0;\n\tclosedUnbalanced = 0;\n\topenCount = 0;\n\tclosedCount = 0;\n\tfor i in range(len(str)):\n\t\tif (str[i] == '('):\n\t\t\topenUnbalanced += 1;\n\t\t\topenCount += 1;\n\t\telse:\n\t\t\tif (openUnbalanced == 0):\n\t\t\t\tclosedUnbalanced += 1;\n\t\t\telse:\n\t\t\t\topenUnbalanced -= 1;\n\t\t\tclosedCount += 1;\n\tresult = a * (abs(openCount - closedCount));\n\tif (closedCount > openCount):\n\t\tclosedUnbalanced -= (closedCount - openCount);\n\tif (openCount > closedCount):\n\t\topenUnbalanced -= (openCount - closedCount);\n\tresult += min(a * (openUnbalanced + closedUnbalanced), b * closedUnbalanced);\n\tprint(result);", "5322": "def countEvenSum(low, high, k):\n\teven_count = high / 2 - (low - 1) / 2\n\todd_count = (high + 1) / 2 - low / 2\n\teven_sum = 1\n\todd_sum = 0\n\tfor i in range(0, k):\n\t\tprev_even = even_sum\n\t\tprev_odd = odd_sum\n\t\teven_sum = ((prev_even * even_count) +\n\t\t\t\t\t(prev_odd * odd_count))\n\t\todd_sum = ((prev_even * odd_count) +\n\t\t\t\t\t(prev_odd * even_count))\n\tprint(int(even_sum))", "5329": "def Length_Diagonals(a, theta):\n\tp = a * math.sqrt(2 + (2 * \\\n\t\t\tmath.cos(math.radians(theta))))\n\tq = a * math.sqrt(2 - (2 * \\\n\t\t\tmath.cos(math.radians(theta))))\n\treturn [p, q]", "5333": "def AddEdge(u, v):\n\tif u not in adj:\n\t\tadj[u] = []\n\tif v not in adj:\n\t\tadj[v] = []\n\tadj[u].append(v)\n\tadj[v].append(u)\ndef Matching_dfs(u, p):\n\tglobal max_matching\n\tfor i in range(len(adj[u])):\n\t\tif (adj[u][i] != p):\n\t\t\tMatching_dfs(adj[u][i], u)\n\tif (not used[u] and not used[p] and p != 0):\n\t\tmax_matching += 1\n\t\tused[u] = 1\n\t\tused[p] = 1\ndef maxMatching():\n\tMatching_dfs(1, 0)\n\tprint(max_matching)", "5353": "def balancedMatrix(mat):\n\tis_balanced = True\n\ti = 0\n\twhile i < N and is_balanced:\n\t\tj = 0\n\t\twhile j < N and is_balanced:\n\t\t\tif ((i == 0 or i == N - 1) and\n\t\t\t\t(j == 0 or j == M - 1)):\n\t\t\t\tif mat[i][j] >= 2:\n\t\t\t\t\tisbalanced = False\n\t\t\telif (i == 0 or i == N - 1 or j == 0 or j == M - 1):\n\t\t\t\tif mat[i][j] >= 3:\n\t\t\t\t\tis_balanced = False\n\t\t\telse:\n\t\t\t\tif mat[i][j] >= 4:\n\t\t\t\t\tis_balanced = False\n\t\t\tj += 1\n\t\ti += 1\n\tif is_balanced:\n\t\treturn \"Balanced\"\n\telse:\n\t\treturn \"Unbalanced\"", "5361": "def getMinCost(A, B, N):\n\tmini = sys.maxsize\n\tfor i in range(N):\n\t\tmini = min(mini, min(A[i], B[i]))\n\treturn mini * (2 * N - 1)", "5370": "def maxSubsequences(arr, n)->int:\n\tm = defaultdict(int)\n\tmaxCount = 0\n\tcount = 0\n\tfor i in range(0, n):\n\t\tif arr[i] in m.keys():\n\t\t\tcount = m[arr[i]]\n\t\t\tif count > 1:\n\t\t\t\tm[arr[i]] = count - 1\n\t\t\telse:\n\t\t\t\tm.pop(arr[i])\n\t\t\tif arr[i] - 1 > 0:\n\t\t\t\tm[arr[i] - 1] += 1\n\t\telse:\n\t\t\tmaxCount += 1\n\t\tmaxCount += 1\n\t\t\tif arr[i] - 1 > 0:\n\t\t\t\tm[arr[i] - 1] += 1\n\treturn maxCount", "5373": "def count(n, k):\n\tcount = (pow(10, k) - pow(10, k - 1));\n\tprint(count);", "5380": "def func(N, P):\n\tsumUptoN = (N * (N + 1) / 2);\n\tsumOfMultiplesOfP = 0;\n\tif (N < P):\n\t\treturn sumUptoN;\n\telif ((N / P) == 1):\n\t\treturn sumUptoN - P + 1;\n\tsumOfMultiplesOfP = (((N / P) *\n\t\t\t\t\t\t(2 * P +\n\t\t\t\t\t\t(N / P - 1) * P)) / 2);\n\treturn (sumUptoN +\n\t\t\tfunc(N / P, P) - sumOfMultiplesOfP);", "5383": "def removeOcc(s, ch):\n\tfor i in range(len(s)):\n\t\tif (s[i] == ch):\n\t\t\ts = s[0 : i] + s[i + 1:]\n\t\t\tbreak\n\tfor i in range(len(s) - 1, -1, -1):\n\t\tif (s[i] == ch):\n\t\t\ts = s[0 : i] + s[i + 1:]\n\t\t\tbreak\n\treturn s", "5388": "def findShifts(A, N):\n\tshift = [0 for i in range(N)]\n\tfor i in range(N):\n\t\tif (i == A[i] - 1):\n\t\t\tshift[i] = 0\n\t\telse:\n\t\t\tshift[i] = (A[i] - 1 - i + N) % N\n\tfor i in range(N):\n\t\tprint(shift[i], end = \" \")", "5398": "def printVector(arr):\n\tif (len(arr) != 1):\n\t\tfor i in range(len(arr)):\n\t\t\tprint(arr[i], end = \" \")\n\t\tprint()\ndef findWays(arr, i, n):\n\tif (n == 0):\n\t\tprintVector(arr)\n\tfor j in range(i, n + 1):\n\t\tarr.append(j)\n\t\tfindWays(arr, j, n - j)\n\t\tdel arr[-1]", "5405": "def Maximum_subsequence(A, N):\n\tfrequency = dict();\n\tmax_freq = 0;\n\tfor i in range(N):\n\tif (A[i] in frequency):\n\t\t\tfrequency[A[i]] += 1\n\t\telse:\n\t\t\tfrequency[A[i]] = 1\n\tfor it in frequency:\n\t\tif (frequency[it] > max_freq):\n\t\t\tmax_freq = frequency[it];\n\tprint(max_freq);", "5407": "def minSteps(N, increasing, decreasing):\n\tMin = sys.maxsize;\n\tfor i in increasing:\n\t\tif (Min > i):\n\t\t\tMin = i;\n\tMax = -sys.maxsize;\n\tfor i in decreasing:\n\t\tif (Max < i):\n\t\t\tMax = i;\n\tminSteps = max(Max, N - Min);\n\tprint(minSteps);", "5416": "def constructmatrix(N):\n\tcheck = bool(True)\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\tif (i == j):\n\t\t\t\tprint(1, end = \" \")\n\t\t\telif (check):\n\t\t\t\tprint(2, end = \" \")\n\t\t\t\tcheck = bool(False)\n\t\t\telse:\n\t\t\t\tprint(-2, end = \" \")\n\t\t\t\tcheck = bool(True)\n\t\tprint()", "5418": "def countChanges(matrix, n, m):\n\tdist = n + m - 1\n\tfreq = [[0] * 10 for i in range(dist)]\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tfreq[i + j][matrix[i][j]] += 1\n\tmin_changes_sum = 0\n\tfor i in range(dist // 2):\n\t\tmaximum = 0\n\t\ttotal_values = 0\n\t\tfor j in range(10):\n\t\t\tmaximum = max(maximum, freq[i][j] + freq[n + m - 2 - i][j])\n\t\t\ttotal_values += (freq[i][j] + freq[n + m - 2 - i][j])\n\t\tmin_changes_sum += (total_values - maximum)\n\treturn min_changes_sum", "5440": "def DivideString(s, n, k):\n\tc = 0\n\tno = 1\n\tc1 = 0\n\tc2 = 0\n\tfr = [0] * 26\n\tans = []\n\tfor i in range(n):\n\t\tfr[ord(s[i]) - ord('a')] += 1\n\tfor i in range(26):\n\t\tif (fr[i] == k):\n\t\t\tc += 1\n\t\tif (fr[i] > k and fr[i] != 2 * k):\n\t\t\tc1 += 1\n\t\t\tch = chr(ord('a') + i)\n\t\tif (fr[i] == 2 * k):\n\t\t\tc2 += 1\n\t\t\tch1 = chr(ord('a') + i)\n\tfor i in range(n):\n\t\tans.append(\"1\")\n\tmp = {}\n\tif (c % 2 == 0 or c1 > 0 or c2 > 0):\n\t\tfor i in range(n):\n\t\t\tif (fr[ord(s[i]) - ord('a')] == k):\n\t\t\t\tif (s[i] in mp):\n\t\t\t\t\tans[i] = '2'\n\t\t\t\telse:\n\t\t\t\t\tif (no <= (c // 2)):\n\t\t\t\t\t\tans[i] = '2'\n\t\t\t\t\t\tno += 1\n\t\t\t\t\t\tmp[s[i]] = 1\n\t\tif (c % 2 == 1 and c1 > 0):\n\t\t\tno = 1\n\t\t\tfor i in range(n):\n\t\t\t\tif (s[i] == ch and no <= k):\n\t\t\t\t\tans[i] = '2'\n\t\t\t\t\tno += 1\n\t\tif (c % 2 == 1 and c1 == 0):\n\t\t\tno = 1\n\t\t\tflag = 0\n\t\t\tfor i in range(n):\n\t\t\t\tif (s[i] == ch1 and no <= k):\n\t\t\t\t\tans[i] = '2'\n\t\t\t\t\tno += 1\n\t\t\t\tif (fr[s[i] - 'a'] == k and flag == 0 and ans[i] == '1'):\n\t\t\t\t\tans[i] = '2'\n\t\t\t\t\tflag = 1\n\t\tprint(\"\".join(ans))\n\telse:\n\t\tprint(\"NO\")", "5447": "def check(unit_digit, X):\n\tfor times in range(1, 11):\n\t\tdigit = (X * times) % 10\n\t\tif (digit == unit_digit):\n\t\t\treturn times\n\treturn -1\ndef getNum(N, X):\n\tunit_digit = N % 10\n\ttimes = check(unit_digit, X)\n\tif (times == -1):\n\t\treturn times\n\telse:\n\t\tif (N >= (times * X)):\n\t\t\treturn times\n\t\telse:\n\t\t\treturn -1", "5455": "def minPoints(n, m):\n\tans = 0\n\tif ((n % 2 != 0) and (m % 2 != 0)):\n\t\tans = ((n * m) // 2) + 1\n\telse:\n\t\tans = (n * m) // 2\n\treturn ans", "5468": "def solve(P, n):\n\tarr = []\n\tarr.append(0)\n\tfor x in P:\n\t\tarr.append(x)\n\tcnt = 0\n\tfor i in range(1, n):\n\t\tif (arr[i] == i):\n\t\t\tarr[i], arr[i + 1] = arr[i + 1], arr[i]\n\t\t\tcnt += 1\n\tif (arr[n] == n):\n\t\tarr[n - 1], arr[n] = arr[n] , arr[n - 1]\n\t\tcnt += 1\n\tprint(cnt)", "5482": "def countEvenOdd(arr, n, K) :\n\teven = 0; odd = 0;\n\tfor i in range(n) :\n\t\tx = bin(arr[i]).count('1');\n\t\tif (x % 2 == 0) :\n\t\t\teven += 1;\n\t\telse :\n\t\t\todd += 1;\n\ty = bin(K).count('1');\n\tif (y & 1) :\n\t\tprint(\"Even =\",odd ,\", Odd =\", even);\n\telse :\n\t\tprint(\"Even =\" , even ,\", Odd =\", odd);", "5495": "def check(S, prices, type1, n):\n\tfor j in range(0, n):\n\t\tfor k in range(j + 1, n):\n\t\t\tif ((type1[j] == 0 and type1[k] == 1) or\n\t\t\t\t(type1[j] == 1 and type1[k] == 0)):\n\t\t\t\tif (prices[j] + prices[k] <= S):\n\t\t\t\t\treturn \"Yes\";\n\treturn \"No\";", "5501": "def getLargestString(s, k):\n\tfrequency_array = [0] * 26\n\tfor i in range(len(s)):\n\t\tfrequency_array[ord(s[i]) - ord('a')] += 1\n\tans = \"\"\n\ti = 25\n\twhile i >= 0:\n\t\tif (frequency_array[i] > k):\n\t\t\ttemp = k\n\t\t\tst = chr( i + ord('a'))\n\t\t\twhile (temp > 0):\n\t\t\t\tans += st\n\t\t\t\ttemp -= 1\n\t\t\tfrequency_array[i] -= k\n\t\t\tj = i - 1\n\t\t\twhile (frequency_array[j] <= 0 and j >= 0):\n\t\t\t\tj -= 1\n\t\t\tif (frequency_array[j] > 0 and j >= 0):\n\t\t\t\tstr1 = chr(j + ord( 'a'))\n\t\t\t\tans += str1\n\t\t\t\tfrequency_array[j] -= 1\n\t\t\telse:\n\t\t\t\tbreak\n\t\telif (frequency_array[i] > 0):\n\t\t\ttemp = frequency_array[i]\n\t\t\tfrequency_array[i] -= temp\n\t\t\tst = chr(i + ord('a'))\n\t\t\twhile (temp > 0):\n\t\t\t\tans += st\n\t\t\t\ttemp -= 1\n\t\telse:\n\t\t\ti -= 1\n\treturn ans", "5512": "def minOperations(a, b, n):\n\tminA = min(a);\n\tfor x in range(minA, -1, -1):\n\t\tcheck = True;\n\t\toperations = 0;\n\t\tfor i in range(n):\n\t\t\tif (x % b[i] == a[i] % b[i]):\n\t\t\t\toperations += (a[i] - x) / b[i];\n\t\t\telse:\n\t\t\t\tcheck = False;\n\t\t\t\tbreak;\n\t\tif (check):\n\t\t\treturn operations;\n\treturn -1;", "5538": "def getLargestSum(N):\n\tmax_sum = 0\n\tfor i in range(1,N+1):\n\t\tfor j in range(i + 1, N + 1, 1):\n\t\t\tif (i * j % (i + j) == 0):\n\t\t\t\tmax_sum = max(max_sum, i + j)\n\treturn max_sum", "5539": "def getLargestSum(N) :\n\tfor i in range(1, int(N ** (1/2))+1) :\n\t\tfor j in range(i + 1, int(N ** (1/2)) + 1) :\n\t\t\tk = N // j;\n\t\t\ta = k * i;\n\t\t\tb = k * j;\n\t\t\tif (a <= N and b <= N and a * b % (a + b) == 0) :\n\t\t\t\tmax_sum = max(max_sum, a + b);\n\treturn max_sum;", "5544": "def maxSubArraySum(a, size):\n\tmax_so_far = -10**9\n\tmax_ending_here = 0\n\tfor i in range(size):\n\t\tmax_ending_here = max_ending_here + a[i]\n\t\tif (max_ending_here < 0):\n\t\t\tmax_ending_here = 0\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\treturn max_so_far\ndef maxSum(a, n):\n\tS = 0\n\tfor i in range(n):\n\t\tS += a[i]\n\tX = maxSubArraySum(a, n)\n\treturn 2 * X - S", "5548": "def isPrime(n):\n\tflag = 1\n\ti = 2\n\twhile(i * i <= n):\n\t\tif (n % i == 0):\n\t\t\tflag = 0\n\t\t\tbreak\n\t\ti += 1\n\treturn (True if flag == 1 else False)\ndef isPerfectSquare(x):\n\tsr = math.sqrt(x)\n\treturn ((sr - math.floor(sr)) == 0)\ndef countInterestingPrimes(n):\n\tanswer = 0\n\tfor i in range(2, n):\n\t\tif (isPrime(i)):\n\t\t\tj = 1\n\t\t\twhile(j * j * j * j <= i):\n\t\t\t\tif (isPerfectSquare(i - j * j * j * j)):\n\t\t\t\t\tanswer += 1\n\t\t\t\t\tbreak\n\t\t\t\tj += 1\n\treturn answer", "5549": "def SieveOfEratosthenes(n, allPrimes):\n\tprime = [True] * (n + 1)\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\tfor p in range(2, n + 1):\n\t\tif prime[p]:\n\t\t\tallPrimes.add(p)\ndef countInterestingPrimes(n):\n\tallPrimes = set()\n\tSieveOfEratosthenes(n, allPrimes)\n\tinterestingPrimes = set()\n\tsquares, quadruples = [], []\n\ti = 1\n\twhile i * i <= n:\n\t\tsquares.append(i * i)\n\t\ti += 1\n\ti = 1\n\twhile i * i * i * i <= n:\n\t\tquadruples.append(i * i * i * i)\n\t\ti += 1\n\tfor a in squares:\n\t\tfor b in quadruples:\n\t\t\tif a + b in allPrimes:\n\t\t\t\tinterestingPrimes.add(a + b)\n\treturn len(interestingPrimes)", "5585": "def decBinary(arr, n):\n\tk = int(math.log2(n))\n\twhile (n > 0):\n\t\tarr[k] = n % 2\n\t\tk = k - 1\n\t\tn = n//2\ndef binaryDec(arr, n):\n\tans = 0\n\tfor i in range(0, n):\n\t\tans = ans + (arr[i] << (n - i - 1))\n\treturn ans\ndef maxNum(n, k):\n\tl = int(math.log2(n)) + 1\n\ta = [0 for i in range(0, l)]\n\tdecBinary(a, n)\n\tcn = 0\n\tfor i in range(0, l):\n\t\tif (a[i] == 0 and cn < k):\n\t\t\ta[i] = 1\n\t\t\tcn = cn + 1\n\treturn binaryDec(a, l)", "5588": "def findSubSeq(arr, n, sum) :\n\tfor i in range(n - 1, -1, -1) :\n\t\tif (sum < arr[i]) :\n\t\t\tarr[i] = -1;\n\t\telse :\n\t\t\tsum -= arr[i];\n\tfor i in range(n) :\n\t\tif (arr[i] != -1) :\n\t\t\tprint(arr[i], end = \" \");", "5594": "def maxAlpha(str, len):\n\tfirst = [-1 for x in range(MAX)]\n\tlast = [-1 for x in range(MAX)]\n\tfor i in range(0,len):\n\t\tindex = ord(str[i])-97\n\t\tif (first[index] == -1):\n\t\t\tfirst[index] = i\n\t\tlast[index] = i\n\tans = -1\n\tmaxVal = -1\n\tfor i in range(0,MAX):\n\t\tif (first[i] == -1):\n\t\t\tcontinue\n\t\tif ((last[i] - first[i]) > maxVal):\n\t\t\tmaxVal = last[i] - first[i];\n\t\t\tans = i\n\treturn chr(ans + 97)", "5621": "def find_distinct(a, n, q, queries):\n\tcheck = [0] * MAX;\n\tidx = [0] * MAX;\n\tcnt = 1;\n\tfor i in range(n - 1, -1, -1):\n\t\tif (check[a[i]] == 0):\n\t\t\tidx[i] = cnt;\n\t\t\tcheck[a[i]] = 1;\n\t\t\tcnt += 1;\n\t\telse:\n\t\t\tidx[i] = cnt - 1;\n\tfor i in range(0, q):\n\t\tm = queries[i];\n\t\tprint(idx[m], end = \" \");", "5627": "def countOp(x) :\n\tarr = [0]*MAX ;\n\tarr[0] = 1;\n\tfor i in range(1, MAX) :\n\t\tarr[i] = arr[i - 1] * 2;\n\ttemp = x;\n\tflag = True;\n\tans = 0;\n\toperations = 0;\n\tflag2 = False;\n\tfor i in range(MAX) :\n\t\tif (arr[i] - 1 == x) :\n\t\t\tflag2 = True;\n\t\tif (arr[i] > x) :\n\t\t\tans = i;\n\t\t\tbreak;\n\tif (flag2) :\n\t\treturn 0;\n\twhile (flag) :\n\t\tif (arr[ans] < x) :\n\t\t\tans += 1;\n\t\toperations += 1;\n\t\tfor i in range(MAX) :\n\t\t\ttake = x ^ (arr[i] - 1);\n\t\t\tif (take <= arr[ans] - 1) :\n\t\t\t\tif (take > temp) :\n\t\t\t\t\ttemp = take;\n\t\tif (temp == arr[ans] - 1) :\n\t\t\tflag = False;\n\t\t\tbreak;\n\t\ttemp += 1;\n\t\toperations += 1;\n\t\tx = temp;\n\t\tif (x == arr[ans] - 1) :\n\t\t\tflag = False;\n\treturn operations;", "5636": "def minOperations(arr, n):\n\tresult = 0\n\tfreq = [0] * 1000001\n\tfor i in range(0, n):\n\t\tfreq[arr[i]] += 1\n\tmaxi = max(arr)\n\tfor i in range(1, maxi+1):\n\t\tif freq[i] != 0:\n\t\t\tfor j in range(i * 2, maxi+1, i):\n\t\t\t\tfreq[j] = 0\n\t\t\tresult += 1\n\treturn result", "5675": "def encryptString(string, n):\n\ti, cnt = 0, 0\n\tencryptedStr = \"\"\n\twhile i < n:\n\t\tcnt = i + 1\n\t\twhile cnt > 0:\n\t\t\tencryptedStr += string[i]\n\t\t\tcnt -= 1\n\t\ti += 1\n\treturn encryptedStr", "5676": "def minGCD(arr, n) :\n\tminGCD = 0;\n\tfor i in range(n) :\n\t\tminGCD = gcd(minGCD, arr[i]);\n\treturn minGCD;\ndef minLCM(arr, n) :\n\tminLCM = arr[0];\n\tfor i in range(1, n) :\n\t\tminLCM = min(minLCM, arr[i]);\n\treturn minLCM;", "5687": "def formStringMinOperations(ss):\n\tcount = [0] * 3;\n\ts = list(ss);\n\tfor i in range(len(s)):\n\t\tcount[ord(s[i]) - ord('0')] += 1;\n\tprocessed = [0] * 3;\n\treqd = math.floor(len(s) / 3);\n\tfor i in range(len(s)):\n\t\tif (count[ord(s[i]) - ord('0')] == reqd):\n\t\t\tcontinue;\n\t\tif (s[i] == '0' and count[0] > reqd and processed[0] >= reqd):\n\t\t\tif (count[1] < reqd):\n\t\t\t\ts[i] = '1';\n\t\t\t\tcount[1] += 1;\n\t\t\t\tcount[0] -= 1;\n\t\t\telif (count[2] < reqd):\n\t\t\t\ts[i] = '2';\n\t\t\t\tcount[2] += 1;\n\t\t\t\tcount[0] -= 1;\n\t\tif (s[i] == '1' and count[1] > reqd):\n\t\t\tif (count[0] < reqd):\n\t\t\t\ts[i] = '0';\n\t\t\t\tcount[0] += 1;\n\t\t\t\tcount[1] -= 1;\n\t\t\telif (count[2] < reqd and processed[1] >= reqd):\n\t\t\t\ts[i] = '2';\n\t\t\t\tcount[2] += 1;\n\t\t\t\tcount[1] -= 1;\n\t\tif (s[i] == '2' and count[2] > reqd):\n\t\t\tif (count[0] < reqd):\n\t\t\t\ts[i] = '0';\n\t\t\t\tcount[0] += 1;\n\t\t\t\tcount[2] -= 1;\n\t\t\telif (count[1] < reqd):\n\t\t\t\ts[i] = '1';\n\t\t\t\tcount[1] += 1;\n\t\t\t\tcount[2] -= 1;\n\t\tprocessed[ord(s[i]) - ord('0')] += 1;\n\treturn ''.join(s);", "5730": "def minDiff( n, x, A):\n\tmn = A[0]\n\tmx = A[0]\n\tfor i in range(0,n):\n\t\tmn = min( mn, A[ i])\n\t\tmx = max( mx, A[ i])\n\treturn max(0, mx - mn - 2 * x)", "5739": "", "5742": "def isWaveArray(arr , n):\n\tresult = True\n\tif (arr[1] > arr[0] and arr[1] > arr[2]):\n\t\tfor i in range(1, n - 1, 2):\n\t\t\tif (arr[i] > arr[i - 1] and arr[i] > arr[i + 1]):\n\t\t\t\tresult = True\n\t\t\telse :\n\t\t\t\tresult = False\n\t\t\t\tbreak\n\t\tif (result == True and n % 2 == 0):\n\t\t\tif (arr[n - 1] <= arr[n - 2]) :\n\t\t\t\tresult = False\n\telif (arr[1] < arr[0] and arr[1] < arr[2]) :\n\t\tfor i in range(1, n - 1, 2) :\n\t\t\tif (arr[i] < arr[i - 1] and arr[i] < arr[i + 1]):\n\t\t\t\tresult = True\n\t\t\telse :\n\t\t\t\tresult = False\n\t\t\t\tbreak\n\t\tif (result == True and n % 2 == 0) :\n\t\t\tif (arr[n - 1] >= arr[n - 2]) :\n\t\t\t\tresult = False\n\treturn result", "5762": "def findMinimumAdjacentSwaps(arr, N) :\n\tvisited = [False] * (N + 1)\n\tminimumSwaps = 0\n\tfor i in range(2 * N) :\n\t\tif (visited[arr[i]] == False) :\n\t\t\tvisited[arr[i]] = True\n\t\t\tcount = 0\n\t\t\tfor j in range( i + 1, 2 * N) :\n\t\t\t\tif (visited[arr[j]] == False) :\n\t\t\t\t\tcount += 1\n\t\t\t\telif (arr[i] == arr[j]) :\n\t\t\t\t\tminimumSwaps += count\n\treturn minimumSwaps", "5772": "def possibility(m, length, s):\n\tcountodd = 0\n\tfor i in range(0, length):\n\t\tif m[int(s[i])] & 1:\n\t\t\tcountodd += 1\n\t\tif countodd > 1:\n\t\t\treturn False\n\treturn True\ndef largestPalindrome(s):\n\tl = len(s)\n\tm = defaultdict(lambda:0)\n\tfor i in range(0, l):\n\t\tm[int(s[i])] += 1\n\tif possibility(m, l, s) == False:\n\t\tprint(\"Palindrome cannot be formed\")\n\t\treturn\n\tlargest = [None] * l\n\tfront = 0\n\tfor i in range(9, -1, -1):\n\t\tif m[i] & 1:\n\t\t\tlargest[l // 2] = chr(i + 48)\n\t\t\tm[i] -= 1\n\t\t\twhile m[i] > 0:\n\t\t\t\tlargest[front] = chr(i + 48)\n\t\t\t\tlargest[l - front - 1] = chr(i + 48)\n\t\t\t\tm[i] -= 2\n\t\t\t\tfront += 1\n\t\telse:\n\t\t\twhile m[i] > 0:\n\t\t\t\tlargest[front] = chr(i + 48)\n\t\t\t\tlargest[l - front - 1] = chr(i + 48)\n\t\t\t\tm[i] -= 2\n\t\t\t\tfront += 1\n\tfor i in range(0, l):\n\t\tprint(largest[i], end = \"\")", "5797": "def swapCount(s):", "5798": "def swapCount(s):\n\tchars = s\n\tcountLeft = 0\n\tcountRight = 0\n\tswap = 0\n\timbalance = 0;\n\tfor i in range(len(chars)):\n\t\tif chars[i] == '[':\n\t\t\tcountLeft += 1\n\t\t\tif imbalance > 0:\n\t\t\t\tswap += imbalance\n\t\t\t\timbalance -= 1\n\t\telif chars[i] == ']':\n\t\t\tcountRight += 1\n\t\t\timbalance = (countRight - countLeft)\n\treturn swap", "5811": "def minimizeWithKSwaps(arr, n, k):\n\tfor i in range(n-1):\n\t\tpos = i\n\t\tfor j in range(i+1, n):\n\t\t\tif (j-i > k):\n\t\t\t\tbreak\n\t\t\tif (arr[j] < arr[pos]):\n\t\t\t\tpos = j\n\t\tfor j in range(pos, i, -1):\n\t\t\tarr[j],arr[j-1] = arr[j-1], arr[j]\n\t\tk -= pos - i", "5816": "def minimumCostOfBreaking(X, Y, m, n):\n\tres = 0\n\tX.sort(reverse = True)\n\tY.sort(reverse = True)\n\thzntl = 1; vert = 1\n\ti = 0; j = 0\n\twhile (i < m and j < n):\n\t\tif (X[i] > Y[j]):\n\t\t\tres += X[i] * vert\n\t\t\thzntl += 1\n\t\t\ti += 1\n\t\telse:\n\t\t\tres += Y[j] * hzntl\n\t\t\tvert += 1\n\t\t\tj += 1\n\ttotal = 0\n\twhile (i < m):\n\t\ttotal += X[i]\n\t\ti += 1\n\tres += total * vert\n\ttotal = 0\n\twhile (j < n):\n\t\ttotal += Y[j]\n\t\tj += 1\n\tres += total * hzntl\n\treturn res", "5865": "def getMin(x, y, z):\n\treturn min(min(x, y), z)\ndef editDistance(str1, str2, m, n):\n\tdp = [[0 for i in range(n + 1)] for j in range(m + 1)]\n\tfor i in range(0, m + 1):\n\t\tfor j in range(0, n + 1):\n\t\t\tif (i == 0):\n\t\t\t\tdp[i][j] = j\n\t\t\telif (j == 0):\n\t\t\t\tdp[i][j] = i\n\t\t\telif (str1[i - 1] == str2[j - 1]):\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1]\n\t\t\telse:\n\t\t\t\tdp[i][j] = 1 + getMin( dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n\treturn dp[m][n]\ndef minimumSteps(S, N):\n\tans = 10**10\n\tfor i in range(1, N):\n\t\tS1 = S[:i]\n\t\tS2 = S[i:]\n\t\tcount = editDistance(S1, S2, len(S1), len(S2))\n\t\tans = min(ans, count)\n\tprint(ans)", "5872": "def minimumOperations(N):\n\tdp = [0 for i in range(N + 1)]\n\tfor i in range(N+1):\n\t\tdp[i] = 1000000000\n\tdp[2] = 0\n\tfor i in range(2,N+1,1):\n\t\tif (dp[i] == 1000000000):\n\t\t\tcontinue\n\t\tif (i * 5 <= N):\n\t\t\tdp[i * 5] = min(dp[i * 5], dp[i] + 1)\n\t\tif (i + 3 <= N):\n\t\t\tdp[i + 3] = min(dp[i + 3], dp[i] + 1)\n\tif (dp[N] == 1000000000):\n\t\treturn -1\n\treturn dp[N]", "5880": "def MaxProfit(arr, n, transactionFee):\n\tbuy = -arr[0]\n\tsell = 0\n\tfor i in range(1, n, 1):\n\t\ttemp = buy\n\t\tbuy = max(buy, sell - arr[i])\n\t\tsell = max(sell, temp + arr[i] - transactionFee)\n\treturn max(sell, buy)", "5904": "def countPossiblities(arr, n):\n\tlastOccur = [-1] * 100000\n\tdp = [0] * (n + 1)\n\tdp[0] = 1\n\tfor i in range(1, n + 1):\n\t\tcurEle = arr[i - 1]\n\t\tdp[i] = dp[i - 1]\n\t\tif (lastOccur[curEle] != -1 and lastOccur[curEle] < i - 1):\n\t\t\tdp[i] += dp[lastOccur[curEle]]\n\t\tlastOccur[curEle] = i\n\tprint(dp[n])", "5919": "def longestSubSequence(A, N, ind=0, lastf=-sys.maxsize-1, lasts=sys.maxsize):\n\tif (ind == N):\n\t\treturn 0\n\tans = longestSubSequence(A, N, ind + 1, lastf, lasts)\n\tif (A[ind][0] > lastf and A[ind][1] < lasts):\n\t\tans = max(ans, longestSubSequence(A, N, ind + 1, A[ind][0], A[ind][1]) + 1)\n\treturn ans", "5920": "def longestSubSequence(A, N):\n\tdp = [0]*N\n\tfor i in range(N):\n\t\tdp[i] = 1\n\t\tfor j in range(i):\n\t\t\tif (A[j][0] < A[i][0] and A[j][1] > A[i][1]):\n\t\t\t\tdp[i] = max(dp[i], dp[j] + 1)\n\tprint (dp[N - 1])", "5924": "def calculateStart(n, m):\n\tfor i in range(1, m, 1):\n\t\tstart[0][i] += start[0][i - 1]\n\tfor i in range(1, n, 1):\n\t\tstart[i][0] += start[i - 1][0]\n\tfor i in range(1, n, 1):\n\t\tfor j in range(1, m, 1):\n\t\t\tstart[i][j] += max(start[i - 1][j], start[i][j - 1])\ndef calculateEnd(n, m):\n\ti = n - 2\n\twhile(i >= 0):\n\t\tending[i][m - 1] += ending[i + 1][m - 1]\n\t\ti -= 1\n\ti = m - 2\n\twhile(i >= 0):\n\t\tending[n - 1][i] += ending[n - 1][i + 1]\n\t\ti -= 1\n\ti = n - 2\n\twhile(i >= 0):\n\t\tj = m - 2\n\t\twhile(j >= 0):\n\t\t\tending[i][j] += max(ending[i + 1][j], ending[i][j + 1])\n\t\t\tj -= 1\n\t\ti -= 1\ndef maximumPathSum(mat, n, m, q, coordinates):\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tstart[i][j] = mat[i][j]\n\t\t\tending[i][j] = mat[i][j]\n\tcalculateStart(n, m)\n\tcalculateEnd(n, m)\n\tans = 0\n\tfor i in range(q):\n\t\tX = coordinates[i][0] - 1\n\t\tY = coordinates[i][1] - 1\n\t\tans = max(ans, start[X][Y] + ending[X][Y] - mat[X][Y])\n\tprint(ans)", "5946": "def MaxSubsetlength(arr, A, B):\n\tdp = [[0 for i in range(B + 1)] for i in range(A + 1)]\n\tfor str in arr:\n\t\tzeros = str.count('0')\n\t\tones = str.count('1')\n\t\tfor i in range(A, zeros - 1, -1):\n\t\t\tfor j in range(B, ones - 1, -1):\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n\treturn dp[A][B]", "5957": "def numOfWays(a, n, i = 0, blue = []):\n\tif i == n:\n\t\treturn 1\n\tcount = 0\n\tfor j in range(n):\n\t\tif mat[i][j] == 1 and j not in blue:\n\t\t\tcount += numOfWays(mat, n, i + 1, blue + [j])\n\treturn count", "5970": "def minCost(arr, n):\n\tif (n < 3):\n\t\tprint(arr[0])\n\t\treturn\n\tdp = [0] * n\n\tdp[0] = arr[0]\n\tdp[1] = dp[0] + arr[1] + arr[2]\n\tfor i in range(2, n - 1):\n\t\tdp[i] = min(dp[i - 2] + arr[i], dp[i - 1] + arr[i] + arr[i + 1])\n\tdp[n - 1] = min(dp[n - 2], dp[n - 3] + arr[n - 1])\n\tprint(dp[n - 1])", "5995": "def power(X, Y):\n\tres = 1\n\tX = X % M\n\tif (X == 0):\n\t\treturn 0\n\twhile (Y > 0):\n\t\tif (Y & 1):\n\t\t\tres = (res * X) % M\n\t\tY = Y >> 1\n\t\tX = (X * X) % M\n\treturn res\ndef findValue(n):\n\tX = 0\n\tpow_10 = 1\n\twhile(n):\n\t\tif (n & 1):\n\t\t\tX += pow_10\n\t\tpow_10 *= 10\n\t\tn //= 2\n\tX = (X * 2) % M\n\tres = power(2, X)\n\treturn res", "5996": "def power(X, Y):\n\tres = 1;\n\tX = X % M;\n\tif (X == 0):\n\t\treturn 0;\n\twhile (Y > 0):\n\t\tif (Y % 2 == 1):\n\t\t\tres = (res * X) % M;\n\t\tY = Y >> 1;\n\t\tX = (X * X) % M;\n\treturn res;\ndef findValue(N):\n\tdp = [0]*(N + 1);\n\tdp[1] = 2;\n\tdp[2] = 1024;\n\tfor i in range(3, N + 1):\n\t\ty = (i & (-i));\n\t\tx = i - y;\n\t\tif (x == 0):\n\t\t\tdp[i] = power(dp[i // 2], 10);\n\t\telse:\n\t\t\tdp[i] = (dp[x] * dp[y]) % M;\n\treturn (dp[N] * dp[N]) % M;", "6000": "def countTriplets(A) :\n\tcnt = 0;\n\ttuples = {};\n\tfor a in A:\n\t\tfor b in A:\n\t\t\tif (a & b) in tuples:\n\t\t\t\ttuples[a & b] += 1;\t\t\t\n\t\t\telse:\n\t\t\t\ttuples[a & b] = 1;\n\tfor a in A:\n\t\tfor t in tuples:\n\t\t\tif ((t & a) == 0):\n\t\t\t\tcnt += tuples[t];\n\treturn cnt;", "6021": "def findMinimum(a, n, pos, myturn):\n\tif (pos, myturn) in m:\n\t\treturn m[( pos, myturn )];\n\tif (pos >= n - 1):\n\t\treturn 0;\n\tif (not myturn):\n\t\tans = min( findMinimum(a, n, pos + 1, not myturn) + a[pos],\n\t\t\t\t\tfindMinimum(a, n, pos + 2, not myturn) + a[pos] + a[pos + 1]);\n\t\tm[( pos, myturn )] = ans;\n\t\treturn ans;\n\tif (myturn):\n\t\tans = min( findMinimum(a, n, pos + 1, not myturn),\n\t\t\t\t\tfindMinimum(a, n, pos + 2, not myturn));\n\t\tm[( pos, myturn )] = ans;\n\t\treturn ans;\n\treturn 0;\ndef countPenality(arr, N):\n\tpos = 0;\n\tturn = False;\n\treturn findMinimum(arr, N, pos, turn) + 1;\ndef printAnswer(arr, N):\n\ta = countPenality(arr, N);\n\tsum = 0;\n\tfor i in range(N):\n\t\tsum += arr[i];\n\tprint(a)", "6028": "def maxSum(arr, n, m):\n\tdp = [[0 for i in range(m + 1)] for i in range(2)]\n\tdp[0][m - 1] = arr[0][m - 1]\n\tdp[1][m - 1] = arr[1][m - 1]\n\tfor j in range(m - 2, -1, -1):\n\t\tfor i in range(2):\n\t\t\tif (i == 1):\n\t\t\t\tdp[i][j] = max(arr[i][j] + dp[0][j + 1], arr[i][j] + dp[0][j + 2])\n\t\t\telse:\n\t\t\t\tdp[i][j] = max(arr[i][j] + dp[1][j + 1], arr[i][j] + dp[1][j + 2])\n\tprint(max(dp[0][0], dp[1][0]))", "6029": "def maxSum(arr, n):\n\tr1 = r2 = 0\n\tfor i in range(n):\n\t\tr1, r2 = max(r1, r2 + arr[0][i]), max(r2, r1 + arr[1][i])\n\tprint(max(r1, r2))", "6065": "def Max_Sum(arr, K, N):\n\tdp = [0] * (N + 1)\n\tprefix = [None] * (N + 1)\n\tprefix[0] = 0\n\tfor i in range(1, N + 1):\n\t\tprefix[i] = prefix[i - 1] + arr[i - 1]\n\tdp[0] = 0\n\tfor i in range(1, K):\n\t\tdp[i] = prefix[i]\n\tfor i in range(K, N + 1):\n\t\tfor j in range(i, i - K, -1):\n\t\t\tdp[i] = max(dp[i], dp[j - 1] + prefix[i] - prefix[j])\n\treturn dp[N]", "6068": "def Calculate_factorial():\n\tfact[0] = 1\n\tfor i in range(1, mx + 1):\n\t\tfact[i] = i * fact[i - 1]\n\t\tfact[i] %= mod\ndef UniModal_per(a, b):\n\tres = 1\n\twhile (b != 0):\n\t\tif (b % 2 != 0):\n\t\t\tres = res * a\n\t\tres %= mod\n\t\ta = a * a\n\t\ta %= mod\n\t\tb //= 2\n\treturn res\ndef countPermutations(n):\n\tCalculate_factorial()\n\tuni_modal = UniModal_per(2, n - 1)\n\tnonuni_modal = fact[n] - uni_modal\n\tprint(int(uni_modal), \"\",\n\t\tint(nonuni_modal))\n\treturn", "6071": "def findWays(N):\n\tif (N == 0):\n\t\treturn 1\n\tcnt = 0\n\tfor i in range(1, 7):\n\t\tif (N - i >= 0):\n\t\t\tcnt = cnt + findWays(N - i)\n\treturn cnt", "6072": "def findWays(N, dp):\n\tif (N == 0):\n\t\treturn 1\n\tif (dp[N] != -1):\n\t\treturn dp[N]\n\tcnt = 0\n\tfor i in range (1, 7):\n\t\tif (N - i >= 0):\n\t\t\tcnt = (cnt +\n\t\t\t\tfindWays(N - i, dp))\n\tdp[N] = cnt\n\treturn dp[N]", "6073": "def findWays(N):\n\tdp = [0] * (N + 1);\n\tdp[0] = 1;\n\tfor i in range(1, N + 1):\n\t\tdp[i] = 0;\n\t\tfor j in range(1, 7):\n\t\t\tif (i - j >= 0):\n\t\t\t\tdp[i] = dp[i] + dp[i - j];\n\tprint(dp[N]);", "6082": "def checkEqualSumUtil(arr, N, sm1, sm2, sm3, j):\n\tif j == N:\n\t\tif sm1 == sm2 and sm2 == sm3:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\telse:\n\t\tl = checkEqualSumUtil(arr, N, sm1 + arr[j], sm2, sm3, j + 1)\n\t\tm = checkEqualSumUtil(arr, N, sm1, sm2 + arr[j], sm3, j + 1)\n\t\tr = checkEqualSumUtil(arr, N, sm1, sm2, sm3 + arr[j], j + 1)\n\t\treturn max(l, m, r)\ndef checkEqualSum(arr, N):\n\tsum1 = sum2 = sum3 = 0\n\tif checkEqualSumUtil(arr, N, sum1, sum2, sum3, 0) == 1:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "6083": "def checkEqualSumUtil(arr, N, sm1, sm2, sm3, j):\n\ts = str(sm1) + \"_\" + str(sm2) + str(j)\n\tif j == N:\n\t\tif sm1 == sm2 and sm2 == sm3:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\tif s in dp:\n\t\treturn dp[s]\n\tl = checkEqualSumUtil(arr, N, sm1 + arr[j], sm2, sm3, j + 1)\n\tm = checkEqualSumUtil(arr, N, sm1, sm2 + arr[j], sm3, j + 1)\n\tr = checkEqualSumUtil(arr, N, sm1, sm2, sm3 + arr[j], j + 1)\n\tdp[s] = max(l, m, r)\n\treturn dp[s]\ndef checkEqualSum(arr, N):\n\tsum1 = sum2 = sum3 = 0\n\tif checkEqualSumUtil(arr, N, sum1, sum2, sum3, 0) == 1:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "6113": "def SieveOfEratosthenes():\n\tp = 2\n\twhile p * p <= MAX:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, MAX, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\ndef getMid(s, e):\n\treturn s + (e - s) // 2\ndef getSumUtil(st, ss, se, qs, qe, si):\n\tif qs <= ss and qe >= se:\n\t\treturn st[si]\n\tif se < qs or ss > qe:\n\t\treturn 0\n\tmid = getMid(ss, se)\n\treturn (getSumUtil(st, ss, mid, qs, qe, 2 * si + 1) +\n\t\t\tgetSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2))\ndef updateValueUtil(st, ss, se, i, diff, si):\n\tif i < ss or i > se:\n\t\treturn\n\tst[si] = st[si] + diff\n\tif se != ss:\n\t\tmid = getMid(ss, se)\n\t\tupdateValueUtil(st, ss, mid, i, diff, 2 * si + 1)\n\t\tupdateValueUtil(st, mid + 1, se, i, diff, 2 * si + 2)\ndef updateValue(arr, st, n, i, new_val):\n\tif i < 0 or i > n - 1:\n\t\tprint(-1)\n\t\treturn\n\tdiff = new_val - arr[i]\n\tprev_val = arr[i]\n\tarr[i] = new_val\n\tif prime[new_val] or prime[prev_val]:\n\t\tif not prime[prev_val]:\n\t\t\tupdateValueUtil(st, 0, n - 1, i, new_val, 0)\n\t\telif not prime[new_val]:\n\t\t\tupdateValueUtil(st, 0, n - 1, i, -prev_val, 0)\n\t\telse:\n\t\t\tupdateValueUtil(st, 0, n - 1, i, diff, 0)\ndef getSum(st, n, qs, qe):\n\tif qs < 0 or qe > n-1 or qs > qe:\n\t\treturn -1\n\treturn getSumUtil(st, 0, n - 1, qs, qe, 0)\ndef constructSTUtil(arr, ss, se, st, si):\n\tif ss == se:\n\t\tif prime[arr[ss]]:\n\t\t\tst[si] = arr[ss]\n\t\telse:\n\t\t\tst[si] = 0\n\t\treturn st[si]\n\tmid = getMid(ss, se)\n\tst[si] = (constructSTUtil(arr, ss, mid, st, 2 * si + 1) +\n\t\t\tconstructSTUtil(arr, mid + 1, se, st, 2 * si + 2))\n\treturn st[si]\ndef constructST(arr, n):\n\tx = int(math.ceil(math.log2(n)))\n\tmax_size = 2 * int(pow(2, x)) - 1\n\tst = [0] * max_size\n\tconstructSTUtil(arr, 0, n - 1, st, 0)\n\treturn st", "6138": "def precompute(nextpos, arr, N):\n\tnextpos[N - 1] = N\n\tfor i in range(N - 2, -1, -1):\n\t\tif arr[i] == arr[i + 1]:\n\t\t\tnextpos[i] = nextpos[i + 1]\n\t\telse:\n\t\t\tnextpos[i] = i + 1\ndef findIndex(query, arr, N, Q):\n\tnextpos = [0] * N\n\tprecompute(nextpos, arr, N)\n\tfor i in range(Q):\n\t\tl = query[i][0]\n\t\tr = query[i][1]\n\t\tx = query[i][2]\n\t\tans = -1\n\t\tif arr[l] != x:\n\t\t\tans = l\n\t\telse:\n\t\t\td = nextpos[l]\n\t\t\tif d <= r:\n\t\t\t\tans = d\n\t\tprint(ans)", "6151": "def countWays(s, t, k):\n\tn = len(s)\n\ta = 0\n\tb = 0\n\tfor i in range(n):\n\t\tp = s[i : n - i + 1] + s[: i + 1]\n\t\tif(p == t):\n\t\t\ta += 1\n\t\telse:\n\t\t\tb += 1\n\tdp1 = [0] * (k + 1)\n\tdp2 = [0] * (k + 1)\n\tif(s == t):\n\t\tdp1[0] = 1\n\t\tdp2[0] = 0\n\telse:\n\t\tdp1[0] = 0\n\t\tdp2[0] = 1\n\tfor i in range(1, k + 1):\n\t\tdp1[i] = ((dp1[i - 1] * (a - 1)) % mod +\n\t\t\t\t(dp2[i - 1] * a) % mod) % mod\n\t\tdp2[i] = ((dp1[i - 1] * (b)) % mod +\n\t\t\t\t(dp2[i - 1] * (b - 1)) % mod) % mod\n\treturn(dp1[k])", "6169": "def insert(idx, s, root):\n\ttemp = root\n\tfor i in range(idx, len(s)):\n\t\tif temp.child[ord(s[i]) - ord('a')] == None:\n\t\t\ttemp.child[ord(s[i]) - ord('a')] = TrieNode()\n\t\ttemp = temp.child[ord(s[i]) - ord('a')]\ndef minCuts(S1, S2):\n\tn1 = len(S1)\n\tn2 = len(S2)\n\troot = TrieNode()\n\tfor i in range(n2):\n\t\tinsert(i, S2, root)\n\tdp = [INF] * (n1 + 1)\n\tdp[0] = 0\n\tfor i in range(n1):\n\t\ttemp = root\n\t\tfor j in range(i + 1, n1 + 1):\n\t\t\tif temp.child[ord(S1[j - 1]) - ord('a')] == None:\n\t\t\t\tbreak\n\t\t\tdp[j] = min(dp[j], dp[i] + 1)\n\t\t\ttemp = temp.child[ord(S1[j - 1]) - ord('a')]\n\tif dp[n1] >= INF:\n\t\treturn -1\n\telse:\n\t\treturn dp[n1]\ndef __init__(self):\n\t\tself.child = [None] * 26", "6174": "def minOperation(k):\n\tdp = [0] * (k + 1)\n\tfor i in range(1, k + 1):\n\t\tdp[i] = dp[i - 1] + 1\n\t\tif (i % 2 == 0):\n\t\t\tdp[i]= min(dp[i], dp[i // 2] + 1)\n\treturn dp[k]", "6181": "def longestSubseq(s, length):\n\tones = [0 for i in range(length + 1)]\n\tzeroes = [0 for i in range(length + 1)]\n\tfor i in range(length):", "6209": "def largestSquare(matrix, R, C, q_i, q_j, K, Q): \n\tfor q in range(Q): \n\t\ti = q_i[q] \n\t\tj = q_j[q] \n\t\tmin_dist = min(min(i, j), \n\t\t\t\tmin(R - i - 1, C - j - 1)) \n\t\tans = -1\n\t\tfor k in range(min_dist + 1):\n\t\t\tcount = 0\n\t\t\tfor row in range(i - k, i + k + 1): \n\t\t\t\tfor col in range(j - k, j + k + 1): \n\t\t\t\t\tcount += matrix[row][col] \n\t\t\tif count > K: \n\t\t\t\tbreak\n\t\t\tans = 2 * k + 1\n\t\tprint(ans)", "6210": "def largestSquare(matrix, R, C, q_i, q_j, K, Q):\n\tcountDP = [[0 for x in range(C)] for x in range(R)] \n\tcountDP[0][0] = matrix[0][0] \n\tfor i in range(1, R):\n\t\tcountDP[i][0] = (countDP[i - 1][0] + matrix[i][0])\n\tfor j in range(1, C):\n\t\tcountDP[0][j] = (countDP[0][j - 1] + matrix[0][j])\n\tfor i in range(1, R):\n\t\tfor j in range(1, C):\n\t\t\tcountDP[i][j] = (matrix[i][j] + countDP[i - 1][j] + countDP[i][j - 1] - countDP[i - 1][j - 1])\n\tfor q in range(0, Q):\n\t\ti = q_i[q]\n\t\tj = q_j[q]\n\t\tmin_dist = min(i, j, R - i - 1, C - j - 1)\n\t\tans = -1\n\t\tfor k in range(0, min_dist + 1): \n\t\t\tx1 = i - k\n\t\t\tx2 = i + k\n\t\t\ty1 = j - k\n\t\t\ty2 = j + k \n\t\t\tcount = countDP[x2][y2]; \n\t\t\tif (x1 > 0): \n\t\t\t\t\tcount -= countDP[x1 - 1][y2]\n\t\t\tif (y1 > 0):\n\t\t\t\t\tcount -= countDP[x2][y1 - 1]\n\t\t\tif (x1 > 0 and y1 > 0):\n\t\t\t\t\tcount += countDP[x1 - 1][y1 - 1]\n\t\t\tif (count > K):\n\t\t\t\t\tbreak\n\t\t\tans = 2 * k + 1\n\t\tprint(ans)", "6211": "def largestSquare(matrix, R, C, q_i, q_j, K, Q):\n\tcountDP = [[0 for x in range(C)] for x in range(R)] \n\tcountDP[0][0] = matrix[0][0] \n\tfor i in range(1, R):\n\t\tcountDP[i][0] = (countDP[i - 1][0] + matrix[i][0])\n\tfor j in range(1, C):\n\t\tcountDP[0][j] = (countDP[0][j - 1] + matrix[0][j])\n\tfor i in range(1, R):\n\t\tfor j in range(1, C):\n\t\t\tcountDP[i][j] = (matrix[i][j] + countDP[i - 1][j] + countDP[i][j - 1] - countDP[i - 1][j - 1])\n\tfor q in range(0,Q):\n\t\ti = q_i[q]\n\t\tj = q_j[q]\n\t\tmin_dist = min(i, j, R - i - 1, C - j - 1)\n\t\tans = -1\n\t\tl = 0\n\t\tu = min_dist\n\t\twhile (l <= u):\n\t\t\tmid = int((l + u) / 2) \n\t\t\tx1 = i - mid\n\t\t\tx2 = i + mid \n\t\t\ty1 = j - mid\n\t\t\ty2 = j + mid \n\t\t\tcount = countDP[x2][y2]\n\t\t\tif (x1 > 0):\n\t\t\t\t\tcount -= countDP[x1 - 1][y2] \n\t\t\tif (y1 > 0):\n\t\t\t\t\tcount -= countDP[x2][y1 - 1]\n\t\t\tif (x1 > 0 and y1 > 0): \n\t\t\t\t\tcount += countDP[x1 - 1][y1 - 1]\n\t\t\tif (count <= K): \n\t\t\t\t\tans = 2 * mid + 1\n\t\t\t\t\tl = mid + 1\n\t\t\telse:\n\t\t\t\tu = mid - 1\n\t\tprint(ans)", "6241": "def count_special(n):\n\tfib = [0 for i in range(n + 1)]\n\tfib[0] = 1\n\tfib[1] = 2\n\tfor i in range(2, n + 1, 1):\n\t\tfib[i] = (fib[i - 1] % mod + fib[i - 2] % mod) % mod\n\treturn fib[n]", "6273": "def maxSum(p0, p1, a, pos, n) :\n\tif (pos == n) :\n\t\tif (p0 == p1) :\n\t\t\treturn p0;\n\t\telse :\n\t\t\treturn 0;\n\tans = maxSum(p0, p1, a, pos + 1, n);\n\tans = max(ans, maxSum(p0 + a[pos], p1, a, pos + 1, n));\n\tans = max(ans, maxSum(p0, p1 + a[pos], a, pos + 1, n));\n\treturn ans;", "6274": "def maxSum(a, n) :\n\tsum = 0;\n\tfor i in range(n) :\n\t\tsum += a[i];\n\tlimit = 2 * sum + 1;\n\tdp = np.zeros((n + 1,limit));\n\tfor i in range(n + 1) :\n\t\tfor j in range(limit) :\n\t\t\tdp[i][j] = INT_MIN;\n\tdp[0][sum] = 0;\n\tfor i in range(1, n + 1) :\n\t\tfor j in range(limit) :\n\t\t\tif ((j - a[i - 1]) >= 0 and dp[i - 1][j - a[i - 1]] != INT_MIN) :\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j - a[i - 1]] + a[i - 1]);\n\t\t\tif ((j + a[i - 1]) < limit and dp[i - 1][j + a[i - 1]] != INT_MIN) :\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j + a[i - 1]]);\n\t\t\tif (dp[i - 1][j] != INT_MIN) :\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j]);\n\treturn dp[n][sum];", "6281": "def calculate(pos, prev, s,index):\n\tif (pos == len(s)):\n\t\treturn 1\n\tif (dp[pos][prev] != -1):\n\t\treturn dp[pos][prev]\n\tc = ord(s[pos]) - ord('a');\n\tanswer = 0\n\tfor i in range(len(index)):\n\t\tif (index[i] > prev):\n\t\t\tanswer = (answer % mod + calculate(pos + 1,index[i], s, index) % mod) % mod\n\tdp[pos][prev] = 4\n\treturn dp[pos][prev]\ndef countWays(a, s):\n\tn = len(a)\n\tindex = [[] for i in range(26)]\n\tfor i in range(n):\n\t\tfor j in range(len(a[i])):\n\t\t\tindex[ord(a[i][j]) - ord('a')].append(j + 1);\n\treturn calculate(0, 0, s, index[0])", "6289": "def computeFibonacci() :\n\tfib[0] = 1;\n\tfib[1] = 1;\n\tfor i in range(2, 100005) :\n\t\tfib[i] = fib[i - 1] + fib[i - 2];\ndef countString(string) :\n\tans = 1;\n\tcnt = 1;\n\tfor i in range(1, len(string)) :\n\t\tif (string[i] == string[i - 1]) :\n\t\t\tcnt += 1;\n\t\telse :\n\t\t\tans = ans * fib[cnt];\n\t\t\tcnt = 1;\n\tans = ans * fib[cnt];\n\treturn ans;", "6298": "def printGolombSequence(N):\n\tarr = [0] * MAX\n\tcnt = 0\n\tarr[0] = 0\n\tarr[1] = 1\n\tM = dict()\n\tM[2] = 2\n\tfor i in range(2, N + 1):\n\t\tif (cnt == 0):\n\t\t\tarr[i] = 1 + arr[i - 1]\n\t\t\tcnt = M[arr[i]]\n\t\t\tcnt -= 1\n\t\telse:\n\t\t\tarr[i] = arr[i - 1]\n\t\t\tcnt -= 1\n\t\tM[i] = arr[i]\n\tfor i in range(1, N + 1):\n\t\tprint(arr[i], end=\" \")", "6299": "def number_of_ways(n):\n\tincludes_3 = [0]*(n + 1)\n\tnot_includes_3 = [0] * (n + 1)\n\tincludes_3[3] = 1\n\tnot_includes_3[1] = 1\n\tnot_includes_3[2] = 2\n\tnot_includes_3[3] = 3\n\tfor i in range(4, n + 1):\n\t\tincludes_3[i] = includes_3[i - 1] + \\\n\t\t\t\t\t\tincludes_3[i - 2] + \\\n\t\t\t\t\t\tnot_includes_3[i - 3]\n\t\tnot_includes_3[i] = not_includes_3[i - 1] + \\\n\t\t\t\t\t\tnot_includes_3[i - 2]\n\treturn includes_3[n]", "6301": "def generateDivisors(n):\n\tfor i in range(1,ceil(sqrt(n)) + 1):\n\t\tif (n % i == 0):\n\t\t\tif (n // i == i):\n\t\t\t\tdivisors[i]+=1\n\t\t\telse:\n\t\t\t\tdivisors[i] += 1\n\t\t\t\tdivisors[n // i] += 1\ndef findMaxMultiples(arr, n):\n\tans = 0\n\tfor i in range(n):\n\t\tans = max(divisors[arr[i]], ans)\n\t\tgenerateDivisors(arr[i])\n\treturn ans", "6335": "def countNum(idx, sum, tight, num, len1, k):\n\tif (len1 == idx):\n\t\tif (sum == 0):\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\tif (dp[idx][sum][tight] != -1):\n\t\treturn dp[idx][sum][tight]\n\tres = 0\n\tif (tight == 0):\n\t\tlimit = num[idx]\n\telse:\n\t\tlimit = 9\n\tfor i in range(limit + 1):\n\t\tnew_tight = tight\n\t\tif (tight == 0 and i < limit):\n\t\t\tnew_tight = 1\n\t\tres += countNum(idx + 1,(sum + i) % k, new_tight, num, len1, k)\n\t\tres %= MOD\n\tif (res < 0):\n\t\tres += MOD\n\tdp[idx][sum][tight] = res\n\treturn dp[idx][sum][tight]\ndef process(s):\n\tnum = []\n\tfor i in range(len(s)):\n\t\tnum.append(ord(s[i]) - ord('0'))\n\treturn num", "6346": "def MinCost(arr, n):\n\tdp = [[0 for i in range(n + 5)] for i in range(n + 5)]\n\tsum = [[0 for i in range(n + 5)] for i in range(n + 5)]\n\tfor i in range(n):\n\t\tk = arr[i]\n\t\tfor j in range(i, n):\n\t\t\tif (i == j):\n\t\t\t\tsum[i][j] = k\n\t\t\telse:\n\t\t\t\tk += arr[j]\n\t\t\t\tsum[i][j] = k\n\tfor i in range(n - 1, -1, -1):\n\t\tfor j in range(i, n):\n\t\t\tdp[i][j] = 10**9\n\t\t\tif (i == j):\n\t\t\t\tdp[i][j] = 0\n\t\t\telse :\n\t\t\t\tfor k in range(i, j):\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[i][j])\n\treturn dp[0][n - 1]", "6364": "def f(i, state, A, dp, N):\n\tif i >= N:\n\t\treturn 0\n\telif dp[i][state] != -1:\n\t\treturn dp[i][state]\n\telse:\n\t\tif i == N - 1:\n\t\t\tdp[i][state] = 1\n\t\telif state == 1 and A[i] > A[i + 1]:\n\t\t\tdp[i][state] = 1\n\t\telif state == 2 and A[i] < A[i + 1]:\n\t\t\tdp[i][state] = 1\n\t\telif state == 1 and A[i] <= A[i + 1]:\n\t\t\tdp[i][state] = 1 + f(i + 1, 2, A, dp, N)\n\t\telif state == 2 and A[i] >= A[i + 1]:\n\t\t\tdp[i][state] = 1 + f(i + 1, 1, A, dp, N)\n\t\treturn dp[i][state]\ndef maxLenSeq(A, N):\n\tdp = [[-1, -1, -1] for i in range(1000)]\n\tfor i in range(N):\n\t\ttmp = f(i, 1, A, dp, N)\n\t\ttmp = f(i, 2, A, dp, N)\n\tans = -1\n\tfor i in range(N):\n\t\ty = dp[i][1]\n\t\tif (i + y) >= N:\n\t\t\tans = max(ans, dp[i][1] + 1)\n\t\telif y % 2 == 0:\n\t\t\tans = max(ans, dp[i][1] + 1 + dp[i + y][2])\n\t\telif y % 2 == 1:\n\t\t\tans = max(ans, dp[i][1] + 1 + dp[i + y][1])\n\treturn ans", "6380": "def ways(i, arr, n):\n\tif (i == n - 1):\n\t\treturn 1;\n\tsum = 0;\n\tfor j in range(1, arr[i] + 1):\n\t\tif(i + j < n):\n\t\t\tsum += (ways(i + j, arr, n)) % mod;\n\t\t\tsum %= mod;\n\treturn int(sum % mod);", "6381": "def ways(arr, n):\n\tdp = [0] * (n + 1)\n\tdp[n - 1] = 1\n\tfor i in range(n - 2, -1, -1):\n\t\tdp[i] = 0\n\t\tj = 1\n\t\twhile((j + i) < n and j <= arr[i]):\n\t\t\tdp[i] += dp[i + j]\n\t\t\tdp[i] %= mod\n\t\t\tj += 1\n\treturn dp[0] % mod", "6386": "def countSum(arr, n):\n\tresult = 0\n\tcount_odd = 0\n\tcount_even = 0\n\tfor i in range(1, n + 1):\n\t\tif (arr[i - 1] % 2 == 0):\n\t\t\tcount_even = count_even + count_even + 1\n\t\t\tcount_odd = count_odd + count_odd\n\t\telse:\n\t\t\ttemp = count_even\n\t\t\tcount_even = count_even + count_odd\n\t\t\tcount_odd = count_odd + temp + 1\n\treturn (count_even, count_odd)", "6395": "def MaxGCD(a, n):\n\tPrefix=[0 for i in range(n + 2)]\n\tSuffix=[0 for i in range(n + 2)]\n\tPrefix[1] = a[0]\n\tfor i in range(2,n+1):\n\t\tPrefix[i] = mt.gcd(Prefix[i - 1], a[i - 1])\n\tSuffix[n] = a[n - 1]\n\tfor i in range(n-1,0,-1):\n\t\tSuffix[i] =mt.gcd(Suffix[i + 1], a[i - 1])\n\tans = max(Suffix[2], Prefix[n - 1])\n\tfor i in range(2,n):\n\t\tans = max(ans, mt.gcd(Prefix[i - 1], Suffix[i + 1]))\n\treturn ans", "6396": "def numToVec(N):\n\tdigit = []\n\twhile (N != 0):\n\t\tdigit.append(N % 10)\n\t\tN = N // 10\n\tif (len(digit) == 0):\n\t\tdigit.append(0)\n\tdigit = digit[::-1]\n\treturn digit\ndef solve(A, B, C):\n\td, d2 = 0,0\n\tdigit = numToVec(C)\n\td = len(A)\n\tif (B > len(digit) or d == 0):\n\t\treturn 0\n\telif (B < len(digit)):\n\t\tif (A[0] == 0 and B != 1):\n\t\t\treturn (d - 1) * pow(d, B - 1)\n\t\telse:\n\t\t\treturn pow(d, B)\n\telse :\n\t\tdp=[0 for i in range(B + 1)]\n\t\tlower=[0 for i in range(MAX + 1)]\n\t\tfor i in range(d):\n\t\t\tlower[A[i] + 1] = 1\n\t\tfor i in range(1, MAX+1):\n\t\t\tlower[i] = lower[i - 1] + lower[i]\n\t\tflag = True\n\t\tdp[0] = 0\n\t\tfor i in range(1, B+1):\n\t\t\td2 = lower[digit[i - 1]]\n\t\t\tdp[i] = dp[i - 1] * d\n\t\t\tif (i == 1 and A[0] == 0 and B != 1):\n\t\t\t\td2 = d2 - 1\n\t\t\tif (flag):\n\t\t\t\tdp[i] += d2\n\t\t\tflag = (flag & (lower[digit[i - 1] + 1] == lower[digit[i - 1]] + 1))\n\t\treturn dp[B]", "6442": "def countWays(i, j, x, arr):\n\tif (i == n or j == n):\n\t\treturn 0\n\tx = (x & arr[i][j])\n\tif (x == 0):\n\t\treturn 0\n\tif (i == n - 1 and j == n - 1):\n\t\treturn 1\n\tif (v[i][j][x]):\n\t\treturn dp[i][j][x]\n\tv[i][j][x] = 1\n\tdp[i][j][x] = countWays(i + 1, j, x, arr) + \\\n\t\t\t\tcountWays(i, j + 1, x, arr);\n\treturn dp[i][j][x]", "6454": "def pre_process(dp, s):\n\tn = len(s)\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tdp[i][j] = False\n\tfor j in range(1, n + 1):\n\t\tfor i in range(n - j + 1):\n\t\t\tif (j <= 2):\n\t\t\t\tif (s[i] == s[i + j - 1]):\n\t\t\t\t\tdp[i][i + j - 1] = True\n\t\t\telif (s[i] == s[i + j - 1]):\n\t\t\t\tdp[i][i + j - 1] = dp[i + 1][i + j - 2]\ndef countPairs(s):\n\tdp = [[False for i in range(N)] for j in range(N)]\n\tpre_process(dp, s)\n\tn = len(s)\n\tleft = [0 for i in range(n)]\n\tright = [0 for i in range(n)]\n\tleft[0] = 1\n\tfor i in range(1, n):\n\t\tfor j in range(i + 1):\n\t\t\tif (dp[j][i] == 1):\n\t\t\t\tleft[i] += 1\n\tright[n - 1] = 1\n\tfor i in range(n - 2, -1, -1):\n\t\tright[i] = right[i + 1]\n\t\tfor j in range(n - 1, i - 1, -1):\n\t\t\tif (dp[i][j] == 1):\n\t\t\t\tright[i] += 1\n\tans = 0\n\tfor i in range(n - 1):\n\t\tans += left[i] * right[i + 1]\n\treturn ans", "6469": "def FindMaximumSum(ind, kon, a, b, c, n, dp):\n\tif ind == n:\n\t\treturn 0\n\tif dp[ind][kon] != -1:\n\t\treturn dp[ind][kon]\n\tans = -10 ** 9 + 5\n\tif kon == 0:\n\t\tans = max(ans, b[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 1, a, b, c, n, dp))\n\t\tans = max(ans, c[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 2, a, b, c, n, dp))\n\telif kon == 1:\n\t\tans = max(ans, a[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 0, a, b, c, n, dp))\n\t\tans = max(ans, c[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 2, a, b, c, n, dp))\n\telif kon == 2:\n\t\tans = max(ans, a[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 1, a, b, c, n, dp))\n\t\tans = max(ans, b[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 0, a, b, c, n, dp))\n\tdp[ind][kon] = ans\n\treturn ans", "6471": "def noOfBinaryStrings(N, k) :\n\tdp = [0] * 100002;\n\tfor i in range(1, K) :\n\t\tdp[i] = 1;\n\tdp[k] = 2;\n\tfor i in range(k + 1, N + 1) :\n\t\tdp[i] = (dp[i - 1] + dp[i - k]) % mod;\n\treturn dp[N];", "6478": "def findWays(p):\n\tdp = [0] * (p + 1)\n\tdp[1] = 1\n\tdp[2] = 2\n\tfor i in range(3, p + 1):\n\t\tdp[i] = (dp[i - 1] +\n\t\t\t\t(i - 1) * dp[i - 2])\n\treturn dp[p]", "6480": "def findSubarraySum(ind, flips, n, a, k) :\n\tif (flips > k) :\n\t\treturn -1e9;\n\tif (ind == n) :\n\t\treturn 0;\n\tif (dp[ind][flips] != -1) :\n\t\treturn dp[ind][flips];\n\tans = 0;\n\tans = max(0, a[ind] +\n\t\t\tfindSubarraySum(ind + 1, flips, n, a, k));\n\tans = max(ans, -a[ind] +\n\t\t\tfindSubarraySum(ind + 1, flips + 1, n, a, k));\n\tdp[ind][flips] = ans;\n\treturn dp[ind][flips] ;\ndef findMaxSubarraySum(a, n, k) :\n\tans = -1e9;\n\tfor i in range(n) :\n\t\tans = max(ans, findSubarraySum(i, 0, n, a, k));\n\tif ans == 0 and k == 0:\n\treturn max(a);\n\treturn ans;", "6486": "def maxWeight(arr, n, w1_r, w2_r, i):\n\tif i == n:\n\t\treturn 0\n\tif dp[i][w1_r][w2_r] != -1:\n\t\treturn dp[i][w1_r][w2_r]\n\tfill_w1, fill_w2, fill_none = 0, 0, 0\n\tif w1_r >= arr[i]:\n\t\tfill_w1 = arr[i] + maxWeight(arr, n, w1_r - arr[i], w2_r, i + 1)\n\tif w2_r >= arr[i]:\n\t\tfill_w2 = arr[i] + maxWeight(arr, n, w1_r, w2_r - arr[i], i + 1)\n\tfill_none = maxWeight(arr, n, w1_r, w2_r, i + 1)\n\tdp[i][w1_r][w2_r] = max(fill_none, max(fill_w1, fill_w2))\n\treturn dp[i][w1_r][w2_r]", "6525": "def solve(dp, wt, K, M, used) :\n\tif (wt < 0) :\n\t\treturn 0\n\tif (wt == 0) :\n\t\tif (used) :\n\t\t\treturn 1\n\t\treturn 0\n\tif (dp[wt][used] != -1) :\n\t\treturn dp[wt][used]\n\tans = 0\n\tfor i in range(1, K + 1) :\n\t\tif (i >= M) :\n\t\t\tans += solve(dp, wt - i, K, M, used 1)\n\t\telse :\n\t\t\tans += solve(dp, wt - i, K, M, used)\n\tdp[wt][used] = ans\n\treturn ans", "6531": "def sumOddFibonacci(n):\n\tSum=[0]*(n + 1);\n\tSum[0] = 0;\n\tSum[1] = 1;\n\tSum[2] = 2;\n\tSum[3] = 5;\n\tSum[4] = 10;\n\tSum[5] = 23;\n\tfor i in range(6,n+1):\n\t\tSum[i] = ((Sum[i - 1] +\n\t\t\t\t\t(4 * Sum[i - 2]) % mod -\n\t\t\t\t\t(4 * Sum[i - 3]) % mod + mod) % mod + (Sum[i - 4] - Sum[i - 5] + mod) % mod) % mod;\n\treturn Sum[n];", "6536": "def CountWays(n):\n\tif n == 0:\n\t\treturn 1\n\tif n == 1:\n\t\treturn 1\n\tif n == 2:\n\t\treturn 1 + 1\n\treturn CountWays(n - 1) + CountWays(n - 3)", "6537": "def CountWays(n):\n\tnoOfWays = [0] * (n + 3)\n\tnoOfWays[0] = 1\n\tnoOfWays[1] = 1\n\tnoOfWays[2] = 1 + 1\n\tfor i in range(3, n+1):\n\t\tnoOfWays[i] = noOfWays[i-1] + noOfWays[i-3]\n\treturn noOfWays[n]", "6538": "def CountWays(n):\n\tnoOfWays = [0] * (n+1)\n\tnoOfWays[0] = 1\n\tnoOfWays[1] = 1\n\tnoOfWays[2] = 1 + 1\n\tfor i in range(3, n+1):\n\t\tnoOfWays[i] = noOfWays[3-1]", "6550": "def fun(marks, n):\n\tdp = [ 1 for i in range(0, n) ]\n\tfor i in range(0, n-1):\n\t\tif marks[i] > marks[i + 1]:\n\t\t\ttemp = i\n\t\t\twhile True:\n\t\t\t\tif marks[temp] > marks[temp + 1] and temp >= 0:\n\t\t\t\t\tif dp[temp] > dp[temp + 1]:\n\t\t\t\t\t\ttemp -= 1\n\t\t\t\t\t\tcontinue\n\t\t\t\t\telse:\n\t\t\t\t\t\tdp[temp] = dp[temp + 1] + 1\n\t\t\t\t\t\ttemp -= 1\t\t\t\t\t\n\t\t\t\telse:\n\t\t\t\t\tbreak \n\t\telif marks[i] < marks[i + 1]:\n\t\t\tdp[i + 1] = dp[i] + 1\n\treturn(sum(dp))", "6553": "def sieve():\n\ti = 2\n\twhile(i * i < MAX):\t\n\t\tif (prime[i] == 0):\t\t\n\t\t\tfor j in range(i * i, MAX, i):\t\t\n\t\t\t\tprime[j] = 1;\t\n\t\ti += 1\ndef dfs(i, j, k, q, n, m):\n\tif (mappedMatrix[i][j] == 0 or i > n or j > m or mark[i][j] or q != 0):\n\t\treturn q;\n\tmark[i][j] = 1;\n\tans[k] = [i, j]\n\tif (i == n and j == m):\n\t\tq = k;\n\t\treturn q;\n\tq = dfs(i + 1, j + 1, k + 1, q, n, m);\n\tq = dfs(i + 1, j, k + 1, q, n, m);\n\tq = dfs(i, j + 1, k + 1, q, n, m);\n\treturn q\ndef lexicographicalPath(n, m):\n\tq = 0;\n\tglobal ans, mark\n\tans = [[0, 0] for i in range(MAX)]\n\tmark = [[0 for j in range(MAX)] for i in range(MAX)]\n\tq = dfs(1, 1, 1, q, n, m);\n\tfor i in range(1, q + 1):\n\t\tprint(str(ans[i][0]) + ' ' +\n\t\t\tstr(ans[i][1]))\ndef countPrimePath(n, m):\n\tglobal dp\n\tdp = [[0 for j in range(MAX)] for i in range(MAX)]\n\tdp[1][1] = 1;\n\tfor i in range(1, n + 1):\n\t\tfor j in range(1, m + 1):\n\t\t\tif (i == 1 and j == 1):\n\t\t\t\tcontinue;\n\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]);\n\t\t\tif (mappedMatrix[i][j] == 0):\n\t\t\t\tdp[i][j] = 0;\n\tprint(dp[n][m])\ndef preprocessMatrix(a, n, m):\n\tglobal prime\n\tprime = [0 for i in range(MAX)]\n\tsieve();\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif (prime[a[i][j]] == 0):\n\t\t\t\tmappedMatrix[i + 1][j + 1] = 1;\n\t\t\telse:\n\t\t\t\tmappedMatrix[i + 1][j + 1] = 0;", "6554": "def partitions(n):\n\tp = [0] * (n + 1)\n\tp[0] = 1\n\tfor i in range(1, n + 1):\n\t\tk = 1\n\t\twhile ((k * (3 * k - 1)) / 2 <= i) :\n\t\t\tp[i] += ((1 if k % 2 else -1) *\n\t\t\t\t\tp[i - (k * (3 * k - 1)) // 2])\n\t\t\tif (k > 0):\n\t\t\t\tk *= -1\n\t\t\telse:\n\t\t\t\tk = 1 - k\n\treturn p[n]", "6586": "def factors(n):\n\tv = []\n\tv.append(1)\n\tfor i in range(2, int(sqrt(n)) + 1, 1):\n\t\tif (n % i == 0):\n\t\t\tv.append(i);\n\t\t\tif (int(n / i) != i):\n\t\t\t\tv.append(int(n / i))\n\treturn v\ndef checkAbundant(n):\n\tsum = 0\n\tv = factors(n)\n\tfor i in range(len(v)):\n\t\tsum += v[i]\n\tif (sum > n):\n\t\treturn True\n\telse:\n\t\treturn False\ndef checkSemiPerfect(n):\n\tv = factors(n)\n\tv.sort(reverse = False)\n\tr = len(v)\n\tsubset = [[0 for i in range(n + 1)] for j in range(r + 1)]\n\tfor i in range(r + 1):\n\t\tsubset[i][0] = True\n\tfor i in range(1, n + 1):\n\t\tsubset[0][i] = False\n\tfor i in range(1, r + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tif (j < v[i - 1]):\n\t\t\t\tsubset[i][j] = subset[i - 1][j]\n\t\t\telse:\n\t\t\t\tsubset[i][j] = (subset[i - 1][j] or subset[i - 1][j - v[i - 1]])\n\tif ((subset[r][n]) == 0):\n\t\treturn False\n\telse:\n\t\treturn True\ndef checkweird(n):\n\tif (checkAbundant(n) == True and\n\t\tcheckSemiPerfect(n) == False):\n\t\treturn True\n\telse:\n\t\treturn False", "6589": "def solve(N, K) :\n\tcombo = [0] * (N + 1)\n\tcombo[0] = 1\n\tfor i in range(1, K + 1) :\n\t\tfor j in range(0, N + 1) :\n\t\t\tif j >= i :\n\t\t\t\tcombo[j] += combo[j - i]\n\treturn combo[N]", "6679": "def maxSubArraySumRepeated(a, n, k):\n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k):\n\t\tmax_ending_here = max_ending_here + a[i%n]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\t\tif (max_ending_here < 0):\n\t\t\tmax_ending_here = 0\n\treturn max_so_far", "6712": "def longOddEvenIncSeq( arr , n ):\n\tlioes = list()\n\tmaxLen = 0\n\tfor i in range(n):\n\t\tlioes.append(1)\n\ti=1\n\tfor i in range(n):\n\t\tfor j in range(i):\n\t\t\tif (arr[i] > arr[j] and\n\t\t\t\t(arr[i] + arr[j]) % 2 != 0 and lioes[i] < lioes[j] + 1):\n\t\t\t\t\tlioes[i] = lioes[j] + 1\n\tfor i in range(n):\n\t\tif maxLen < lioes[i]:\n\t\t\tmaxLen = lioes[i]\n\treturn maxLen", "6725": "def isSubsetSum(arr, n, sum):\n\tsubset = [[False for x in range(n + 1)] for y in range (sum + 1)]\n\tcount = [[0 for x in range (n + 1)] for y in range (sum + 1)]\n\tfor i in range (n + 1):\n\t\tsubset[0][i] = True\n\t\tcount[0][i] = 0\n\tfor i in range (1, sum + 1):\n\t\tsubset[i][0] = False\n\t\tcount[i][0] = -1\n\tfor i in range (1, sum + 1):\n\t\tfor j in range (1, n + 1):\n\t\t\tsubset[i][j] = subset[i][j - 1]\n\t\t\tcount[i][j] = count[i][j - 1]\n\t\t\tif (i >= arr[j - 1]) :\n\t\t\t\tsubset[i][j] = (subset[i][j] or subset[i - arr[j - 1]][j - 1])\n\t\t\t\tif (subset[i][j]):\n\t\t\t\t\tcount[i][j] = (max(count[i][j - 1], count[i - arr[j - 1]][j - 1] + 1))\n\treturn count[sum][n]", "6749": "def LIP(dp, mat, n, m, x, y):\n\tif (dp[x][y] < 0):\n\t\tresult = 0\n\t\tif (x == n - 1 and y == m - 1):\n\t\t\tdp[x][y] = 1\n\t\t\treturn dp[x][y]\n\t\tif (x == n - 1 or y == m - 1):\n\t\t\tresult = 1\n\t\tif (x + 1 < n and mat[x][y] < mat[x + 1][y]):\n\t\t\tresult = 1 + LIP(dp, mat, n, m, x + 1, y)\n\t\tif (y + 1 < m and mat[x][y] < mat[x][y + 1]):\n\t\t\tresult = max(result, 1 + LIP(dp, mat, n, m, x, y + 1))\n\t\tdp[x][y] = result\n\treturn dp[x][y]\ndef wrapper(mat, n, m):\n\tdp = [[-1 for i in range(MAX)] for i in range(MAX)]\n\treturn LIP(dp, mat, n, m, 0, 0)", "6787": "def computeLIS(circBuff, start, end, n):\n\tLIS = [0 for i in range(end)]\t\t\n\tfor i in range(start, end):\n\t\tLIS[i] = 1\n\tfor i in range(start + 1, end):\n\t\tfor j in range(start,i):\n\t\t\tif (circBuff[i] > circBuff[j] and LIS[i] < LIS[j] + 1):\n\t\t\t\tLIS[i] = LIS[j] + 1\n\tres = -100000\n\tfor i in range(start, end):\n\t\tres = max(res, LIS[i])\n\treturn res\ndef LICS(arr, n):\n\tcircBuff = [0 for i in range(2 * n)]\n\tfor i in range(n):\n\t\tcircBuff[i] = arr[i]\n\tfor i in range(n, 2 * n):\n\t\tcircBuff[i] = arr[i - n]\n\tres = -100000\n\tfor i in range(n):\n\t\tres = max(computeLIS(circBuff, i, i + n, n), res)\n\treturn res", "6791": "def countPaths(n,m):\n\tif (n==0 or m==0):\n\t\treturn 1\n\treturn (countPaths(n-1, m) + countPaths(n, m-1))", "6792": "def countPaths(n, m):\n\tif (n == 0 or m == 0):\n\t\treturn 1\n\treturn (countPaths(n - 1, m) + \n\t\t\tcountPaths(n, m - 1))", "6793": "def binomialCoeff(n,k):\n\tC = [0]*(k+1)\n\tC[0] = 1\n\tfor i in range(1, n + 1): \n\t\tj = min(i ,k) \n\t\twhile (j > 0): \n\t\t\tC[j] = C[j] + C[j-1] \n\t\t\tj -= 1\n\treturn C[k]", "6848": "def getMaxGold(gold, m, n):\n\tgoldTable = [[0 for i in range(n)] for j in range(m)]\n\tfor col in range(n-1, -1, -1):\n\t\tfor row in range(m):\n\t\t\tif (col == n-1):\n\t\t\t\tright = 0\n\t\t\telse:\n\t\t\t\tright = goldTable[row][col+1]\n\t\t\tif (row == 0 or col == n-1):\n\t\t\t\tright_up = 0\n\t\t\telse:\n\t\t\t\tright_up = goldTable[row-1][col+1]\n\t\t\tif (row == m-1 or col == n-1):\n\t\t\t\tright_down = 0\n\t\t\telse:\n\t\t\t\tright_down = goldTable[row+1][col+1]\n\t\t\tgoldTable[row][col] = gold[row][col] + max(right, right_up, right_down)\n\tres = goldTable[0][0]\n\tfor i in range(1, m):\n\t\tres = max(res, goldTable[i][0])\n\treturn res", "6885": "def isOperator(op):\n\treturn (op == '+' or op == '*')\ndef printMinAndMaxValueOfExp(exp):\n\tnum = []\n\topr = []\n\ttmp = \"\"\n\tfor i in range(len(exp)):\n\t\tif (isOperator(exp[i])):\n\t\t\topr.append(exp[i])\n\t\t\tnum.append(int(tmp))\n\t\t\ttmp = \"\"\n\t\telse:\n\t\t\ttmp += exp[i]\n\tnum.append(int(tmp))\n\tllen = len(num)\n\tminVal = [[ 0 for i in range(llen)] for i in range(llen)]\n\tmaxVal = [[ 0 for i in range(llen)] for i in range(llen)]\n\tfor i in range(llen):\n\t\tfor j in range(llen):\n\t\t\tminVal[i][j] = 10**9\n\t\t\tmaxVal[i][j] = 0\n\t\t\tif (i == j):\n\t\t\t\tminVal[i][j] = maxVal[i][j] = num[i]\n\tfor L in range(2, llen + 1):\n\t\tfor i in range(llen - L + 1):\n\t\t\tj = i + L - 1\n\t\t\tfor k in range(i, j):\n\t\t\t\tminTmp = 0\n\t\t\t\tmaxTmp = 0\n\t\t\t\tif(opr[k] == '+'):\n\t\t\t\t\tminTmp = minVal[i][k] + minVal[k + 1][j]\n\t\t\t\t\tmaxTmp = maxVal[i][k] + maxVal[k + 1][j]\n\t\t\t\telif(opr[k] == '*'):\n\t\t\t\t\tminTmp = minVal[i][k] * minVal[k + 1][j]\n\t\t\t\t\tmaxTmp = maxVal[i][k] * maxVal[k + 1][j]\n\t\t\t\tif (minTmp < minVal[i][j]):\n\t\t\t\t\tminVal[i][j] = minTmp\n\t\t\t\tif (maxTmp > maxVal[i][j]):\n\t\t\t\t\tmaxVal[i][j] = maxTmp\n\tprint(\"Minimum value : \",minVal[0][llen - 1],\", \\ Maximum value : \",maxVal[0][llen - 1])", "6907": "def lcs(str1, str2, len1, len2, i, j):\n\tif (i == len1 or j == len2):\n\t\tdp[i][j] = 0\n\t\treturn dp[i][j]\n\tif (dp[i][j] != -1):\n\t\treturn dp[i][j]\n\tret = 0\n\tif (str1[i] == str2[j]):\n\t\tret = 1 + lcs(str1, str2, len1, len2, i + 1, j + 1)\n\telse:\n\t\tret = max(lcs(str1, str2, len1, len2, i + 1, j),\n\t\t\t\tlcs(str1, str2, len1, len2, i, j + 1))\n\tdp[i][j] = ret\n\treturn ret\ndef printAll(str1, str2, len1, len2,data, indx1, indx2, currlcs):\n\tif (currlcs == lcslen):\n\t\tprint(\"\".join(data[:currlcs]))\n\t\treturn\n\tif (indx1 == len1 or indx2 == len2):\n\t\treturn\n\tfor ch in range(ord('a'),ord('z') + 1):\n\t\tdone = False\n\t\tfor i in range(indx1,len1):\n\t\t\tif (chr(ch)==str1[i]):\n\t\t\tfor j in range(indx2, len2):\n\t\t\t\tif (chr(ch) == str2[j] and dp[i][j] == lcslen-currlcs):\n\t\t\t\tdata[currlcs] = chr(ch)\n\t\t\t\tprintAll(str1, str2, len1, len2, data, i + 1, j + 1, currlcs + 1)\n\t\t\t\tdone = True\n\t\t\t\tbreak\n\t\t\tif (done):\n\t\t\t\tbreak\ndef prinlAllLCSSorted(str1, str2):\n\tglobal lcslen\n\tlen1,len2 = len(str1),len(str2)\n\tlcslen = lcs(str1, str2, len1, len2, 0, 0)\n\tdata = ['a' for i in range(MAX)]\n\tprintAll(str1, str2, len1, len2, data, 0, 0, 0)", "6933": "def minAdjustmentCost(A, n, target):\n\tdp = [[0 for i in range(M + 1)] for i in range(n)]\n\tfor j in range(M + 1):\n\t\tdp[0][j] = abs(j - A[0])\n\tfor i in range(1, n):\n\t\tfor j in range(M + 1):\n\t\t\tdp[i][j] = 100000000\n\t\t\tfor k in range(max(j - target, 0),\n\t\t\t\t\t\tmin(M, j + target) + 1):\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] +\n\t\t\t\t\t\t\t\t\t\tabs(A[i] - j))\n\tres = 10000000\n\tfor j in range(M + 1):\n\t\tres = min(res, dp[n - 1][j])\n\treturn res", "6944": "def LCIS(arr1, n, arr2, m):\n\ttable = [0] * m\n\tfor j in range(m):\n\t\ttable[j] = 0\n\tfor i in range(n):\n\t\tcurrent = 0\n\t\tfor j in range(m):\n\t\t\tif (arr1[i] == arr2[j]):\n\t\t\t\tif (current + 1 > table[j]):\n\t\t\t\t\ttable[j] = current + 1\n\t\t\tif (arr1[i] > arr2[j]):\n\t\t\t\tif (table[j] > current):\n\t\t\t\t\tcurrent = table[j]\n\tresult = 0\n\tfor i in range(m):\n\t\tif (table[i] > result):\n\t\t\tresult = table[i]\n\treturn result", "7051": "def cutRod(price, n):\n\tval = [0 for x in range(n+1)]\n\tval[0] = 0\n\tfor i in range(1, n+1):\n\t\tmax_val = INT_MIN\n\t\tfor j in range(i):\n\t\t\tmax_val = max(max_val, price[j] + val[i-j-1])\n\t\tval[i] = max_val\n\treturn val[n]", "7068": "def MatrixChainOrder(p, i, j):\n\tif i == j:\n\t\treturn 0\n\t_min = sys.maxsize\n\tfor k in range(i, j):\n\t\tcount = (MatrixChainOrder(p, i, k)\n\t\t\t\t+ MatrixChainOrder(p, k + 1, j) + p[i-1] * p[k] * p[j])\n\t\tif count < _min:\n\t\t\t_min = count\n\treturn _min", "7069": "def matrixChainMemoised(p, i, j):\n\tif(i == j):\n\t\treturn 0\n\tif(dp[i][j] != -1):\n\t\treturn dp[i][j]\n\tdp[i][j] = sys.maxsize\n\tfor k in range(i,j):\n\t\tdp[i][j] = min(dp[i][j], matrixChainMemoised(p, i, k) + matrixChainMemoised(p, k + 1, j)+ p[i - 1] * p[k] * p[j])\n\treturn dp[i][j]\ndef MatrixChainOrder(p,n):\n\ti = 1\n\tj = n - 1 \n\treturn matrixChainMemoised(p, i, j)", "7071": "def count(S, m, n ):\n\tif (n == 0):\n\t\treturn 1\n\tif (n < 0):\n\t\treturn 0;\n\tif (m <=0 and n >= 1):\n\t\treturn 0\n\treturn count( S, m - 1, n ) + count( S, m, n-S[m-1] );", "7119": "def totalCombination(L, R):\n\tcount = 0\n\tK = R - L\n\tif (K < L):\n\t\treturn 0\n\tans = K - L\n\tcount = ((ans + 1) * (ans + 2)) // 2\n\treturn count", "7135": "def printArrays(n) :\n\tA, B = [], [];\n\tfor i in range(1, 2 * n + 1):\n\t\tif (i % 2 == 0) :\n\t\t\tA.append(i);\n\t\telse :\n\t\t\tB.append(i);\n\tprint(\"{ \", end=\"\");\n\tfor i in range(n) :\n\t\tprint(A[i], end=\"\");\n\t\tif (i != n - 1) :\n\t\t\tprint(\", \", end=\"\");\n\tprint(\"}\");\n\tprint(\"{ \", end=\"\");\n\tfor i in range(n) :\n\t\tprint(B[i], end=\"\");\n\t\tif (i != n - 1) :\n\t\t\tprint(\",\", end=\" \");\n\tprint(\" }\", end=\"\");", "7139": "def flipBitsOfAandB(A, B):\n\tfor i in range(0, 32):\n\t\tif ((A & (1 << i)) and\n\t\t\t(B & (1 << i))):\n\t\t\tA = A ^ (1 << i)\n\t\t\tB = B ^ (1 << i)\n\tprint(A, B)", "7140": "def flipBitsOfAandB(A, B):\n\tA = A ^ (A & B)\n\tB = B ^ (A & B)\n\tprint(A, B)", "7167": "def TotalHammingDistance(n):\n\ti = 1\n\tsum = 0\n\twhile (n // i > 0):\n\t\tsum = sum + n // i\n\t\ti = i * 2\n\treturn sum", "7176": "def solve(n):\n\ts = 0;\n\tl = 1;\n\twhile(l < n + 1):\n\t\tr = (int)(n /\n\t\t\tmath.floor(n / l));\n\t\tx = ((((r % m) *\n\t\t\t((r + 1) % m)) / 2) % m);\n\t\ty = ((((l % m) *\n\t\t\t((l - 1) % m)) / 2) % m);\n\t\tp = (int)((n / l) % m);\n\t\ts = ((s + (((x - y) % m) * p) % m + m) % m);\n\t\ts %= m;\n\t\tl = r + 1;\n\tprint (int((s + m) % m));", "7187": "def min_time_to_cut(N):\n\tif (N == 0):\n\t\treturn 0\n\treturn int(math.log2(N)) + 1", "7203": "def findDistinctSums(n):\n\ts = set()\n\tfor i in range(1, n + 1):\n\t\tfor j in range(i, n + 1):\n\t\t\ts.add(i + j)\n\treturn len(s)", "7204": "def findDistinctSums(N):\n\treturn (2 * N - 1)", "7234": "def printPattern(i,j, n):\n\tif (j >= n) :\n\t\treturn 0\n\tif (i >= n):\n\t\treturn 1\n\tif (j == i or j == n - 1 - i):\n\t\tif (i == n - 1 - j):\n\t\t\tprint(\"/\",end=\"\")\n\t\telse:\n\t\t\tprint(\"\\\\\",end=\"\")", "7248": "def zArray(arr) :\n\tn = len(arr);\n\tz = [0]*n;\n\tr = 0;\n\tl = 0;\n\tfor k in range(1, n) :\n\t\tif (k > r) :\n\t\t\tr = l = k;\n\t\t\twhile (r < n and arr[r] == arr[r - l]) :\n\t\t\t\tr += 1;\n\t\t\tz[k] = r - l;\n\t\t\tr -= 1;\n\t\telse :\n\t\t\tk1 = k - l;\n\t\t\tif (z[k1] < r - k + 1) :\n\t\t\t\tz[k] = z[k1];\n\t\t\telse :\n\t\t\t\tl = k;\n\t\t\t\twhile (r < n and arr[r] == arr[r - l]) :\n\t\t\t\t\tr += 1 ;\n\t\t\t\tz[k] = r - l;\n\t\t\t\tr -= 1;\n\treturn z;\ndef mergeArray(A,B) :\n\tn = len(A);\n\tm = len(B);\n\tc = [0]*(n + m + 1);\n\tfor i in range(m) :\n\t\tc[i] = B[i];\n\tc[m] = sys.maxsize;\n\tfor i in range(n) :\n\t\tc[m + i + 1] = A[i];\n\tz = zArray(c);\n\treturn z;\ndef findZArray( A,B, n) :\n\tflag = 0;\n\tz = mergeArray(A, B);\n\tfor i in range(len(z)) :\n\t\tif (z[i] == n) :\n\t\t\tprint(i - n - 1, end= \" \");\n\t\t\tflag = 1;\n\tif (flag == 0) :\n\t\tprint(\"Not Found\");", "7276": "def getCount(a, b):\n\tif(len(b) % len(a) != 0):\n\t\treturn -1;\n\tcount = int(len(b) / len(a))\n\ta = a * count\n\tif(a == b):\n\t\treturn count\n\treturn -1;", "7298": "def check(S1, S2):\n\tn1 = len(S1)\n\tn2 = len(S2)\n\tmp = defaultdict(lambda:0)\n\tfor i in range(0, n1):\n\t\tmp[S1[i]] += 1\n\tfor i in range(0, n2):\n\t\tif mp[S2[i]]:\n\t\t\tmp[S2[i]] -= 1\n\t\telif (mp[chr(ord(S2[i]) - 1)] and\n\t\t\tmp[chr(ord(S2[i]) - 2)]):\n\t\t\tmp[chr(ord(S2[i]) - 1)] -= 1\n\t\t\tmp[chr(ord(S2[i]) - 2)] -= 1\n\t\telse:\n\t\t\treturn False\n\treturn True", "7309": "def countPattern(s):\n\tlength = len(s)\n\toneSeen = False\n\tfor i in range(length):\n\t\tif (s[i] == '1' and oneSeen):\n\t\t\tif (s[i - 1] == '0'):\n\t\t\t\tcount += 1\n\t\tif (s[i] == '1' and oneSeen == 0):\n\t\t\toneSeen = True\n\t\tif (s[i] != '0' and s[i] != '1'):\n\t\t\toneSeen = False\n\treturn count", "7336": "def countSubstrings(str):\n\tfreq = [ 0 ]*3\n\tcount = 0\n\ti = 0\n\tfor j in range ( 0 ,len(str)):\n\t\tfreq[ord(str[j]) - ord('0')] += 1\n\t\twhile (freq[0] > 0 and freq[1] > 0 and freq[2] > 0):\n\t\t\ti += 1\n\t\t\tfreq[ord(str[i]) - ord('0')] -= 1\n\t\tcount += i\n\treturn count", "7347": "def minFlips(st):\n\tcount = 0\n\tif (len(st) <= 2):\n\t\treturn 0\n\tfor i in range(len(st) - 2):\n\t\tif (st[i] == st[i + 1] and st[i + 2] == st[i + 1]):\n\t\t\ti = i + 3\n\t\t\tcount += 1\n\t\telse:\n\t\t\ti += 1\n\treturn count", "7382": "def checkIfPossible(N, arr, T):\n\tfreqS = [0] * 256\n\tfreqT = [0] * 256\n\tfor ch in T:\n\t\tfreqT[ord(ch) - ord('a')] += 1\n\tfor i in range(N):\n\t\tfor ch in arr[i]:\n\t\t\tfreqS[ord(ch) - ord('a')] += 1\n\tfor i in range(256):\n\t\tif (freqT[i] == 0 and freqS[i] != 0):\n\t\t\treturn \"No\"\n\t\telif (freqS[i] == 0 and freqT[i] != 0):\n\t\t\treturn \"No\"\n\t\telif (freqT[i] != 0 and freqS[i]!= (freqT[i] * N)):\n\t\t\treturn \"No\"\n\treturn \"Yes\"", "7390": "def convertToHex(num):\n\ttemp = \"\"\n\twhile (num != 0):\n\t\trem = num % 16\n\t\tc = 0\n\t\tif (rem < 10):\n\t\t\tc = rem + 48\n\t\telse:\n\t\t\tc = rem + 87\n\t\ttemp += chr(c)\n\t\tnum = num // 16\n\treturn temp\ndef encryptString(S, N):\n\tans = \"\"\n\tfor i in range(N):\n\t\tch = S[i]\n\t\tcount = 0\n\t\twhile (i < N and S[i] == ch):\n\t\t\tcount += 1\n\t\t\ti += 1\n\t\ti -= 1\n\t\thex = convertToHex(count)\n\t\tans += ch\n\t\tans += hex\n\tans = ans[::-1]\n\treturn ans", "7401": "def groupsOfOnes(S, N):\n\tcount = 0\n\tst = []\n\tfor i in range(N):", "7412": "def generatePalindrome(S):\n\tHash = {}\n\tfor ch in S:\n\t\tHash[ch] = Hash.get(ch,0) + 1\n\tst = {}\n\tfor i in range(ord('a'), ord('z') + 1):\n\t\tif (chr(i) in Hash and Hash[chr(i)] == 2):\n\t\t\tfor j in range(ord('a'), ord('z') + 1):\n\t\t\t\ts = \"\"\n\t\t\t\tif (chr(j) in Hash and i != j):\n\t\t\t\t\ts += chr(i)\n\t\t\t\t\ts += chr(j)\n\t\t\t\t\ts += chr(i)\n\t\t\t\t\tst[s] = 1\n\t\tif ((chr(i) in Hash) and Hash[chr(i)] >= 3):\n\t\t\tfor j in range(ord('a'), ord('z') + 1):\n\t\t\t\ts = \"\"\n\t\t\t\tif (chr(j) in Hash):\n\t\t\t\t\ts += chr(i)\n\t\t\t\t\ts += chr(j)\n\t\t\t\t\ts += chr(i)\n\t\t\t\t\tst[s] = 1\n\tfor ans in st:\n\t\tprint(ans)", "7423": "def countOccurrences(S, X, Y):\n\tcount = 0\n\tN = len(S)\n\tA = len(X)\n\tB = len(Y)\n\tfor i in range( 0, N):\n\t\tif (S[i: i+B] == Y):\n\t\t\tcount+=1\n\t\tif (S[i:i+A] == X):\n\t\t\tprint(count, end = \" \")", "7487": "def findWinner(a, n) :\n\tv = []\n\tc = 0\n\tfor i in range(0, n) :\n\t\tif (a[i] == '0') :\n\t\t\tc += 1\n\t\telse :\n\t\t\tif (c != 0) :\n\t\t\t\tv.append(c)\n\t\t\tc = 0\n\tif (c != 0) :\n\t\tv.append(c)\n\tif (len(v) == 0) :\n\t\tprint(\"Player B\", end = \"\")\n\t\treturn\n\tif (len(v) == 1) :\n\t\tif ((v[0] & 1) != 0) :\n\t\t\tprint(\"Player A\", end = \"\")\n\t\telse :\n\t\t\tprint(\"Player B\", end = \"\")\n\t\treturn\n\tfirst = sys.minsize\n\tsecond = sys.minsize\n\tfor i in range(len(v)) :\n\t\tif (a[i] > first) :\n\t\t\tsecond = first\n\t\t\tfirst = a[i]\n\t\telif (a[i] > second and a[i] != first) :\n\t\t\tsecond = a[i]\n\tif (((first & 1) != 0) and (first + 1) // 2 > second) :\n\t\tprint(\"Player A\", end = \"\")\n\telse :\n\t\tprint(\"Player B\", end = \"\")", "7507": "def DFA(str, N):\n\tif (N <= 1):\n\t\tprint(\"No\")\n\t\treturn\n\tcount = 0\n\tif (str[0] == 'C'):\n\t\tcount += 1\n\t\tfor i in range(1, N):\n\t\t\tif (str[i] == 'A' or str[i] == 'B'):\n\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tbreak\n\telse:\n\t\tprint(\"No\")\n\t\treturn\n\tif (count == N):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "7542": "def minMaxDigits(str, N):\n\tarr = [0]* N\n\tfor i in range(N):\n\t\tarr[i] = (ord(str[i]) -\n\t\t\t\tord('0')) % 3\n\tzero = 0\n\tone = 0\n\ttwo = 0\n\tfor i in range(N):\n\t\tif (arr[i] == 0):\n\t\t\tzero += 1\n\t\tif (arr[i] == 1):\n\t\t\tone += 1\n\t\tif (arr[i] == 2):\n\t\t\ttwo += 1\n\tsum = 0\n\tfor i in range(N):\n\t\tsum = (sum + arr[i]) % 3\n\tif (sum == 0):\n\t\tprint(\"0\", end = \" \")\n\tif (sum == 1):\n\t\tif (one and N > 1):\n\t\t\tprint(\"1\", end = \" \")\n\t\telif (two > 1 and N > 2):\n\t\t\tprint(\"2\", end = \" \")\n\t\telse:\n\t\t\tprint(\"-1\", end = \" \")\n\tif (sum == 2):\n\t\tif (two and N > 1):\n\t\t\tprint(\"1\", end = \" \")\n\t\telif (one > 1 and N > 2):\n\t\t\tprint(\"2\", end = \" \")\n\t\telse:\n\t\t\tprint(\"-1\", end = \" \")\n\tif (zero > 0):\n\t\tprint(N - 1, end = \" \")\n\telif (one > 0 and two > 0):\n\t\tprint(N - 2, end = \" \")\n\telif (one > 2 or two > 2):\n\t\tprint(N - 3, end = \" \")\n\telse :\n\t\tprint(\"-1\", end = \" \")", "7548": "def findMinimumChanges(N, K, S):\n\tans = 0\n\tfor i in range((K + 1) // 2):\n\t\tmp = {}\n\t\tfor j in range(i, N, K):\n\t\t\tmp[S[j]] = mp.get(S[j], 0) + 1\n\t\tj = N - i - 1\n\t\twhile(j >= 0):\n\t\t\tif ((K & 1) and\n\t\t\t\t(i == K // 2)):\n\t\t\t\tbreak\n\t\t\tmp[S[j]] = mp.get(S[j], 0) + 1\n\t\t\tj -= K\n\t\tcurr_max = -sys.maxsize - 1\n\t\tfor key, value in mp.items():\n\t\t\tcurr_max = max(curr_max, value)\n\t\tif ((K & 1) and\n\t\t\t(i == K // 2)):\n\t\t\tans += (N // K - curr_max)\n\t\telse:\n\t\t\tans += (N // K * 2 - curr_max)\n\treturn ans", "7564": "def longComPre(arr, N):\n\tfreq = [[0 for i in range(256)] for i in range(N)]\n\tfor i in range(N):\n\t\tM = len(arr[i])\n\t\tfor j in range(M):\n\t\t\tfreq[i][ord(arr[i][j])] += 1\n\tmaxLen = 0\n\tfor j in range(256):\n\t\tminRowVal = sys.maxsize\n\t\tfor i in range(N):\n\t\t\tminRowVal = min(minRowVal, freq[i][j])\n\t\tmaxLen += minRowVal\n\treturn maxLen", "7587": "def binomialCoeff(n, k):\n\tres = 1\n\tif(k > n - k):\n\t\tk = n - k\n\tfor i in range(k):\n\t\tres *= (n - i)\n\t\tres //= (i + 1)\n\treturn res\ndef countOfString(N):\n\tStotal = pow(2, N)\n\tSequal = 0\n\tif(N % 2 == 0):\n\t\tSequal = binomialCoeff(N, N // 2)\n\tS1 = (Stotal - Sequal) // 2\n\treturn S1", "7593": "def removeCharRecursive(str, X):\n\tif (len(str) == 0):\n\t\treturn \"\"\n\tif (str[0] == X):\n\t\treturn removeCharRecursive(str[1:], X)\n\treturn str[0] + removeCharRecursive(str[1:], X)", "7594": "def checkString(s, K):\n\tn = len(s)\n\tdict = {}\n\tfor i in range(n):\n\t\tdict[s[i]] = i;\n\tst = set()\n\tfor i in range(n):\n\t\tst.add(s[i])\n\t\tif len(st) > K:\n\t\t\tprint(\"Yes\")\n\t\t\treturn\n\t\tif dict[s[i]] == i:\n\t\t\tst.remove(s[i])\n\tprint(\"No\")", "7609": "def isValid(a1, a2, strr, flag):\n\tv1, v2 = 0, 0\n\tif (flag == 0):\n\t\tv1 = strr[4]\n\t\tv2 = strr[3]\n\telse:\n\t\tv1 = strr[1]\n\t\tv2 = strr[0]\n\tif (v1 != a1 and v1 != '?'):\n\t\treturn False\n\tif (v2 != a2 and v2 != '?'):\n\t\treturn False\n\treturn True\ndef inRange(hh, mm, L, R):\n\ta = abs(hh - mm)\n\tif (a < L or a > R):\n\t\treturn False\n\treturn True\ndef displayTime(hh, mm):\n\tif (hh > 10):\n\t\tprint(hh, end = \":\")\n\telif (hh < 10):\n\t\tprint(\"0\", hh, end = \":\")\n\tif (mm > 10):\n\t\tprint(mm)\n\telif (mm < 10):\n\t\tprint(\"0\", mm)\ndef maximumTimeWithDifferenceInRange(strr, L, R):\n\ti, j = 0, 0\n\th1, h2, m1, m2 = 0, 0, 0, 0\n\tfor i in range(23, -1, -1):\n\t\th1 = i % 10\n\t\th2 = i // 10\n\t\tif (not isValid(chr(h1), chr(h2), strr, 1)):\n\t\t\tcontinue\n\t\tfor j in range(59, -1, -1):\n\t\t\tm1 = j % 10\n\t\t\tm2 = j // 10\n\t\t\tif (not isValid(chr(m1), chr(m2), strr, 0)):\n\t\t\t\tcontinue\n\t\t\tif (inRange(i, j, L, R)):\n\t\t\t\tdisplayTime(i, j)\n\t\t\t\treturn\n\tif (inRange(i, j, L, R)):\n\t\tdisplayTime(i, j)\n\telse:\n\t\tprint(-1)", "7622": "def check(s, n):\n\tst = []\n\tfor i in range(n):\n\t\tif (len(st) != 0 and\n\t\tst[len(st) - 1] == s[i]):\n\t\t\tst.pop();\n\t\telse:\n\t\t\tst.append(s[i]);\n\tif (len(st) == 0):\n\t\treturn True;\n\telse:\n\t\treturn False;", "7646": "def can_Construct(S, K):\n\tm = dict()\n\tp = 0\n\tif (len(S) == K):\n\t\treturn True\n\tfor i in S:\n\t\tm[i] = m.get(i, 0) + 1\n\tif (K > len(S)):\n\t\treturn False\n\telse:\n\t\tfor h in m:\n\t\t\tif (m[h] % 2 != 0):\n\t\t\t\tp = p + 1\n\tif (K < p):\n\t\treturn False\n\treturn True", "7688": "def findNumOfValidWords(w, p):\n\tm = defaultdict(int)\n\tres = []\n\tfor s in w:\n\t\tval = 0\n\t\tfor c in s:\n\t\t\tval = val | (1 << (ord(c) - ord('a')))\n\t\tm[val] += 1\n\tfor s in p:\n\t\tval = 0\n\t\tfor c in s:\n\t\t\tval = val | (1 << (ord(c) - ord('a')))\n\t\ttemp = val\n\t\tfirst = ord(s[0]) - ord('a')\n\t\tcount = 0\n\t\twhile (temp != 0):\n\t\t\tif (((temp >> first) & 1) == 1):\n\t\t\t\tif (temp in m):\n\t\t\t\t\tcount += m[temp]\n\t\t\ttemp = (temp - 1) & val\n\t\tres.append(count)\n\tfor it in res:\n\t\tprint(it)", "7693": "def flip(s):\n\ts = list(s)\n\tfor i in range(len(s)):\n\t\tif(s[i] == '0'):\n\t\t\twhile(s[i] == '0'):\n\t\t\t\ts[i] = '1'\n\t\t\t\ti += 1\n\t\t\ts = ''.join(map(str, s))\n\t\t\treturn s", "7694": "def distinct(S, M):\n\tcount = 0\n\tfor i in range (len(S)):\n\t\tc = len(set([d for d in S[i]]))\n\t\tif (c <= M):\n\t\t\tcount += 1\n\tprint(count)", "7734": "def removeOddFrequencyCharacters(s):\n\tm = dict()\n\tfor i in s:\n\t\tm[i] = m.get(i, 0) + 1\n\tnew_s = \"\"\n\tfor i in s:\n\t\tif (m[i] & 1):\n\t\t\tcontinue\n\t\tnew_s += i\n\treturn new_s", "7735": "def removeChars(arr, k):\n\thash = [0]*MAX_CHAR\n\tn = len(arr)\n\tfor i in range( n):\n\t\thash[ord(arr[i]) - ord('a')] += 1\n\tans = \"\"\n\tindex = 0\n\tfor i in range(n):\n\t\tif (hash[ord(arr[i]) - ord('a')] != k):\n\t\t\tans += arr[i]\n\treturn ans", "7753": "def productAtKthLevel(tree, k, i, level):\n\tif(tree[i[0]]=='('):\n\t\ti[0]+= 1\n\t\tif(tree[i[0]] == ')'):\n\t\t\treturn 1\t\t\n\t\tproduct = 1\n\t\tif(level == k):\n\t\t\tproduct = int(tree[i[0]])\n\t\ti[0]+= 1\n\t\tleftproduct = productAtKthLevel(tree, k, i, level + 1)\n\t\ti[0]+= 1\n\t\trightproduct = productAtKthLevel(tree, k, i, level + 1)\n\t\ti[0]+= 1\n\t\treturn product * leftproduct * rightproduct", "7758": "def findMostOccurringChar(string) :\n\thash = [0]*26;\n\tfor i in range(len(string)) :\n\t\tfor j in range(len(string[i])) :\n\t\t\thash[ord(string[i][j]) - ord('a')] += 1;\n\tmax = 0;\n\tfor i in range(26) :\n\t\tmax = i if hash[i] > hash[max] else max;\n\tprint((chr)(max + 97));", "7788": "def sub_segments (string, n):\n\tl = len (string)\n\tfor x in range (0, l, n):\n\t\tnewlist = string[x : x + n]\n\t\tarr = []\n\t\tfor y in newlist:\n\t\t\tif y not in arr:\n\t\t\t\tarr.append (y)\n\t\tprint (''.join (arr))", "7816": "def isPalindrome(num) :\n\ts = str(num)\n\tlow = 0\n\thigh = len(s) - 1\n\twhile (low < high):\n\t\tif (s[low] != s[high]):\n\t\t\treturn False\n\t\tlow += 1\n\t\thigh -= 1\n\treturn True", "7819": "def maxSubStr(str1, len1, str2, len2):\n\tif (len1 > len2):\n\t\treturn 0;\n\tfreq1 = [0] * MAX;\n\tfor i in range(len1):\n\t\tfreq1[ord(str1[i]) - ord('a')] += 1;\n\tfreq2 = [0] * MAX;\n\tfor i in range(len2):\n\t\tfreq2[ord(str2[i]) - ord('a')] += 1;\n\tminPoss = sys.maxsize;\n\tfor i in range(MAX):\n\t\tif (freq1[i] == 0):\n\t\t\tcontinue;\n\t\tif (freq1[i] > freq2[i]):\n\t\t\treturn 0;\n\t\tminPoss = min(minPoss, freq2[i] / freq1[i]);\n\treturn int(minPoss);", "7820": "def cntWays(string, n) :\n\tx = n + 1;\n\tways = x * x * (x * x - 1) // 12;\n\treturn ways;", "7828": "def findSubStr(string, cnt, start) :\n\tglobal minCnt;\n\tif (start == len(string)) :\n\t\tminCnt = min(cnt, minCnt);\n\tfor length in range(1, len(string) - start + 1) :\n\t\tsubStr = string[start : start + length];\n\t\tif subStr in uSet :\n\t\t\tfindSubStr(string, cnt + 1, start + length);\ndef findMinSubStr(arr, n, string) :\n\tfor i in range(n) :\n\t\tuSet.add(arr[i]);\n\tfindSubStr(string, 0, 0);", "7851": "def countSubStr(s, n) :\n\tc1 = 0; c2 = 0;\n\tfor i in range(n) :\n\t\tif (s[i : i + 5] == \"geeks\") :\n\t\t\tc1 += 1;\n\t\tif (s[i :i+ 3] == \"for\") :\n\t\t\tc2 = c2 + c1;\n\treturn c2;", "7861": "def findWord(c, n):\n\tco = 0\n\ts = [0] * n\n\tfor i in range(n):\n\t\tif (i < n / 2):\n\t\t\tco += 1\n\t\telse:\n\t\t\tco = n - i\n\t\tif (ord(c[i]) + co <= 122):\n\t\t\ts[i] = chr(ord(c[i]) + co)\n\t\telse:\n\t\t\ts[i] = chr(ord(c[i]) + co - 26)\n\tprint(*s, sep = \"\")", "7864": "", "7868": "def encryptstrr(strr, n, x):\n\tx = x % MAX\n\tarr = list(strr)\n\tfreq = [0]*MAX\n\tfor i in range(n):\n\t\tfreq[ord(arr[i]) - ord('a')] += 1\n\tfor i in range(n):\n\t\tif (freq[ord(arr[i]) - ord('a')] % 2 == 0):\n\t\t\tpos = (ord(arr[i]) - ord('a') + x) % MAX\n\t\t\tarr[i] = chr(pos + ord('a'))\n\t\telse:\n\t\t\tpos = (ord(arr[i]) - ord('a') - x)\n\t\t\tif (pos < 0):\n\t\t\t\tpos += MAX\n\t\t\tarr[i] = chr(pos + ord('a'))\n\treturn \"\".join(arr)", "7889": "def getOrgString(s):\n\tprint(s[0],end=\"\")\n\ti = 1\n\twhile (i < len(s)):\n\t\tif (ord(s[i]) >= ord('A') and ord(s[i] )<= ord('Z')):\n\t\t\tprint(\" \",s[i].lower(),end=\"\")\n\t\telse:\n\t\t\tprint(s[i],end=\"\")\n\t\ti+=1", "7892": "def isPossible(Str):\n\tfreq = dict()\n\tmax_freq = 0\n\tfor j in range(len(Str)):\n\t\tfreq[Str[j]] = freq.get(Str[j], 0) + 1\n\t\tif (freq[Str[j]] > max_freq):\n\t\t\tmax_freq = freq[Str[j]]\n\tif (max_freq <= (len(Str) - max_freq + 1)):\n\t\treturn True\n\treturn False", "7899": "def printUncommon(str1, str2) :\n\ta1 = 0; a2 = 0;\n\tfor i in range(len(str1)) :\n\t\tch = ord(str1[i]) - ord('a');\n\t\ta1 = a1 | (1 << ch);\n\tfor i in range(len(str2)) :\n\t\tch = ord(str2[i]) - ord('a');\n\t\ta2 = a2 | (1 << ch);\n\tans = a1 ^ a2;\n\ti = 0;\n\twhile (i < 26) :\n\t\tif (ans % 2 == 1) :\n\t\t\tprint(chr(ord('a') + i),end=\"\");\n\t\tans = ans // 2;\n\t\ti += 1;", "7900": "def isPalin(i, j, k, l, p, q, s) :\n\tstart = i; end = q;\n\twhile (start < end) :\n\t\tif (s[start] != s[end]) :\n\t\t\treturn False;\n\t\tstart += 1;\n\t\tif (start == j + 1) :\n\t\t\tstart = k;\n\t\tend -= 1;\n\t\tif (end == p - 1) :\n\t\t\tend = l;\n\treturn True;\ndef countSubStr(s) :\n\tcount = 0;\n\tn = len(s);\n\tfor i in range(n-2) :\n\t\tfor j in range(i, n-2) :\n\t\t\tfor k in range(j + 1, n-1) :\n\t\t\t\tfor l in range(k, n-1) :\n\t\t\t\t\tfor p in range(l + 1, n) :\n\t\t\t\t\t\tfor q in range(p, n) :\n\t\t\t\t\t\t\tif (isPalin(i, j, k, l, p, q, s)) :\n\t\t\t\t\t\t\t\tcount += 1;\n\treturn count;", "7938": "def equalIgnoreCase(str1, str2):\n\ti = 0\n\tlen1 = len(str1)\n\tlen2 = len(str2)\n\tif (len1 != len2):\n\t\treturn False\n\twhile (i < len1):\n\t\tif (str1[i] == str2[i]):\n\t\t\ti += 1\n\t\telif (((str1[i] >= 'a' and str1[i] <= 'z') or\n\t\t\t(str1[i] >= 'A' and str1[i] <= 'Z')) == False):\n\t\t\treturn False\n\t\telif (((str2[i] >= 'a' and str2[i] <= 'z') or\n\t\t\t(str2[i] >= 'A' and str2[i] <= 'Z')) == False):\n\t\t\treturn False\n\t\telse:\n\t\t\tif (str1[i] >= 'a' and str1[i] <= 'z'):\n\t\t\t\tif (ord(str1[i]) - 32 != ord(str2[i])):\n\t\t\t\t\treturn False\n\t\t\telif (str1[i] >= 'A' and str1[i] <= 'Z'):\n\t\t\t\tif (ord(str1[i]) + 32 != ord(str2[i])):\n\t\t\t\t\treturn False\n\t\t\ti += 1\n\treturn True\ndef equalIgnoreCaseUtil(str1, str2):\n\tres = equalIgnoreCase(str1, str2)\n\tif (res == True):\n\t\tprint(\"Same\")\n\telse:\n\t\tprint(\"Not Same\")", "7939": "def equalIgnoreCase(str1, str2) :\n\tstr1 = str1.upper();\n\tstr2 = str2.upper();\n\tx = str1 == str2;\n\treturn x;\ndef equalIgnoreCaseUtil(str1, str2) :\n\tres = equalIgnoreCase(str1, str2);\n\tif (res == True) :\n\t\tprint(\"Same\");\n\telse :\n\t\tprint(\"Not Same\");", "7940": "def equalIgnoreCase(str1, str2) :\n\tstr1 = str1.lower();\n\tstr2 = str2.lower();\n\tx = str1 == str2;\n\treturn x;\ndef equalIgnoreCaseUtil(str1, str2) :\n\tres = equalIgnoreCase(str1, str2);\n\tif (res == True) :\n\t\tprint(\"Same\");\n\telse :\n\t\tprint(\"Not Same\");", "7966": "def countMinReversals(expr):\n\tlength = len(expr)\n\tif length % 2:\n\t\treturn -1\n\tans = 0\n\topen = 0\n\tclose = 0\n\tfor i in range(0, length):\n\t\tif expr[i] == \"\":\n\t\t\topen += 1\n\t\telse:\n\t\t\tif not open:\n\t\t\t\tclose += 1\n\t\t\telse:\n\t\t\t\topen -= 1\n\tans = (close // 2) + (open // 2)\n\tclose %= 2\n\topen %= 2\n\tif close > 0:\n\t\tans += 2\n\treturn ans", "7977": "def totalPairs(s1, s2) :\n\ta1 = 0; b1 = 0;\n\tfor i in range(len(s1)) :\n\t\tif (ord(s1[i]) % 2 != 0) :\n\t\t\ta1 += 1;\n\t\telse :\n\t\t\tb1 += 1;\n\ta2 = 0 ; b2 = 0;\n\tfor i in range(len(s2)) :\n\t\tif (ord(s2[i]) % 2 != 0) :\n\t\t\ta2 += 1;\n\t\telse :\n\t\t\tb2 += 1;\n\treturn ((a1 * a2) + (b1 * b2));", "7978": "def replaceConsonants(string) :\n\tres = \"\";\n\ti = 0; count = 0;\n\twhile (i < len(string)) :\n\t\tif (string[i] != 'a' and string[i] != 'e' and string[i] != 'i' and string[i] != 'o' and string[i] != 'u') :\n\t\t\ti += 1;\n\t\t\tcount += 1;\n\t\telse :\n\t\t\tif (count > 0) :\n\t\t\t\tres += str(count);\n\t\t\tres += string[i];\n\t\t\ti += 1\n\t\t\tcount = 0;\n\tif (count > 0) :\n\t\tres += str(count);\n\treturn res;", "7979": "def prefixOccurrences(str1):\n\tc = str1[0]\n\tcountc = 0\n\tfor i in range(len(str1)):\n\t\tif (str1[i] == c):\n\t\t\tcountc += 1\n\treturn countc", "7989": "def minOperations(s, t, n):\n\tct0 = 0\n\tct1 = 0\n\tfor i in range(n):\n\t\tif (s[i] == t[i]):\n\t\t\tcontinue\n\t\tif (s[i] == '0'):\n\t\t\tct0 += 1\n\t\telse:\n\t\t\tct1 += 1\n\treturn max(ct0, ct1)", "7991": "def maxValue(a, b):\n\tb = sorted(b)\n\tbi = [i for i in b]\n\tai = [i for i in a]\n\tn = len(a)\n\tm = len(b)\n\tj = m - 1\n\tfor i in range(n):\n\t\tif (j < 0):\n\t\t\tbreak\n\t\tif (bi[j] > ai[i]):\n\t\t\tai[i] = bi[j]\n\t\t\tj -= 1\n\tx = \"\" . join(ai)\n\treturn x", "8004": "def decryptString(str, n):\n\ti = 0\n\tjump = 1\n\tdecryptedStr = \"\"\n\twhile (i < n):\n\t\tdecryptedStr += str[i];\n\t\ti += jump\n\t\tjump += 1\n\treturn decryptedStr", "8015": "def steps(string, n):\n\tflag = False\n\tx = 0\n\tfor i in range(len(string)):\n\t\tif (x == 0):\n\t\t\tflag = True\n\t\tif (x == n - 1):\n\t\t\tflag = False\n\t\tfor j in range(x):\n\t\t\tprint(\"*\", end = \"\")\n\t\tprint(string[i])\n\t\tif (flag == True):\n\t\t\tx += 1\n\t\telse:\n\t\t\tx -= 1", "8054": "def bitToBeFlipped( s):\n\tlast = s[len(s) - 1]\n\tfirst = s[0]\n\tif (last == first) :\n\t\tif (last == '0') :\n\t\t\treturn '1'\n\t\telse :\n\t\t\treturn '0'\n\telif (last != first) :\n\t\treturn last", "8061": "def SieveofEratosthenes(prime, p_size):\n\tprime[0] = False\n\tprime[1] = False\n\tfor p in range(2, p_size + 1):\n\t\tif prime[p]:\n\t\t\tfor i in range(p * 2, p_size + 1, p):\n\t\t\t\tprime[i] = False\ndef sumProdOfPrimeFreq(s):\n\tprime = [True] * (len(s) + 2)\n\tSieveofEratosthenes(prime, len(s) + 1)\n\ti = 0\n\tj = 0\n\tm = dict()\n\tfor i in range(len(s)):\n\t\tm[s[i]] = (m[s[i]] + 1) if s[i] in m else 1\n\ts = 0\n\tproduct = 1\n\tfor it in m:\n\t\tif prime[m[it]]:\n\t\t\ts += m[it]\n\t\t\tproduct *= m[it]\n\tprint(\"Sum =\", s)\n\tprint(\"Product =\", product)", "8078": "def countChar(str, x):\n\tcount = 0\n\tfor i in range(len(str)):\n\t\tif (str[i] == x) :\n\t\t\tcount += 1\n\tn = 10\n\trepetitions = n // len(str)\n\tcount = count * repetitions\n\tl = n % len(str)\n\tfor i in range(l):\n\t\tif (str[i] == x):\n\t\t\tcount += 1\n\treturn count", "8085": "def multipleOrFactor(s1, s2):\n\tm1 = defaultdict(lambda:0)\n\tm2 = defaultdict(lambda:0)\n\tfor i in range(0, len(s1)):\n\t\tm1[s1[i]] += 1\n\tfor i in range(0, len(s2)):\n\t\tm2[s2[i]] += 1\n\tfor it in m1: \n\t\tif it not in m2:\n\t\t\tcontinue\n\t\tif (m2[it] % m1[it] == 0 or m1[it] % m2[it] == 0):\n\t\t\tcontinue\n\t\telse:\n\t\t\treturn False\n\treturn True", "8099": "def checkIfUnequal(n, q):\n\ts1 = str(n)\n\ta = [0 for i in range(26)]\n\tfor i in range(0, len(s1), 1):\n\t\ta[ord(s1[i]) - ord('0')] += 1\n\tprod = n * q\n\ts2 = str(prod)\n\tfor i in range(0, len(s2), 1):\n\t\tif (a[ord(s2[i]) - ord('0')]):\n\t\t\treturn False\n\treturn True\ndef countInRange(l, r, q):\n\tcount = 0\n\tfor i in range(l, r + 1, 1):\n\t\tif (checkIfUnequal(i, q)):\n\t\t\tcount += 1\n\treturn count", "8110": "def is_possible(s):\n\tl = len(s)\n\tone = 0\n\tzero = 0\n\tfor i in range(0,l) :\n\t\tif (s[i] == '0'):\n\t\t\tzero += 1\n\t\telse:\n\t\t\tone += 1\n\tif (l % 2 == 0) :\n\t\treturn (one == zero)\n\telse:\n\t\treturn (abs(one - zero) == 1)", "8128": "def solve(s):\n\tm = dict()\n\tfor i in range(len(s)):\n\t\tif s[i] in m:\n\t\t\tm[s[i]] = m[s[i]]+1\n\t\telse:\n\t\t\tm[s[i]] = 1\n\tnew_string = \"\"\n\tfor i in range(len(s)):\n\t\tif m[s[i]]%2 == 0:\n\t\t\tcontinue\n\t\tnew_string = new_string+s[i]\n\tprint(new_string)", "8167": "def countFreq(arr, n):\n\tvisited = [False for i in range(n)]\n\tfor i in range(n):\n\t\tif visited[i] == True:\n\t\t\tcontinue\n\t\tcount = 1\n\t\tfor j in range(i + 1, n):\n\t\t\tif arr[i] == arr[j]:\n\t\t\t\tvisited[j] = True\n\t\t\t\tcount += 1\n\t\tprint(arr[i], count)", "8168": "def countFreq(arr, n, limit):\n\tcount = [0 for i in range(limit + 1)]\n\tfor i in range(n):\n\t\tcount[arr[i]] += 1\n\tfor i in range(limit + 1):\n\t\tif (count[i] > 0):\n\t\t\tprint(i, count[i])", "8169": "def countFreq(Str) :\n\tcount = [0] * (limit + 1)\n\tfor i in range(len(Str)) :\n\t\tcount[ord(Str[i])] += 1\n\tfor i in range(limit + 1) :\n\tif (count[i] > 0) :\n\t\tprint(chr(i), count[i])", "8184": "def countEvenOdd(arr, n, K) :\n\teven = 0; odd = 0;\n\tfor i in range(n) :\n\t\tx = bin(arr[i]).count('1');\n\t\tif (x % 2 == 0) :\n\t\t\teven += 1;\n\t\telse :\n\t\t\todd += 1;\n\ty = bin(K).count('1');\n\tif (y & 1) :\n\t\tprint(\"Even =\",odd ,\", Odd =\", even);\n\telse :\n\t\tprint(\"Even =\" , even ,\", Odd =\", odd);", "8213": "def check(s, m):\n\tl = len(s);\n\tc1 = 0;\n\tc2 = 0;\n\tfor i in range(0, l - 1):\n\t\tif (s[i] == '0'):\n\t\t\tc2 = 0;\n\t\t\tc1 = c1 + 1;\n\t\telse :\n\t\t\tc1 = 0;\n\t\t\tc2 = c2 + 1;\n\t\tif (c1 == m or c2 == m):\n\t\t\treturn True;\n\treturn False;", "8241": "def isDivisible(str, k):\n\tn = len(str)\n\tc = 0\n\tfor i in range(0, k):\n\t\tif (str[n - i - 1] == '0'):\t\n\t\t\tc += 1\n\treturn (c == k)", "8281": "def productAtKthLevel(tree, k):\n\tlevel = -1\n\tproduct = 1\n\tn = len(tree)\n\tfor i in range(0, n):\n\t\tif (tree[i] == '('):\n\t\t\tlevel+=1\n\t\telif (tree[i] == ')'):\n\t\t\tlevel-=1\n\t\telse:\n\t\t\tif (level == k):\n\t\t\t\tproduct *= (int(tree[i]) - int('0'))\n\treturn product", "8296": "def isPalindrome(string) :\n\ti = 0; j = len(string) - 1;\n\twhile (i < j) :\n\t\tif (string[i] != string[j]) :\n\t\t\treturn False;\n\t\ti += 1;\n\t\tj -= 1;\n\treturn True;\ndef removePalinWords(string) :", "8301": "def findSubSequence(s, num):\n\tres = 0\n\ti = 0\n\twhile (num) :\n\t\tif (num & 1):\n\t\t\tres += ord(s[i]) - ord('0')\n\t\ti+=1\n\t\tnum = num >> 1\n\treturn res\ndef combinedSum(s):\n\tn = len(s)\n\tc_sum = 0\n\tran = (1 << n) - 1\n\tfor i in range( ran+1):\n\t\tc_sum += findSubSequence(s, i)\n\treturn c_sum", "8304": "def findSubsequence(stri, k):\n\ta = [0] * MAX_CHAR;\n\tfor i in range(len(stri)):\n\t\ta[ord(stri[i]) - ord('a')] += 1\n\tfor i in range(len(stri)):\n\t\tif a[ord(stri[i]) - ord('a')] >= k:\n\t\t\tprint(stri[i],end='')", "8310": "def findDuplicates(a, n, m):\n\tisPresent = [[False for i in range(n)] for j in range(m)]\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tfor k in range(n):\n\t\t\t\tif i != k and a[i][j] == a[k][j]:\n\t\t\t\t\tisPresent[i][j] = True\n\t\t\t\t\tisPresent[k][j] = True\n\t\t\tfor k in range(m):\n\t\t\t\tif j != k and a[i][j] == a[i][k]:\n\t\t\t\t\tisPresent[i][j] = True\n\t\t\t\t\tisPresent[i][k] = True\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif not isPresent[i][j]:\n\t\t\t\tprint(a[i][j], end = \"\")", "8315": "def convert(str):\n\tw = \"\"\n\tz = \"\";\n\tstr = str.upper() + \" \";\n\tfor i in range(len(str)):\n\t\tch = str[i];\n\t\tif (ch != ' '):\n\t\t\tw = w + ch;\n\t\telse:\n\t\t\tz = (z + (w[0]).lower() +\n\t\t\t\tw[1:len(w)] + \" \");\n\t\t\tw = \"\";\n\treturn z;", "8316": "def convert( s):\n\t\tn = len(s)\n\t\ts1 = \"\"\n\t\ts1 = s1 + s[0].lower()\n\t\ti = 1\n\t\twhile i < n:\n\t\t\tif (s[i] == ' ' and i <= n):\n\t\t\t\ts1 = s1 + \" \" + (s[i + 1]).lower()\n\t\t\t\ti = i + 1\n\t\t\telse:\n\t\t\t\ts1 = s1 + (s[i]).upper()\n\t\t\ti = i + 1\n\t\treturn s1", "8366": "def isVowel(c):\n\treturn (c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u')\ndef encryptString(s, n, k):\n\tcountVowels = 0\n\tcountConsonants = 0\n\tans = \"\"\n\tfor l in range(n - k + 1):\n\t\tcountVowels = 0\n\t\tcountConsonants = 0\n\t\tfor r in range(l, l + k):\n\t\t\tif (isVowel(s[r]) == True):\n\t\t\t\tcountVowels += 1\n\t\t\telse:\n\t\t\t\tcountConsonants += 1\n\t\tans += (str)(countVowels * countConsonants)\n\treturn ans", "8367": "def isVowel(c):\n\treturn (c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u')\ndef encryptString(s, n, k):\n\tcv = [0 for i in range(n)]\n\tcc = [0 for i in range(n)]\n\tif (isVowel(s[0])):\n\t\tcv[0] = 1\n\telse:\n\t\tcc[0] = 1\n\tfor i in range(1,n):\n\t\tcv[i] = cv[i - 1] + isVowel(s[i])\n\t\tcc[i] = cc[i - 1] + (isVowel(s[i]) == False)\n\tans = \"\"\n\tprod = 0\n\tprod = cc[k - 1] * cv[k - 1]\n\tans += str(prod)\n\tfor i in range(k, len(s)):\n\t\tprod = ((cc[i] - cc[i - k]) *\n\t\t\t\t(cv[i] - cv[i - k]))\n\t\tans += str(prod)\n\treturn ans", "8374": "def countOccurrences(str, word):\n\ta = str.split(\" \")\n\tcount = 0\n\tfor i in range(0, len(a)):\n\t\tif (word == a[i]):\n\t\tcount = count + 1\n\treturn count", "8396": "def isValidISBN(isbn):\n\tif len(isbn) != 10:\n\t\treturn False\n\t_sum = 0\n\tfor i in range(9):\n\t\tif 0 <= int(isbn[i]) <= 9:\n\t\t\t_sum += int(isbn[i]) * (10 - i)\n\t\telse:\n\t\t\treturn False\n\tif(isbn[9] != 'X' and\n\t0 <= int(isbn[9]) <= 9):\n\t\treturn False\n\t_sum += 10 if isbn[9] == 'X' else int(isbn[9])\n\treturn (_sum % 11 == 0)", "8439": "def printInitials(name):\n\tif (len(name) == 0):\n\t\treturn\n\twords = name.split(\" \")\n\tfor word in words:\n\t\tprint(word[0].upper(), end = \" \")", "8460": "def canFormPalindrome(string):\n\tcount = [0 for i in range(NO_OF_CHARS)]\n\tfor i in string:\n\t\tcount[ord(i)] += 1\n\todd = 0\n\tfor i in range(NO_OF_CHARS):\n\t\tif (count[i] & 1):\n\t\t\todd += 1\n\t\tif (odd > 1):\n\t\t\treturn False\n\treturn True", "8490": "def permute(inp):\n\tn = len(inp)\n\tmx = 1 << n\n\tinp = inp.lower()\n\tfor i in range(mx):\n\t\tcombination = [k for k in inp]\n\t\tfor j in range(n):\n\t\t\tif (((i >> j) & 1) == 1):\n\t\t\t\tcombination[j] = inp[j].upper()\n\t\ttemp = \"\"\n\t\tfor i in combination:\n\t\t\ttemp += i\n\t\tprint temp,", "8501": "def isNumber(s):\n\tfor i in range(len(s)):\n\t\tif s[i].isdigit() != True:\n\t\t\treturn False\n\treturn True", "8506": "def printString(str, ch, count):\n\tocc, i = 0, 0\n\tif (count == 0):\n\t\tprint(str)\n\tfor i in range(len(str)):\n\t\tif (str[i] == ch):\n\t\t\tocc += 1\n\t\tif (occ == count):\n\t\t\tbreak\n\tif (i < len(str)- 1):\n\t\tprint(str[i + 1: len(str) - i + 2])\n\telse:\n\t\tprint(\"Empty string\")", "8527": "def isVowel(c):\n\tif (c == 'a' or c == 'A' or c == 'e' or c == 'E' or c == 'i' or c == 'I' or c == 'o' or c == 'O' or c == 'u' or c == 'U'):\n\t\treturn True\n\treturn False\ndef reverserVowel(string):\n\tj = 0\n\tvowel = [0] * len(string)\n\tstring = list(string)\n\tfor i in range(len(string)):\n\t\tif isVowel(string[i]):\n\t\t\tvowel[j] = string[i]\n\t\t\tj += 1\n\tfor i in range(len(string)):\n\t\tif isVowel(string[i]):\n\t\t\tj -= 1\n\t\t\tstring[i] = vowel[j]\n\treturn ''.join(string)", "8528": "def isVowel(c):\n\treturn (c=='a' or c=='A' or c=='e' or c=='E' or c=='i' or c=='I' or c=='o' or c=='O' or c=='u' or c=='U')\ndef reverseVowel(str):\n\ti = 0\n\tj = len(str) - 1\n\twhile (i < j):\n\t\tif not isVowel(str[i]):\n\t\t\ti += 1\n\t\t\tcontinue\n\t\tif (not isVowel(str[j])):\n\t\t\tj -= 1\n\t\t\tcontinue\n\t\tstr[i], str[j] = str[j], str[i]\n\t\ti += 1\n\t\tj -= 1\n\treturn str", "8538": "def firstLetterWord(str):\n\tresult = \"\"\n\tv = True\n\tfor i in range(len(str)):\n\t\tif (str[i] == ' '):\n\t\t\tv = True\n\t\telif (str[i] != ' ' and v == True):\n\t\t\tresult += (str[i])\n\t\t\tv = False\n\treturn result", "8539": "def processWords(input):\n\ts = input.split(\" \")\n\tfor values in s:\n\t\tcharBuffer.append(values[0])\n\treturn charBuffer", "8577": "def largest_alphabet(a, n) :\ndef smallest_alphabet(a, n) :", "8615": "def maximumPalinUsingKChanges(strr, k):\n\tpalin = strr[::]\n\tl = 0\n\tr = len(strr) - 1\n\twhile (l <= r):\n\t\tif (strr[l] != strr[r]):\n\t\t\tpalin[l] = palin[r] =\n\t\t\t\tmax(strr[l], strr[r])\n\t\t\tk -= 1\n\t\tl += 1\n\t\tr -= 1\n\tif (k < 0):\n\t\treturn \"Not possible\"\n\tl = 0\n\tr = len(strr) - 1\n\twhile (l <= r):\n\t\tif (l == r):\n\t\t\tif (k > 0):\n\t\t\t\tpalin[l] = '9'\n\t\tif (palin[l] < '9'):\n\t\t\tif (k >= 2 and palin[l] == strr[l] and palin[r] == strr[r]):\n\t\t\t\tk -= 2\n\t\t\t\tpalin[l] = palin[r] = '9'\n\t\t\telif (k >= 1 and (palin[l] != strr[l] or palin[r] != strr[r])):\n\t\t\t\tk -= 1\n\t\t\t\tpalin[l] = palin[r] = '9'\n\t\tl += 1\n\t\tr -= 1\n\treturn palin", "8636": "def generateAllStringsUtil(K, str, n):\n\tif (n == K):\n\t\tprint(*str[:n], sep = \"\", end = \" \")\n\t\treturn\n\tif (str[n-1] == '1'):\n\t\tstr[n] = '0'\n\t\tgenerateAllStringsUtil (K, str, n + 1)\n\tif (str[n-1] == '0'):\n\t\tstr[n] = '0'\n\t\tgenerateAllStringsUtil(K, str, n + 1)\n\t\tstr[n] = '1'\n\t\tgenerateAllStringsUtil(K, str, n + 1)\ndef generateAllStrings(K):\n\tif (K <= 0):\n\t\treturn\n\tstr = [0] * K", "8702": "def countTriplets(A) :\n\tcnt = 0;\n\ttuples = {};\n\tfor a in A:\n\t\tfor b in A:\n\t\t\tif (a & b) in tuples:\n\t\t\t\ttuples[a & b] += 1;\t\t\t\n\t\t\telse:\n\t\t\t\ttuples[a & b] = 1;\n\tfor a in A:\n\t\tfor t in tuples:\n\t\t\tif ((t & a) == 0):\n\t\t\t\tcnt += tuples[t];\n\treturn cnt;", "8705": "def isPalindrome(str):\n\tl = 0\n\th = len(str) - 1\n\twhile (h > l):\n\t\tif (str[l] != str[h]):\n\t\t\treturn 0\n\t\tl = l + 1\n\t\th = h - 1\n\treturn 1\ndef minRemovals(str):\n\tif (str[0] == ''):\n\t\treturn 0\n\tif (isPalindrome(str)):\n\t\treturn 1\n\treturn 2", "8787": "", "8788": "def RevString(s,l):\n if l%2 == 0:\n\tj = int(l/2)\n\twhile(j <= l - 1):\n\ts[j], s[l - j - 1] = s[l - j - 1], s[j]\n\tj += 1\n else:\n\tj = int(l/2 + 1)\n\twhile(j <= l - 1):\n\ts[j], s[l - 1 - j] = s[l - j - 1], s[j]\n\tj += 1\n\treturn s;", "8795": "def reverse(string):\n\tif len(string) == 0:\n\t\treturn\n\ttemp = string[0]\n\treverse(string[1:])\n\tprint(temp, end='')", "8823": "def getProbability(balls):\n\tglobal box1, box2, fact\n\tfactorial(10)\n\tbox2 = len(balls)\n\tK = 0\n\tfor i in range(len(balls)):\n\t\tK += balls[i]\n\tif (K % 2 == 1):\n\t\treturn 0\n\tall = comb(K, K // 2)\n\tvalidPermutation = validPermutations( K // 2, balls, 0, 0)\n\treturn validPermutation / all\ndef validPermutations(n, balls, usedBalls, i):\n\tglobal box1, box2, fact\n\tif (usedBalls == n):\n\t\tif (box1 == box2):\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn 0\n\tif (i >= len(balls)):\n\t\treturn 0\n\tres = validPermutations(n, balls, usedBalls, i + 1)\n\tbox1 += 1\n\tfor j in range(1, balls[i] + 1):\n\t\tif (j == balls[i]):\n\t\t\tbox2 -= 1\n\t\tcombinations = comb(balls[i], j)\n\t\tres += combinations * validPermutations(n, balls, usedBalls + j, i + 1)\n\tbox1 -= 1\n\tbox2 += 1\n\treturn res\ndef factorial(N):\n\tglobal box1, box2, fact\n\tfact[0] = 1\n\tfor i in range(1, N + 1):\n\t\tfact[i] = fact[i - 1] * i\ndef comb(n, r):\n\tglobal box1, box2, fact\n\tres = fact[n] // fact[r]\n\tres //= fact[n - r]\n\treturn res", "8840": "def parity(even,odd,v,i):\n\tglobal mn\n\tif (i == len(v) or len(even) == 0 or len(odd) == 0):\n\t\tcount = 0\n\t\tfor j in range(len(v)- 1):\n\t\t\tif (v[j] % 2 != v[j + 1] % 2):\n\t\t\t\tcount += 1\n\t\tif (count < mn):\n\t\t\tmn = count\n\t\treturn\n\tif (v[i] != -1):\n\t\tparity(even, odd, v, i + 1)\n\telse:\n\t\tif (len(even) != 0):\n\t\t\tx = even[len(even) - 1]\n\t\t\teven.remove(even[len(even) - 1])\n\t\t\tv[i] = x\n\t\t\tparity(even, odd, v, i + 1)\n\t\t\teven.append(x)\n\t\tif (len(odd) != 0):\n\t\t\tx = odd[len(odd) - 1]\n\t\t\todd.remove(odd[len(odd) - 1])\n\t\t\tv[i] = x\n\t\t\tparity(even, odd, v, i + 1)\n\t\t\todd.append(x)\ndef mnDiffParity(v, n):\n\tglobal mn\n\teven = []\n\todd = []\n\tm = {i:0 for i in range(100)}\n\tfor i in range(1, n + 1):\n\t\tm[i] = 1\n\tfor i in range(len(v)):\n\t\tif (v[i] != -1):\n\t\t\tm.pop(v[i])\n\tfor key in m.keys():\n\t\tif (key % 2 == 0):\n\t\t\teven.append(key)\n\t\telse:\n\t\t\todd.append(key)\n\tparity(even, odd, v, 0)\n\tprint(mn + 4)", "8855": "def dfs(u, count):\n\tvisited[u] = True\n\ttemp = 0\n\tglobal startnode, maxi\n\tfor i in range(0, len(adjacent[u])):\n\t\tif not visited[adjacent[u][i]]:\n\t\t\ttemp += 1\n\t\t\tdfs(adjacent[u][i], count + 1)\n\tif temp == 0:\n\t\tif maxi < count:\n\t\t\tmaxi = count\n\t\t\tstartnode = u\ndef dfs1(u, count):\n\tvisited[u] = True\n\ttemp = 0\n\tglobal endnode, maxi\n\tfor i in range(0, len(adjacent[u])):\n\t\tif not visited[adjacent[u][i]]:\n\t\t\ttemp += 1\n\t\t\tparent[adjacent[u][i]] = u\n\t\t\tdfs1(adjacent[u][i], count + 1)\n\tif temp == 0:\n\t\tif maxi < count:\n\t\t\tmaxi = count\n\t\t\tendnode = u\ndef dfs2(u, count):\n\tvisited[u] = True\n\ttemp = 0\n\tglobal thirdnode, maxi\n\tfor i in range(0, len(adjacent[u])):\n\t\tif (not visited[adjacent[u][i]] and not vis[adjacent[u][i]]):\n\t\t\ttemp += 1\n\t\t\tdfs2(adjacent[u][i], count + 1)\n\tif temp == 0:\n\t\tif maxi < count:\n\t\t\tmaxi = count\n\t\t\tthirdnode = u\ndef findNodes():\n\tdfs(1, 0)\n\tglobal maxi\n\tfor i in range(0, N+1):\n\t\tvisited[i] = False\n\tmaxi = -1\n\tdfs1(startnode, 0)\n\tfor i in range(0, N+1):\n\t\tvisited[i] = False\n\tx = endnode\n\tvis[startnode] = True\n\twhile x != startnode:\n\t\tvis[x] = True\n\t\tx = parent[x]\n\tmaxi = -1\n\tfor i in range(1, N+1):\n\t\tif vis[i]:\n\t\t\tdfs2(i, 0)", "8858": "def dfs(i, j, grid, vis, ans, z, z_count):\n\tn = len(grid)\n\tm = len(grid[0])\n\tvis[i][j] = 1\n\tif (grid[i][j] == 0):\n\t\tz += 1\n\tif (grid[i][j] == 2):\n\t\tif (z == z_count):\n\t\t\tans += 1\n\t\tvis[i][j] = 0\n\t\treturn grid, vis, ans\n\tif (i >= 1 and not vis[i - 1][j] and grid[i - 1][j] != -1):\n\t\tgrid, vis, ans = dfs(i - 1, j, grid, vis, ans, z, z_count)\n\tif (i < n - 1 and not vis[i + 1][j] and grid[i + 1][j] != -1):\n\t\tgrid, vis, ans = dfs(i + 1, j, grid, vis, ans, z, z_count)\n\tif (j >= 1 and not vis[i][j - 1] and grid[i][j - 1] != -1):\n\t\tgrid, vis, ans = dfs(i, j - 1, grid, vis, ans, z, z_count)\n\tif (j < m - 1 and not vis[i][j + 1] and grid[i][j + 1] != -1):\n\t\tgrid, vis, ans = dfs(i, j + 1, grid, vis, ans, z, z_count)\n\tvis[i][j] = 0\n\treturn grid, vis, ans\ndef uniquePaths(grid):\n\tz_count = 0\n\tn = len(grid)\n\tm = len(grid[0])\n\tans = 0\n\tvis = [[0 for j in range(m)] for i in range(n)]\n\tx = 0\n\ty = 0\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif grid[i][j] == 0:\n\t\t\t\tz_count += 1\n\t\t\telif (grid[i][j] == 1):\n\t\t\t\tx = i\n\t\t\t\ty = j\n\tgrid, vis, ans = dfs(x, y, grid, vis, ans, 0, z_count)\n\treturn ans", "8907": "def numPairs(a, n):\n\tans = 0\n\tfor i in range(n):\n\t\ta[i] = abs(a[i])\n\ta.sort()\n\tfor i in range(n):\n\t\tindex = 0\n\t\tfor j in range(i + 1, n):\n\t\t\tif (2 * a[i] >= a[j - 1] and 2 * a[i] < a[j]):\n\t\t\t\tindex = j\n\t\tif index == 0:\n\t\t\tindex = n\n\t\tans += index - i - 1\n\treturn ans", "8939": "def power(x, y, p) :\n\tres = 1;\n\tx = x % p;\n\twhile (y > 0) :\n\t\tif (y and 1) :\n\t\t\tres = (res * x) % p;\n\t\ty = y >> 1;\n\t\tx = (x * x) % p;\n\treturn res;\ndef findModuloByM(X, N, M) :\n\tif (N < 6) :\n\t\ttemp = chr(48 + X) * N\n\t\tres = int(temp) % M;\n\t\treturn res;\n\tif (N % 2 == 0) :\n\t\thalf = findModuloByM(X, N // 2, M) % M;\n\t\tres = (half * power(10, N // 2, M) + half) % M;\n\t\treturn res;\n\telse :\n\t\thalf = findModuloByM(X, N // 2, M) % M;\n\t\tres = (half * power(10, N // 2 + 1, M) + half * 10 + X) % M;\n\t\treturn res;", "9007": "def check(C):\n\tC1C2 = sqrt((C[1].x - C[0].x)\n\t\t\t\t* (C[1].x - C[0].x)\n\t\t\t+ (C[1].y - C[0].y)\n\t\t\t\t\t* (C[1].y - C[0].y))\n\tflag = 0\n\tif (C1C2 < (C[0].r + C[1].r)):\n\t\tif ((C[0].x + C[1].x) == 2 * C[2].x and (C[0].y + C[1].y) == 2 * C[2].y):\n\t\t\tflag = 1\n\treturn flag\ndef IsFairTriplet(c):\n\tf = False\n\tf |= check(c)\n\tfor i in range(2):\n\t\tc[0], c[2] = c[2], c[0]\n\t\tf |= check(c)\n\treturn f\ndef __init__(self, a, b, c):\n\t\tself.x = a\n\t\tself.y = b\n\t\tself.r = c", "9009": "def eccHyperbola(A, B):\n\tr = B * B / A * A\n\tr += 1\n\treturn math.sqrt(r)", "9012": "def calculateArea(A, B, C, D):\n\tS = (A + B + C + D) // 2\n\tarea = sqrt((S - A) * (S - B) *\n\t\t\t\t(S - C) * (S - D))\n\treturn area", "9015": "def triangleArea(a, b):\n\tratio = b / a\n\tprint(ratio)", "9021": "def distance(m, n, p, q):\n\treturn (sqrt(pow(n - m, 2) +\n\t\t\t\tpow(q - p, 2) * 1.0))\ndef Excenters(x1, y1, x2, y2, x3, y3):\n\ta = distance(x2, x3, y2, y3)\n\tb = distance(x3, x1, y3, y1)\n\tc = distance(x1, x2, y1, y2)\n\texcenter = [[0, 0] for i in range(4)]\n\texcenter[1][0] = ((-(a * x1) + (b * x2) +\n\t\t\t\t\t\t(c * x3)) // (-a + b + c))\n\texcenter[1][1] = ((-(a * y1) + (b * y2) +\n\t\t\t\t\t\t(c * y3)) // (-a + b + c))\n\texcenter[2][0] = (((a * x1) - (b * x2) +\n\t\t\t\t\t(c * x3)) // (a - b + c))\n\texcenter[2][1] = (((a * y1) - (b * y2) +\n\t\t\t\t\t(c * y3)) // (a - b + c))\n\texcenter[3][0] = (((a * x1) + (b * x2) -\n\t\t\t\t\t(c * x3)) // (a + b - c))\n\texcenter[3][1] = (((a * y1) + (b * y2) -\n\t\t\t\t\t(c * y3)) // (a + b - c))\n\tfor i in range(1, 4):\n\t\tprint(int(excenter[i][0]),\n\t\t\tint(excenter[i][1]))", "9035": "def findHeight(p1, p2, b, c) :\t\t\t\n\ta = max(p1, p2) - min(p1, p2)\n\ts = (a + b + c) // 2\n\tarea = math.sqrt(s * (s - a)\n\t\t\t\t\t* (s - b) * (s - c))\n\theight = (area * 2) / a\n\tprint(\"Height is: \", height)", "9070": "def areaOfSquare(S):\n\tarea = S * S\n\treturn area", "9079": "def maxPointOfIntersection(x, y):\n\tk = y * ( y - 1 ) // 2\n\tk = k + x * ( 2 * y + x - 1 )\n\treturn k", "9113": "def Icositetragonal_num(n):\n\treturn (22 * n * n - 20 * n) / 2", "9114": "def Icosihenagonal_num(n):\n\treturn (19 * n * n - 17 * n) / 2", "9119": "def area_of_circle(m, n):\n\tsquare_of_radius = ( m * n ) / 4\n\tarea = ( 3.141 * square_of_radius )\n\treturn area", "9129": "def area(R):\n\tbase = 1.732 * R\n\theight = ( 3 / 2 ) * R\n\tarea = (( 1 / 2 ) * base * height )\n\treturn area", "9130": "def circlearea(R) :\n\tif (R < 0) :\n\t\treturn -1;\n\ta = (3.14 * R * R) / 4;\n\treturn a;", "9137": "def countPairs(P, Q, N, M):\n\tA = [0] * 2\n\tB = [0] * 2\n\tfor i in range(N):\n\t\tA[P[i] % 2] += 1\n\tfor i in range(M):\n\t\tB[Q[i] % 2] += 1\n\treturn (A[0] * B[0] + A[1] * B[1])", "9142": "def find_Centroid(v):\n\tans = [0, 0]\n\tn = len(v)\n\tsignedArea = 0\n\tfor i in range(len(v)):\n\t\tx0 = v[i][0]\n\t\ty0 = v[i][1]\n\t\tx1 = v[(i + 1) % n][0]\n\t\ty1 =v[(i + 1) % n][1]\n\t\tA = (x0 * y1) - (x1 * y0)\n\t\tsignedArea += A\n\t\tans[0] += (x0 + x1) * A\n\t\tans[1] += (y0 + y1) * A\n\tsignedArea *= 0.5\n\tans[0] = (ans[0]) / (6 * signedArea)\n\tans[1] = (ans[1]) / (6 * signedArea)\n\treturn ans", "9147": "def countIntersections(n):\n\treturn n * (n - 1) // 2", "9169": "def newvol(x):\n\tprint(\"percentage increase in the\"\n\t\t\" volume of the sphere is \"\n\t\t,pow(x, 3) / 10000 + 3 * x\n\t\t\t\t+ (3 * pow(x, 2)) / 100 ,\"%\")", "9177": "def areaOfTriangle(d) :\n\tc = 1.618 * d\n\ts = (d + c + c) / 2\n\tarea = math.sqrt(s * (s - c) *\n\t\t\t\t\t\t(s - c) * (s - d))\n\treturn 5 * area\ndef areaOfRegPentagon(d) :\n\tglobal PI\n\tcal = 4 * math.tan(PI / 5)\n\tarea = (5 * d * d) / cal\n\treturn area\ndef areaOfPentagram(d) :\n\treturn areaOfRegPentagon(d) + areaOfTriangle(d)", "9181": "def anglequichord(z):\n\tprint (\"The angle is \" , z , \" degrees\")", "9187": "def circle(x1, y1, x2,y2, r1, r2):\n\tdistSq = (((x1 - x2)* (x1 - x2))+ ((y1 - y2)* (y1 - y2)))**(.5)\n\tif (distSq + r2 == r1):\n\t\tprint(\"The smaller circle lies completely\" \" inside the bigger circle with \" \"touching each other \" \"at a point of circumference. \")\n\telif (distSq + r2 < r1):\n\t\tprint(\"The smaller circle lies completely\" \" inside the bigger circle without\" \" touching each other \" \"at a point of circumference. \")\n\telse:\n\t\tprint(\"The smaller does not lies inside\" \" the bigger circle completely.\")", "9195": "def lengtang(r1, r2, d):\n\tprint(\"The length of the direct common tangent is \"\n\t\t,((d** 2) - ((r1 - r2)** 2))**(1/2));", "9196": "def rad(d, h):\n\tprint(\"The radius of the circle is\",\n\t\t((d * d) / (8 * h) + h / 2))", "9197": "def shortdis(r, d):\n\tprint(\"The shortest distance \",end=\"\");\n\tprint(\"from the chord to centre \",end=\"\");\n\tprint(((r * r) - ((d * d) / 4))**(1/2));", "9200": "def lengtang(r1, r2, d):\n\tprint(\"The length of the direct common tangent is\",\n\t\t(((d ** 2) - ((r1 - r2) ** 2)) ** (1 / 2)));", "9201": "def length_of_chord(r, x):\n\tprint(\"The length of the chord\"\n\t\t,\" of the circle is \"\n\t\t,2 * r * mt.sin(x * (3.14 / 180)))", "9232": "def square( a ):\n\tif (a < 0):\n\t\treturn -1\n\tx = 0.464 * a\n\treturn x", "9238": "def polyapothem(n, a):\n\tif (a < 0 and n < 0):\n\t\treturn -1\n\treturn a / (2 * tan((180 / n) * 3.14159 / 180))", "9240": "def polyarea(n, r) :\n\tif (r < 0 and n < 0) :\n\t\treturn -1\n\tA = (((r * r * n) * sin((360 / n) * 3.14159 / 180)) / 2);\n\treturn round(A, 3)", "9241": "def polyarea(n, a):\n\tif (a < 0 and n < 0):\n\t\treturn -1\n\tA = (a * a * n) / (4 * tan((180 / n) * 3.14159 / 180))\n\treturn A", "9247": "def hexDiagonal(a):\n\tif (a < 0):\n\t\treturn -1;\n\td = 1.73 * a;\n\treturn d;", "9250": "def calculateSide(n, r):\n\ttheta = 360 / n\n\ttheta_in_radians = theta * 3.14 / 180\n\treturn 2 * r * sin(theta_in_radians / 2)", "9257": "def cyl(r, R, h) :\n\tif (h < 0 and r < 0 and R < 0) :\n\t\treturn -1\n\tr1 = r\n\th1 = h\n\tV = 3.14 * pow(r1, 2) * h1\n\treturn round(V,2)", "9258": "def findVolume(a) :\n\tif (a < 0) :\n\t\treturn -1\n\tr = a / 2\n\th = a\n\tV = 3.14 * pow(r, 2) * h\n\treturn V", "9290": "def Perimeter(s, n):\n\tperimeter = 1\n\tperimeter = n * s\n\treturn perimeter", "9291": "def area(r):\n\treturn (0.5)*(3.14)*(r * r)\ndef perimeter(r):\n\treturn (3.14)*(r)", "9302": "", "9305": "def rhombusarea(l,b):\n\tif (l < 0 or b < 0):\n\t\treturn -1\n\treturn (l * b) / 2", "9318": "def area(a):\n\tif a < 0 :\n\t\treturn -1\n\tarea = sqrt(a) / 6\n\treturn area", "9329": "def longestRodInCuboid(length, breadth, height) :\n\ttemp = length * length + breadth * breadth + height * height\n\tresult = sqrt(temp)\n\treturn result", "9346": "def is_partition_possible(n, x, y, w):\n\tweight_at_x = defaultdict(int)\n\tmax_x = -2e3\n\tmin_x = 2e3\n\tfor i in range(n):\n\t\tnew_x = x[i] - y[i]\n\t\tmax_x = max(max_x, new_x)\n\t\tmin_x = min(min_x, new_x)\n\t\tweight_at_x[new_x] += w[i]\n\tsum_till = []\n\tsum_till.append(0)\n\tfor x in range(min_x, max_x + 1):\n\t\tsum_till.append(sum_till[-1] + weight_at_x[x])\n\ttotal_sum = sum_till[-1]\n\tpartition_possible = False\n\tfor i in range(1, len(sum_till)):\n\t\tif (sum_till[i] == total_sum - sum_till[i]):\n\t\t\tpartition_possible = True\n\t\tif (sum_till[i - 1] == total_sum - sum_till[i]):\n\t\t\tpartition_possible = True\n\tif partition_possible:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")", "9348": "def LiesInsieRectangle(a, b, x, y) :\n\tif(x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0) :\n\t\treturn True\n\treturn False", "9358": "def FindPoint(x1, y1, x2, y2, x, y) :\n\tif (x > x1 and x < x2 and y > y1 and y < y2) :\n\t\treturn True\n\telse :\n\t\treturn False", "9359": "def distance(a1, b1, c1, d1, a2, b2, c2, d2):\n\tif (a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2):\n\t\tx1 = y1 = 0\n\t\tz1 =-d1 / c1\n\t\td = abs(( c2 * z1 + d2)) / (math.sqrt(a2 * a2 + b2 * b2 + c2 * c2))\n\t\tprint(\"Perpendicular distance is\"), d\n\telse:\n\t\tprint(\"Planes are not parallel\")", "9362": "def shortest_distance(x1, y1, z1, a, b, c, d):\n\td = abs((a * x1 + b * y1 + c * z1 + d))\n\te = (math.sqrt(a * a + b * b + c * c))\n\tprint(\"Perpendicular distance is\", d/e)", "9369": "def findVolume(l, b, h) :\n\treturn ((l * b * h) / 2)", "9405": "def findPCSlope(m):\n\treturn -1.0 / m", "9423": "def isRectangle(a, b, c, d):\n\tif (a==b and d==c) or (a==c and b==d) or (a==d and b==c):\n\t\treturn True\n\telse:\t\n\t\treturn False", "9430": "def area_of_segment(radius, angle):\n\tarea_of_sector = pi *\n\t\t\t\t\t(radius * radius)\n\t\t\t\t\t* (angle / 360)\n\tarea_of_triangle = 1 / 2 *\n\t\t\t\t\t(radius * radius) *\n\t\t\t\t\tmath.sin((angle * pi) / 180)\n\treturn area_of_sector - area_of_triangle;", "9432": "def midpoint(x1, x2, y1, y2):\n\tprint((x1 + x2) // 2, \" , \",\n\t\t\t\t(y1 + y2) // 2)", "9445": "def maxvolume (s):\n\tmaxvalue = 0\n\ti = 1\n\tfor i in range(s - 1):\n\t\tj = 1\n\t\tfor j in range(s):\n\t\t\tk = s - i - j\n\t\t\tmaxvalue = max(maxvalue, i * j * k)\n\treturn maxvalue", "9446": "def maxvolume( s ):\n\tlength = int(s / 3)\n\ts -= length\n\tbreadth = s / 2\n\theight = s - breadth\n\treturn int(length * breadth * height)", "9452": "def volumeTriangular(a, b, h):\n\treturn (0.1666) * a * b * h\ndef volumeSquare(b, h):\n\treturn (0.33) * b * b * h\ndef volumePentagonal(a, b, h):\n\treturn (0.83) * a * b * h\ndef volumeHexagonal(a, b, h):\n\treturn a * b * h", "9457": "def Area(b1, b2, h):\n\treturn ((b1 + b2) / 2) * h", "9458": "def hexagonArea(s):\n\treturn ((3 * math.sqrt(3) *\n\t\t\t(s * s)) / 2);", "9467": "def arcLength(diameter, angle ):\n\tif angle >= 360:\n\t\tprint(\"Angle cannot be formed\")\n\t\treturn 0\n\telse:\n\t\tarc = (3.142857142857143 * diameter) * (angle / 360.0)\n\t\treturn arc", "9468": "def SectorArea(radius, angle):\n\tpi = 22 / 7\n\tif angle >= 360:\n\t\tprint(\"Angle not possible\")\n\t\treturn\n\telse:\n\t\tsector = (pi * radius ** 2) * (angle / 360)\n\t\tprint(sector)\n\t\treturn", "9476": "def maxSquare(b, m):\n\treturn (b / m - 1) * (b / m) / 2", "9478": "def checkCollision(a, b, c, x, y, radius):\n\tdist = ((abs(a * x + b * y + c)) /\n\t\t\tmath.sqrt(a * a + b * b))\n\tif (radius == dist):\n\t\tprint(\"Touch\")\n\telif (radius > dist):\n\t\tprint(\"Intersect\")\n\telse:\n\t\tprint(\"Outside\")", "9493": "def lineFromPoints(P, Q, a, b, c):\n\ta = Q[1] - P[1]\n\tb = P[0] - Q[0]\n\tc = a * (P[0]) + b * (P[1])\n\treturn a, b, c\ndef perpendicularBisectorFromLine(P, Q, a, b, c):\n\tmid_point = [(P[0] + Q[0])//2, (P[1] + Q[1])//2]\n\tc = -b * (mid_point[0]) + a * (mid_point[1])\n\ttemp = a\n\ta = -b\n\tb = temp\n\treturn a, b, c\ndef lineLineIntersection(a1, b1, c1, a2, b2, c2):\n\tdeterminant = a1 * b2 - a2 * b1\n\tif (determinant == 0):\n\t\treturn [(10.0)**19, (10.0)**19]\n\telse:\n\t\tx = (b2 * c1 - b1 * c2)//determinant\n\t\ty = (a1 * c2 - a2 * c1)//determinant\n\t\treturn [x, y]\ndef findCircumCenter(P, Q, R):\n\ta, b, c = 0.0, 0.0, 0.0\n\ta, b, c = lineFromPoints(P, Q, a, b, c)\n\te, f, g = 0.0, 0.0, 0.0\n\te, f, g = lineFromPoints(Q, R, e, f, g)\n\ta, b, c = perpendicularBisectorFromLine(P, Q, a, b, c)\n\te, f, g = perpendicularBisectorFromLine(Q, R, e, f, g)\n\tcircumcenter = lineLineIntersection(a, b, c, e, f, g)\n\tif (circumcenter[0] == (10.0)**19 and circumcenter[1] == (10.0)**19):\n\t\tprint(\"The two perpendicular bisectors found come parallel\")\n\t\tprint(\"Thus, the given points do not form a triangle and are collinear\")\n\telse:\n\t\tprint(\"The circumcenter of the triangle PQR is: \", end=\"\")\n\t\tprint(\"(\", circumcenter[0], \",\", circumcenter[1], \")\")", "9496": "def numberOfDiagonals(n):\n\treturn n * (n - 3) / 2", "9505": "def findRightAngle(A, H):\n\tD = pow(H,4) - 16 * A * A\n\tif D >= 0:\n\t\troot1 = (H * H + sqrt(D))/2\n\t\troot2 = (H * H - sqrt(D))/2\n\t\ta = sqrt(root1)\n\t\tb = sqrt(root2)\n\t\tif b >= a:\n\t\t\tprint a, b, H\n\t\telse:\n\t\t\tprint b, a, H\n\telse:\n\t\tprint \"-1\"", "9507": "def numberOfSquares(base):\n\tbase = (base - 2)\n\tbase = base // 2\n\treturn base * (base + 1) / 2", "9528": "def polygonArea(X,Y, n) :\n\tarea = 0.0\n\tj = n - 1\n\tfor i in range( 0, n) :\n\t\tarea = area + (X[j] + X[i]) * (Y[j] - Y[i])\n\treturn abs(area // 2.0)", "9567": "def chk(v):\n\tv = list(bin(v)[2:])\n\tv.reverse()\n\tif('1' in v):\n\t\tv = v.index('1')\n\t\treturn (2**v)\n\telse:\n\t\treturn 0\ndef sumOfLSB(arr, N):\n\tlsb_arr = []\n\tfor i in range(N):\n\t\tlsb_arr.append(chk(arr[i]))\n\tlsb_arr.sort(reverse=True)\n\tans = 0\n\tfor i in range(0, N-1, 2):\n\t\tans += (lsb_arr[i+1])\n\tprint(ans)", "9574": "def countSubsequences(arr):\n\todd = 0\n\tfor x in arr:\n\t\tif (x & 1):\n\t\t\todd = odd + 1\n\treturn (1 << odd) - 1", "9608": "def performQuery(arr, Q):\n\tfor i in range (0, len(Q)):\n\t\torr = 0\n\t\tx = Q[i][0]\n\t\tarr[x - 1] = Q[i][1]\n\t\tfor j in range(0,len(arr)):\n\t\t\torr = orr | arr[j]\n\t\tprint(orr ,end= \" \")", "9638": "def smallest(k, d):\n\tcnt = 1\n\tm = d % k\n\tv = [0 for i in range(k)];\n\tv[m] = 1\n\twhile (1):\n\t\tif (m == 0):\n\t\t\treturn cnt\n\t\tm = (((m * (10 % k)) % k) + (d % k)) % k\n\t\tif (v[m] == 1):\n\t\t\treturn -1\n\t\tv[m] = 1\n\t\tcnt += 1\n\treturn -1", "9639": "def getPairsCount(arr, n):\n\tcount = 0\n\tfor i in range(n):\n\t\tfor j in range(arr[i] - (i % arr[i]),n,arr[i]):\n\t\t\tif (i < j and abs(arr[i] - arr[j]) >= min(arr[i], arr[j])):\n\t\t\t\tcount += 1\n\treturn count", "9673": "def check(N):\n\ttwos = 0\n\tfives = 0\n\twhile (N % 2 == 0):\n\t\tN /= 2\n\t\ttwos += 1\n\twhile (N % 5 == 0):\n\t\tN /= 5\n\t\tfives += 1\n\tif (N == 1 and twos <= fives):\n\t\tprint(2 * fives - twos)\n\telse:\n\t\tprint(-1)", "9685": "def rangeSum(arr, N, L, R):\n\tsum = 0\n\tfor i in range(L - 1,R,1):\n\t\tsum += arr[i % N]\n\tprint(sum)", "9686": "def rangeSum(arr, N, L, R):\n\tprefix = [0 for i in range(N + 1)]\n\tprefix[0] = 0\n\tfor i in range(1,N+1,1):\n\t\tprefix[i] = prefix[i - 1] + arr[i - 1]\n\tleftsum = ((L - 1) // N) * prefix[N] + prefix[(L - 1) % N]\n\trightsum = (R // N) * prefix[N] + prefix[R % N]\n\tprint(rightsum - leftsum)", "9702": "def ExpoFactorial(N):\n\tres = 1\n\tmod = (int)(1000000007)\n\tfor i in range(2, N + 1):\n\t\tres = pow(i, res, mod)\n\treturn res", "9704": "def maxSubArraySumRepeated(arr, N, K):\n\tsum = 0\n\tfor i in range(N):\n\t\tsum += arr[i]\n\tcurr = arr[0]\n\tans = arr[0]\n\tif (K == 1):\n\t\tfor i in range(1,N,1):\n\t\t\tcurr = max(arr[i], curr + arr[i])\n\t\t\tans = max(ans, curr)\n\t\treturn ans\n\tV = []\n\tfor i in range(2 * N):\n\t\tV.append(arr[i % N])\n\tmaxSuf = V[0]\n\tmaxPref = V[2 * N - 1]\n\tcurr = V[0]\n\tfor i in range(1,2 * N,1):\n\t\tcurr += V[i]\n\t\tmaxPref = max(maxPref, curr)\n\tcurr = V[2 * N - 1]\n\ti = 2 * N - 2\n\twhile(i >= 0):\n\t\tcurr += V[i]\n\t\tmaxSuf = max(maxSuf, curr)\n\t\ti -= 1\n\tcurr = V[0]\n\tfor i in range(1, 2 * N, 1):\n\t\tcurr = max(V[i], curr + V[i])\n\t\tans = max(ans, curr)\n\tif (sum > 0):\n\t\ttemp = sum * (K - 2)\n\t\tans = max(ans, max(temp + maxPref, temp + maxSuf))\n\treturn ans", "9707": "def factorial(n):\n\tif (n == 0):\n\t\treturn 1\n\treturn n * factorial(n - 1)\ndef numOfNecklace(N):\n\tans = factorial(N) // (factorial(N // 2) * factorial(N // 2))\n\tans = ans * factorial(N // 2 - 1)\n\tans = ans * factorial(N // 2 - 1)\n\tans //= 2\n\treturn ans", "9726": "def gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\ndef countPairs(arr, N):\n\tfor i in range(0, N):\n\t\tcount = 0\n\t\tfor x in range(1, arr[i] + 1):\n\t\t\tfor y in range(x, arr[i] + 1):\n\t\t\t\tif gcd(x, y) > 1:\n\t\t\t\t\tcount += 1\n\t\tprint(count, end = \" \")", "9735": "def countSubarray(arr, n):\n\tcount = 0\n\tfor i in range(n):\n\t\tfor j in range(i, n, 1):\n\t\t\tmxSubarray = 0\n\t\t\tmxOther = 0\n\t\t\tfor k in range(i, j + 1, 1):\n\t\t\t\tmxSubarray = max(mxSubarray, arr[k])\n\t\t\tfor k in range(0, i, 1):\n\t\t\t\tmxOther = max(mxOther, arr[k])\n\t\t\tfor k in range(j + 1,n,1):\n\t\t\t\tmxOther = max(mxOther, arr[k])\n\t\t\tif (mxSubarray > (2 * mxOther)):\n\t\t\t\tcount += 1\n\tprint(count)", "9736": "def countSubarray(arr, n):\n\tcount = 0\n\tL = 0\n\tR = 0\n\tmx = max(arr)\n\tfor i in range(n):\n\t\tif (arr[i] * 2 > mx):\n\t\t\tL = i\n\t\t\tbreak\n\ti = n - 1\n\twhile (i >= 0):\n\t\tif (arr[i] * 2 > mx):\n\t\t\tR = i\n\t\t\tbreak\n\t\ti -= 1\n\tprint((L + 1) * (n - R))", "9738": "def isPrime(X):\n\tfor i in range(2, int(sqrt(X)) + 1, 1):\n\t\tif (X % i == 0):\n\t\t\treturn False\n\treturn True\ndef printPrimes(A, N):\n\tfor i in range(N):\n\t\tj = A[i] - 1\n\t\twhile(1):\n\t\t\tif (isPrime(j)):\n\t\t\t\tprint(j, end = \" \")\n\t\t\t\tbreak\n\t\t\tj -= 1\n\t\tj = A[i] + 1\n\t\twhile (1):\n\t\t\tif (isPrime(j)):\n\t\t\t\tprint(j, end = \" \")\n\t\t\t\tbreak\n\t\t\tj += 1\n\t\tprint(\"\\n\", end = \"\")", "9759": "def PrimeFactor(N):\n\tANS = dict()\n\twhile N % 2 == 0:\n\t\tif 2 in ANS:\n\t\t\tANS[2] += 1\n\t\telse:\n\t\t\tANS[2] = 1\n\t\tN = N//2\n\tfor i in range(3, int(math.sqrt(N))+1, 2):\n\t\twhile N % i == 0:\n\t\t\tif i in ANS:\n\t\t\t\tANS[i] += 1\n\t\t\telse:\n\t\t\t\tANS[i] = 1\n\t\t\tN = N // i\n\tif 2 < N:\n\t\tANS[N] = 1\n\treturn ANS\ndef CountToMakeEqual(X, Y):\n\tGCD = math.gcd(X, Y)\n\tnewY = X//GCD\n\tnewX = Y//GCD\n\tprimeX = PrimeFactor(newX)\n\tprimeY = PrimeFactor(newY)\n\tans = 0\n\tfor factor in primeX:\n\t\tif X % factor != 0:\n\t\t\treturn -1\n\t\tans += primeX[factor]\n\tfor factor in primeY:\n\t\tif Y % factor != 0:\n\t\t\treturn -1\n\t\tans += primeY[factor]\n\treturn ans", "9777": "def isDivisibleByDivisor(S, D):\n\tS %= D\n\thashMap = set()\n\thashMap.add(S)\n\tfor i in range(D+1):\n\t\tS += (S % D)\n\t\tS %= D\n\t\tif (S in hashMap):\n\t\t\tif (S == 0):\n\t\t\t\treturn \"Yes\"\n\t\t\treturn \"No\"\n\t\telse:\n\t\t\thashMap.add(S)\n\treturn \"Yes\"", "9787": "def KthSmallest(A, B, N, K):\n\tM = 0\n\tfor i in range(N):\n\t\tM = max(A[i], M)\n\tfreq = [0] * (M + 1)\n\tfor i in range(N):\n\t\tfreq[A[i]] += B[i]\n\tsum = 0\n\tfor i in range(M + 1):\n\t\tsum += freq[i]\n\t\tif (sum >= K):\n\t\t\treturn i\n\treturn -1", "9804": "def findbitwiseOR(a, n):\n\tres = 0\n\tfor i in range(n):\n\t\tcurr_sub_array = a[i]\n\t\tres = res | curr_sub_array\n\t\tfor j in range(i, n):\n\t\t\tcurr_sub_array = curr_sub_array & a[j]\n\t\t\tres = res | curr_sub_array\n\tprint (res)", "9805": "def findbitwiseOR(a, n):\n\tres = 0\n\tfor i in range(n):\n\t\tres = res | a[i]\n\tprint(res)", "9818": "def check(n):\n\tsumOfDigit = 0\n\tprodOfDigit = 1\n\twhile n > 0:\n\t\trem = n % 10\n\t\tsumOfDigit += rem\n\t\tprodOfDigit *= rem\n\t\tn = n // 10\n\tif sumOfDigit > prodOfDigit:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "9824": "def evenOddBitwiseXOR(N):\n\tprint(\"Even: \", 0, end = \" \")\n\tfor i in range(4, N + 1, 4):\n\t\tprint(i, end = \" \")\n\tprint()\n\tprint(\"Odd: \", 1, end = \" \")\n\tfor i in range(4, N + 1, 4):\n\t\tprint(i - 1, end = \" \")\n\tif (N % 4 == 2):\n\t\tprint(N + 1)\n\telif (N % 4 == 3):\n\t\tprint(N)", "9829": "def findPermutation(arr):\n\tN = len(arr)\n\ti = N - 2\n\twhile (i >= 0 and arr[i] <= arr[i + 1]):\n\t\ti -= 1\n\tif (i == -1) :\n\t\tprint(\"-1\")\n\t\treturn\n\tj = N - 1\n\twhile (j > i and arr[j] >= arr[i]):\n\t\tj -= 1\n\twhile (j > i and arr[j] == arr[j - 1]) :\n\t\tj -= 1\n\ttemp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n\tfor it in arr :\n\t\tprint(it, end = \" \")", "9849": "def sieveOfEratosthenes(N, s):\n\tprime = [False]*(N + 1)\n\tfor i in range(2, N + 1, 2):\n\t\ts[i] = 2\n\tfor i in range(3, N, 2):\n\t\tif (prime[i] == False):\n\t\t\ts[i] = i\n\t\t\tfor j in range(i, N, 2):\n\t\t\t\tif j * i > N:\n\t\t\t\t\tbreak\n\t\t\t\tif (not prime[i * j]):\n\t\t\t\t\tprime[i * j] = True\n\t\t\t\t\ts[i * j] = i\ndef findDifference(N):\n\ts = [0]*(N+1)\n\tsieveOfEratosthenes(N, s)\n\ttotal , odd , even =1, 1, 0\n\tcurr = s[N]\n\tcnt = 1\n\twhile (N > 1):\n\t\tN //= s[N]\n\t\tif (curr == s[N]):\n\t\t\tcnt += 1\n\t\t\tcontinue\n\t\tif (curr == 2):\n\t\t\ttotal = total * (cnt + 1)\n\t\telse:\n\t\t\ttotal = total * (cnt + 1)\n\t\t\todd = odd * (cnt + 1)\n\t\tcurr = s[N]\n\t\tcnt = 1\n\teven = total - odd\n\tprint(abs(even - odd))", "9877": "def findMedian(Mean, Mode):\n\tMedian = (2 * Mean + Mode) // 3\n\tprint(Median)", "9889": "def vectorMagnitude(x, y, z):\n\tsum = x * x + y * y + z * z\n\treturn sqrt(sum)", "9905": "def minimumSteps(x, y):\n\tcnt = 0\n\twhile (x != 0 and y != 0):\n\t\tif (x > y):\n\t\t\tcnt += x / y\n\t\t\tx %= y\n\t\telse:\n\t\t\tcnt += y / x\n\t\t\ty %= x\n\tcnt -= 1\n\tif (x > 1 or y > 1):\n\t\tcnt = -1\n\tprint(int(cnt))", "9915": "def check(Adj, Src, N, visited):\n\tcolor = [0] * N\n\tvisited = [True] * Src\n\tq = deque()\n\tq.append(Src)\n\twhile (len(q) > 0):\n\t\tu = q.popleft()\n\t\tCol = color[u]\n\t\tfor x in Adj[u]:\n\t\t\tif (visited[x] == True and color[x] == Col):\n\t\t\t\treturn False\n\t\t\telif (visited[x] == False):\n\t\t\t\tvisited[x] = True\n\t\t\t\tq.append(x)\n\t\t\t\tcolor[x] = 1 - Col\n\treturn True\ndef addEdge(Adj, u, v):\n\tAdj[u].append(v)\n\tAdj[v].append(u)\n\treturn Adj\ndef isPossible(Arr, N):\n\tAdj = [[] for i in range(N)]\n\tfor i in range(N - 1):\n\t\tfor j in range(i + 1, N):\n\t\t\tif (Arr[i][0] < Arr[j][1] or Arr[i][1] > Arr[j][0]):\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tif (Arr[i][2] == Arr[j][2]):\n\t\t\t\t\tAdj = addEdge(Adj, i, j)\n\tvisited = [False] * N\n\tfor i in range(N):\n\t\tif (visited[i] == False and len(Adj[i]) > 0):\n\t\t\tif (check(Adj, i, N, visited) == False):\n\t\t\t\tprint (\"No\")\n\t\t\t\treturn\n\tprint (\"Yes\")", "9935": "def checkCommonDivisor(arr, N, X):\n\tG = 0\n\tfor i in range(N):\n\t\tG = math.gcd(G, arr[i])\n\tcopy_G = G\n\tfor divisor in range(2, X + 1):\n\t\twhile (G % divisor == 0):\n\t\t\tG = G // divisor\n\tif (G <= X):\n\t\tprint(\"Yes\")\n\t\tfor i in range(N):\n\t\t\tprint(arr[i] // copy_G, end = \" \")\n\t\tprint()\n\telse:\n\t\tprint(\"No\")", "9948": "def multiplyByMersenne(N, M) :\n\tx = int(math.log2(M + 1))\n\treturn ((N << x) - N)", "9958": "def perfectSquare(num):\n\tsr = int(sqrt(num))\n\ta = sr * sr\n\tb = (sr + 1) * (sr + 1)\n\tif ((num - a) < (b - num)):\n\t\treturn a\n\telse:\n\t\treturn b\ndef powerOfTwo(num):\n\tlg = int(log2(num))\n\tp = int(pow(2, lg))\n\treturn p\ndef uniqueElement(arr, N):\n\tans = True\n\tfreq = {}\n\tfor i in range(N):\n\t\tif (arr[i] in freq):\n\t\t\tfreq[arr[i]] += 1\n\t\telse:\n\t\t\tfreq[arr[i]] = 1\n\tres = []\n\tfor key,value in freq.items():\n\t\tif (value == 1):\n\t\t\tans = False\n\t\t\tps = perfectSquare(key)\n\t\t\tres.append(powerOfTwo(ps))\n\tres.sort(reverse = False)\n\tfor x in res:\n\tprint(x, end = \" \")\n\tif (ans):\n\t\tprint(\"-1\")", "9963": "def partitionArray(a, n) :\n Min = [0] * n\n Mini = sys.maxsize\n for i in range(n - 1, -1, -1):\n\tMini = min(Mini, a[i])\n\tMin[i] = Mini\n Maxi = -sys.maxsize - 1\n ind = -1\n for i in range(n - 1):\n\tMaxi = max(Maxi, a[i])\n\tif (Maxi < Min[i + 1]) :\n\tind = i\n\tbreak\n if (ind != -1) :\n\tfor i in range(ind + 1):\n\tprint(a[i], end = \" \")\n\tprint()\n\tfor i in range(ind + 1 , n , 1):\n\tprint(a[i], end = \" \")\n else :\n\tprint(\"Impossible\")", "9971": "def countPrimeFactors(n) :\n\tcount = 0\n\twhile (n % 2 == 0) :\n\t\tn = n // 2\n\t\tcount += 1\n\tfor i in range(3, int(math.sqrt(n) + 1), 2) :\n\t\twhile (n % i == 0) :\n\t\t\tn = n // i\n\t\t\tcount += 1\n\tif (n > 2) :\n\t\tcount += 1\n\treturn (count)\ndef findSum(n) :\n\tsum = 0\n\ti = 1\n\tnum = 2\n\twhile(i <= n) :\n\t\tif (countPrimeFactors(num) == 2) :\n\t\t\tsum += num\n\t\t\ti += 1\n\t\tnum += 1\n\treturn sum\ndef check(n, k) :\n\ts = findSum(k - 1)\n\tif (s >= n) :\n\t\tprint(\"No\")\n\telse :\n\t\tprint(\"Yes\")", "9979": "def gcd(a, b) :\n\twhile (b > 0) :\n\t\trem = a % b\n\t\ta = b\n\t\tb = rem\n\treturn a\ndef countNumberOfWays(n) :\n\tif (n == 1) :\n\t\treturn -1\n\tg = 0\n\tpower = 0\n\twhile (n % 2 == 0) :\n\t\tpower += 1\n\t\tn //= 2\n\tg = gcd(g, power)\n\tfor i in range(3, int(math. sqrt(g)) + 1, 2):\n\t\tpower = 0\n\t\twhile (n % i == 0) :\n\t\t\tpower += 1\n\t\t\tn //= i\t\n\t\tg = gcd(g, power)\n\tif (n > 2) :\n\t\tg = gcd(g, 1)\n\tways = 1\n\tpower = 0\n\twhile (g % 2 == 0) :\n\t\tg //= 2\n\t\tpower += 1\n\tways *= (power + 1)\n\tfor i in range(3, int(math. sqrt(g)) + 1, 2):\n\t\tpower = 0\n\t\twhile (g % i == 0) :\n\t\t\tpower += 1\n\t\t\tg /= i\n\t\tways *= (power + 1)\n\tif (g > 2) :\n\t\tways *= 2\n\treturn ways", "10030": "def isPossible(target):\n max = 0\n index = 0\n for i in range(len(target)):\n\tif (max < target[i]):\n\tmax = target[i]\n\tindex = i\n if (max == 1):\n\treturn True\n for i in range(len(target)):\n\tif (i != index):\n\tmax -= target[i]\n\tif (max <= 0):\n\t\treturn False\n target[index] = max\n return isPossible(target)", "10041": "def convertToASCII(N):\n\tnum = str(N)\n\ti = 0\n\tfor ch in num:\n\t\tprint(ch, \"(\", ord(ch), \")\")", "10049": "def productExceptSelf(arr, N) :\n\tproduct = 1\n\tz = 0\n\tfor i in range(N):\n\t\tif (arr[i] != 0) :\n\t\t\tproduct *= arr[i]\n\t\tif(arr[i] == 0):\n\t\t\tz += 1\n\ta = abs(product)\n\tfor i in range(N):\n\t\tif (z == 1) :\n\t\t\tif (arr[i] != 0) :\n\t\t\t\tarr[i] = 0\n\t\t\telse :\n\t\t\t\tarr[i] = product\n\t\t\tcontinue\n\t\telif (z > 1) :\n\t\t\tarr[i] = 0\n\t\t\tcontinue\n\t\tb = abs(arr[i])\n\t\tcurr = round(math.exp(math.log(a) - math.log(b)))\n\t\tif (arr[i] < 0 and product < 0):\n\t\t\tarr[i] = curr\n\t\telif (arr[i] > 0 and product > 0):\n\t\t\tarr[i] = curr\n\t\telse:\n\t\t\tarr[i] = -1 * curr\n\tfor i in range(N):\n\t\tprint(arr[i], end = \" \")", "10054": "def singleDigitSubarrayCount(arr, N):\n\tres = 0\n\tcount = 0\n\tfor i in range(N):\n\t\tif (arr[i] <= 9):\n\t\t\tcount += 1\n\t\t\tres += count\n\t\telse:\n\t\t\tcount = 0\n\tprint (res)", "10057": "def isPossible(N):\n\treturn ((N & (N - 1)) and N)\ndef countElements(N):\n\tcount = 0\n\tfor i in range(1, N + 1):\n\t\tif (isPossible(i)):\n\t\t\tcount += 1\n\tprint (count)", "10058": "def countElements(N):\n\tCur_Ele = 1\n\tCount = 0\n\twhile (Cur_Ele <= N):\n\t\tCount += 1\n\t\tCur_Ele = Cur_Ele * 2\n\tprint(N - Count)", "10062": "def minSum(A, N):\n\tmp = {}\n\tsum = 0\n\tfor i in range(N):\n\t\tsum += A[i]\n\t\tif A[i] in mp:\n\t\t\tmp[A[i]] += 1\n\t\telse:\n\t\t\tmp[A[i]] = 1\n\tminSum = float('inf')\n\tfor it in mp:\n\t\tminSum = min(minSum, sum - (it * mp[it]))\n\treturn minSum", "10063": "def maxAdjacent(arr, N):\n\tres = []\n\tfor i in range(1, N - 1):\n\t\tprev = arr[0]\n\t\tmaxi = -1* float('inf')\n\t\tfor j in range(1,N):\n\t\t\tif (i == j):\n\t\t\t\tcontinue\n\t\t\tmaxi = max(maxi, abs(arr[j] - prev))\n\t\t\tprev = arr[j]\n\t\tres.append(maxi)\n\tfor x in res:\n\t\tprint(x,end=' ')\n\tprint()", "10064": "def maxAdjacent(arr, N):\n\tres = []\n\tarr_max = -sys.maxsize - 1\n\tfor i in range(1, N):\n\t\tarr_max = max(arr_max,\n\t\t\t\t\tabs(arr[i - 1] - arr[i]))\n\tfor i in range(1, N - 1):\n\t\tcurr_max = abs(arr[i - 1] - arr[i + 1])\n\t\tans = max(curr_max, arr_max)\n\t\tres.append(ans)\n\tfor x in res:\n\t\tprint(x, end=\" \")\n\tprint()", "10071": "def minimumIncrement(arr, N):\n\tif (N % 2 != 0):\n\t\tprint(\"-1\")\n\t\treturn\n\tcntEven = 0\n\tcntOdd = 0\n\tfor i in range(N):\n\t\tif (arr[i] % 2 == 0):\n\t\t\tcntEven += 1\n\tcntOdd = N - cntEven\n\treturn abs(cntEven - cntOdd) // 2", "10076": "def findSize(N):\n\tif (N == 0):\n\t\treturn 1\n\tif (N == 1):\n\t\treturn 1\n\tSize = 2 * findSize(N // 2) + 1\n\treturn Size\ndef CountOnes(N, L, R):\n\tif (L > R):\n\t\treturn 0\n\tif (N <= 1):\n\t\treturn N\n\tret = 0\n\tM = N // 2\n\tSiz_M = findSize(M)\n\tif (L <= Siz_M):\n\t\tret += CountOnes(\n\t\t\tN // 2, L, min(Siz_M, R))\n\tif (L <= Siz_M + 1 and Siz_M + 1 <= R):\n\t\tret += N % 2\n\tif (Siz_M + 1 < R):\n\t\tret += CountOnes(N // 2,\n\t\t\t\t\t\tmax(1, L - Siz_M - 1), R - Siz_M - 1)\n\treturn ret", "10114": "def cntWaysConsArray(A, N) :\n\ttotal = 1;\n\toddArray = 1;\n\tfor i in range(N) :\n\t\ttotal = total * 3;\n\t\tif (A[i] % 2 == 0) :\n\t\t\toddArray *= 2;\n\tprint(total - oddArray);", "10120": "def countNumberHavingKthBitSet(N, K):\n\tnumbers_rightmost_setbit_K = 0\n\tfor i in range(1, K + 1):\n\t\tnumbers_rightmost_bit_i = (N + 1) // 2\n\t\tN -= numbers_rightmost_bit_i\n\t\tif (i == K):\n\t\t\tnumbers_rightmost_setbit_K = numbers_rightmost_bit_i\n\tprint (numbers_rightmost_setbit_K)", "10123": "def countSetBits(N: int) -> int:\n\tcount = 0\n\twhile (N):\n\t\tN = N & (N - 1)\n\t\tcount += 1\n\treturn count", "10124": "def minMoves(arr, N):\n\todd_element_cnt = 0;\n\tfor i in range(N):\n\t\tif (arr[i] % 2 != 0):\n\t\t\todd_element_cnt += 1;\n\tmoves = (odd_element_cnt) // 2;\n\tif (odd_element_cnt % 2 != 0):\n\t\tmoves += 2;\n\tprint(moves);", "10145": "def minimumSubsetDifference(N):\n\tblockOfSize8 = N // 8\n\tstr = \"ABBABAAB\"\n\tsubsetDifference = 0\n\tpartition = \"\"\n\twhile blockOfSize8 != 0:\n\t\tpartition = partition + str\n\t\tblockOfSize8 = blockOfSize8 - 1\n\tA = []\n\tB = []\n\tfor i in range(N):\n\t\tif partition[i] == 'A':\n\t\t\tA.append((i + 1) * (i + 1))\n\t\telse:\n\t\t\tB.append((i + 1) * (i + 1))\n\tprint(subsetDifference)\n\tfor i in A:\n\t\tprint(i, end = \" \")\n\tprint()\n\tfor i in B:\n\t\tprint(i, end = \" \")", "10155": "def findTheGreatestX(P, Q):\n\tdivisiors = defaultdict(int)\n\ti = 2\n\twhile i * i <= Q:\n\t\twhile (Q % i == 0 and Q > 1):\n\t\t\tQ //= i\n\t\t\tdivisiors[i] += 1\n\t\ti += 1\n\tif (Q > 1):\n\t\tdivisiors[Q] += 1\n\tans = 0\n\tfor i in divisiors:\n\t\tfrequency = divisiors[i]\n\t\ttemp = P\n\t\tcur = 0\n\t\twhile (temp % i == 0):\n\t\t\ttemp //= i\n\t\t\tcur += 1\n\t\tif (cur < frequency):\n\t\t\tans = P\n\t\t\tbreak\n\t\ttemp = P\n\t\tfor j in range(cur, frequency-1, -1):\n\t\t\ttemp //= i\n\t\tans = max(temp, ans)\n\tprint(ans)", "10174": "def checkRearrangements(mat, N, M):\n\tfor i in range(N):\n\t\tfor j in range(1, M):\n\t\t\tif (mat[i][0] != mat[i][j]):\n\t\t\t\treturn \"Yes\"\n\treturn \"No\"\ndef nonZeroXor(mat, N, M):\n\tres = 0\n\tfor i in range(N):\n\t\tres = res ^ mat[i][0]\n\tif (res != 0):\n\t\treturn \"Yes\"\n\telse:\n\t\treturn checkRearrangements(mat, N, M)", "10186": "def findPrimeNos(L, R, M):\n\tfor i in range(L, R + 1):\n\t\tM[i] = M.get(i, 0) + 1\n\tif (1 in M):\n\t\tM.pop(1)\n\tfor i in range(2, int(sqrt(R)) + 1, 1):\n\t\tmultiple = 2\n\t\twhile ((i * multiple) <= R):\n\t\t\tif ((i * multiple) in M):\n\t\t\t\tM.pop(i * multiple)\n\t\t\tmultiple += 1\ndef getPrimePairs(L, R, K):\n\tM = {}\n\tfindPrimeNos(L, R, M)\n\tfor key, values in M.items():\n\t\tif ((key + K) in M):\n\t\t\tprint(\"(\", key, \",\", key + K, \")\", end = \" \")", "10212": "def functionMax(arr, n):\n\tsetBit = [[] for i in range(32)]\n\tfor i in range(n):\n\t\tfor j in range(32):\n\t\t\tif (arr[i] & (1 << j)):\n\t\t\t\tsetBit[j].append(i)\n\ti = 31\n\twhile(i >= 0):\n\t\tif (len(setBit[i]) == 1):\n\t\t\ttemp = arr[0]\n\t\t\tarr[0] = arr[setBit[i][0]]\n\t\t\tarr[setBit[i][0]] = temp\n\t\t\tbreak\n\t\ti -= 1\n\tmaxAnd = arr[0]\n\tfor i in range(1, n, 1):\n\t\tmaxAnd = (maxAnd & (~arr[i]))\n\treturn maxAnd", "10228": "def prime(n):\n\tif (n == 1):\n\t\treturn False\n\tfor i in range(2, n + 1):\n\t\tif i * i > n:\n\t\t\tbreak\n\t\tif (n % i == 0):\n\t\t\treturn False\n\treturn True\ndef minDivisior(n):\n\tif (prime(n)):\n\t\tprint(1, n - 1)\n\telse:\n\t\tfor i in range(2, n + 1):\n\t\t\tif i * i > n:\n\t\t\t\tbreak\n\t\t\tif (n % i == 0):\n\t\t\t\tprint(n // i, n // i * (i - 1))\n\t\t\t\tbreak", "10233": "def gcd(a, b):\n\tif (a == 0):\n\t\treturn b\n\treturn gcd(b % a, a)\ndef lcm(a, b):\n\treturn (a * b) // gcd(a, b)\ndef findLCM(arr):\n\tglobal Landau\n\tnth_lcm = arr[0]\n\tfor i in range(1, len(arr)):\n\t\tnth_lcm = lcm(nth_lcm, arr[i])\n\tLandau = max(Landau, nth_lcm)\ndef findWays(arr, i, n):\n\tif (n == 0):\n\t\tfindLCM(arr)\n\tfor j in range(i, n + 1):\n\t\tarr.append(j)\n\t\tfindWays(arr, j, n - j)\n\t\tarr.pop()\ndef Landau_function(n):\n\tarr = []\n\tfindWays(arr, 1, n)\n\tprint(Landau)", "10237": "def nCr(n, r):\n\tres = 1\n\tif r > n - r:\n\t\tr = n - r\n\tfor i in range(r):\n\t\tres *= (n - i)\n\t\tres /= (i + 1)\n\treturn res;\ndef solve(n, m, k):\n\tsum = 0;\n\tfor i in range(k + 1):\n\t\tsum += nCr(n, i) * nCr(m, k - i)\n\treturn int(sum)", "10238": "def nCr(n, r):\n\tres = 1\n\tif(r > n - r):\n\t\tr = n - r\n\tfor i in range(r):\n\t\tres *= (n - i)\n\t\tres //= (i + 1)\n\treturn res", "10267": "def powerOptimised(a, n):\n\tans = 1\n\twhile (n > 0):\n\t\tlast_bit = (n & 1)\n\t\tif (last_bit):\n\t\t\tans = ans * a\n\t\ta = a * a\n\t\tn = n >> 1\n\treturn ans", "10269": "def findMaximumGcd(n):\n\tmax_gcd = 1\n\ti = 1\n\twhile (i * i <= n):\n\t\tif n % i == 0:\n\t\t\tif (i > max_gcd):\n\t\t\t\tmax_gcd = i\n\t\t\tif ((n / i != i) and\n\t\t\t\t(n / i != n) and\n\t\t\t((n / i) > max_gcd)):\n\t\t\t\tmax_gcd = n / i\n\t\ti += 1\n\treturn (int(max_gcd))", "10309": "def sieve():\n\tv[1] = 1\n\tfor i in range(2, x):\n\t\tv[i] = i\n\tfor i in range(4, x, 2):\n\t\tv[i] = 2\n\ti = 3\n\twhile (i * i < x):\n\t\tif (v[i] == i):\n\t\t\tfor j in range(i * i, x, i):\n\t\t\t\tif (v[j] == j):\n\t\t\t\t\tv[j] = i\n\t\ti += 1\ndef prime_factors(n):\n\ts = set()\n\twhile (n != 1):\n\t\ts.add(v[n])\n\t\tn = n // v[n]\n\treturn len(s)\ndef distinctPrimes(m, k):\n\tresult = []\n\tfor i in range(14, m + k):\n\t\tcount = prime_factors(i)\n\t\tif (count == k):\n\t\t\tresult.append(i)\n\tp = len(result)\n\tfor index in range(p - 1):\n\t\telement = result[index]\n\t\tcount = 1\n\t\tz = index\n\t\twhile (z < p - 1 and count <= k and result[z] + 1 == result[z + 1]):\n\t\t\tcount += 1\n\t\t\tz += 1\n\t\tif (count >= k):\n\t\t\tprint(element, end = ' ')", "10325": "def print_product(a, b, c, d):\n\tprod1 = a * c\n\tprod2 = b * d\n\tprod3 = (a + b) * (c + d)\n\treal = prod1 - prod2\n\timag = prod3 - (prod1 + prod2)\n\tprint(real, \" + \", imag, \"i\")", "10330": "def reverse(num):\n\trev_num = 0\n\twhile(num > 0):\n\t\trev_num = rev_num * 10 + num % 10\n\t\tnum = num // 10\n\treturn rev_num\ndef properDivSum(num):\n\tresult = 0\ndef isTcefrep(n):\n\treturn properDivSum(n) == reverse(n);", "10335": "def isInsolite(n):\n\tN = n;\n\tsum = 0;\n\tproduct = 1;\n\twhile (n != 0):\n\t\tr = n % 10;\n\t\tsum = sum + r * r;\n\t\tproduct = product * r * r;\n\t\tn = n // 10;\n\treturn ((N % sum == 0) and\n\t\t\t(N % product == 0));", "10337": "def sigma(n):\n\tif (n == 1):\n\t\treturn 1\n\tresult = 0\ndef isSuperabundant(N):\n\tfor i in range(1, N):\n\t\tx = sigma((int)(i)) / i\n\t\ty = sigma((int)(N)) / (N * 1.0)\n\t\tif (x > y):\n\t\t\treturn False\n\treturn True", "10345": "def isDNum(n):\n\tif n < 4:\n\t\treturn False\n\tfor k in range(2, n):\n\t\tnumerator = pow(k, n - 2) - k\n\t\thcf = math.gcd(n, k)\n\t\tif(hcf ==1 and (numerator % n) != 0):\n\t\t\treturn False\n\treturn True", "10367": "def isPrime(n):\n\tif (n == 1):\n\t\treturn True\n\tif (n <= 3):\n\t\treturn True\n\tif ((n % 2 == 0) or (n % 3 == 0)):\n\t\treturn False\n\ti = 5\n\twhile (i * i <= n):\n\t\tif ((n % i == 0) or\n\t\t\t(n % (i + 2) == 0)):\n\t\t\treturn False;\n\t\t\ti += 6\n\treturn true;\ndef checkExpression(n):\n\tif (isPrime(n)):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "10377": "def Sum(N):\n\tSumOfPrimeDivisors = [0] * (N + 1)\n\tfor i in range(2, N + 1):\n\t\tif (SumOfPrimeDivisors[i] == 0):\n\t\t\tfor j in range(i, N + 1, i):\n\t\t\t\tSumOfPrimeDivisors[j] += i\n\treturn SumOfPrimeDivisors[N]\ndef RuthAaronNumber(n):\n\tif (Sum(n) == Sum(n + 1)):\n\t\treturn True\n\telse:\n\t\treturn False", "10394": "def Is_possible(N):\n\tC = 0\n\tD = 0\n\twhile ( N % 10 == 0):\n\t\tN = N / 10\n\t\tC += 1\n\tif ( math.log(N, 2)\n\t- int(math.log(N, 2)) == 0):\n\t\tD = int(math.log(N, 2))\n\t\tif (C >= D):\n\t\t\tprint(\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"NO\")", "10406": "def maxAdjacentDifference(N, K):\n\tif (N == 1):\n\t\treturn 0;\n\tif (N == 2):\n\t\treturn K;\n\treturn 2 * K;", "10408": "def linearSum(n):\n\treturn n*(n + 1)//2 % mod\ndef rangeSum(b, a):\n\treturn (linearSum(b) - (\n\t\tlinearSum(a))) % mod\ndef totalSum(n):\n\tresult = 0\n\ti = 1\n\twhile True:\n\t\tresult += rangeSum(\n\t\t\tn//i, n//(i + 1)) * ( i % mod) % mod;\n\t\tresult %= mod;\n\t\tif i == n:\n\t\t\tbreak\n\t\ti = n//(n//(i + 1))\n\treturn result", "10423": "def isDouble(num):\n\ts = str(num)\n\tl = len(s)\n\tif(s[0] == s[1]):\n\t\treturn False\n\tif(l % 2 == 1):\n\t\ts = s + s[1]\n\t\tl += 1\n\ts1 = s[:l // 2]\n\ts2 = s[l // 2:]\n\treturn s1 == s2\ndef isNontrivialUndulant(N):\n\treturn N > 100 and isDouble(N)", "10434": "def findNthTerm(n):\n\tprint(n * n - n + 1)", "10438": "def rev(num):\n\trev_num = 0\n\twhile (num > 0) :\n\t\trev_num = rev_num * 10 + num % 10\n\t\tnum = num // 10\n\treturn rev_num\ndef divSum(num) :\n\tresult = 0\n\tfor i in range(2, int(num**0.5)):\ndef isAntiPerfect(n):\n\treturn divSum(n) == n", "10445": "def printSeries(n, a, b, c):\n\tif (n == 1):\n\t\tprint(a, end = \" \");\n\t\treturn;\n\tif (n == 2):\n\t\tprint(a, b, end = \" \");\n\t\treturn;\n\tprint(a, b, c, end = \" \");\n\tfor i in range (4, n + 1):\n\t\td = a + b + c;\n\t\tprint(d, end = \" \");\n\t\ta = b;\n\t\tb = c;\n\t\tc = d;", "10452": "def checkArray(n, k, arr):\n\tcnt = 0\n\tfor i in range(n):\n\t\tif (arr[i] & 1):\n\t\t\tcnt += 1\n\tif (cnt >= k and cnt % 2 == k % 2):\n\t\treturn True\n\telse:\n\t\treturn False", "10462": "def func (arr, n):\n\tans = 0\n\tmaxx = 0\n\tfreq = [0] * 100005\n\ttemp = 0\n\tfor i in range(n):\n\t\ttemp = arr[i]\n\t\tfreq[temp] += 1\n\t\tmaxx = max(maxx, temp)\n\tfor i in range(1, maxx + 1):\n\t\tfreq[i] += freq[i - 1]\n\tfor i in range(1, maxx + 1):\n\t\tif (freq[i]):\n\t\t\tvalue = 0\n\t\t\tcur = ceil(0.5 * i) - 1.0\n\t\t\tj = 1.5\n\t\t\twhile (1):\n\t\t\t\tval = min(maxx, (ceil(i * j) - 1.0))\n\t\t\t\ttimes = (freq[i] - freq[i - 1])\n\t\t\t\tcon = j - 0.5\n\t\t\t\tans += times * con * (freq[int(val)] -\n\t\t\t\t\t\t\t\t\tfreq[int(cur)])\n\t\t\t\tcur = val\n\t\t\t\tif (val == maxx):\n\t\t\t\t\tbreak\n\t\t\t\tj += 1\n\treturn int(ans)", "10474": "def EnneacontahexagonNum(n):\n\treturn (94 * n * n - 92 * n) // 2;", "10475": "def MegagonNum(n):\n\treturn (999998 * n * n - 999996 * n) // 2;", "10492": "def insert_element(a, n):\n\tXor = 0\n\tSum = 0\n\tfor i in range(n):\n\t\tXor^= a[i]\n\t\tSum+= a[i]\n\tif(Sum == 2 * Xor):\n\t\tprint(0)\n\t\treturn\n\tif(Xor == 0):\n\t\tprint(1)\n\t\tprint(Sum)\n\t\treturn\n\tnum1 = Sum + Xor\n\tnum2 = Xor\n\tprint(2)\n\tprint(num1, num2)", "10502": "def checkSolution(a, b, c):\n\tif (a == c):\n\t\tprint(\"Yes\");\n\telse:\n\t\tprint(\"No\");", "10539": "def productPairs(arr, n):\n\tproduct = 1;\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tproduct *= (arr[i] % mod * arr[j] % mod) % mod;\n\t\t\tproduct = product % mod;\n\treturn product % mod;", "10540": "def power(x, y):\n\tp = 1000000007\n\tres = 1\n\tx = x % p\n\twhile (y > 0):\n\t\tif ((y & 1) != 0):\n\t\t\tres = (res * x) % p\n\t\ty = y >> 1\n\t\tx = (x * x) % p\n\treturn res\ndef productPairs(arr, n):\n\tproduct = 1\n\tfor i in range(n):\n\t\tproduct = (product % mod *\n\t\t(int)(power(arr[i], (2 * n))) % mod) % mod\n\treturn (product % mod)", "10546": "def constructArray(N):\n\tarr = [0] * N\n\tfor i in range(1, N + 1):\n\t\tarr[i - 1] = i;\n\tfor i in range(N):\n\t\tprint(arr[i], end = \", \")", "10568": "def isPrime(n):\n\tif (n <= 1):\n\t\treturn False;\n\tfor i in range(2, n):\n\t\tif (n % i == 0):\n\t\t\treturn False;\n\treturn True;\ndef countSubsequences(arr, n):\n\ttotalSubsequence = (int)(pow(2, n) - 1);\n\tcountPrime = 0;\n\tcountOnes = 0;\n\tfor i in range(n):\n\t\tif (arr[i] == 1):\n\t\t\tcountOnes += 1;\n\t\telif (isPrime(arr[i])):\n\t\t\tcountPrime += 1;\n\tcompositeSubsequence = 0;\n\tonesSequence = (int)(pow(2, countOnes) - 1);\n\tcompositeSubsequence = (totalSubsequence - countPrime - onesSequence - onesSequence * countPrime);\n\treturn compositeSubsequence;", "10569": "def nCr(n, r):\n\treturn fact(n) / (fact(r) * \n\t\t\t\t\tfact(n - r))\ndef fact(n):\n\tres = 1\n\tfor i in range(2, n + 1):\n\t\tres = res * i \n\treturn res\ndef sumSubsequences(arr, n, k):\n\tsum = 0\n\tfor i in range(0, n):\n\t\tsum = sum + arr[i]\n\tkLengthSubSequence = nCr(n, k)\n\tans = sum * ((k * kLengthSubSequence) / n);\n\treturn ans", "10573": "def getFactorization(x):\n\tcount = 0\n\tv = []\n\twhile (x % 2 == 0):\n\t\tcount += 1\n\t\tx = x // 2\n\tif (count != 0):\n\t\tv.append(count)\n\tfor i in range(3, int(sqrt(x)) + 12):\n\t\tcount = 0\n\t\twhile (x % i == 0):\n\t\t\tcount += 1\n\t\t\tx //= i\n\t\tif (count != 0):\n\t\t\tv.append(count)\n\tif (x > 1):\n\t\tv.append(1)\n\treturn v\ndef nonPrimeDivisors(N):\n\tv = getFactorization(N)\n\tret = 1\n\tfor i in range(len(v)):\n\t\tret = ret * (v[i] + 1)\n\tret = ret - len(v)\n\treturn ret", "10653": "def checksum(n, k):\n\tfirst_term = ((2 * n) / k + (1 - k)) / 2.0\n\tif (first_term - int(first_term) == 0):\n\t\tfor i in range(int(first_term),\n\t\t\t\t\tint(first_term) + k):\n\t\t\tprint(i, end = ' ')\n\telse:\n\t\tprint('-1')", "10668": "def sumEvenNumbers(N, K):\n\tcheck = N - 2 * (K - 1)\n\tif (check > 0 and check % 2 == 0):\n\t\tfor i in range(K - 1):\n\t\t\tprint(\"2 \", end = \"\")\n\t\tprint(check)\n\telse:\n\t\tprint(\"-1\")", "10677": "def isPerfectSquare(x):\n\tsr = sqrt(x)\n\treturn((sr - floor(sr)) == 0)\ndef checkSunnyNumber(N):\n\tif (isPerfectSquare(N + 1)):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "10694": "def calculateWays(N):\n\tx = 0;\n\tv = [];\n\tfor i in range(N):\n\t\tv.append(0);\n\tfor i in range(N // 2 + 1):\n\t\tif (N % 2 == 0 and i == N // 2):\n\t\t\tbreak;\n\t\tx = N * (i + 1) - (i + 1) * i;\n\t\tv[i] = x;\n\t\tv[N - i - 1] = x;\n\treturn v;\ndef printArray(v):\n\tfor i in range(len(v)):\n\t\tprint(v[i], end = \" \");", "10703": "def sumOfDigits(n):\n\tsum = 0\n\twhile(n > 0):\n\t\tsum += n % 10\n\t\tn //= 10\n\treturn sum\ndef smallestNum(X, Y):\n\tres = -1;\n\tfor i in range(X, MAXN):\n\t\tsum_of_digit = sumOfDigits(i)\n\t\tif sum_of_digit % Y == 0:\n\t\t\tres = i\n\t\t\tbreak\n\treturn res", "10706": "def countValues(n):\n\tanswer = 0\n\tfor i in range(2, n + 1, 1):\n\t\tk = n\n\t\twhile (k >= i):\n\t\t\tif (k % i == 0):\n\t\t\t\tk //= i\n\t\t\telse:\n\t\t\t\tk -= i\n\t\tif (k == 1):\n\t\t\tanswer += 1\n\treturn answer", "10707": "def countValues(N):\n\tdiv = []\n\ti = 2\n\twhile ((i * i) <= N):\n\t\tif (N % i == 0):\n\t\t\tdiv.append(i)\n\t\t\tif (N != i * i):\n\t\t\t\tdiv.append(N // i)\n\t\ti += 1 \n\tanswer = 0\n\ti = 1\n\twhile((i * i) <= N - 1):\n\t\tif ((N - 1) % i == 0):\n\t\t\tif (i * i == N - 1):\n\t\t\t\tanswer += 1\n\t\t\telse:\n\t\t\t\tanswer += 2\n\t\ti += 1\n\tfor d in div:\n\t\tK = N\n\t\twhile (K % d == 0):\n\t\t\tK //= d\n\t\tif ((K - 1) % d == 0):\n\t\t\tanswer += 1\n\treturn answer", "10719": "def findMaxPrimeDivisor(n):\n\tmax_possible_prime = 0\n\twhile (n % 2 == 0):\n\t\tmax_possible_prime += 1\n\t\tn = n // 2\n\ti = 3\n\twhile(i * i <= n):\n\t\twhile (n % i == 0):\n\t\t\tmax_possible_prime += 1\n\t\t\tn = n // i\n\t\ti = i + 2\n\tif (n > 2):\n\t\tmax_possible_prime += 1\n\tprint(max_possible_prime)", "10721": "def printKNumbers(N, K):\n\tfor i in range(K - 1):\n\t\tprint(1, end = ' ')\n\tprint(N - K + 1)", "10751": "def CountWays(n) :\n\tans = (n - 1) // 2\n\treturn ans", "10753": "def Solve(arr, size, n):\n\tv = [0] * (n + 1);\n\tfor i in range(size):\n\t\tv[arr[i]] += 1\n\tmax1 = max(set(arr), key = v.count)\n\tdiff1 = n + 1 - v.count(0)\n\tmax_size = max(min(v[max1] - 1, diff1),\n\t\t\t\tmin(v[max1], diff1 - 1))\n\tprint(\"Maximum size is :\", max_size)\n\tprint(\"The First Array Is : \")\n\tfor i in range(max_size):\n\t\tprint(max1, end = \" \")\n\t\tv[max1] -= 1\n\tprint()\n\tprint(\"The Second Array Is : \")\n\tfor i in range(n + 1):\n\t\tif (v[i] > 0):\n\t\t\tprint(i, end = \" \")\n\t\t\tmax_size -= 1\n\t\tif (max_size < 1):\n\t\t\tbreak\n\tprint()", "10768": "def power(x, y, p):\n\tres = 1\n\tx = x % p\n\twhile (y > 0):\n\t\tif (y & 1):\n\t\t\tres = (res * x) % p\n\t\tx = (x * x) % p\n\treturn res\ndef modInverse(n, p):\n\treturn power(n, p - 2, p)\ndef nCrModPFermat(n, r, p):\n\tif (r == 0):\n\t\treturn 1\n\tif (n < r):\n\t\treturn 0\n\tfac = [0]*(n + 1)\n\tfac[0] = 1\n\tfor i in range(1, n + 1):\n\t\tfac[i] = fac[i - 1] * i % p\n\treturn (fac[n] * modInverse(fac[r], p) % p *\n\t\t\tmodInverse(fac[n - r], p) % p) % p\ndef SumOfXor(a, n):\n\tmod = 10037\n\tanswer = 0\n\tfor k in range(32):\n\t\tx = 0\n\t\ty = 0\n\t\tfor i in range(n):\n\t\t\tif (a[i] & (1 << k)):\n\t\t\t\tx += 1\n\t\t\telse:\n\t\t\t\ty += 1\n\t\tanswer += ((1 << k) % mod * (nCrModPFermat(x, 3, mod)\n\t\t\t\t\t+ x * nCrModPFermat(y, 2, mod)) % mod) % mod\n\treturn answer", "10801": "def NthSmallest(K):\n\tQ = []\n\tfor i in range(1,10):\n\t\tQ.append(i)\n\tfor i in range(1,K+1):\n\t\tx = Q[0]\n\t\tQ.remove(Q[0])\n\t\tif (x % 10 != 0):\n\t\t\tQ.append(x * 10 + x % 10 - 1)\n\t\tQ.append(x * 10 + x % 10)\n\t\tif (x % 10 != 9):\n\t\t\tQ.append(x * 10 + x % 10 + 1)\n\treturn x", "10812": "def probability(N):\n\ta = 2\n\tb = 3\n\tif N == 1:\n\t\treturn a\n\telif N == 2:\n\t\treturn b\n\telse:\n\t\tfor i in range(3, N + 1):\n\t\t\tc = a + b\n\t\t\ta = b\n\t\t\tb = c\n\t\treturn b\ndef operations(N):\n\tx = probability (N)\n\ty = math.pow(2, N)\n\treturn round(x / y, 2)", "10874": "def isPerfectCube(x):\n\tx = abs(x)\n\treturn int(round(x ** (1. / 3))) ** 3 == x\ndef checkCube(a, b):\n\ts1 = str(a)\n\ts2 = str(b)\n\tc = int(s1 + s2)\n\tif (isPerfectCube(c)):\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\")", "10885": "def largest_sum(arr, n):\n\tmaximum = -1\n\tm = dict()\n\tfor i in arr:\n\t\tm[i] = m.get(i,0) + 1\n\tfor j in list(m):\n\t\tif ((j in m) and m[j] > 1):\n\t\t\tx, y = 0, 0\n\t\t\tif 2*j in m:\n\t\t\t\tm[2*j] = m[2 * j]+ m[j]// 2\n\t\t\telse:\n\t\t\t\tm[2*j] = m[j]//2\n\t\t\tif (2 * j > maximum):\n\t\t\t\tmaximum = 2 * j\n\treturn maximum", "10897": "def canBeReduced(x,y):\n\tmaxi = max(x, y)\n\tmini = min(x, y)\n\tif (((x + y) % 3) == 0 and maxi <= 2*mini):\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")", "10921": "def isPrime( N):\n\tisPrime = True;\n\tarr= [ 7, 11, 13, 17, 19, 23, 29, 31 ]\n\tif (N < 2) :\n\t\tisPrime = False\n\tif (N % 2 == 0 or N % 3 == 0 or N % 5 == 0):\n\t\tisPrime = False\n\tfor i in range(0,int(math.sqrt(N)), 30) :\n\t\tfor c in arr:\n\t\t\tif (c > int(math.sqrt(N))):\n\t\t\t\tbreak\n\t\t\telse :\n\t\t\t\tif (N % (c + i) == 0) :\n\t\t\t\t\tisPrime = False\n\t\t\t\t\tbreak\n\t\t\tif (not isPrime):\n\t\t\t\tbreak\n\tif (isPrime):\n\t\tprint(\"Prime Number\")\n\telse:\n\t\tprint(\"Not a Prime Number\")", "10932": "def printPairs(arr, n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tprint(\"(\",arr[i],\",\",arr[j],\")\",end=\", \")", "10935": "def power(p) :\n\tres = 1; \n\tfor i in range(1, p + 1) :\n\t\tres *= 2; \n\t\tres %= mod; \n\treturn res % mod;\ndef subset_cube_sum(A) : \n\tn = len(A); \n\tans = 0; \n\tfor i in A :\n\t\tans += (i * i * i) % mod; \n\t\tans %= mod; \n\treturn (ans * power(n - 1)) % mod;", "10936": "def nearest(n) :\n\tprevSquare = int(sqrt(n));\n\tnextSquare = prevSquare + 1;\n\tprevSquare = prevSquare * prevSquare;\n\tnextSquare = nextSquare * nextSquare;\n\tans\t= (prevSquare - n) if (n - prevSquare) < (nextSquare - n) else (nextSquare - n);\n\treturn ans;", "10951": "def printValueOfPi(N) :\n\tb = '{:.' + str(N) + 'f}'\n\tpi= b.format(2 * acos(0.0))\n\tprint(pi);", "10952": "def powOfPositive(n) :\n\tpos = floor(log2(n));\n\treturn 2**pos;\ndef powOfNegative(n) :\n\tpos = ceil(log2(n));\n\treturn (-1 * pow(2, pos));\ndef highestPowerOf2(n) :\n\tif (n > 0) :\n\t\tprint(powOfPositive(n));\n\telse :\n\t\tn = -n;\n\t\tprint(powOfNegative(n));", "10960": "def noOfCards(n):\n\treturn n * (3 * n + 1) // 2", "10974": "def smallestPoss(s, n):\n\tans = \"\";\n\tarr = [0]*10;\n\tfor i in range(n):\n\t\tarr[ord(s[i]) - 48] += 1;\n\tfor i in range(10):\n\t\tfor j in range(arr[i]):\n\t\t\tans = ans + str(i);\n\treturn ans;", "11014": "def Count_subarray(arr, n):\n\tsubarray_sum, remaining_sum, count = 0, 0, 0;\n\tfor i in range(n):\n\t\tfor j in range(i, n):\n\t\t\tsubarray_sum = 0;\n\t\t\tremaining_sum = 0;\n\t\t\tfor k in range(i, j + 1):\n\t\t\t\tsubarray_sum += arr[k];\n\t\t\tfor l in range(i):\n\t\t\t\tremaining_sum += arr[l];\n\t\t\tfor l in range(j + 1, n):\n\t\t\t\tremaining_sum += arr[l];\n\t\t\tif (subarray_sum > remaining_sum):\n\t\t\t\tcount += 1;\n\treturn count;", "11015": "def Count_subarray(arr, n) :\n\ttotal_sum = 0;\n\tcount = 0;\n\tfor i in range(n) :\n\t\ttotal_sum += arr[i];\n\tfor i in range(n) :\n\t\tsubarray_sum = 0;\n\t\tfor j in range(i, n) :\n\t\t\tsubarray_sum += arr[j];\n\t\t\tremaining_sum = total_sum - subarray_sum;\n\t\t\tif (subarray_sum > remaining_sum) :\n\t\t\t\tcount += 1;\n\treturn count;", "11045": "def decBinary(arr, n):\n\tk = int(math.log2(n))\n\twhile (n > 0):\n\t\tarr[k] = n % 2\n\t\tk = k - 1\n\t\tn = n//2\ndef binaryDec(arr, n):\n\tans = 0\n\tfor i in range(0, n):\n\t\tans = ans + (arr[i] << (n - i - 1))\n\treturn ans\ndef getNum(n, k):\n\tl = int(math.log2(n)) + 1\n\ta = [0 for i in range(0, l)]\n\tdecBinary(a, n)\n\tif(k > l):\n\t\treturn n\n\tif(a[k - 1] == 0):\n\t\ta[k - 1] = 1\n\telse:\n\t\ta[k - 1] = 0\n\treturn binaryDec(a, l)", "11051": "def find_composite_nos(n) :\n\tprint(9 * n, 8 * n);", "11052": "def maxXOR(arr, n):\n\txorArr = 0\n\tfor i in range(n):\n\t\txorArr ^= arr[i]\n\tans = 0\n\tfor i in range(n):\n\t\tans = max(ans, (xorArr ^ arr[i]))\n\treturn ans", "11060": "def digitDividesK(num, k):\n\twhile (num):\n\t\td = num % 10\n\t\tif (d != 0 and k % d == 0):\n\t\t\treturn True\n\t\tnum = num // 10\n\treturn False\ndef findCount(l, r, k):\n\tcount = 0\n\tfor i in range(l, r + 1):\n\t\tif (digitDividesK(i, k)):\n\t\t\tcount += 1\n\treturn count", "11088": "def isFactorial(n) :\n\ti = 1;\n\twhile(True) :\n\t\tif (n % i == 0) :\n\t\t\tn //= i;\n\t\telse :\n\t\t\tbreak;\n\t\ti += 1;\n\tif (n == 1) :\n\t\treturn True;\n\telse :\n\t\treturn False;", "11094": "def lcm(a, b) :\n\tGCD = gcd(a, b);\n\treturn (a * b) // GCD;\ndef MinLCM(a, n) :\n\tPrefix = [0] * (n + 2);\n\tSuffix = [0] * (n + 2);\n\tPrefix[1] = a[0];\n\tfor i in range(2, n + 1) :\n\t\tPrefix[i] = lcm(Prefix[i - 1], a[i - 1]);\n\tSuffix[n] = a[n - 1];\n\tfor i in range(n - 1, 0, -1) :\n\t\tSuffix[i] = lcm(Suffix[i + 1], a[i - 1]);\n\tans = min(Suffix[2], Prefix[n - 1]);\n\tfor i in range(2, n) :\n\t\tans = min(ans, lcm(Prefix[i - 1], Suffix[i + 1]));\n\treturn ans;", "11102": "def diameter(n):\n\tL, H, templen = 0, 0, 0;\n\tL = 1;\n\tH = 0;\n\tif (n == 1):\n\t\treturn 1;\n\tif (n == 2):\n\t\treturn 2;\n\tif (n == 3):\n\t\treturn 3;\n\twhile (L * 2 <= n):\n\t\tL *= 2;\n\t\tH += 1;\n\tif (n >= L * 2 - 1):\n\t\treturn 2 * H + 1;\n\telif (n >= L + (L / 2) - 1):\n\t\treturn 2 * H;\n\treturn 2 * H - 1;", "11139": "def count(n) :\n\treturn n * (3 * n - 1) // 2;", "11180": "def findMinValue(arr, n):\n\tsum = 0\n\tfor i in range(n):\n\t\tsum += arr[i]\n\treturn (sum // n) + 1", "11182": "def modFact(n, m) :\n\tresult = 1\n\tfor i in range(1, m + 1) :\n\t\tresult = (result * i) % MOD\n\treturn result", "11194": "def preCompute():\n\tfact[0] = 1\n\tresult[0] = 1\n\tfor i in range(1, MAX + 1):\n\t\tfact[i] = ((fact[i - 1] % MOD) * i) % MOD\n\t\tresult[i] = ((result[i - 1] % MOD) *\n\t\t\t\t\t(fact[i] % MOD)) % MOD\ndef performQueries(q, n):\n\tpreCompute()\n\tfor i in range(n):\n\t\tprint(result[q[i]])", "11196": "def gcd(a, b):\n\tif (a == 0):\n\t\treturn b;\n\treturn gcd(b % a, a);\ndef divTermCount(a, b, c, num):\n\treturn ((num / a) + (num / b) + (num / c) -\n\t\t\t\t(num / ((a * b) / gcd(a, b))) -\n\t\t\t\t(num / ((c * b) / gcd(c, b))) -\n\t\t\t\t(num / ((a * c) / gcd(a, c))) +\n\t\t\t\t(num / ((a * b * c) / gcd(gcd(a, b), c))));\ndef findNthTerm(a, b, c, n):\n\tlow = 1; high = sys.maxsize; mid = 0;\n\twhile (low < high):\n\t\tmid = low + (high - low) / 2;\n\t\tif (divTermCount(a, b, c, mid) < n):\n\t\t\tlow = mid + 1;\n\t\telse:\n\t\t\thigh = mid;\n\treturn int(low);", "11199": "def calculate_angle(n, i, j, k):\n\tx, y = 0, 0\n\tif (i < j):\n\t\tx = j - i\n\telse:\n\t\tx = j + n - i\n\tif (j < k):\n\t\ty = k - j\n\telse:\n\t\ty = k + n - j\n\tang1 = (180 * x) // n\n\tang2 = (180 * y) // n\n\tans = 180 - ang1 - ang2\n\treturn ans", "11204": "def power(p):\n\tres = 1\n\tfor i in range(1, p + 1):\n\t\tres *= 2\n\t\tres %= mod\n\treturn res % mod\ndef subset_square_sum(A):\n\tn = len(A)\n\tans = 0\n\tfor i in A:\n\t\tans += i * i % mod\n\t\tans %= mod\n\treturn ans * power(n - 1) % mod", "11217": "def least_prime_factor():\n\tfor i in range(2, N):\n\t\tif (lpf[i] == 0):\n\t\t\tfor j in range(i, N, i):\n\t\t\t\tif (lpf[j] == 0):\n\t\t\t\t\tlpf[j] = i\ndef Mobius():\n\tfor i in range(1, N):\n\t\tif (i == 1):\n\t\t\tmobius[i] = 1\n\t\telse:\n\t\t\tif (lpf[ (i // lpf[i]) ] == lpf[i]):\n\t\t\t\tmobius[i] = 0\n\t\t\telse:\n\t\t\t\tmobius[i] = -1 * mobius[i // lpf[i]]\ndef gcd_pairs(a, n):\n\tmaxi = 0\n\tfre = [0 for i in range(N)]\n\tfor i in range(n):\n\t\tfre[a[i]] += 1\n\t\tmaxi = max(a[i], maxi)\n\tleast_prime_factor()\n\tMobius()\n\tans = 0\n\tfor i in range(1, maxi + 1):\n\t\tif (mobius[i] == 0):\n\t\t\tcontinue\n\t\ttemp = 0\n\t\tfor j in range(i, maxi + 1, i):\n\t\t\ttemp += fre[j]\n\t\tans += temp * (temp - 1) // 2 * mobius[i]\n\treturn ans", "11253": "def compareVal(x, y) :\n\ta = y * log(x);\n\tb = x * log(y);\n\tif (a > b) :\n\t\tprint(x, \"^\", y, \">\", y, \"^\", x);\n\telif (a < b) :\n\t\tprint(x, \"^\", y, \"<\", y ,\"^\", x);\n\telif (a == b) :\n\t\tprint(x, \"^\", y, \"=\", y, \"^\", x);", "11283": "def compareValues(a, b, c, d):\n\tlog1 = math.log10(a)\n\tnum1 = log1 * b\n\tlog2 = math.log10(c)\n\tnum2 = log2 * d\n\tif num1 > num2 :\n\t\tprint(a, '^', b)\n\telse :\n\t\tprint(c, '^', d)", "11294": "def ZigZag(n):\n\tfact = [0 for i in range(n + 1)]\n\tzig = [0 for i in range(n + 1)]\n\tfact[0] = 1\n\tfor i in range(1, n + 1):\n\t\tfact[i] = fact[i - 1] * i\n\tzig[0] = 1\n\tzig[1] = 1\n\tprint(\"zig zag numbers: \", end = \" \")\n\tprint(zig[0], zig[1], end = \" \")\n\tfor i in range(2, n):\n\t\tsum = 0\n\t\tfor k in range(0, i):\n\t\t\tsum += ((fact[i - 1] //\n\t\t\t\t\t(fact[i - 1 - k] * fact[k])) * zig[k] * zig[i - 1 - k])\n\t\tzig[i] = sum // 2\n\t\tprint(sum // 2, end = \" \")", "11302": "def find_count(ele):\n\tcount = 0\n\tfor i in range(len(ele)):\n\t\tp = []\n\t\tc = 0\n\t\tj = len(ele) - 1\n\t\twhile j >= (len(ele) - 1 - i) and j >= 0:\n\t\t\tp.append(ele[j])\n\t\t\tj -= 1\n\t\tj = len(ele) - 1\n\t\tk = 0\n\t\twhile j >= 0:\n\t\t\tif ele[j] != p[k]:\n\t\t\t\tbreak\n\t\t\tj -= 1\n\t\t\tk += 1\n\t\t\tif k == len(p):\n\t\t\t\tc += 1\n\t\t\t\tk = 0\n\t\tcount = max(count, c)\n\treturn count\ndef solve(n):\n\tcount = 1\n\tele = []\n\tfor i in range(n):\n\t\tprint(count, end = \" \")\n\t\tele.append(count)\n\t\tcount = find_count(ele)", "11306": "def addPrimes():\n\tn = MAX\n\tprime = [True for i in range(n + 1)]\n\tfor p in range(2, n + 1):\n\t\tif p * p > n:\n\t\t\tbreak\n\t\tif (prime[p] == True):\n\t\t\tfor i in range(2 * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\tans = []\n\tfor p in range(2, n + 1):\n\t\tif (prime[p]):\n\t\t\tans.append(p)\n\treturn ans\ndef is_prime(n):\n\tif n in [3, 5, 7]:\n\t\treturn True\n\treturn False\ndef find_Sum(n):\n\tSum = 0\n\tv = addPrimes()\n\tfor i in range(len(v)):\n\t\tflag = 1\n\t\ta = v[i]\n\t\twhile (a != 0):\n\t\t\td = a % 10;\n\t\t\ta = a // 10;\n\t\t\tif (is_prime(d)):\n\t\t\t\tflag = 0\n\t\t\t\tbreak\n\t\tif (flag == 1):\n\t\t\tn -= 1\n\t\t\tSum = Sum + v[i]\n\t\tif n == 0:\n\t\t\tbreak\n\treturn Sum", "11315": "def Wedderburn(n):\n\tif (n <= 2):\n\t\treturn store[n]\n\telif (n % 2 == 0):\n\t\tx = n // 2\n\t\tans = 0\n\t\tfor i in range(1, x):\n\t\t\tans += store[i] * store[n - i]\n\t\tans += (store[x] * (store[x] + 1)) // 2\n\t\tstore[n] = ans\n\t\treturn ans\n\telse:\n\t\tx = (n + 1) // 2\n\t\tans = 0\n\t\tfor i in range(1, x):\n\t\t\tans += store[i] * store[n - i]\n\t\tstore[n] = ans\n\t\treturn ans\ndef Wedderburn_Etherington(n):\n\tstore[0] = 0\n\tstore[1] = 1\n\tstore[2] = 1\n\tfor i in range(n):\n\t\tprint(Wedderburn(i), end = \"\")\n\t\tif(i != n - 1):\n\t\t\tprint(end = \", \")", "11331": "def Max_sum(a, n):\n\tpos = 0\n\tneg = 0\n\tfor i in range(n):\n\t\tif(a[i] > 0):\n\t\t\tpos = 1\n\t\telif(a[i] < 0):\n\t\t\tneg = 1\n\t\tif(pos == 1 and neg == 1):\n\t\t\tbreak\n\tsum = 0\n\tif(pos==1 and neg==1):\n\t\tfor i in range(n):\n\t\t\tsum += abs(a[i])\n\telif(pos == 1):\n\t\tmini = a[0]\n\t\tsum = a[0]\n\t\tfor i in range(1,n,1):\n\t\t\tmini = min(mini, a[i])\n\t\t\tsum += a[i]\n\t\tsum -= 2*mini\n\telif(neg == 1):\n\t\tfor i in range(n):\n\t\t\ta[i] = abs(a[i])\n\t\tmini = a[0]\n\t\tsum = a[0]\n\t\tfor i in range(1,n):\n\t\t\tmini = min(mini, a[i])\n\t\t\tsum += a[i]\n\t\tsum -= 2*mini\n\treturn sum", "11342": "def decimalToBinary(n) :\n\tif (n == 0) :\n\t\tprint(\"0\",end=\"\");\n\t\treturn;\n\tdecimalToBinary(n // 2);\n\tprint(n % 2,end=\"\");", "11343": "def MinimumValue(x, y):\n\tif (x > y):\n\t\tx, y = y, x\n\ta = 1\n\tb = x - 1\n\tc = y - b\n\tprint(a, b, c)", "11370": "def canConvert(a, b) :\n\twhile (b > a) :\n\t\tif (b % 10 == 1) :\n\t\t\tb //= 10;\n\t\t\tcontinue;\n\t\tif (b % 2 == 0) :\n\t\t\tb /= 2;\n\t\t\tcontinue;\n\t\treturn false;\n\tif (b == a) :\n\t\treturn True;\n\treturn False;", "11387": "def count(N):\n\ta = 0;\n\ta = (N * (N + 1)) / 2;\n\treturn int(a);", "11404": "def numberOfDays(a, b, n):\n\tDays = b * (n + a) // (a + b)\n\treturn Days", "11418": "def getAverage(x, y):\n\tavg = (x & y) + ((x ^ y) >> 1);\n\treturn avg", "11435": "def primeCount(arr, n):\n\tmax_val = max(arr)\n\tprime = [True] * (max_val+1)\n\tprime[0] = prime[1] = False\n\tp = 2\n\twhile p * p <= max_val: \n\t\tif prime[p] == True: \n\t\t\tfor i in range(p * 2, max_val+1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\tcount = 0\n\tfor i in range(0, n):\n\t\tif prime[arr[i]]:\n\t\t\tcount += 1\n\treturn count\ndef getPrefixArray(arr, n, pre):\n\tpre[0] = arr[0]\n\tfor i in range(1, n): \n\t\tpre[i] = pre[i - 1] + arr[i]", "11510": "def smallestIndex(a, n):\n\tright1 = 0\n\tright0 = 0\n\tfor i in range(n):\n\t\tif (a[i] == 1):\n\t\t\tright1 = i\n\t\telse:\n\t\t\tright0 = i\n\treturn min(right1, right0)", "11523": "def freqPairs(arr, n):\n\tmax = arr[0]\n\tfor i in range(len(arr)):\n\t\tif arr[i] > max:\n\t\t\tmax = arr[i]\n\tfreq = [0 for i in range(max + 1)]\n\tcount = 0\n\tfor i in range(n):\n\t\tfreq[arr[i]] += 1\n\tfor i in range(n):\n\t\tfor j in range(2 * arr[i], max + 1, arr[i]):\n\t\t\tif (freq[j] >= 1):\n\t\t\t\tcount += freq[j]\n\t\tif (freq[arr[i]] > 1):\n\t\t\tcount += freq[arr[i]] - 1\n\t\t\tfreq[arr[i]] -= 1\n\treturn count", "11533": "def countSquares(r, c, m):\n\tsquares = 0\n\tfor i in range (1, 9):\n\t\tfor j in range (1, 9):\n\t\t\tif(max(abs(i - r), abs(j - c)) <= m):\n\t\t\t\tsquares = squares + 1\n\treturn squares", "11549": "def Loss(SP, P):\n\tloss = 0\n\tloss = ((2 * P * P * SP) /\n\t\t\t(100 * 100 - P * P))\n\tprint(\"Loss =\", round(loss, 3))", "11611": "def sieve():\n\tfor i in range(4, MAXN, 2):\n\t\tspf[i] = 2\n\tfor i in range(3, MAXN):\n\t\tif i * i >= MAXN:\n\t\t\tbreak\n\t\tif (spf[i] == i):\n\t\t\tfor j in range(i * i, MAXN, i):\n\t\t\t\tif (spf[j] == j):\n\t\t\t\t\tspf[j] = i\ndef getFactorization(x):\n\twhile (x != 1):\n\t\ttemp = spf[x]\n\t\tif (x % temp == 0):\n\t\t\thash1[spf[x]] += 1\n\t\t\tx = x // spf[x]\n\t\twhile (x % temp == 0):\n\t\t\tx = x // temp\ndef check(x):\n\twhile (x != 1):\n\t\ttemp = spf[x]\n\t\tif (x % temp == 0 and hash1[temp] > 1):\n\t\t\treturn False\n\t\twhile (x % temp == 0):\n\t\t\tx = x //temp\n\treturn True\ndef hasValidNum(arr, n):\n\tsieve()\n\tfor i in range(n):\n\t\tgetFactorization(arr[i])\n\tfor i in range(n):\n\t\tif (check(arr[i])):\n\t\t\treturn True\n\treturn False", "11613": "def countQuadruples(a, n) :\n\tmpp = dict.fromkeys(a, 0);\n\tfor i in range(n) :\n\t\tmpp[a[i]] += 1;\n\tcount = 0;\n\tfor j in range(n) :\n\t\tfor k in range(n) :\n\t\t\tif (j == k) :\n\t\t\t\tcontinue;\n\t\t\tmpp[a[j]] -= 1;\n\t\t\tmpp[a[k]] -= 1;\n\t\t\tfirst = a[j] - (a[k] - a[j]);\n\t\t\tif first not in mpp :\n\t\t\t\tmpp[first] = 0;\n\t\t\tfourth = (a[k] * a[k]) // a[j];\n\t\t\tif fourth not in mpp :\n\t\t\t\tmpp[fourth] = 0;\n\t\t\tif ((a[k] * a[k]) % a[j] == 0) :\n\t\t\t\tif (a[j] != a[k]) :\n\t\t\t\t\tcount += mpp[first] * mpp[fourth];\n\t\t\t\telse :\n\t\t\t\t\tcount += (mpp[first] *\n\t\t\t\t\t\t\t(mpp[fourth] - 1));\n\t\t\tmpp[a[j]] += 1;\n\t\t\tmpp[a[k]] += 1;\n\treturn count;", "11626": "def countNumbers(L, R, K):\n\tif (K == 9):\n\t\tK = 0\n\ttotalnumbers = R - L + 1\n\tfactor9 = totalnumbers // 9\n\trem = totalnumbers % 9\n\tans = factor9\n\tfor i in range(R, R - rem, -1):\n\t\trem1 = i % 9\n\t\tif (rem1 == K):\n\t\t\tans += 1\n\treturn ans", "11627": "def countWays(N):\n\tE = (N * (N - 1)) / 2\n\tif (N == 1):\n\t\treturn 0\n\treturn int(pow(2, E - 1))", "11628": "def EvenSum(A, index, value):\n\tA[index] = A[index] + value\n\tsum = 0\n\tfor i in A:\n\t\tif (i % 2 == 0):\n\t\t\tsum = sum + i\n\treturn sum\ndef BalanceArray(A,Q):\n\tANS = []\n\ti, sum = 0, 0\n\tfor i in range(len(Q)):\n\t\tindex = Q[i][0]\n\t\tvalue = Q[i][1]\n\t\tsum = EvenSum(A, index, value)\n\t\tANS.append(sum)\n\tfor i in ANS:\n\t\tprint(i, end = \" \")", "11629": "def BalanceArray(A, Q) :\n\tANS = []\n\tsum = 0\n\tfor i in range(len(A)) :\n\t\tif (A[i] % 2 == 0) :\n\t\t\tsum += A[i];\n\tfor i in range(len(Q)) :\n\t\tindex = Q[i][0];\n\t\tvalue = Q[i][1];\n\t\tif (A[index] % 2 == 0) :\n\t\t\tsum -= A[index];\n\t\tA[index] += value;\n\t\tif (A[index] % 2 == 0) :\n\t\t\tsum += A[index];\n\t\tANS.append(sum);\n\tfor i in range(len(ANS)) :\n\t\tprint(ANS[i], end = \" \");", "11658": "def Cycles(N):\n\tfact = 1\n\tresult = N - 1\n\ti = result\n\twhile (i > 0):\n\t\tfact = fact * i\n\t\ti -= 1\n\treturn fact // 2", "11667": "def findAndSum(arr, n):\n\tSum = 0\n\tmul = 1\n\tfor i in range(30):\n\t\tcount_on = 0\n\t\tl = 0\n\t\tfor j in range(n):\n\t\t\tif ((arr[j] & (1 << i)) > 0):\n\t\t\t\tif (count_on):\n\t\t\t\t\tl += 1\n\t\t\t\telse:\n\t\t\t\t\tcount_on = 1\n\t\t\t\t\tl += 1\n\t\t\telif (count_on):\n\t\t\t\tSum += ((mul * l * (l + 1)) // 2)\n\t\t\t\tcount_on = 0\n\t\t\t\tl = 0\n\t\tif (count_on):\n\t\t\tSum += ((mul * l * (l + 1)) // 2)\n\t\t\tcount_on = 0\n\t\t\tl = 0\n\t\tmul *= 2\n\treturn Sum", "11677": "def initialize():\n\tl[0][0] = 1\n\tfor i in range(1, 1001):\n\t\tl[i][0] = 1\n\t\tfor j in range(1, i + 1):\n\t\t\tl[i][j] = (l[i - 1][j - 1] + l[i - 1][j])\ndef nCr(n, r):\n\treturn l[n][r]", "11687": "def minValue(n, x, y):\n\tval = (y * n)/100\n\tif x >= val:\n\t\treturn 0\n\telse:\n\t\treturn math.ceil(val) - x", "11707": "def digitWell(n, m, k):\n\tcnt = 0\n\twhile (n > 0):\n\t\tif (n % 10 == m):\n\t\t\tcnt = cnt + 1;\n\t\tn = (int)(n / 10);\n\treturn cnt == k;\ndef findInt(n, m, k):\n\ti = n + 1;\n\twhile (True):\n\t\tif (digitWell(i, m, k)):\n\t\t\treturn i;\n\t\ti = i + 1;", "11709": "def minAbsDiff(n) :\n\tmod = n % 4;\n\tif (mod == 0 or mod == 3) :\n\t\treturn 0;\n\treturn 1;", "11722": "def countOdd(arr, n):\n\todd = 0;\n\tfor i in range(0, n):\n\t\tif (arr[i] % 2 == 1):\n\t\t\todd = odd + 1;\n\treturn odd;\ndef countValidPairs(arr, n):\n\todd = countOdd(arr, n);\n\treturn (odd * (odd - 1)) / 2;", "11748": "def gcd(a, b) :\n\tif (b == 0) :\n\t\treturn a\n\telse :\n\t\treturn gcd(b, a % b)\ndef lcmOfArray(arr, n) :\n\tif (n < 1) :\n\t\treturn 0\n\tlcm = arr[0]\n\tfor i in range(n) :\n\t\tlcm = (lcm * arr[i]) // gcd(lcm, arr[i]);\n\treturn lcm\ndef minPerfectCube(arr, n) :\n\tlcm = lcmOfArray(arr, n)\n\tminPerfectCube = lcm\n\tcnt = 0\n\twhile (lcm > 1 and lcm % 2 == 0) :\n\t\tcnt += 1\n\t\tlcm //= 2\n\tif (cnt % 3 == 2) :\n\t\tminPerfectCube *= 2\n\telif (cnt % 3 == 1) :\n\t\tminPerfectCube *= 4\n\ti = 3\n\twhile (lcm > 1) :\n\t\tcnt = 0\n\t\twhile (lcm % i == 0) :\n\t\t\tcnt += 1\n\t\t\tlcm //= i\n\t\tif (cnt % 3 == 1) :\n\t\t\tminPerfectCube *= i * i\n\t\telif (cnt % 3 == 2) :\n\t\t\tminPerfectCube *= i\n\t\ti += 2\n\treturn minPerfectCube", "11772": "def isPrime(n):\n\tif (n <= 1):\n\t\treturn False\n\tif (n <= 3):\n\t\treturn True\n\tif (n % 2 == 0 or n % 3 == 0):\n\t\treturn False\n\tk = int(sqrt(n)) + 1\n\tfor i in range(5, k, 6):\n\t\tif (n % i == 0 or n % (i + 2) == 0):\n\t\t\treturn False\n\treturn True\ndef isStrongPrime(n):\n\tif (isPrime(n) == False or n == 2):\n\t\treturn False\n\tprevious_prime = n - 1\n\tnext_prime = n + 1\n\twhile (isPrime(next_prime) == False):\n\t\tnext_prime += 1\n\twhile (isPrime(previous_prime) == False):\n\t\tprevious_prime -= 1\n\tmean = (previous_prime + next_prime) / 2\n\tif (n > mean):\n\t\treturn True\n\telse:\n\t\treturn False", "11774": "def isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\tfor i in range(5, int(sqrt(n)) + 1, 6) :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\treturn True\ndef isFactorialPrime(n) :\n\tif (not isPrime(n)) :\n\t\treturn False\n\tfact = 1\n\ti = 1\n\twhile (fact <= n + 1) :\n\t\tfact = fact * i\n\t\tif (n + 1 == fact or n - 1 == fact) :\n\t\t\treturn True\n\t\ti += 1\n\treturn False", "11815": "def countDigitsToBeRemoved(N, K):\n\ts = str(N);\n\tres = 0;\n\tf_zero = 0;\n\tfor i in range(len(s) - 1, -1, -1):\n\t\tif (K == 0):\n\t\t\treturn res;\n\t\tif (s[i] == '0'):\n\t\t\tf_zero = 1;\n\t\t\tK -= 1;\n\t\telse:\n\t\t\tres += 1;\n\tif (K == 0):\n\t\treturn res;\n\telif (f_zero > 0):\n\t\treturn len(s) - 1;\n\treturn -1;", "11906": "def getSum(a, n):\n\tsum = 0;\n\tfor i in range (1, n + 1):\n\t\tsum += (i / math.pow(a, i));\n\treturn sum;", "11948": "def check(s):\n\tfreq =[0]*10\n\twhile(s != 0):\n\t\tr = s % 10\n\t\ts = s//10\n\t\tfreq[r]+= 1\n\txor = 0\n\tfor i in range(10):\n\t\txor = xor ^ freq[i]\n\tif(xor == 0):\n\t\treturn True\n\telse:\n\t\treturn False", "11998": "def largestPrimeFactor(n):\n\tmax = -1\n\twhile n % 2 == 0:\n\t\tmax = 2;\n\tfor i in range(3,int(sqrt(n))+1,2):\n\t\twhile n % i == 0:\n\t\t\tmax = i;\n\t\t\tn = n / i;\n\tif n > 2:\n\t\tmax = n\n\treturn max\ndef checkUnusual(n):\n\tfactor = largestPrimeFactor(n)\n\tif factor > sqrt(n):\n\t\treturn True\n\telse :\n\t\treturn False", "12002": "def Nth_Term(n):\n\treturn (2 * pow(n, 3) - 3 * pow(n, 2) + n + 6) // 6", "12035": "def isHalfReducible(arr, n, m):\n\tfrequencyHash =[0]*(m + 1);\n\ti = 0;\n\twhile(i < n):\n\t\tfrequencyHash[(arr[i] % (m + 1))] += 1;\n\t\ti += 1;\n\ti = 0;\n\twhile(i <= m):\n\t\tif(frequencyHash[i] >= (n / 2)):\n\t\t\tbreak;\n\t\ti += 1;\n\tif (i <= m):\n\t\tprint(\"Yes\");\n\telse:\n\t\tprint(\"No\");", "12037": "def generateDivisors(n):\n\tfor i in range(1, int(n**(0.5)) + 1):\n\t\tif n % i == 0:\ndef harmonicMean(n):\n\tgenerateDivisors(n)\n\tSum = 0\n\tlength = len(arr)\n\tfor i in range(0, length):\n\t\tSum = Sum + (n / arr[i])\n\tSum = Sum / n\n\treturn length / Sum\ndef isOreNumber(n):\n\tmean = harmonicMean(n)\n\tif mean - int(mean) == 0:\n\t\treturn True\n\telse:\n\t\treturn False", "12058": "", "12070": "def printLines(n, k) :\n\tfor i in range(n) :\n\t\tprint( k * (6 * i + 1),\n\t\t\t\tk * (6 * i + 2),\n\t\t\tk * (6 * i + 3),\n\t\t\tk * (6 * i + 5))", "12076": "def SieveOfEratosthenes():\n\tprime = [True] * MAX\n\tp = 2\n\twhile p * p < MAX :\n\t\tif (prime[p] == True):\n\t\t\tfor i in range(p * 2, MAX, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\ndef isEuclid(n):\n\tproduct = 1\n\ti = 0\n\twhile (product < n) :\n\t\tproduct = product * arr[i]\n\t\tif (product + 1 == n):\n\t\t\treturn True\n\t\ti += 1\n\treturn False", "12077": "def SieveOfEratosthenes():\n\tprime = [True] * (MAX)\n\tprime[0], prime[1] = False, False\n\tfor p in range(2, 100):\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * 2, MAX, p):\n\t\t\t\tprime[i] = False\ndef isEuclid(n):\n\tif n in s:\n\t\treturn True\n\telse:\n\t\treturn False", "12078": "def isPrime(n) : \n\tif (n <= 1) : \n\t\treturn False\n\tif (n <= 3) : \n\t\treturn True\n\tif (n % 2 == 0 or n % 3 == 0) : \n\t\treturn False\n\ti = 5\n\twhile(i * i <= n) : \n\t\tif (n % i == 0 or n % (i + 2) == 0) : \n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\ndef isPowerOfTwo(n):\n\treturn (n and (not(n & (n - 1))))", "12117": "def area(a):\n\tif (a < 0):\n\t\treturn -1\n\tarea = pow((a * sqrt(3)) /\n\t\t\t\t(sqrt(2)), 2)\n\treturn area", "12147": "def nthTerm(n):\n\treturn 3 * pow(n, 2) - 4 * n + 2", "12157": "def calculateSum(n):\n\treturn (n * (n + 1) // 2 +\n\t\tpow((n * (n + 1) // 2), 2))", "12170": "def reverse(s):\n\tif len(s) == 0:\n\t\treturn s\n\telse:\n\t\treturn reverse(s[1:]) + s[0]\ndef findNthNo(n):\n\tres = \"\";\n\twhile (n >= 1):\n\t\tif (n & 1):\n\t\t\tres = res + \"3\";\n\t\t\tn = (int)((n - 1) / 2);\n\t\telse:\n\t\t\tres = res + \"5\";\n\t\t\tn = (int)((n - 2) / 2);\n\treturn reverse(res);", "12180": "def printNthElement(n) :\n\tarr =[0] * (n + 1);\n\tarr[1] = 3\n\tarr[2] = 5\n\tfor i in range(3, n + 1) :\n\t\tif (i % 2 != 0) :\n\t\t\tarr[i] = arr[i // 2] * 10 + 3\n\t\telse :\n\t\t\tarr[i] = arr[(i // 2) - 1] * 10 + 5\n\treturn arr[n]", "12185": "def arePermutations(a, b, n, m) :\n\tsum1, sum2, mul1, mul2 = 0, 0, 1, 1\n\tfor i in range(n) :\n\t\tsum1 += a[i]\n\t\tmul1 *= a[i]\n\tfor i in range(m) :\n\t\tsum2 += b[i]\n\t\tmul2 *= b[i]\n\treturn((sum1 == sum2) and (mul1 == mul2))", "12191": "def nextPerfectCube(N) :\n\tnextN = floor(N ** (1/3)) + 1\n\treturn nextN ** 3", "12192": "def nthTerm( N):\n\treturn (N * ((N // 2) + ((N % 2) * 2) + N))", "12225": "def Race(B, C):\n\tresult = 0;\n\tresult = ((C * 100) // B)\n\treturn 100 - result", "12228": "def calculateSum(n):\n\treturn (2**(n + 1) + n - 2)", "12239": "def Time(arr, n, Emptypipe) :\n\tfill = 0\n\tfor i in range(0,n) :\n\t\tfill += (1 / arr[i])\n\tfill = fill - (1 / float(Emptypipe))\n\treturn int(1 / fill)", "12261": "def isPrime(n):\n\ti, c = 0, 0\n\tfor i in range(1, n // 2):\n\t\tif (n % i == 0):\n\t\t\tc += 1\n\tif (c == 1):\n\t\treturn 1\n\telse:\n\t\treturn 0\ndef findMinNum(arr, n):\n\tfirst, last = 0, 0\n\tHash = [0 for i in range(10)]\n\tfor i in range(n):\n\t\tHash[arr[i]] += 1\n\tprint(\"Minimum number: \", end = \"\")\n\tfor i in range(0, 10):\n\t\tfor j in range(Hash[i]):\n\t\t\tprint(i, end = \"\")\n\tprint()\n\tfor i in range(10):\n\t\tif (Hash[i] != 0):\n\t\t\tfirst = i\n\t\t\tbreak\n\tfor i in range(9, -1, -1):\n\t\tif (Hash[i] != 0):\n\t\t\tlast = i\n\t\t\tbreak\n\tnum = first * 10 + last\n\trev = last * 10 + first\n\tprint(\"Prime combinations: \", end = \"\")\n\tif (isPrime(num) and isPrime(rev)):\n\t\tprint(num, \" \", rev)\n\telif (isPrime(num)):\n\t\tprint(num)\n\telif (isPrime(rev)):\n\t\tprint(rev)\n\telse:\n\t\tprint(\"No combinations exist\")", "12264": "def check(n):\n\tsum = 0\n\twhile n != 0 :\n\t\tsum += n % 10\n\t\tn = n // 10\n\tif sum % 7 == 0 :\n\t\treturn 1\n\telse:\n\t\treturn 0", "12314": "def isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tif n <= 3:\n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0:\n\t\treturn False\n\ti = 5\n\twhile i * i <= n:\n\t\tif (n % i == 0 or\n\t\t\tn % (i + 2) == 0):\n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\ndef SumOfPrimeDivisors(n):\n\tsum = 0\n\tfor i in range(1, n + 1) :\n\t\tif n % i == 0 :\n\t\t\tif isPrime(i):\n\t\t\t\tsum += i\n\treturn sum", "12315": "def Sum(N):\n\tSumOfPrimeDivisors = [0] * (N + 1)\n\tfor i in range(2, N + 1) :\n\t\tif (SumOfPrimeDivisors[i] == 0) :\n\t\t\tfor j in range(i, N + 1, i) :\n\t\t\t\tSumOfPrimeDivisors[j] += i\n\treturn SumOfPrimeDivisors[N]", "12316": "def isPrime(n) :\n\tif (n <= 1) :\n\t\treturn False\n\tif (n <= 3) :\n\t\treturn True\n\tif (n % 2 == 0 or n % 3 == 0) :\n\t\treturn False\n\ti = 5\n\twhile i * i <= n :\n\t\tif (n % i == 0 or n % (i + 2) == 0) :\n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\ndef SumOfPrimeDivisors(n) :\n\tSum = 0\n\troot_n = (int)(math.sqrt(n))\n\tfor i in range(1, root_n + 1) :\n\t\tif (n % i == 0) :\n\t\t\tif (i == (int)(n / i) and isPrime(i)) :\n\t\t\t\tSum += i\n\t\t\telse :\n\t\t\t\tif (isPrime(i)) :\n\t\t\t\t\tSum += i\n\t\t\t\tif (isPrime((int)(n / i))) :\n\t\t\t\t\tSum += (int)(n / i)\n\treturn Sum", "12333": "def findNthNonSquare(n):\n\tx = n;\n\tans = x + math.floor(0.5 + math.sqrt(x));\n\treturn int(ans);", "12340": "def power(x, y, p):\n\tx = x % p\n\twhile (y > 0):\n\t\tif (y & 1):\n\t\t\tres = (res * x) % p\n\t\tx = (x * x) % p\n\treturn res", "12422": "def find_Square_369(num):\n\tif (num[0] == '3'):\n\t\ta = '1'\n\t\tb = '0'\n\t\tc = '8'\n\t\td = '9'\n\telif (num[0] == '6'):\n\t\ta = '4'\n\t\tb = '3'\n\t\tc = '5'\n\t\td = '6'\n\telse:\n\t\ta = '9'\n\t\tb = '8'\n\t\tc = '0'\n\t\td = '1'\n\tresult = \"\"\n\tsize = len(num)\n\tfor i in range(1, size):\n\t\tresult += a\n\tresult += b\n\tfor i in range(1, size):\n\t\tresult += c\n\tresult += d\n\treturn result", "12429": "", "12430": "", "12439": "def findpos(n):\n\tpos = 0\n\tfor i in n:\n\t\tif i == '2':\n\t\t\tpos = pos * 4 + 1\n\t\telif i == '3':\n\t\t\tpos = pos * 4 + 2\n\t\telif i == '5':\n\t\t\tpos = pos * 4 + 3\n\t\telif i == '7':\n\t\t\tpos = pos * 4 + 4\n\treturn pos", "12462": "def fact(n):\n\tif (n == 0 or n == 1):\n\t\treturn 1;\n\tans = 1;\n\tfor i in range(1, n + 1):\n\t\tans = ans * i;\n\treturn ans;\ndef nCr(n, r):\n\tNr = n ; Dr = 1 ; ans = 1;\n\tfor i in range(1, r + 1):\n\t\tans = int((ans * Nr) / (Dr));\n\t\tNr = Nr - 1;\n\t\tDr = Dr + 1;\n\treturn ans;\ndef solve ( n ):\n\tN = 2* n - 2;\n\tR = n - 1 ;\n\treturn (nCr (N, R) *\n\t\t\tfact(n - 1));", "12485": "def gcd(a, b):\n\tif (a == 0):\n\t\treturn b;\n\treturn gcd(b % a, a);\ndef coprime(a, b):\n\treturn (gcd(a, b) == 1);\ndef possibleTripletInRange(L, R):\n\tflag = False;\n\tpossibleA = 0;\n\tpossibleB = 0;\n\tpossibleC = 0;\n\tfor a in range(L, R + 1):\n\t\tfor b in range(a + 1, R + 1):\n\t\t\tfor c in range(b + 1, R + 1):\n\t\t\t\tif (coprime(a, b) and coprime(b, c) and\t\n\t\t\t\t\t\t\t\t\tcoprime(a, c) == False):\n\t\t\t\t\tflag = True;\n\t\t\t\t\tpossibleA = a;\n\t\t\t\t\tpossibleB = b;\n\t\t\t\t\tpossibleC = c;\n\t\t\t\t\tbreak;\n\tif (flag == True):\n\t\tprint(\"(\", possibleA, \",\", possibleB, \",\", possibleC, \") is one such\", \"possible triplet between\", L, \"and\", R);\n\telse:\n\t\tprint(\"No Such Triplet exists between\", L, \"and\", R);", "12486": "def possibleTripletInRange(L, R):\n\tflag = False;\n\tpossibleA = 0;\n\tpossibleB = 0;\n\tpossibleC = 0;\n\tnumbersInRange = (R - L + 1);\n\tif (numbersInRange < 3):\n\t\tflag = False;\n\telif (numbersInRange > 3):\n\t\tflag = True;\n\t\tif ((L % 2) > 0):\n\t\t\tL += 1;\n\t\tpossibleA = L;\n\t\tpossibleB = L + 1;\n\t\tpossibleC = L + 2;\n\telse:\n\t\tif ((L % 2) == 0):\n\t\t\tflag = True;\n\t\t\tpossibleA = L;\n\t\t\tpossibleB = L + 1;\n\t\t\tpossibleC = L + 2;\n\t\telse:\n\t\t\tflag = False;\n\tif (flag == True):\n\t\tprint(\"(\", possibleA, \",\", possibleB, \",\", possibleC, \") is one such\", \"possible triplet between\", L, \"and\", R);\n\telse:\n\t\tprint(\"No Such Triplet exists between\", L, \"and\", R);", "12496": "def possibleToReach(a, b):\n\tc = np.cbrt(a * b)\n\tre1 = a // c\n\tre2 = b // c\n\tif ((re1 * re1 * re2 == a) and\n\t\t(re2 * re2 * re1 == b)):\n\t\treturn True\n\telse:\n\t\treturn False", "12520": "def isUndulating(n):\n\tif (len(n) <= 2):\n\t\treturn False\n\tfor i in range(2, len(n)):\n\t\tif (n[i - 2] != n[i]):\n\t\t\treturn False\n\treturn True", "12523": "def pythagoreanTriplet(n):\n\tfor i in range(1, int(n / 3) + 1):\n\t\tfor j in range(i + 1,\n\t\t\t\t\tint(n / 2) + 1):\n\t\t\tk = n - i - j\n\t\t\tif (i * i + j * j == k * k):\n\t\t\t\tprint(i, \", \", j, \", \", k, sep = \"\")\n\t\t\t\treturn\n\tprint(\"No Triplet\")", "12532": "def factorial(n):\n\tf = 1\n\tfor i in range(2, n+1):\n\t\tf *= i\n\treturn f\ndef series(A, X, n):\n\tnFact = factorial(n)\n\tfor i in range(0, n + 1):\n\t\tniFact = factorial(n - i)\n\t\tiFact = factorial(i)\n\t\taPow = pow(A, n - i)\n\t\txPow = pow(X, i)\n\t\tprint (int((nFact * aPow * xPow) /\n\t\t\t\t(niFact * iFact)), end = \" \")", "12533": "def series(A, X, n):\n\tterm = pow(A, n)\n\tprint(term, end = \" \")\n\tfor i in range(1, n+1):\n\t\tterm = int(term * X * (n - i + 1)/(i * A))\n\t\tprint(term, end = \" \")", "12547": "def seiresSum(n, a):\n\tres = 0\n\tfor i in range(0, 2 * n):\n\t\tif (i % 2 == 0):\n\t\t\tres += a[i] * a[i]\n\t\telse:\n\t\t\tres -= a[i] * a[i]\n\treturn res", "12548": "def seiresSum(n, a):\n\treturn (n * (a[0] * a[0] - a[2 * n - 1] * a[2 * n - 1]) / (2 * n - 1))", "12550": "def checkdigit(n, k):\n\twhile (n):\n\t\trem = n % 10\n\t\tif (rem == k):\n\t\t\treturn 1\n\t\tn = n / 10\n\treturn 0\ndef findNthNumber(n, k):\n\ti = k + 1\n\tcount = 1\n\twhile(count < n):\n\t\tif (checkdigit(i, k) or (i % k == 0)):\n\t\t\tcount += 1\n\t\tif (count == n):\n\t\t\treturn i\n\t\ti += 1\n\treturn -1", "12561": "def power(n, r):\n\tcount = 0; i = r\n\twhile((n / i) >= 1):\n\t\tcount += n / i\n\t\ti = i * r\n\treturn int(count)", "12564": "def digitNumber(n):\n\tif (n == 0):\n\t\treturn 1\n\tif (n == 1):\n\t\treturn 9\n\tif (n % 2!=0):\n\t\ttemp = digitNumber((n - 1) // 2) % mod\n\t\treturn (9 * (temp * temp) % mod) % mod\n\telse:\n\t\ttemp = digitNumber(n // 2) % mod\n\t\treturn (temp * temp) % mod\ndef countExcluding(n,d):\n\tif (d == 0):\n\t\treturn (9 * digitNumber(n - 1)) % mod\n\telse:\n\t\treturn (8 * digitNumber(n - 1)) % mod", "12587": "def Div_by_8(n):\n\treturn (((n >> 3) << 3) == n)", "12603": "def avg_of_odd_num(n) :\n\tsm = 0\n\tfor i in range(0, n) :\n\t\tsm = sm + (2 * i + 1)\n\treturn sm//n", "12604": "def avg_of_odd_num(n) :\n\treturn n", "12615": "def fib(f, N):\n\tf[1] = 1\n\tf[2] = 1\n\tfor i in range(3, N + 1):\n\t\tf[i] = f[i - 1] + f[i - 2]\ndef fiboTriangle(n):\n\tN = n * (n + 1) // 2\n\tf = [0] * (N + 1)\n\tfib(f, N)\n\tfiboNum = 1\n\tfor i in range(1, n + 1):\n\t\tfor j in range(1, i + 1):\n\t\t\tprint(f[fiboNum], \" \", end=\"\")\n\t\t\tfiboNum = fiboNum + 1\n\t\tprint()", "12638": "def averageEven(n) :\n\tif (n % 2 != 0) :\n\t\tprint(\"Invalid Input\")\n\t\treturn -1\n\tsm = 0\n\tcount = 0\n\twhile (n >= 2) :\n\t\tcount = count + 1\n\t\tsm = sm + n\n\t\tn = n - 2\n\treturn sm // count", "12639": "def averageEven(n) :\n\tif (n % 2 != 0) :\n\t\tprint(\"Invalid Input\")\n\t\treturn -1\n\treturn (n + 2) // 2", "12645": "def averageOdd(n) :\n\tif (n % 2 == 0) :\n\t\tprint(\"Invalid Input\")\n\t\treturn -1\n\tsm = 0\n\tcount = 0\n\twhile (n >= 1) :\n\t\tcount = count + 1\n\t\tsm = sm + n\n\t\tn = n - 2\n\treturn sm // count", "12646": "def averageOdd(n) :\n\tif (n % 2 == 0) :\n\t\tprint(\"Invalid Input\")\n\t\treturn -1\n\treturn (n + 1) // 2", "12686": "def lcm(a, b):\n\treturn (a * b) // (math.gcd(a, b))\ndef maxRational(first, sec):\n\tk = lcm(first[1], sec[1])\n\tnume1 = first[0]\n\tnume2 = sec[0]\n\tnume1 *= k // (first[1])\n\tnume2 *= k // (sec[1])\n\treturn first if (nume2 < nume1) else sec", "12714": "def TrinomialValue(n, k):\n\tif n == 0 and k == 0:\n\t\treturn 1\n\tif k < -n or k > n:\n\t\treturn 0\n\treturn (TrinomialValue (n - 1, k - 1)+\n\t\t\t\tTrinomialValue (n - 1, k)+\n\t\t\t\t\t\tTrinomialValue (n - 1, k + 1))\ndef printTrinomial( n ):\n\tfor i in range(n):\n\t\tfor j in range(-i, 1):\n\t\t\tprint(TrinomialValue(i, j),end=\" \")\n\t\tfor j in range(1, i+1):\n\t\t\tprint( TrinomialValue(i, j),end=\" \")\n\t\tprint(\"\\n\",end='')", "12715": "def TrinomialValue(dp , n , k):\n\tif k < 0:\n\t\tk = -k\n\tif dp[n][k] != 0:\n\t\treturn dp[n][k]\n\tif n == 0 and k == 0:\n\t\treturn 1\n\tif k < -n or k > n:\n\t\treturn 0\n\treturn (TrinomialValue(dp, n - 1, k - 1) +\n\t\t\t\tTrinomialValue(dp, n - 1, k)+\n\t\t\t\t\tTrinomialValue(dp, n - 1, k + 1))\ndef printTrinomial(n):\n\tdp = [[0]*10]*10\n\tfor i in range(n):\n\t\tfor j in range(-i,1):\n\t\t\tprint(TrinomialValue(dp, i, j),end=\" \")\n\t\tfor j in range(1,i+1):\n\t\t\tprint(TrinomialValue(dp, i, j),end=\" \")\n\t\tprint(\"\\n\",end='')", "12716": "def Series(n):\n\tsums = 0\n\tfor i in range(1, n + 1):\n\t\tsums += (i * i);\n\treturn sums", "12745": "def isPrime( n ):\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, n):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\ndef isEmirp( n):\n\tn = int(n)\n\tif isPrime(n) == False:\n\t\treturn False\n\trev = 0\n\twhile n != 0:\n\t\td = n % 10\n\t\trev = rev * 10 + d\n\t\tn = int(n / 10)\n\treturn isPrime(rev)", "12747": "def sumOfLargePrimeFactor( n ):\n\tprime = [0] * (n + 1)\n\tsum = 0\n\tmax = int(n / 2)\n\tfor p in range(2, max + 1):\n\t\tif prime[p] == 0:\n\t\t\tfor i in range(p * 2, n + 1, p):\n\t\t\t\tprime[i] = p\n\tfor p in range(2, n + 1):\n\t\tif prime[p]:\n\t\t\tsum += prime[p]\n\t\telse:\n\t\t\tsum += p\n\treturn sum", "12750": "def gcd (a, b):\n\tif a == 0 or b == 0:\n\t\treturn 0\n\tif a == b:\n\t\treturn a\n\tif a > b:\n\t\treturn gcd(a - b, b)\n\treturn gcd(a, b - a)\ndef cpFact(x, y):\n\twhile gcd(x, y) != 1:\n\t\tx = x / gcd(x, y)\n\treturn int(x)", "12764": "def counLastDigitK(low, high, k):\n\tcount = 0\n\tfor i in range(low, high+1):\n\t\tif (i % 10 == k):\n\t\t\tcount+=1\n\treturn count", "12765": "def counLastDigitK(low, high, k):\n\tmlow = 10 * math.ceil(low/10.0)\n\tmhigh = 10 * int(high/10.0)\n\tcount = (mhigh - mlow)/10\n\tif (high % 10 >= k):\n\t\tcount += 1\n\tif (low % 10 <= k and \\\n\t\t(low%10) > 0):\n\t\tcount += 1\n\treturn int(count)", "12794": "def Convert(radian):\n\tpi = 3.14159\n\tdegree = radian * (180/pi)\n\treturn degree", "12799": "def sn(n, an):\n\treturn (n * (1 + an)) / 2;\ndef trace(n, m):\n\tan = 1 + (n - 1) * (m + 1);\n\trowmajorSum = sn(n, an);\n\tan = 1 + (n - 1) * (n + 1);\n\tcolmajorSum = sn(n, an);\n\treturn int(rowmajorSum + colmajorSum);", "12810": "def avgOfFirstN(n) :\n\treturn (float)(1 + n) / 2;", "12842": "", "12844": "def max_area(n,m,k):\n\tif (k > (n + m - 2)):\n\t\tprint(\"Not possible\")\n\telse:\n\t\tif (k < max(m,n) - 1):\n\t\t\tresult = max(m * (n / (k + 1)), n * (m / (k + 1)));\n\t\telse:\n\t\t\tresult = max(m / (k - n + 2), n / (k - m + 2));\n\t\tprint(result)", "12855": "def prevNum(string, n):\n\tindex = -1\n\tfor i in range(n - 2, -1, -1):\n\t\tif int(string[i]) > int(string[i + 1]):\n\t\t\tindex = i\n\t\t\tbreak\n\tsmallGreatDgt = -1\n\tfor i in range(n - 1, index, -1):\n\t\tif (smallGreatDgt == -1 and int(string[i]) <\n\t\t\t\t\t\t\t\t\tint(string[index])):\n\t\t\tsmallGreatDgt = i\n\t\telif (index > -1 and int(string[i]) >=\n\t\t\t\t\t\t\tint(string[smallGreatDgt]) and\n\t\t\t\t\t\t\tint(string[i]) < int(string[index])):\n\t\t\tsmallGreatDgt = i\n\tif index == -1:\n\t\treturn \"\" . join(\"-1\")\n\telse:\n\t\t(string[index], string[smallGreatDgt]) = (string[smallGreatDgt], string[index])\n\treturn \"\" . join(string)", "12891": "def calculate_sum(a, N):\n\tm = N / a\n\tsum = m * (m + 1) / 2\n\tans = a * sum\n\tprint(\"Sum of multiples of \", a, \" up to \", N, \" = \", ans)", "12895": "def horner( poly, n, x):\n\tresult = poly[0];\n\tfor i in range(1,n):\n\t\tresult = (result * x + poly[i]);\n\treturn result;\ndef findSign(poly, n, x):\n\tresult = horner(poly, n, x);\n\tif (result > 0):\n\t\treturn 1;\n\telif (result < 0):\n\t\treturn -1;\n\treturn 0;", "12905": "def isPowerOf2(sttr):\n\tlen_str = len(sttr);\n\tsttr=list(sttr);\n\tnum = 0;\n\tif (len_str == 1 and sttr[len_str - 1] == '1'):\n\t\treturn 0;\n\twhile (len_str != 1 or sttr[len_str - 1] != '1'):\n\t\tif ((ord(sttr[len_str - 1]) - ord('0')) % 2 == 1):\n\t\t\treturn 0;\n\t\tj = 0;\n\t\tfor i in range(len_str):\n\t\t\tnum = num * 10 + (ord(sttr[i]) - ord('0'));\n\t\t\tif (num < 2):\n\t\t\t\tif (i != 0):\n\t\t\t\t\tsttr[j] = '0';\n\t\t\t\t\tj += 1;\n\t\t\t\tcontinue;\n\t\t\tsttr[j] = chr((num // 2) + ord('0'));\n\t\t\tj += 1;\n\t\t\tnum = (num) - (num // 2) * 2;\n\t\tlen_str = j;\n\treturn 1;", "12906": "def ispowerof2(num):\n\tif((num & (num - 1)) == 0):\n\t\treturn 1\n\treturn 0", "12970": "def counDivisors(X):\n\tcount = 0\n\tfor i in range(1, X + 1):\n\t\tif (X % i == 0):\n\t\t\tcount += 1\n\treturn count\ndef countDivisorsMult(arr, n):\n\tmul = 1\n\tfor i in range(n):\n\t\tmul *= arr[i]\n\treturn counDivisors(mul)", "12971": "def SieveOfEratosthenes(largest, prime):\n\tisPrime = [True] * (largest + 1)\n\tp = 2\n\twhile p * p <= largest:\n\t\tif (isPrime[p] == True):\n\t\t\tfor i in range(p * 2, largest + 1, p):\n\t\t\t\tisPrime[i] = False\n\t\tp += 1\n\tfor p in range(2, largest + 1):\n\t\tif (isPrime[p]):\n\t\t\tprime.append(p)\ndef countDivisorsMult(arr, n):\n\tlargest = max(arr)\n\tprime = []\n\tSieveOfEratosthenes(largest, prime)\n\tmp = defaultdict(int)\n\tfor i in range(n):\n\t\tfor j in range(len(prime)):\n\t\t\twhile(arr[i] > 1 and arr[i] % prime[j] == 0):\n\t\t\t\tarr[i] //= prime[j]\n\t\t\t\tmp[prime[j]] += 1\n\t\tif (arr[i] != 1):\n\t\t\tmp[arr[i]] += 1\n\tres = 1\n\tfor it in mp.values():\n\t\tres *= (it + 1)\n\treturn res", "12983": "def printTaxicab2(N):\n\ti, count = 1, 0\n\twhile (count < N):\n\t\tint_count = 0\n\t\tfor j in range(1, math.ceil(\\\n\t\t\t\tpow(i, 1.0 / 3)) + 1):\n\t\t\tfor k in range(j + 1,\\\n\t\t\tmath.ceil(pow(i, 1.0 / 3)) + 1):\n\t\t\t\tif (j * j * j + k * k * k == i):\n\t\t\t\t\tint_count += 1\n\t\tif (int_count == 2):\n\t\t\tcount += 1\n\t\t\tprint(count, \" \", i)\n\t\ti += 1", "12991": "def isComposite(n):\n\tif (n <= 1):\n\t\treturn False\n\tif (n <= 3):\n\t\treturn False\n\tif (n % 2 == 0 or n % 3 == 0):\n\t\treturn True\n\ti = 5\n\twhile(i * i <= n):\n\t\tif (n % i == 0 or n % (i + 2) == 0):\n\t\t\treturn True\n\t\ti = i + 6\n\treturn False", "13022": "def area_fun(side):\n\tarea = side * side\n\treturn area", "13040": "def countConsecutive(N):\n\tcount = 0\n\tL = 1\n\twhile( L * (L + 1) < 2 * N):\n\t\ta = (1.0 * N - (L * (L + 1) ) / 2) / (L + 1)\n\t\tif (a - int(a) == 0.0):\n\t\t\tcount += 1\n\t\tL += 1\n\treturn count", "13048": "def isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, n):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\ndef findPrime(n):\n\tnum = n + 1\n\twhile (num):\n\t\tif isPrime(num):\n\t\t\treturn num\n\t\tnum += 1\n\treturn 0\ndef minNumber(arr):\n\ts = 0\n\tfor i in range(0, len(arr)):\n\t\ts += arr[i]\n\tif isPrime(s) :\n\t\treturn 0\n\tnum = findPrime(s)\n\treturn num - s", "13049": "def sieveOfEratostheneses():\n\tisPrime[1] = False\n\ti = 2\n\twhile i * i < 100005:\n\t\tif(isPrime[i]):\n\t\t\tj = 2 * i\n\t\t\twhile j < 100005:\n\t\t\t\tisPrime[j] = False\n\t\t\t\tj += i\n\t\ti += 1\n\treturn\ndef findPrime(n):\n\tnum = n + 1\n\twhile(num):\n\t\tif isPrime[num]:\n\t\t\treturn num\n\t\tnum += 1\n\treturn 0\ndef minNumber(arr):\n\tsieveOfEratostheneses()\n\ts = 0\n\tfor i in range(0, len(arr)):\n\t\ts += arr[i]\n\tif isPrime[s] == True:\n\t\treturn 0\n\tnum = findPrime(s)\n\treturn num - s", "13140": "def fact(n):\n\tif (n == 0):\n\t\treturn 1\n\treturn n * fact(n - 1)\ndef div(x):\n\tans = 0;\n\tfor i in range(1, x + 1):\n\t\tif (x % i == 0):\n\t\t\tans += i\n\treturn ans\ndef sumFactDiv(n):\n\treturn div(fact(n))", "13141": "def sieve(n):\n\tprime = [True] * (n + 1);\n\tp = 2;\n\twhile (p * p <= n):\n\t\tif (prime[p] == True):\n\t\t\tfor i in range(p * 2, n + 1, p):\n\t\t\t\tprime[i] = False;\n\t\tp += 1;\n\tfor p in range(2, n + 1):\n\t\tif (prime[p]):\n\t\t\tallPrimes.append(p);\ndef factorialDivisors(n):\n\tresult = 1;\n\tfor i in range(len(allPrimes)):\n\t\tp = allPrimes[i];\n\t\texp = 0;\n\t\twhile (p <= n):\n\t\t\texp = exp + int(n / p);\n\t\t\tp = p * allPrimes[i];\n\t\tresult = int(result * (pow(allPrimes[i], exp + 1) - 1) /\n\t\t\t\t\t\t\t\t\t\t(allPrimes[i] - 1));\n\treturn result;", "13144": "def isAutomorphic(N) :\n\tsq = N * N\n\twhile (N > 0) :\n\t\tif (N % 10 != sq % 10) :\n\t\t\treturn False\n\t\tN /= 10\n\t\tsq /= 10\n\treturn True", "13179": "def checkPandigital(b, n):\n\tif (len(n) < b):\n\t\treturn 0;\n\thash = [0] * b;\n\tfor i in range(len(n)):\n\t\tif (n[i] >= '0' and n[i] <= '9'):\n\t\t\thash[ord(n[i]) - ord('0')] = 1;\n\t\telif (ord(n[i]) - ord('A') <= b - 11):\n\t\t\thash[ord(n[i]) - ord('A') + 10] = 1;\n\tfor i in range(b):\n\t\tif (hash[i] == 0):\n\t\t\treturn 0;\n\treturn 1;", "13180": "def conver(m, n):\n\tif(m == n):\n\t\treturn 0\n\tif(m > n):\n\t\treturn m - n\n\tif(m <= 0 and n > 0):\n\t\treturn -1\n\tif(n % 2 == 1):\n\t\treturn 1 + conver(m, n + 1)\n\telse:\n\t\treturn 1 + conver(m, n / 2)", "13236": "def getDigitProduct(x):\n\tif (x < 10):\n\t\treturn x;\n\tif (prodDig[x] != 0):\n\t\treturn prodDig[x];\n\tprod = (int(x % 10) *\n\t\t\tgetDigitProduct(int(x / 10)));\n\tprodDig[x] = prod;\n\treturn prod;\ndef findSeed(n):\n\tres = [];\n\tfor i in range(1, int(n / 2 + 2)):\n\t\tif (i * getDigitProduct(i) == n):\n\t\t\tres.append(i);\n\tif (len(res) == 0):\n\t\tprint(\"NO seed exists\");\n\t\treturn;\n\tfor i in range(len(res)):\n\t\tprint(res[i], end = \" \");", "13240": "def maxPrimefactorNum(N):\n\tarr = [0 for i in range(N + 5)]\n\tfor i in range(2, int(sqrt(N)) + 1, 1):\n\t\tif (arr[i] == 0):\n\t\t\tfor j in range(2 * i, N + 1, i):\n\t\t\t\tarr[j] += 1\n\t\tarr[i] = 1\n\tmaxval = 0\n\tmaxint = 1\n\tfor i in range(1, N + 1, 1):\n\t\tif (arr[i] > maxval):\n\t\t\tmaxval = arr[i]\n\t\t\tmaxint = i\n\treturn maxint", "13241": "def maxPrimefactorNum(N):\n\tarr = [True] * (N + 5);\n\ti = 3;\n\twhile (i * i <= N):\n\t\tif (arr[i]):\n\t\t\tfor j in range(i * i, N + 1, i):\n\t\t\t\tarr[j] = False;\n\t\ti += 2;\n\tprime = [];\n\tprime.append(2);\n\tfor i in range(3, N + 1, 2):\n\t\tif(arr[i]):\n\t\t\tprime.append(i);\n\ti = 0;\n\tans = 1;\n\twhile (ans * prime[i] <= N and\n\t\t\t\t\ti < len(prime)):\n\t\tans *= prime[i];\n\t\ti += 1;\n\treturn ans;", "13250": "def SubArraySum(arr, n):\n\ttemp,result = 0,0\n\tfor i in range(0, n):\n\t\ttemp=0;\n\t\tfor j in range(i, n):\n\t\t\ttemp+=arr[j]\n\t\t\tresult += temp\n\treturn result", "13251": "def SubArraySum(arr, n ):\n\tresult = 0\n\tfor i in range(0, n):\n\t\tresult += (arr[i] * (i+1) * (n-i))\n\treturn result", "13288": "def highestPowerof2(n):\n\tres = 0;\n\tfor i in range(n, 0, -1):\n\t\tif ((i & (i - 1)) == 0):\n\t\t\tres = i;\n\t\t\tbreak;\n\treturn res;", "13290": "def highestPowerof2(n):\n\tp = int(math.log(n, 2));\n\treturn int(pow(2, p));", "13307": "def aModM(s, mod):\n\tnumber = 0\n\tfor i in range(len(s)):\n\t\tnumber = (number*10 + int(s[i]))\n\t\tnumber = number % m\n\treturn number\ndef ApowBmodM(a, b, m):\n\tans = aModM(a, m)\n\tmul = ans\n\tfor i in range(1,b):\n\t\tans = (ans*mul) % m\n\treturn ans", "13352": "def divSum(num) :\n\tresult = 0", "13400": "def findPairs( n):\n\tcubeRoot = int(math.pow(n, 1.0 / 3.0));", "13401": "def findPairs(n):\n\tcubeRoot = pow(n, 1.0 / 3.0);\n\ts = {}\n\tfor x in range(int(cubeRoot)):\n\t\tfor y in range(x + 1,\n\t\tint(cubeRoot) + 1):\n\t\t\tsum = x * x * x + y * y * y;\n\t\t\tif (sum != n):\n\t\t\t\tcontinue;\n\t\t\tif sum in s.keys():\n\t\t\t\tprint(\"(\" + str(s[sum][0]) +\n\t\t\t\t\t\", \" + str(s[sum][1]) + \") and (\" + str(x) +\n\t\t\t\t\t\t\t\", \" + str(y) + \")\" + \"\\n\")\n\t\t\telse:\n\t\t\t\ts[sum] = [x, y]", "13409": "def gcd(a,b):\n\twhile (b != 0):\n\t\tt = b\n\t\tb = a % b\n\t\ta = t\n\treturn a\ndef findMinDiff (a, b, x, y):\n\tg = gcd(a,b)\n\tdiff = abs(x-y) % g\n\treturn min(diff, g - diff)", "13429": "def printDivisors(n) :\n\tlist = []\n\tfor i in range(1, int(math.sqrt(n) + 1)) :\n\t\tif (n % i == 0) :\n\t\t\tif (n / i == i) :\n\t\t\t\tprint (i, end =\" \")\n\t\t\telse :\n\t\t\t\tprint (i, end =\" \")\n\t\t\t\tlist.append(int(n / i))\n\tfor i in list[::-1] :\n\t\tprint (i, end =\" \")", "13430": "def printDivisors (n):\n\ti = 1\n\twhile (i * i < n):\n\t\tif (n % i == 0):\n\t\t\tprint(i, end = \" \")\n\t\ti += 1\n\tfor i in range(int(sqrt(n)), 0, -1):\n\t\tif (n % i == 0):\n\t\t\tprint(n // i, end = \" \")", "13431": "def printDivisors(n) :\n\ti = 1\n\twhile i <= n :\n\t\tif (n % i==0) :\n\t\t\tprint i,\n\t\ti = i + 1", "13432": "def printDivisors(n) :\n\ti = 1\n\twhile i <= math.sqrt(n):\n\t\tif (n % i == 0) :\n\t\t\tif (n / i == i) :\n\t\t\t\tprint i,\n\t\t\telse :\n\t\t\t\tprint i , n/i,\n\t\ti = i + 1", "13448": "def interpolate(f: list, xi: int, n: int) -> float:\n\tresult = 0.0\n\tfor i in range(n):\n\t\tterm = f[i].y\n\t\tfor j in range(n):\n\t\t\tif j != i:\n\t\t\t\tterm = term * (xi - f[j].x) / (f[i].x - f[j].x)\n\t\tresult += term\n\treturn result\ndef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y", "13453": "def SieveOfAtkin(limit):\n\tif (limit > 2):\n\t\tprint(2 , end = \" \")\n\tif (limit > 3):\n\t\tprint(3 , end = \" \")\n\tsieve = [False] * limit\n\tfor i in range( 0 , limit ):\n\t\tsieve[i] = False\n\tx = 1\n\twhile(x * x < limit ) :\n\t\ty = 1\n\t\twhile(y * y < limit ) :\n\t\t\tn = (4 * x * x) + (y * y)\n\t\t\tif (n <= limit and (n % 12 == 1 or n % 12 == 5)):\n\t\t\t\tsieve[n] ^= True\n\t\t\tn = (3 * x * x) + (y * y)\n\t\t\tif (n <= limit and n % 12 == 7):\n\t\t\t\tsieve[n] ^= True\n\t\t\tn = (3 * x * x) - (y * y)\n\t\t\tif (x > y and n <= limit and n % 12 == 11):\n\t\t\t\tsieve[n] ^= True\n\t\t\ty += 1\n\t\tx += 1\n\tr = 5\n\twhile(r * r < limit) :\n\t\tif (sieve[r]) :\n\t\t\tfor i in range(r * r, limit, r * r):\n\t\t\t\tsieve[i] = False\n\tfor a in range(5 , limit ):\n\t\tif (sieve[a]):\n\t\t\tprint(a , end = \" \")", "13454": "def SieveOfSundaram(n):\n\tnNew = int((n - 1) / 2);\n\tmarked = [0] * (nNew + 1);\n\tfor i in range(1, nNew + 1):\n\t\tj = i;\n\t\twhile((i + j + 2 * i * j) <= nNew):\n\t\t\tmarked[i + j + 2 * i * j] = 1;\n\t\t\tj += 1;\n\tif (n > 2):\n\t\tprint(2, end = \" \");\n\tfor i in range(1, nNew + 1):\n\t\tif (marked[i] == 0):\n\t\t\tprint((2 * i + 1), end = \" \");", "13460": "def power(x, y, p) :\n\twhile (y > 0):\n\t\tif (y & 1):\n\t\t\tres = (res * x) % p\n\t\tx = (x * x) % p\n\treturn res\ndef squareRoot(n, p):\n\tif (p % 4 != 3) :\n\t\tprint( \"Invalid Input\" )\n\t\treturn\n\tn = n % p\n\tx = power(n, (p + 1) // 4, p)\n\tif ((x * x) % p == n):\n\t\tprint( \"Square root is \", x)\n\t\treturn\n\tx = p - x\n\tif ((x * x) % p == n):\n\t\tprint( \"Square root is \", x )\n\t\treturn\n\tprint( \"Square root doesn't exist \" )", "13468": "def power(x, y, p):\n\tres = 1;\n\tx = x % p;\n\twhile (y > 0):\n\t\tif (y & 1):\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\treturn res;\ndef miillerTest(d, n):\n\ta = 2 + random.randint(1, n - 4);\n\tx = power(a, d, n);\n\tif (x == 1 or x == n - 1):\n\t\treturn True;\n\twhile (d != n - 1):\n\t\tx = (x * x) % n;\n\t\td *= 2;\n\t\tif (x == 1):\n\t\t\treturn False;\n\t\tif (x == n - 1):\n\t\t\treturn True;\n\treturn False;\ndef isPrime( n, k):\n\tif (n <= 1 or n == 4):\n\t\treturn False;\n\tif (n <= 3):\n\t\treturn True;\n\td = n - 1;\n\twhile (d % 2 == 0):\n\t\td //= 2;\n\tfor i in range(k):\n\t\tif (miillerTest(d, n) == False):\n\t\t\treturn False;\n\treturn True;", "13489": "def isInside(circle_x, circle_y, rad, x, y):\n\tif ((x - circle_x) * (x - circle_x) +\n\t\t(y - circle_y) * (y - circle_y) <= rad * rad):\n\t\treturn True;\n\telse:\n\t\treturn False;", "13501": "def eval(a, op, b):\n\tif op == '+': return a + b\n\tif op == '-': return a - b\n\tif op == '*': return a * b\ndef evaluateAll(expr, low, high):\n\tres = []\n\tif low == high:\n\t\tres.append(int(expr[low]))\n\t\treturn res\n\tif low == (high - 2):\n\t\tnum = eval(int(expr[low]),\n\t\t\t\t\texpr[low + 1],\n\t\t\t\tint(expr[low + 2]))\n\t\tres.append(num)\n\t\treturn res\n\tfor i in range(low + 1, high + 1, 2):", "13504": "def isLucky(n):\n\tar = [0] * 10\n\twhile (n > 0):\n\t\tdigit = math.floor(n % 10)\n\t\tif (ar[digit]):\n\t\t\treturn 0\n\t\tar[digit] = 1\n\t\tn = n / 10\n\treturn 1", "13535": "def printSquares(n):\n\tsquare = 0\n\todd = 1\n\tfor x in range(0 , n):\n\t\tprint(square, end= \" \")", "13575": "def reversDigits(num):\n\tglobal rev_num\n\tglobal base_pos\n\tif(num > 0):\n\t\treversDigits((int)(num / 10))\n\t\trev_num += (num % 10) * base_pos\n\t\tbase_pos *= 10\n\treturn rev_num", "13606": "def constructArray(A, N, K):\n\tB = [0] * N;\n\ttotalXOR = A[0] ^ K;\n\tfor i in range(N):\n\t\tB[i] = totalXOR ^ A[i];\n\tfor i in range(N):\n\t\tprint(B[i], end = \" \");", "13633": "def RecursiveFunction(ref, bit):\n\tif(len(ref) == 0 or bit < 0):\n\t\treturn 0;\n\tcurr_on = []\n\tcurr_off = []\n\tfor i in range(len(ref)):\n\t\tif(((ref[i] >> bit) & 1) == 0):\n\t\t\tcurr_off.append(ref[i])\n\t\telse:\n\t\t\tcurr_on.append(ref[i])\n\tif(len(curr_off) == 0):\n\t\treturn RecursiveFunction(curr_on, bit - 1)\n\tif(len(curr_on) == 0):\n\t\treturn RecursiveFunction(curr_off, bit - 1)\n\treturn(min(RecursiveFunction(curr_off, bit - 1),\n\t\t\tRecursiveFunction(curr_on, bit - 1)) + (1 << bit))\ndef PrintMinimum(a, n):\n\tv = []\n\tfor i in range(n):\n\t\tv.append(a[i])\n\tprint(RecursiveFunction(v, 30))", "13660": "def extraElement(A, B, n):\n\tans = 0;\n\tfor i in range(n):\n\t\tans ^= A[i];\n\tfor i in range(n + 1):\n\t\tans ^= B[i];\n\treturn ans;", "13671": "def cntElements(arr, n):\n\tcnt = 0\n\tfor i in range(n - 2):\n\t\tif (arr[i] == (arr[i + 1] ^ arr[i + 2])):\n\t\t\tcnt += 1\n\treturn cnt", "13672": "def xor_triplet(arr, n):\n\tans = 0;\n\tfor i in range(n):\n\t\tfor j in range(i + 1, n):\n\t\t\tfor k in range(j, n):\n\t\t\t\txor1 = 0; xor2 = 0;\n\t\t\t\tfor x in range(i, j):\n\t\t\t\t\txor1 ^= arr[x];\n\t\t\t\tfor x in range(j, k + 1):\n\t\t\t\t\txor2 ^= arr[x];\n\t\t\t\tif (xor1 == xor2):\n\t\t\t\t\tans += 1;\n\treturn ans;", "13684": "def bit_q(i, j):\n\tsum = 0\n\twhile (j > 0):\n\t\tsum += bit[j]\n\t\tj -= (j & (j * -1))\n\ti -= 1\n\twhile (i > 0):\n\t\tsum -= bit[i]\n\t\ti -= (i & (i * -1))\n\treturn sum\ndef bit_up(i, diff):\n\twhile (i <= n):\n\t\tbit[i] += diff\n\t\ti += i & -i\ndef dfs(node, x):\n\tIdeal_pair = x\n\tIdeal_pair += bit_q(max(1, node - k),\n\t\t\t\t\t\tmin(n, node + k))\n\tbit_up(node, 1)\n\tfor i in range(len(al[node])):\n\t\tIdeal_pair = dfs(al[node][i], Ideal_pair)\n\tbit_up(node, -1)\n\treturn Ideal_pair\ndef initialise():\n\tIdeal_pair = 0;\n\tfor i in range(n + 1):\n\t\troot_node[i] = True\n\t\tbit[i] = 0\ndef Add_Edge(x, y):\n\tal[x].append(y)\n\troot_node[y] = False\ndef Idealpairs():\n\tr = -1\n\tfor i in range(1, n + 1, 1):\n\t\tif (root_node[i]):\n\t\t\tr = i\n\t\t\tbreak\n\tIdeal_pair = dfs(r, 0)\n\treturn Ideal_pair", "13757": "def hammingDistance(n1, n2) :\n\tx = n1 ^ n2\n\tsetBits = 0\n\twhile (x > 0) :\n\t\tsetBits += x & 1\n\t\tx >>= 1\n\treturn setBits", "13829": "def printSubsets(n):\n\tfor i in range(n + 1):\n\t\tif ((n & i) == i):\n\t\t\tprint(i ,\" \", end = \"\")", "13830": "def printSubsets(n):\n\ti=n\n\twhile(i != 0):\n\t\tprint(i,end=\" \")\n\t\ti=(i - 1) & n\n\tprint(\"0\")", "13875": "def isDivisibleby17(n):\n\tif (n == 0 or n == 17):\n\t\treturn True\n\tif (n < 17):\n\t\treturn False\n\treturn isDivisibleby17((int)(n >> 4) - (int)(n & 15))", "13876": "def answer(n):\n\tm = 2;\n\tans = 1;\n\tr = 1;\n\twhile r < n:\n\t\tr = (int)((pow(2, m) - 1) *\n\t\t\t\t(pow(2, m - 1)));\n\t\tif r < n:\n\t\t\tans = r;\n\t\tm = m + 1;\n\treturn ans;", "13897": "def setBitNumber(n):\n\tif (n == 0):\n\t\treturn 0;\n\tmsb = 0;\n\tn = int(n / 2);\n\twhile (n > 0):\n\t\tn = int(n / 2);\n\t\tmsb += 1;\n\treturn (1 << msb);", "13898": "def setBitNumber(n):\n\tn |= n>>1\n\tn |= n>>2 \n\tn |= n>>4 \n\tn |= n>>8\n\tn |= n>>16\n\tn = n + 1\n\treturn (n >> 1)", "13899": "def setBitNumber(n):\n\tk = int(math.log(n, 2))\n\treturn 1 << k", "13966": "def countTrailingZero(x):\n\tcount = 0\n\twhile ((x & 1) == 0):\n\t\tx = x >> 1\n\t\tcount += 1\n\treturn count", "13967": "def countTrailingZero(x):\n\tlookup = [32, 0, 1, 26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11, 0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19, 18]\n\treturn lookup[(-x & x) % 37]", "13987": "def maxConsecutiveOnes(x):\n\tcount = 0\n\twhile (x!=0):\n\t\tx = (x & (x << 1))\n\t\tcount=count+1\n\treturn count", "14020": "def multiplyBySevenByEight(n):", "14021": "def multiplyBySevenByEight(n):\n\treturn ((n << 3) -n) >> 3;", "14022": "def subtract(x, y):\n\twhile (y != 0):\n\t\tborrow = (~x) & y\n\t\tx = x ^ y\n\t\ty = borrow << 1\n\treturn x", "14023": "def subtract(x, y):\n\tif (y == 0):\n\t\treturn x\n\treturn subtract(x ^ y, (~x & y) << 1)"}, "C#": {"451": "static int minCost(int [,]cost)\n\t{\n\t\tint []dist = new int[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tdist[i] = INF;\n\t\tdist[0] = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\tif (dist[j] > dist[i] + cost[i,j])\n\t\t\t\t\tdist[j] = dist[i] + cost[i,j];\n\t\treturn dist[N-1];\n\t}", "455": "static int numOfways(int n, int k)\n\t{\n\t\tint p = 1;\n\t\tif (k % 2 != 0)\n\t\t\tp = -1;\n\t\treturn (int)(Math.Pow(n - 1, k)\n\t\t\t\t\t+ p * (n - 1)) / n;\n\t}", "496": "static int fib(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn n;\n\t\treturn fib(n - 1) + fib(n - 2);\n\t}\nstatic int findVertices (int n)\n\t{\n\t\treturn fib(n + 2);\n\t}", "617": "static Node reverse( Node head_ref)\n{\n\tNode temp = null;\n\tNode current = head_ref;\n\twhile (current != null)\n\t{\n\t\ttemp = current.prev;\n\t\tcurrent.prev = current.next;\n\t\tcurrent.next = temp;\n\t\tcurrent = current.prev;\n\t}\n\tif (temp != null)\n\t\thead_ref = temp.prev;\n\t\treturn head_ref;\n}\nstatic Node merge(Node first, Node second)\n{\n\tif (first == null)\n\t\treturn second;\n\tif (second == null)\n\t\treturn first;\n\tif (first.data < second.data)\n\t{\n\t\tfirst.next = merge(first.next, second);\n\t\tfirst.next.prev = first;\n\t\tfirst.prev = null;\n\t\treturn first;\n\t}\n\telse\n\t{\n\t\tsecond.next = merge(first, second.next);\n\t\tsecond.next.prev = second;\n\t\tsecond.prev = null;\n\t\treturn second;\n\t}\n}\nstatic Node sort(Node head)\n{\n\tif (head == null head.next == null)\n\t\treturn head;\n\tNode current = head.next;\n\twhile (current != null)\n\t{\n\t\tif (current.data < current.prev.data)\n\t\t\tbreak;\n\t\tcurrent = current.next;\n\t}\n\tif (current == null)\n\t\treturn head;\n\tcurrent.prev.next = null;\n\tcurrent.prev = null;\n\tcurrent = reverse(current);\n\treturn merge(head, current);\n}\nstatic Node push( Node head_ref, int new_data)\n{\n\tNode new_node = new Node();\n\tnew_node.data = new_data;\n\tnew_node.prev = null;\n\tnew_node.next = (head_ref);\n\tif ((head_ref) != null)\n\t\t(head_ref).prev = new_node;\n\t(head_ref) = new_node;\n\treturn head_ref;\n}\nstatic void printList( Node head)\n{\n\tif (head == null)\n\t\tConsole.WriteLine(\"Doubly Linked list empty\");\n\twhile (head != null)\n\t{\n\t\tConsole.Write(head.data + \" \");\n\t\thead = head.next;\n\t}\n}", "647": "static Node newNode(char key)\n\t{\n\t\tNode temp = new Node();\n\t\ttemp.data = key;\n\t\ttemp.next = null;\n\t\treturn temp;\n\t}\nstatic void printlist(Node head)\n\t{\n\t\tif (head == null)\n\t\t{\n\t\t\tConsole.WriteLine(\"Empty List\");\n\t\t\treturn;\n\t\t}\n\t\twhile (head != null)\n\t\t{\n\t\t\tConsole.Write(head.data +\" \");\n\t\t\tif (head.next != null)\n\t\t\t\tConsole.Write(\"-> \");\n\t\t\thead = head.next;\n\t\t}\n\t\tConsole.WriteLine();\n\t}\nstatic bool isVowel(char x)\n\t{\n\t\treturn (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n\t}\nstatic Node arrange(Node head)\n\t{\n\t\tNode newHead = head;\n\t\tNode latestVowel;\n\t\tNode curr = head;\n\t\tif (head == null)\n\t\t\treturn null;\n\t\tif (isVowel(head.data) == true)\n\t\t\tlatestVowel = head;\n\t\telse\n\t\t{\n\t\t\twhile (curr.next != null &&\n\t\t\t\t!isVowel(curr.next.data))\n\t\t\t\tcurr = curr.next;\n\t\t\tif (curr.next == null)\n\t\t\t\treturn head;\n\t\t\tlatestVowel = newHead = curr.next;\n\t\t\tcurr.next = curr.next.next;\n\t\t\tlatestVowel.next = head;\n\t\t}\n\t\twhile (curr != null && curr.next != null)\n\t\t{\n\t\t\tif (isVowel(curr.next.data) == true)\n\t\t\t{\n\t\t\t\tif (curr == latestVowel)\n\t\t\t\t{\n\t\t\t\t\tlatestVowel = curr = curr.next;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNode temp = latestVowel.next;\n\t\t\t\t\tlatestVowel.next = curr.next;\n\t\t\t\t\tlatestVowel = latestVowel.next;\n\t\t\t\t\tcurr.next = curr.next.next;\n\t\t\t\t\tlatestVowel.next = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurr = curr.next;\n\t\t\t}\n\t\t}\n\t\treturn newHead;\n\t}", "694": "static Node newNode(int data)\n{\n\tNode temp = new Node();\n\ttemp.data = data;\n\ttemp.right = null;\n\ttemp.left = null;\n\treturn temp;\n}\nstatic Node KthLargestUsingMorrisTraversal(Node root, int k)\n{\n\tNode curr = root;\n\tNode Klargest = null;\n\tint count = 0;\n\twhile (curr != null)\n\t{\n\t\tif (curr.right == null)\n\t\t{\n\t\t\tif (++count == k)\n\t\t\t\tKlargest = curr;\n\t\t\tcurr = curr.left;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNode succ = curr.right;\n\t\t\twhile (succ.left != null && succ.left != curr)\n\t\t\t\tsucc = succ.left;\n\t\t\tif (succ.left == null)\n\t\t\t{\n\t\t\t\tsucc.left = curr;\n\t\t\t\tcurr = curr.right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsucc.left = null;\n\t\t\t\tif (++count == k)\n\t\t\t\t\tKlargest = curr;\n\t\t\t\tcurr = curr.left;\n\t\t\t}\n\t\t}\n\t}\n\treturn Klargest;\n}", "815": "static void sortByRow(int [,]mat, int n)\n\t{\n\tfor (int i = 0; i < n ; i++)\n\t\t{\n\t\tfor(int j = 0; j < n - 1; j++)\n\t\t{\n\t\t\tif(mat[i, j] > mat[i, j + 1])\n\t\t\t{\n\t\t\t\tvar temp = mat[i, j];\n\t\t\t\tmat[i, j] = mat[i, j + 1];\n\t\t\t\tmat[i, j + 1] = temp;\n\t\t\t}\n\t\t}\n\t\t}\n\t}\nstatic void transpose(int [,]mat, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvar temp = mat[i, j];\n\t\t\t\t\tmat[i, j] = mat[j, i];\n\t\t\t\t\tmat[j, i] = temp;\n\t\t\t\t}\n\t}\nstatic void sortMatRowAndColWise(int [,]mat, int n)\n\t{\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t}\nstatic void printMat(int [,]mat, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tConsole.Write(mat[i, j] + \" \");\n\t\t\tConsole.Write(\"\\n\");\n\t\t}\n\t}", "818": "public static void doublyEven(int n)\n{\n\tint[,] arr = new int[n,n];\n\tint i, j;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tarr[i, j] = (n * i) + j + 1;\n\t\t}\n\t}\n\tfor (i = 0; i < n / 4; i++)\n\t{\n\t\tfor (j = 0; j < n / 4; j++)\n\t\t{\n\t\t\tarr[i, j] = (n * n + 1) - arr[i, j];\n\t\t}\n\t}\n\tfor (i = 0; i < n / 4; i++)\n\t{\n\t\tfor (j = 3 * (n / 4); j < n; j++)\n\t\t{\n\t\t\tarr[i, j] = (n * n + 1) - arr[i, j];\n\t\t}\n\t}\n\tfor (i = 3 * n / 4; i < n; i++)\n\t{\n\t\tfor (j = 0; j < n / 4; j++)\n\t\t{\n\t\t\tarr[i, j] = (n * n + 1) - arr[i, j];\n\t\t}\n\t}\n\tfor (i = 3 * n / 4; i < n; i++)\n\t{\n\t\tfor (j = 3 * n / 4; j < n; j++)\n\t\t{\n\t\t\tarr[i, j] = (n * n + 1) - arr[i, j];\n\t\t}\n\t}\n\tfor (i = n / 4; i < 3 * n / 4; i++)\n\t{\n\t\tfor (j = n / 4; j < 3 * n / 4; j++)\n\t\t{\n\t\t\tarr[i, j] = (n * n + 1) - arr[i, j];\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tConsole.Write(arr[i, j] + \" \" + \" \");\n\t\t}\n\t\tConsole.WriteLine();\n\t}\n}", "821": "static void Kroneckerproduct(int [,]A, int [,]B)\n\t{\n\t\tint [,]C= new int[rowa * rowb, cola * colb];\n\t\tfor (int i = 0; i < rowa; i++)\n\t\t{\n\t\t\tfor (int k = 0; k < rowb; k++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < cola; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < colb; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tC[i + l + 1, j + k + 1] = A[i, j] *\n\t\t\t\t\t\t\t\t\t\t\t\tB[k, l];\n\t\t\t\t\t\tConsole.Write( C[i + l + 1, j + k + 1] + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t}", "832": "bool isLowerTriangularMatrix(int[, ] mat)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t\tif (mat[i, j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "833": "public static bool isUpperTriangularMatrix(int [,]mat)\n\t{\n\t\tfor (int i = 1; i < N ; i++)\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tif (mat[i, j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "846": "static long countSets(int [,]a)\n\t{\n\t\tlong res = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint u = 0, v = 0;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif (a[i,j] == 1)\n\t\t\t\t\tu++;\n\t\t\t\telse\n\t\t\t\t\tv++;\n\t\t\t}\n\t\t\tres += (long)(Math.Pow(2, u) - 1\n\t\t\t\t\t+ Math.Pow(2, v)) - 1;\n\t\t}\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint u = 0, v = 0;\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (a[j,i] == 1)\n\t\t\t\t\tu++;\n\t\t\t\telse\n\t\t\t\t\tv++;\n\t\t\t}\n\t\t\tres += (long)(Math.Pow(2, u) - 1\n\t\t\t\t\t+ Math.Pow(2, v)) - 1;\n\t\t}\n\t\treturn res - (n * m);\n\t}", "861": "static void transpose(int [,]mat, int [,]tr, int N)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\ttr[i,j] = mat[j,i];\n\t}\nstatic bool isSymmetric(int [,]mat, int N)\n\t{\n\t\tint [,]tr = new int[N,MAX];\n\t\ttranspose(mat, tr, N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\tif (mat[i,j] != tr[i,j])\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "862": "static bool isSymmetric(int [,]mat, int N)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\tif (mat[i, j] != mat[j, i])\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "883": "static int findNormal(int [,]mat, int n)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tsum += mat[i,j] * mat[i,j];\n\t\treturn (int)Math.Sqrt(sum);\n\t}\nstatic int findTrace(int [,]mat, int n)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += mat[i,i];\n\t\treturn sum;\n\t}", "895": "static int maxDet(int n)\n{\n\treturn (2 * n * n * n);\n}\nvoid resMatrix(int n)\n{\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tfor (int j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (i == 0 && j == 2)\n\t\t\t\tConsole.Write(\"0 \");\n\t\t\telse if (i == 1 && j == 0)\n\t\t\t\tConsole.Write(\"0 \");\n\t\t\telse if (i == 2 && j == 1)\n\t\t\t\tConsole.Write(\"0 \");\n\t\t\telse\n\t\t\t\tConsole.Write(n +\" \");\n\t\t}\n\t\tConsole.WriteLine(\"\");\n\t}\n}", "918": "static int countNegative(int[, ] M, int n, int m)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (M[i, j] < 0)\n\t\t\t\t\tcount += 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "919": "static int countNegative(int[, ] M, int n, int m)\n\t{\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = m - 1;\n\t\twhile (j >= 0 && i < n) {\n\t\t\tif (M[i, j] < 0) {\n\t\t\t\tcount += j + 1;\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tj -= 1;\n\t\t}\n\t\treturn count;\n\t}", "920": "static int getLastNegativeIndex(int []array, int start, int end)\n\t{\n\t\tif (start == end)\n\t\t{\n\t\t\treturn start;\n\t\t}\n\t\tint mid = start + (end - start) / 2;\n\t\tif (array[mid] < 0)\n\t\t{\n\t\t\tif (mid + 1 < array.GetLength(0) && array[mid + 1] >= 0)\n\t\t\t{\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\treturn getLastNegativeIndex(array, mid + 1, end);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn getLastNegativeIndex(array, start, mid - 1);\n\t\t}\n\t}\nstatic int countNegative(int [,]M, int n, int m)\n\t{\n\t\tint count = 0;\n\t\tint nextEnd = m - 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (M[i, 0] >= 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextEnd = getLastNegativeIndex(GetRow(M, i), 0, nextEnd);\n\t\t\tcount += nextEnd + 1;\n\t\t}\n\t\treturn count;\n\t}\npublic static int[] GetRow(int[,] matrix, int row)\n\t{\n\t\tvar rowLength = matrix.GetLength(1);\n\t\tvar rowVector = new int[rowLength];\n\t\tfor (var i = 0; i < rowLength; i++)\n\t\t\trowVector[i] = matrix[row, i];\n\t\treturn rowVector;\n\t}", "926": "static int findMaxValue(int N, int [,]mat)\n\t{\n\t\tint maxValue = int.MinValue;\n\t\tfor (int a = 0; a< N - 1; a++)\n\t\tfor (int b = 0; b < N - 1; b++)\n\t\t\tfor (int d = a + 1; d < N; d++)\n\t\t\tfor (int e = b + 1; e < N; e++)\n\t\t\t\tif (maxValue < (mat[d, e] - mat[a, b]))\n\t\t\t\t\tmaxValue = mat[d, e] -\n\t\t\t\t\t\t\tmat[a, b];\n\t\treturn maxValue;\n\t}", "927": "static int findMaxValue(int N, int [,]mat)\n\t{\n\t\tint maxValue = int.MinValue;\n\t\tint [,]maxArr = new int[N, N];\n\t\tmaxArr[N - 1, N - 1] = mat[N - 1,N - 1];\n\t\tint maxv = mat[N - 1, N - 1];\n\t\tfor (int j = N - 2; j >= 0; j--)\n\t\t{\n\t\t\tif (mat[N - 1, j] > maxv)\n\t\t\t\tmaxv = mat[N - 1, j];\n\t\t\tmaxArr[N - 1, j] = maxv;\n\t\t}\n\t\tmaxv = mat[N - 1,N - 1];\n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t{\n\t\t\tif (mat[i, N - 1] > maxv)\n\t\t\t\tmaxv = mat[i,N - 1];\n\t\t\tmaxArr[i,N - 1] = maxv;\n\t\t}\n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = N - 2; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (maxArr[i + 1,j + 1] - mat[i, j] > maxValue)\n\t\t\t\t\tmaxValue = maxArr[i + 1,j + 1] -\n\t\t\t\t\t\t\t\t\t\tmat[i, j];\n\t\t\t\tmaxArr[i,j] = Math.Max(mat[i, j],\n\t\t\t\t\t\t\tMath.Max(maxArr[i, j + 1], maxArr[i + 1, j]) );\n\t\t\t}\n\t\t}\n\t\treturn maxValue;\n\t}", "953": "static void youngify(int [,]mat, int i, int j)\n\t{\n\t\tint downVal = (i + 1 < N) ?\n\t\t\t\t\tmat[i + 1,j] : INF;\n\t\tint rightVal = (j + 1 < N) ?\n\t\t\t\t\tmat[i,j + 1] : INF;\n\t\tif (downVal == INF && rightVal == INF)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (downVal < rightVal)\n\t\t{\n\t\t\tmat[i,j] = downVal;\n\t\t\tmat[i + 1,j] = INF;\n\t\t\tyoungify(mat, i + 1, j);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmat[i, j] = rightVal;\n\t\t\tmat[i, j + 1] = INF;\n\t\t\tyoungify(mat, i, j + 1);\n\t\t}\n\t}\nstatic int extractMin(int [,]mat)\n\t{\n\t\tint ret = mat[0,0];\n\t\tmat[0, 0] = INF;\n\t\tyoungify(mat, 0, 0);\n\t\treturn ret;\n\t}\nstatic void printSorted(int [,]mat)\n\t{\n\t\t\tConsole.WriteLine(\"Elements of matrix in sorted order n\");\n\t\tfor (int i = 0; i < N * N; i++)\n\t\t{\n\t\t\tConsole.Write(extractMin(mat) + \" \");\n\t\t}\n\t}", "955": "static void printSumSimple(int [,]mat, int k)\n\t{\n\t\tif (k > n) return;\n\t\tfor (int i = 0; i < n-k+1; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n-k+1; j++)\n\t\t\t{\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int p = i; p < k+i; p++)\n\t\t\t\t\tfor (int q = j; q < k+j; q++)\n\t\t\t\t\t\tsum += mat[p,q];\n\t\t\t\tConsole.Write(sum+ \" \");\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t}\n\t}", "956": "static void printSumTricky(int [,]mat, int k)\n\t{\n\t\tif (k > n)\n\t\treturn;\n\t\tint [,]stripSum = new int[n,n];\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tsum += mat[i,j];\n\t\t\tstripSum[0,j] = sum;\n\t\t\tfor (int i = 1; i < n - k + 1; i++)\n\t\t\t{\n\t\t\t\tsum += (mat[i + k - 1,j] - mat[i - 1,j]);\n\t\t\t\tstripSum[i,j] = sum;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n - k + 1; i++)\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < k; j++)\n\t\t\t\tsum += stripSum[i,j];\n\t\t\tConsole.Write(sum + \" \");\n\t\t\tfor (int j = 1; j < n - k + 1; j++)\n\t\t\t{\n\t\t\t\tsum += (stripSum[i,j + k - 1] - stripSum[i,j - 1]);\n\t\t\t\tConsole.Write(sum + \" \");\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t}\n\t}", "958": "static void transpose(int [,]A, int [,]B)\n\t{\n\t\tint i, j;\n\t\tfor (i = 0; i < N; i++)\n\t\t\tfor (j = 0; j < M; j++)\n\t\t\t\tB[i,j] = A[j,i];\n\t}", "959": "static void transpose(int [,]A)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tfor (int j = i+1; j < N; j++)\n\t\t\t{\n\t\t\t\tint temp = A[i,j];\n\t\t\t\tA[i,j] = A[j,i];\n\t\t\t\tA[j,i] = temp;\n\t\t\t}\n\t}", "965": "public static int pathCountRec(int[][] mat, int m, int n, int k)\n\t{\n\t\tif (m < 0 n < 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (m == 0 && n == 0 && (k == mat[m][n]))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\treturn pathCountRec(mat, m - 1, n, k - mat[m][n])\n\t\t\t\t+ pathCountRec(mat, m, n - 1, k - mat[m][n]);\n\t}\npublic static int pathCount(int[][] mat, int k)\n\t{\n\t\treturn pathCountRec(mat, R - 1, C - 1, k);\n\t}", "966": "static int pathCountDPRecDP(int [,]mat, int m, int n, int k)\n\t{\n\t\tif (m < 0 n < 0) return 0;\n\t\tif (m == 0 && n == 0)\n\t\t\treturn (k == mat[m, n] ? 1 : 0);\n\t\tif (dp[m, n, k] != -1) return dp[m, n, k];\n\t\tdp[m, n, k] = pathCountDPRecDP(mat, m - 1, n, k - mat[m, n]) +\n\t\t\t\t\tpathCountDPRecDP(mat, m, n - 1, k - mat[m, n]);\n\t\treturn dp[m, n, k];\n\t}\nstatic int pathCountDP(int [,]mat, int k)\n\t{\n\t\tfor(int i = 0; i < R; i++)\n\t\t\tfor(int j = 0; j < C; j++)\n\t\t\t\tfor(int l = 0; l < MAX_K; l++)\n\t\t\t\tdp[i, j, l] = -1;\n\t\treturn pathCountDPRecDP(mat, R - 1, C - 1, k);\n\t}", "1064": "public static int countMinReversals(string expr)\n{\n\tint len = expr.Length;\n\tif (len % 2 != 0)\n\t{\n\t\treturn -1;\n\t}\n\tStack<char> s = new Stack<char>();\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tchar c = expr[i];\n\t\tif (c == '}' && s.Count > 0)\n\t\t{\n\t\t\tif (s.Peek() == '{')\n\t\t\t{\n\t\t\t\ts.Pop();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts.Push(c);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts.Push(c);\n\t\t}\n\t}\n\tint red_len = s.Count;\n\tint n = 0;\n\twhile (s.Count > 0 && s.Peek() == '{')\n\t{\n\t\ts.Pop();\n\t\tn++;\n\t}\n\treturn (red_len / 2 + n % 2);\n}", "1065": "static int countMinReversals(String expr)\n\t{\n\t\tint len = expr.Length;\n\t\tint ans;\n\t\tif (len % 2 != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tint left_brace = 0, right_brace = 0;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tchar ch = expr[i];\n\t\t\tif (ch == '{') {\n\t\t\t\tleft_brace++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (left_brace == 0) {\n\t\t\t\t\tright_brace++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tleft_brace--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (int)(Math.Ceiling((0.0 + left_brace) / 2)\n\t\t\t\t\t+ Math.Ceiling((0.0 + right_brace) / 2));\n\t\treturn ans;\n\t}", "1072": "static void PrintMinNumberForPattern(String arr)\n\t{\n\t\tint curr_max = 0;\n\t\tint last_entry = 0;\n\t\tint j;\n\t\tfor (int i = 0; i < arr.Length; i++)\n\t\t{\n\t\t\tint noOfNextD = 0;\n\t\t\tswitch (arr[i])\n\t\t\t{\n\t\t\t\tcase 'I':\n\t\t\t\t\tj = i + 1;\n\t\t\t\t\twhile (j < arr.Length && arr[j] == 'D')\n\t\t\t\t\t{\n\t\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\t\tConsole.Write(\" \" + ++last_entry);\n\t\t\t\t\t\tConsole.Write(\" \" + curr_max);\n\t\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurr_max = curr_max + noOfNextD + 1;\n\t\t\t\t\t\tlast_entry = curr_max;\n\t\t\t\t\t\tConsole.Write(\" \" + last_entry);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < noOfNextD; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tConsole.Write(\" \" + --last_entry);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = i + 1;\n\t\t\t\t\t\twhile (j < arr.Length&&arr[j] == 'D')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnoOfNextD++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurr_max = noOfNextD + 2;\n\t\t\t\t\t\tConsole.Write(\" \" + curr_max + \" \" + (curr_max - 1));\n\t\t\t\t\t\tlast_entry = curr_max - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tConsole.Write(\" \" + (last_entry - 1));\n\t\t\t\t\t\tlast_entry--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine();\n\t}", "1073": "static void printLeast(String arr)\n{\n\tint min_avail = 1, pos_of_I = 0;\n\tList<int> al = new List<int>();\n\tif (arr[0] == 'I')\n\t{\n\t\tal.Add(1);\n\t\tal.Add(2);\n\t\tmin_avail = 3;\n\t\tpos_of_I = 1;\n\t}\n\telse\n\t{\n\t\tal.Add(2);\n\t\tal.Add(1);\n\t\tmin_avail = 3;\n\t\tpos_of_I = 0;\n\t}\n\tfor (int i = 1; i < arr.Length; i++)\n\t{\n\t\tif (arr[i] == 'I')\n\t\t{\n\t\t\tal.Add(min_avail);\n\t\t\tmin_avail++;\n\t\t\tpos_of_I = i + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tal.Add(al[i]);\n\t\t\tfor (int j = pos_of_I; j <= i; j++)\n\t\t\t\tal[j] = al[j] + 1;\n\t\t\tmin_avail++;\n\t\t}\n\t}\n\tfor (int i = 0; i < al.Count; i++)\n\t\tConsole.Write(al[i] + \" \");\n\tConsole.WriteLine();\n}", "1074": "static void PrintMinNumberForPattern(String seq) {\n\t\tString result = \"\";\n\t\tStack stk = new Stack();\n\t\tfor (int i = 0; i <= seq.Length; i++) {\n\t\t\tstk.Push(i + 1);\n\t\t\tif (i == seq.Length seq[i] == 'I') {\n\t\t\t\twhile (stk.Count!=0) {\n\t\t\t\t\tresult += String.Join(\"\",stk.Peek());\n\t\t\t\t\tresult += \" \";\n\t\t\t\t\tstk.Pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(result);\n\t}", "1075": "static String getMinNumberForPattern(String seq)\n{\n\tint n = seq.Length;\n\tif (n >= 9)\n\t\treturn \"-1\";\n\tchar []result = new char[n + 1];\n\tint count = 1;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tif (i == n seq[i] == 'I')\n\t\t{\n\t\t\tfor (int j = i - 1; j >= -1; j--)\n\t\t\t{\n\t\t\t\tresult[j + 1] = (char) ((int) '0' + count++);\n\t\t\t\tif (j >= 0 && seq[j] == 'I')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn new String(result);\n}", "1252": "public static int subset(int []ar, int n)\n\t{\n\t\tint res = 0;\n\t\tArray.Sort(ar);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint count = 1;\n\t\t\tfor ( ; i < n - 1; i++) {\n\t\t\t\tif (ar[i] == ar[i + 1])\n\t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = Math.Max(res, count);\n\t\t}\n\t\treturn res;\n\t}", "1253": "static int subset(int []arr, int n)\n{\n\tDictionary<int,\n\t\t\tint> mp = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tfor (int i = 0 ; i < n; i++)\n\t{\n\t\tif(mp.ContainsKey(arr[i]))\n\t\t{\n\t\t\tvar val = mp[arr[i]];\n\t\t\tmp.Remove(arr[i]);\n\t\t\tmp.Add(arr[i], val + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.Add(arr[i], 1);\n\t\t}\n\t}\n\tint res = 0;\n\tforeach(KeyValuePair<int, int> entry in mp)\n\t\tres = Math.Max(res, entry.Value);\n\treturn res;\n}", "1344": "static bool areElementsContiguous(int []arr, int n)\n\t{\n\tArray.Sort(arr);\n\tfor (int i = 1; i < n; i++)\n\t\tif (arr[i] - arr[i - 1] > 1)\n\t\t\treturn false;\n\treturn true;\n\t}", "1345": "static bool areElementsContiguous( int []arr, int n)\n\t{\n\t\tint max = int.MinValue;\n\t\tint min = int.MaxValue;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tmax = Math.Max(max, arr[i]);\n\t\t\tmin = Math.Min(min, arr[i]);\n\t\t}\n\t\tint m = max - min + 1;\n\t\tif (m > n)\n\t\t\treturn false;\n\t\tbool []visited = new bool[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tvisited[arr[i] - min] = true;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif (visited[i] == false)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "1346": "public static bool? areElementsContiguous(int[] arr, int n)\n\t{\n\t\tHashSet<int> us = new HashSet<int>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tus.Add(arr[i]);\n\t\t}\n\t\tint count = 1;\n\t\tint curr_ele = arr[0] - 1;\n\t\twhile (us.Contains(curr_ele) == true)\n\t\t{\n\t\t\tcount++;\n\t\t\tcurr_ele--;\n\t\t}\n\t\tcurr_ele = arr[0] + 1;\n\t\twhile (us.Contains(curr_ele) == true)\n\t\t{\n\t\t\tcount++;\n\t\t\tcurr_ele++;\n\t\t}\n\t\treturn (count == (us.Count));\n\t}", "1366": "static void longest(int []a, int n, int k)\n{\n\tint[] freq = new int[7];\n\tint start = 0, end = 0, now = 0, l = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfreq[a[i]]++;\n\t\tif (freq[a[i]] == 1)\n\t\t\tnow++;\n\t\twhile (now > k)\n\t\t{\n\t\t\tfreq[a[l]]--;\n\t\t\tif (freq[a[l]] == 0)\n\t\t\t\tnow--;\n\t\t\tl++;\n\t\t}\n\t\tif (i - l + 1 >= end - start + 1)\n\t\t{\n\t\t\tend = i;\n\t\t\tstart = l;\n\t\t}\n\t}\n\tfor (int i = start; i <= end; i++)\n\t\tConsole.Write(a[i]+\" \");\n}", "1390": "static void findSmallestRange(int[, ] arr, int n, int k)\n\t{\n\t\tint i, minval, maxval, minrange,\n\t\t\tminel = 0, maxel = 0, flag, minind;\n\t\tfor (i = 0; i <= k; i++) {\n\t\t\tptr[i] = 0;\n\t\t}\n\t\tminrange = int.MaxValue;\n\t\twhile (true) {\n\t\t\tminind = -1;\n\t\t\tminval = int.MaxValue;\n\t\t\tmaxval = int.MinValue;\n\t\t\tflag = 0;\n\t\t\tfor (i = 0; i < k; i++) {\n\t\t\t\tif (ptr[i] == n) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i, ptr[i]] < minval) {\nminind = i; \n\t\t\t\t\tminval = arr[i, ptr[i]];\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i, ptr[i]] > maxval) {\n\t\t\t\t\tmaxval = arr[i, ptr[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr[minind]++;\n\t\t\tif ((maxval - minval) < minrange) {\n\t\t\t\tminel = minval;\n\t\t\t\tmaxel = maxval;\n\t\t\t\tminrange = maxel - minel;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"The smallest range is\" + \"[{0}, {1}]\\n\", minel, maxel);\n\t}", "1405": "static int findLargestd(int []S, int n)\n{\n\tbool found = false;\n\tArray.Sort(S);\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tfor (int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tif (i == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int l = k + 1; l < n; l++)\n\t\t\t\t{\n\t\t\t\t\tif (i == l)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l])\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\treturn S[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (found == false)\n\t\treturn int.MaxValue;\n\treturn -1;\n}", "1406": "public int getI()\n\t{\n\t\treturn i;\n\t}\npublic int getJ()\n\t{\n\t\treturn j;\n\t}\nstatic int findFourElements(int[] arr, int n)\n\t{\n\t\tDictionary<int, Indexes> map =\n\t\t\t\t\tnew Dictionary<int, Indexes>();\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tmap.Add(arr[i] + arr[j],\n\t\t\t\t\t\tnew Indexes(i, j));\n\t\t\t}\n\t\t}\n\t\tint d = int.MinValue;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tint abs_diff = Math.Abs(arr[i] - arr[j]);\n\t\t\t\tif (map.ContainsKey(abs_diff))\n\t\t\t\t{\n\t\t\t\t\tIndexes indexes = map[abs_diff];\n\t\t\t\t\tif (indexes.getI() != i &&\n\t\t\t\t\t\tindexes.getI() != j &&\n\t\t\t\t\t\tindexes.getJ() != i &&\n\t\t\t\t\t\tindexes.getJ() != j)\n\t\t\t\t\t{\n\t\t\t\t\t\td = Math.Max(d, Math.Max(arr[i], arr[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}", "1428": "static void leftRotatebyOne(int[] arr, int n)\n\t{\n\t\tint i, temp = arr[0];\n\t\tfor (i = 0; i < n - 1; i++)\n\t\t\tarr[i] = arr[i + 1];\n\t\tarr[n-1] = temp;\n\t}\nstatic void leftRotate(int[] arr, int d, int n)\n\t{\n\t\tfor (int i = 0; i < d; i++)\n\t\t\tleftRotatebyOne(arr, n);\n\t}\nstatic void printArray(int[] arr, int size)\n\t{\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tConsole.Write(arr[i] + \" \");\n\t}", "1468": "static void pushZerosToEnd(int []arr, int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\tif (arr[i] != 0)\n\t\tarr[count++] = arr[i];\n\t\twhile (count < n)\n\t\tarr[count++] = 0;\n\t}", "1469": "static void moveZerosToEnd(int[] arr, int n)\n\t{\n\t\tint count = 0;\n\t\tint temp;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif ((arr[i] != 0))\n\t\t\t{\n\t\t\t\ttemp = arr[count];\n\t\t\t\tarr[count] = arr[i];\n\t\t\t\tarr[i] = temp;\n\t\t\t\tcount = count + 1;\n\t\t\t}\n\t\t}\n\t}\nstatic void printArray(int[] arr, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tConsole.Write(arr[i] + \" \");\n\t}", "1473": "static void pushZerosToEnd(int[] arr, int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[count++] = arr[i];\n\t\twhile (count < n)\n\t\t\tarr[count++] = 0;\n\t}\nstatic void modifyAndRearrangeArr(int[] arr, int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif ((arr[i] != 0) && (arr[i] == arr[i + 1])) {\n\t\t\t\tarr[i] = 2 * arr[i];\n\t\t\t\tarr[i + 1] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpushZerosToEnd(arr, n);\n\t}\nstatic void printArray(int[] arr, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\tConsole.WriteLine();\n\t}", "1478": "static void printArray(int[] arr, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\tConsole.WriteLine();\n\t}\nstatic void RearrangePosNeg(int[] arr, int n)\n\t{\n\t\tint key, j;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tkey = arr[i];\n\t\t\tif (key > 0)\n\t\t\t\tcontinue;\n\t\t\tj = i - 1;\n\t\t\twhile (j >= 0 && arr[j] > 0) {\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tj = j - 1;\n\t\t\t}\n\t\t\tarr[j + 1] = key;\n\t\t}\n\t}", "1480": "static void printArray(int[] A, int size)\n\t{\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tConsole.Write(A[i] + \" \");\n\t\tConsole.WriteLine(\"\");\n\t\t;\n\t}\nstatic void reverse(int[] arr, int l, int r)\n\t{\n\t\tif (l < r) {\n\t\t\tarr = swap(arr, l, r);\n\t\t\treverse(arr, ++l, --r);\n\t\t}\n\t}\nstatic void merge(int[] arr, int l, int m, int r)\n\t{\nint i = l; \nint j = m + 1; \n\t\twhile (i <= m && arr[i] < 0)\n\t\t\ti++;\n\t\twhile (j <= r && arr[j] < 0)\n\t\t\tj++;\n\t\treverse(arr, i, m);\n\t\treverse(arr, m + 1, j - 1);\n\t\treverse(arr, i, j - 1);\n\t}\nstatic void RearrangePosNeg(int[] arr, int l, int r)\n\t{\n\t\tif (l < r) {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\tRearrangePosNeg(arr, l, m);\n\t\t\tRearrangePosNeg(arr, m + 1, r);\n\t\t\tmerge(arr, l, m, r);\n\t\t}\n\t}\nstatic int[] swap(int[] arr, int i, int j)\n\t{\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t\treturn arr;\n\t}", "1481": "public static void RearrangePosNeg(int[] arr)\n {\n\tint i = 0;\n\tint j = arr.Length - 1;\n\twhile(true)\n\t{\n\twhile(arr[i]<0 && i<arr.Length)\n\t\ti++;\n\twhile(arr[j]>0 && j>=0)\n\t\tj--;\n\tif(i<j)\n\t{\n\t\tint temp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t}\n\telse\n\t\tbreak;\n\t}\n }", "1515": "static void findElements(int []arr, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint count = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (arr[j] > arr[i])\n\t\t\t\tcount++;\n\t\tif (count >= 2)\n\tConsole.Write(arr[i] + \" \");\n\t}\n}", "1516": "static void findElements(int []arr, int n)\n{\n\tArray.Sort(arr);\n\tfor (int i = 0; i < n-2; i++)\n\t\tConsole.Write(arr[i] + \" \");\n}", "1517": "static void findElements(int []arr, int n)\n\t{\n\tint first = int.MinValue;\n\tint second = int.MaxValue;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > first)\n\t\t{\n\t\t\tsecond = first;\n\t\t\tfirst = arr[i];\n\t\t}\n\t\telse if (arr[i] > second)\n\t\t\tsecond = arr[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (arr[i] < second)\n\t\t\tConsole.Write(arr[i] + \" \") ;\n}", "1535": "static int findFirstMissing(int []array, int start, int end)\n\t{\n\t\tif (start > end)\n\t\t\treturn end + 1;\n\t\tif (start != array[start])\n\t\t\treturn start;\n\t\tint mid = (start + end) / 2;\n\t\tif (array[mid] == mid)\n\t\t\treturn findFirstMissing(array, mid+1, end);\n\t\treturn findFirstMissing(array, start, mid);\n\t}", "1536": "int findFirstMissing(int[] arr , int start , int end, int first) \n{\n\tif (start < end) \n\t{\n\t\tint mid = (start + end) / 2;\n\t\tif (arr[mid] != mid+first)\n\t\t\treturn findFirstMissing(arr, start, mid, first);\n\t\telse\n\t\t\treturn findFirstMissing(arr, mid + 1, end, first);\n\t}\n\treturn start + first;\n}\nint findSmallestMissinginSortedArray(int[] arr) \n{ \n\tif (arr[0] != 0)\n\t\treturn 0;\n\tif (arr[arr.Length - 1] == arr.Length - 1)\n\t\treturn arr.Length;\n\tint first = arr[0];\n\treturn findFirstMissing(arr, 0, arr.Length - 1,first);\n}", "1537": "static int FindMaxSum(int []arr, int n)\n\t{\n\t\tint incl = arr[0];\n\t\tint excl = 0;\n\t\tint excl_new;\n\t\tint i;\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\texcl_new = (incl > excl) ?\n\t\t\t\t\t\t\tincl : excl;\n\t\t\tincl = excl + arr[i];\n\t\t\texcl = excl_new;\n\t\t}\n\t\treturn ((incl > excl) ? incl : excl);\n\t}", "1545": "static void buildSparseTable(int []arr, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlookup[i, 0] = arr[i];\n\t\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\t\tfor (int i = 0; (i + (1 << j) - 1) < n; i++) {\n\t\t\t\tif (lookup[i, j - 1] <\n\t\t\t\t\t\t\tlookup[i + (1 << (j - 1)), j - 1])\n\t\t\t\t\tlookup[i, j] = lookup[i, j - 1];\n\t\t\t\telse\n\t\t\t\t\tlookup[i, j] =\n\t\t\t\t\t\t\tlookup[i + (1 << (j - 1)), j - 1];\n\t\t\t}\n\t\t}\n\t}\nstatic int query(int L, int R)\n\t{\n\t\tint j = (int)Math.Log(R - L + 1);\n\t\tif (lookup[L, j] <= lookup[R - (1 << j) + 1, j])\n\t\t\treturn lookup[L, j];\n\t\telse\n\t\t\treturn lookup[R - (1 << j) + 1, j];\n\t}", "1546": "static void buildSparseTable(int []arr, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\ttable[i, 0] = arr[i];\n\tfor (int j = 1; j <= n; j++)\n\t\tfor (int i = 0; i <= n - (1 << j); i++)\n\t\t\ttable[i, j] = __gcd(table[i, j - 1],\n\t\t\t\t\t\t\t\ttable[i + (1 << (j - 1)), j - 1]);\n}\nstatic int query(int L, int R)\n{\n\tint j = (int)Math.Log(R - L + 1);\n\treturn __gcd(table[L, j],\n\t\t\t\ttable[R - (1 << j) + 1, j]);\n}\nstatic int __gcd(int a, int b)\n{\n\treturn b == 0 ? a : __gcd(b, a % b);\t\n}", "1590": "static int findMaxAverage(int []arr, int n, int k)\n{\n\tif (k > n)\n\t\treturn -1;\n\tint []csum = new int[n];\n\tcsum[0] = arr[0];\n\tfor (int i = 1; i < n; i++)\n\tcsum[i] = csum[i - 1] + arr[i];\n\tint max_sum = csum[k - 1],\n\t\t\tmax_end = k - 1;\n\tfor (int i = k; i < n; i++)\n\t{\n\t\tint curr_sum = csum[i] -\n\t\t\t\tcsum[i - k];\n\t\tif (curr_sum > max_sum)\n\t\t{\n\t\t\tmax_sum = curr_sum;\n\t\t\tmax_end = i;\n\t\t}\n\t}\n\treturn max_end - k + 1;\n}", "1591": "static int findMaxAverage(int []arr, int n, int k)\n\t{\n\t\tif (k > n)\n\t\t\treturn -1;\n\t\tint sum = arr[0];\n\t\tfor (int i = 1; i < k; i++)\n\t\t\tsum += arr[i];\n\t\tint max_sum = sum;\n\t\tint max_end = k-1;\n\t\tfor (int i = k; i < n; i++)\n\t\t{\n\t\t\tsum = sum + arr[i] - arr[i-k];\n\t\t\tif (sum > max_sum)\n\t\t\t{\n\t\t\t\tmax_sum = sum;\n\t\t\t\tmax_end = i;\n\t\t\t}\n\t\t}\n\t\treturn max_end - k + 1;\n\t}", "1694": "static bool isMajority(int[] arr, int n, int x)\n\t{\n\t\tint i, last_index = 0;\n\t\tlast_index = (n % 2 == 0) ? n / 2 :\n\t\t\t\t\t\t\t\t\tn / 2 + 1;\n\t\tfor (i = 0; i < last_index; i++) {\n\t\t\tif (arr[i] == x && arr[i + n / 2] == x)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "1695": "static int _binarySearch(int[] arr, int low, int high, int x)\n\t{\n\t\tif (high >= low) {\n\t\t\tint mid = (low + high) / 2;\n\t\t\tif ((mid == 0 x > arr[mid - 1]) &&\n\t\t\t\t\t\t\t\t(arr[mid] == x))\n\t\t\t\treturn mid;\n\t\t\telse if (x > arr[mid])\n\t\t\t\treturn _binarySearch(arr, (mid + 1), high, x);\n\t\t\telse\n\t\t\t\treturn _binarySearch(arr, low,\n\t\t\t\t\t\t\t\t\t(mid - 1), x);\n\t\t}\n\t\treturn -1;\n\t}\nstatic bool isMajority(int[] arr, int n, int x)\n\t{\n\t\tint i = _binarySearch(arr, 0, n - 1, x);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\tif (((i + n / 2) <= (n - 1)) && arr[i + n / 2] == x)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "1696": "static bool isMajorityElement(int []arr, int n, int key)\n{\n\tif (arr[n / 2] == key)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "1730": "static void sortMat(int[, ] mat, int n)\n\t{\n\t\tint[] temp = new int[n * n];\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\ttemp[k++] = mat[i, j];\n\t\tArray.Sort(temp);\n\t\tk = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\tmat[i, j] = temp[k++];\n\t}\nstatic void printMat(int[, ] mat, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\tConsole.Write(mat[i, j] + \" \");\n\t\t\tConsole.WriteLine();\n\t\t}\n\t}", "1795": "static void sort(int []arr)\n\t{\n\t\tint n = arr.Length;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tint min_idx = i;\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\tif (arr[j] < arr[min_idx])\n\t\t\t\t\tmin_idx = j;\n\t\t\tint temp = arr[min_idx];\n\t\t\tarr[min_idx] = arr[i];\n\t\t\tarr[i] = temp;\n\t\t}\n\t}\nstatic void printArray(int []arr)\n\t{\n\t\tint n = arr.Length;\n\t\tfor (int i=0; i<n; ++i)\n\t\t\tConsole.Write(arr[i]+\" \");\n\t\tConsole.WriteLine();\n\t}", "1797": "static void bubbleSort(int []arr, int n)\n\t{\n\t\tint i, j, temp;\n\t\tbool swapped;\n\t\tfor (i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tswapped = false;\n\t\t\tfor (j = 0; j < n - i - 1; j++)\n\t\t\t{\n\t\t\t\tif (arr[j] > arr[j + 1])\n\t\t\t\t{\n\t\t\t\t\ttemp = arr[j];\n\t\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\t\tarr[j + 1] = temp;\n\t\t\t\t\tswapped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (swapped == false)\n\t\t\t\tbreak;\n\t\t}\n\t}\nstatic void printArray(int []arr, int size)\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < size; i++)\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\tConsole.WriteLine();\n\t}", "1813": "static int findCrossOver(int []arr, int low, int high, int x)\n\t{\n\t\tif (arr[high] <= x)\n\t\t\treturn high;\n\t\tif (arr[low] > x)\n\t\t\treturn low;\n\t\t\tint mid = (low + high)/2; \n\t\tif (arr[mid] <= x && arr[mid+1] > x)\n\t\t\treturn mid;\n\t\tif(arr[mid] < x)\n\t\t\treturn findCrossOver(arr, mid+1, high, x);\n\t\treturn findCrossOver(arr, low, mid - 1, x);\n\t}\nstatic void printKclosest(int []arr, int x, int k, int n)\n\t{\n\t\tint l = findCrossOver(arr, 0, n-1, x);\n\t\tint r = l + 1;\n\t\tint count = 0;\n\t\tif (arr[l] == x) l--;\n\t\twhile (l >= 0 && r < n && count < k)\n\t\t{\n\t\t\tif (x - arr[l] < arr[r] - x)\n\t\t\t\tConsole.Write(arr[l--]+\" \");\n\t\t\telse\n\t\t\t\tConsole.Write(arr[r++]+\" \");\n\t\t\tcount++;\n\t\t}\n\t\twhile (count < k && l >= 0)\n\t\t{\n\t\t\tConsole.Write(arr[l--]+\" \");\n\t\t\tcount++;\n\t\t}\n\t\twhile (count < k && r < n)\n\t\t{\n\t\t\tConsole.Write(arr[r++] + \" \");\n\t\t\tcount++;\n\t\t}\n\t}", "1822": "void push(int val)\n\t{\n\t\tnode newnode = new node(val);\n\t\tnewnode.next = head;\n\t\thead = newnode;\n\t}\nvoid insertionSort(node headref)\n\t{\n\t\tsorted = null;\n\t\tnode current = headref;\n\t\twhile (current != null)\n\t\t{\n\t\t\tnode next = current.next;\n\t\t\tsortedInsert(current);\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = sorted;\n\t}\nvoid sortedInsert(node newnode)\n\t{\n\t\tif (sorted == null sorted.val >= newnode.val)\n\t\t{\n\t\t\tnewnode.next = sorted;\n\t\t\tsorted = newnode;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode current = sorted;\n\t\t\twhile (current.next != null && current.next.val < newnode.val)\n\t\t\t{\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\tnewnode.next = current.next;\n\t\t\tcurrent.next = newnode;\n\t\t}\n\t}\nvoid printlist(node head)\n\t{\n\t\twhile (head != null)\n\t\t{\n\t\t\tConsole.Write(head.val + \" \");\n\t\t\thead = head.next;\n\t\t}\n\t}", "1847": "static int count( int []S, int m, int n )\n\t{\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\tif (n < 0)\n\t\t\treturn 0;\n\t\tif (m <=0 && n >= 1)\n\t\t\treturn 0;\n\t\treturn count( S, m - 1, n ) +\n\t\t\tcount( S, m, n - S[m - 1] );\n\t}", "1849": "static int count(int []S, int m, int n)\n{\n\tint [] table = new int[n + 1];\n\ttable[0] = 1;\n\tfor(int i = 0; i < m; i++)\n\t\tfor(int j = S[i]; j <= n; j++)\n\t\t\ttable[j] += table[j - S[i]];\n\treturn table[n];\n}", "1852": "static int matrixChainMemoised(int[] p, int i, int j)\n {\n\tif (i == j) \n\t{\n\treturn 0;\n\t}\n\tif (dp[i, j] != -1) \n\t{\n\treturn dp[i, j];\n\t}\n\tdp[i, j] = Int32.MaxValue;\n\tfor (int k = i; k < j; k++) \n\t{\n\tdp[i, j] = Math.Min(\n\t\tdp[i, j], matrixChainMemoised(p, i, k)\n\t\t+ matrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n\t}\n\treturn dp[i,j];\n }\nstatic int MatrixChainOrder(int[] p, int n)\n {\n\tint i = 1, j = n - 1;\n\treturn matrixChainMemoised(p, i, j);\n }", "1853": "static int MatrixChainOrder(int[] p, int n)\n\t{\n\t\tint[, ] m = new int[n, n];\n\t\tint i, j, k, L, q;\n\t\tfor (i = 1; i < n; i++)\n\t\t\tm[i, i] = 0;\n\t\tfor (L = 2; L < n; L++)\n\t\t{\n\t\t\tfor (i = 1; i < n - L + 1; i++)\n\t\t\t{\n\t\t\t\tj = i + L - 1;\n\t\t\t\tif (j == n)\n\t\t\t\t\tcontinue;\n\t\t\t\tm[i, j] = int.MaxValue;\n\t\t\t\tfor (k = i; k <= j - 1; k++)\n\t\t\t\t{\n\t\t\t\t\tq = m[i, k] + m[k + 1, j]\n\t\t\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\t\t\t\tif (q < m[i, j])\n\t\t\t\t\t\tm[i, j] = q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn m[1, n - 1];\n\t}", "1869": "static int cutRod(int []price, int n)\n\t{\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tint max_val = int.MinValue;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmax_val = Math.Max(max_val, price[i] +\n\t\t\t\t\t\tcutRod(price, n - i - 1));\n\t\treturn max_val;\n\t}", "1870": "static int cutRod(int []price,int n)\n\t{\n\t\tint []val = new int[n + 1];\n\t\tval[0] = 0;\n\t\tfor (int i = 1; i<=n; i++)\n\t\t{\n\t\t\tint max_val = int.MinValue;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tmax_val = Math.Max(max_val, price[j] + val[i - j - 1]);\n\t\t\tval[i] = max_val;\n\t\t}\n\t\treturn val[n];\n\t}", "1998": "static int multiply(int x, int y) {\n\t\tif (y == 0)\n\t\t\treturn 0;\n\t\tif (y > 0)\n\t\t\treturn (x + multiply(x, y - 1));\n\t\tif (y < 0)\n\t\t\treturn -multiply(x, -y);\n\t\treturn -1;\n\t}", "2013": "public static void SieveOfEratosthenes(int n)\n\t{\n\t\tbool[] prime = new bool[n + 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprime[i] = true;\n\t\tfor (int p = 2; p * p <= n; p++)\n\t\t{\n\t\t\tif (prime[p] == true)\n\t\t\t{\n\t\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\tif (prime[i] == true)\n\t\t\t\tConsole.Write(i + \" \");\n\t\t}\n\t}", "2024": "static int binomialCoeff(int n, int k)\n\t{\n\t\tint res = 1;\n\t\tif (k > n - k)\n\t\tk = n - k;\n\t\tfor (int i = 0; i < k; ++i)\n\t\t{\n\t\t\tres *= (n - i);\n\t\t\tres /= (i + 1);\n\t\t}\n\t\treturn res;\n\t}\nstatic void printPascal(int n)\n\t{\n\tfor (int line = 0; line < n; line++)\n\t{\n\t\tfor (int i = 0; i <= line; i++)\n\t\tConsole.Write(binomialCoeff\n\t\t\t\t\t\t(line, i)+\" \");\n\t\tConsole.WriteLine();\n\t}\n\t}", "2025": "public static void printPascal(int n)\n{\nint[,] arr = new int[n, n];\nfor (int line = 0; line < n; line++)\n{\n\tfor (int i = 0; i <= line; i++)\n\t{\n\tif (line == i i == 0)\n\t\tarr[line, i] = 1;\nelse \n\t\tarr[line, i] = arr[line - 1, i - 1] +\n\t\t\t\t\tarr[line - 1, i];\n\tConsole.Write(arr[line, i]);\n\t}\nConsole.WriteLine(\"\");\n}\n}", "2026": "public static void printPascal(int n)\n{\n\tfor(int line = 1; line <= n; line++)\n\t{\nint C = 1;\n\tfor(int i = 1; i <= line; i++)\n\t{\n\t\tConsole.Write(C + \" \");\n\t\tC = C * (line - i) / i;\n\t}\n\tConsole.Write(\"\\n\") ;\n\t}\n}", "2079": "static int Add(int x, int y)\n\t{\n\t\twhile (y != 0)\n\t\t{\n\t\t\tint carry = x & y;\n\t\t\tx = x ^ y;\n\t\t\ty = carry << 1;\n\t\t}\n\t\treturn x;\n\t}", "2080": "", "2101": "static uint getModulo( uint n, uint d)\n{\nreturn ( n & (d-1) );\n}", "2114": "static int countSetBits(int n)\n\t{\n\t\tint count = 0;\n\t\twhile (n > 0) {\n\t\t\tcount += n & 1;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn count;\n\t}", "2117": "public static int countSetBits(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1 + countSetBits(n & (n - 1));\n\t}", "2118": "public static void initialize()\n\t{\n\t\tBitsSetTable256[0] = 0;\n\t\tfor (int i = 0; i < 256; i++)\n\t\t{\n\t\t\tBitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n\t\t}\n\t}\npublic static int countSetBits(int n)\n\t{\n\t\treturn (BitsSetTable256[n & 0xff]\n\t\t\t\t+ BitsSetTable256[(n >> 8) & 0xff]\n\t\t\t\t+ BitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24]);\n\t}", "2119": "", "2120": "static int countSetBitsRec(int num)\n\t{\n\t\tint nibble = 0;\n\t\tif (0 == num)\n\t\t\treturn num_to_bits[0];\n\t\tnibble = num & 0xf;\n\t\treturn num_to_bits[nibble] + countSetBitsRec(num >> 4);\n\t}", "2121": "static int countSetBits(int N)\n {\n\tint count = 0;\n\tfor (int i = 0; i < 4 * 8; i++)\n\t{\n\tif ((N & (1 << i)) != 0)\n\t\tcount++;\n\t}\n\treturn count;\n }", "2127": "static bool getParity(int n)\n\t{\n\t\tbool parity = false;\n\t\twhile(n != 0)\n\t\t{\n\t\t\tparity = !parity;\n\t\t\tn = n & (n-1);\n\t\t}\n\t\treturn parity;\n\t}", "2129": "static bool isPowerOfTwo(int n)\n{\n\tif(n==0)\n\treturn false;\n\treturn (int)(Math.Ceiling((Math.Log(n) /\n\t\t\t\t\t\t\tMath.Log(2)))) ==\n\t\t(int)(Math.Floor(((Math.Log(n) /\n\t\t\t\t\t\t\tMath.Log(2)))));\n}", "2130": "static bool isPowerOfTwo(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn false;\n\t\twhile (n != 1) {\n\t\t\tif (n % 2 != 0)\n\t\t\t\treturn false;\n\t\t\tn = n / 2;\n\t\t}\n\t\treturn true;\n\t}", "2131": "static bool powerOf2(int n)\n{\n\tif (n == 1)\n\treturn true;\n\telse if (n % 2 != 0 n == 0)\n\treturn false;\n\treturn powerOf2(n / 2);\n}", "2132": "static bool isPowerOfTwo (int x)\n\t{\n\t\treturn x != 0 && ((x & (x - 1)) == 0);\n\t}", "2210": "static int maxRepeating(int []arr, int n, int k)\n\t{\n\t\tfor (int i = 0; i< n; i++)\n\t\t\tarr[(arr[i]%k)] += k;\n\t\tint max = arr[0], result = 0;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] > max)\n\t\t\t{\n\t\t\t\tmax = arr[i];\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "2226": "static int fun(int x)\n\t{\n\t\tint y = (x / 4) * 4;\n\t\tint ans = 0;\n\t\tfor (int i = y; i <= x; i++)\n\t\t\tans ^= i;\n\t\treturn ans;\n\t}\nstatic int query(int x)\n\t{\n\t\tif (x == 0)\n\t\t\treturn 0;\n\t\tint k = (x + 1) / 2;\n\t\treturn ((x %= 2)!=0) ? 2 * fun(k) :\n\t\t\t\t((fun(k - 1) * 2) ^ (k & 1));\n\t}\nstatic void allQueries(int q, int []l, int []r)\n\t{\n\t\tfor (int i = 0; i < q; i++)\n\t\t\tConsole.WriteLine((query(r[i])\n\t\t\t\t\t\t\t^ query(l[i] - 1))) ;\n\t}", "2243": "static void prefixXOR(int []arr, int []preXOR, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\twhile (arr[i] % 2 != 1)\n\t\t\t\tarr[i] /= 2;\n\t\t\tpreXOR[i] = arr[i];\n\t\t}\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tpreXOR[i] = preXOR[i - 1] ^ preXOR[i];\n\t}\nstatic int query(int [] preXOR, int l, int r)\n\t{\n\t\tif (l == 0)\n\t\t\treturn preXOR[r];\n\t\telse\n\t\t\treturn preXOR[r] ^ preXOR[l - 1];\n\t}", "2258": "static int findMinSwaps(int []arr, int n)\n\t{\n\t\tint []noOfZeroes = new int[n];\n\t\tint i, count = 0;\n\t\tnoOfZeroes[n - 1] = 1 - arr[n - 1];\n\t\tfor (i = n - 2; i >= 0; i--)\n\t\t{\n\t\t\tnoOfZeroes[i] = noOfZeroes[i + 1];\n\t\t\tif (arr[i] == 0)\n\t\t\t\tnoOfZeroes[i]++;\n\t\t}\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] == 1)\n\t\t\t\tcount += noOfZeroes[i];\n\t\t}\n\t\treturn count;\n\t}", "2259": "static int minswaps(int[] arr, int n)\n\t{\n\t\tint count = 0;\n\t\tint num_unplaced_zeros = 0;\n\t\tfor (int index = n - 2; index >= 0; index--)\n\t\t{\n\t\t\tif (arr[index] == 0)\n\t\t\t\tnum_unplaced_zeros += 1;\n\t\t\telse\n\t\t\t\tcount += num_unplaced_zeros;\n\t\t}\n\t\treturn count;\n\t}", "2281": "static bool arraySortedOrNot(int []arr, int n)\n\t{\n\t\tif (n == 0 n == 1)\n\t\t\treturn true;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tif (arr[i - 1] > arr[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "2308": "static void printTwoOdd(int []arr, int size) {\n\tint xor2 = arr[0];\n\tint set_bit_no; \n\tint i;\n\tint n = size - 2;\n\tint x = 0, y = 0;\n\tfor(i = 1; i < size; i++)\n\t\txor2 = xor2 ^ arr[i];\n\t\tset_bit_no = xor2 & ~(xor2-1);\n\tfor(i = 0; i < size; i++)\n\t{\n\t\t\tif((arr[i] & set_bit_no)>0)\n\t\t\tx = x ^ arr[i];\n\t\t\telse\n\t\t\ty = y ^ arr[i];\n\t}\n\tConsole.WriteLine(\"The two ODD elements are \"+ x + \" & \" + y);\n\t}", "2310": "static bool findPair(int []arr, int n)\n\t{\n\t\tint size = arr.Length;\n\t\tint i = 0, j = 1;\n\t\twhile (i < size && j < size)\n\t\t{\n\t\t\tif (i != j && arr[j] - arr[i] == n)\n\t\t\t{\n\t\t\t\tConsole.Write(\"Pair Found: \"\n\t\t\t\t+ \"( \" + arr[i] + \", \" + arr[j] +\" )\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (arr[j] - arr[i] < n)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\ti++;\n\t\t}\n\t\tConsole.Write(\"No such pair\");\n\t\treturn false;\n\t}", "2360": "public static void printMax(int[] arr, int k, int n)\n{\n\tint[] brr = new int[n];\n\tfor(int i = 0; i < n; i++)\n\t\tbrr[i] = arr[i];\n\tArray.Sort(brr);\n\tArray.Reverse(brr);\n\tint[] crr = new int[k];\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tcrr[i] = brr[i];\n\t}\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tif (crr.Contains(arr[i]))\n\t\t{\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\t}\n\t}\n}", "2372": "static void printSmall(int []arr, int asize, int n)\n{\n\tint []copy_arr = new int[asize];\n\tArray.Copy(arr, copy_arr, asize);\n\tArray.Sort(copy_arr);\n\tfor (int i = 0; i < asize; ++i)\n\t{\n\t\tif (Array.BinarySearch(copy_arr, 0, n, arr[i])>-1)\n\t\t\tConsole.Write(arr[i] + \" \");\n\t}\n}", "2379": "static bool checkIsAP(int []arr, int n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn true;\n\t\tArray.Sort(arr);\n\t\tint d = arr[1] - arr[0];\n\t\tfor (int i = 2; i < n; i++)\n\t\t\tif (arr[i] - arr[i - 1] != d)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "2382": "static int countPairs(int[] a, int n)\n\t{\n\t\tint mn = int.MaxValue;\n\t\tint mx = int.MinValue;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmn = Math.Min(mn, a[i]);\n\t\t\tmx = Math.Max(mx, a[i]);\n\t\t}\n\t\tint c1 = 0;\nint c2 = 0; \n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] == mn)\n\t\t\t\tc1++;\n\t\t\tif (a[i] == mx)\n\t\t\t\tc2++;\n\t\t}\n\t\tif (mn == mx)\n\t\t\treturn n * (n - 1) / 2;\n\t\telse\n\t\t\treturn c1 * c2;\n\t}", "2437": "static Node rearrange(Node head)\n\t{\n\t\tif (head == null)\n\t\t\treturn null;\n\t\tNode prev = head, curr = head.next;\n\t\twhile (curr != null) {\n\t\t\tif (prev.data > curr.data) {\n\t\t\t\tint t = prev.data;\n\t\t\t\tprev.data = curr.data;\n\t\t\t\tcurr.data = t;\n\t\t\t}\n\t\t\tif (curr.next != null && curr.next.data > curr.data) {\n\t\t\t\tint t = curr.next.data;\n\t\t\t\tcurr.next.data = curr.data;\n\t\t\t\tcurr.data = t;\n\t\t\t}\n\t\t\tprev = curr.next;\n\t\t\tif (curr.next == null)\n\t\t\t\tbreak;\n\t\t\tcurr = curr.next.next;\n\t\t}\n\t\treturn head;\n\t}\nstatic Node push(Node head, int k)\n\t{\n\t\tNode tem = new Node();\n\t\ttem.data = k;\n\t\ttem.next = head;\n\t\thead = tem;\n\t\treturn head;\n\t}\nstatic void display(Node head)\n\t{\n\t\tNode curr = head;\n\t\twhile (curr != null) {\n\t\t\tConsole.Write(curr.data + \" \");\n\t\t\tcurr = curr.next;\n\t\t}\n\t}", "2438": "void printlist(Node head)\n{\n\twhile (head != null)\n\t{\n\t\tConsole.Write(head.data + \" \");\n\t\tif (head.next != null)\n\t\t{\n\t\t\tConsole.Write(\"->\");\n\t\t}\n\t\thead = head.next;\n\t}\n\tConsole.WriteLine();\n}\nvoid rearrange(Node head)\n{\n\tif (head != null)\n\t{\n\t\tleft = head;\n\t\treorderListUtil(left);\n\t}\n}\nvoid reorderListUtil(Node right)\n{\n\tif (right == null)\n\t{\n\t\treturn;\n\t}\n\treorderListUtil(right.next);\n\tif (left == null)\n\t{\n\t\treturn;\n\t}\n\tif (left != right && left.next != right)\n\t{\n\t\tNode temp = left.next;\n\t\tleft.next = right;\n\t\tright.next = temp;\n\t\tleft = temp;\n\t}\n\telse\n\t{\n\t\tif (left.next == right)\n\t\t{\n\t\t\tleft.next.next = null;\n\t\t\tleft = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tleft.next = null;\n\t\t\tleft = null;\n\t\t}\n\t}\n}", "2464": "int getLength(Node node)\n\t{\n\t\tint size = 0;\n\t\twhile (node != null) {\n\t\t\tnode = node.next;\n\t\t\tsize++;\n\t\t}\n\t\treturn size;\n\t}\nNode paddZeros(Node sNode, int diff)\n\t{\n\t\tif (sNode == null)\n\t\t\treturn null;\n\t\tNode zHead = new Node(0);\n\t\tdiff--;\n\t\tNode temp = zHead;\n\t\twhile ((diff--) != 0) {\n\t\t\ttemp.next = new Node(0);\n\t\t\ttemp = temp.next;\n\t\t}\n\t\ttemp.next = sNode;\n\t\treturn zHead;\n\t}\nNode subtractLinkedListHelper(Node l1, Node l2)\n\t{\n\t\tif (l1 == null && l2 == null && borrow == false)\n\t\t\treturn null;\n\t\tNode previous = subtractLinkedListHelper((l1 != null) ? l1.next : null, (l2 != null) ? l2.next : null);\n\t\tint d1 = l1.data;\n\t\tint d2 = l2.data;\n\t\tint sub = 0;\n\t\tif (borrow) {\n\t\t\td1--;\n\t\t\tborrow = false;\n\t\t}\n\t\tif (d1 < d2) {\n\t\t\tborrow = true;\n\t\t\td1 = d1 + 10;\n\t\t}\n\t\tsub = d1 - d2;\n\t\tNode current = new Node(sub);\n\t\tcurrent.next = previous;\n\t\treturn current;\n\t}\nNode subtractLinkedList(Node l1, Node l2)\n\t{\n\t\tif (l1 == null && l2 == null)\n\t\t\treturn null;\n\t\tint len1 = getLength(l1);\n\t\tint len2 = getLength(l2);\n\t\tNode lNode = null, sNode = null;\n\t\tNode temp1 = l1;\n\t\tNode temp2 = l2;\n\t\tif (len1 != len2) {\n\t\t\tlNode = len1 > len2 ? l1 : l2;\n\t\t\tsNode = len1 > len2 ? l2 : l1;\n\t\t\tsNode = paddZeros(sNode, Math.Abs(len1 - len2));\n\t\t}\n\t\telse {\n\t\t\twhile (l1 != null && l2 != null) {\n\t\t\t\tif (l1.data != l2.data) {\n\t\t\t\t\tlNode = l1.data > l2.data ? temp1 : temp2;\n\t\t\t\t\tsNode = l1.data > l2.data ? temp2 : temp1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tl1 = l1.next;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t}\n\t\tborrow = false;\n\t\treturn subtractLinkedListHelper(lNode, sNode);\n\t}\nstatic void printList(Node head)\n\t{\n\t\tNode temp = head;\n\t\twhile (temp != null) {\n\t\t\tConsole.Write(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2501": "static void insertAtMid(int x)\n\t{\n\t\tif (head == null)\n\t\t\thead = new Node(x);\n\t\telse\n\t\t{\n\t\t\tNode newNode = new Node(x);\n\t\t\tNode ptr = head;\n\t\t\tint len = 0;\n\t\t\twhile (ptr != null)\n\t\t\t{\n\t\t\t\tlen++;\n\t\t\t\tptr = ptr.next;\n\t\t\t}\n\t\t\tint count = ((len % 2) == 0) ? (len / 2) :\n\t\t\t\t\t\t\t\t\t\t(len + 1) / 2;\n\t\t\tptr = head;\n\t\t\twhile (count-- > 1)\n\t\t\t\tptr = ptr.next;\n\t\t\tnewNode.next = ptr.next;\n\t\t\tptr.next = newNode;\n\t\t}\n\t}\nstatic void display()\n\t{\n\t\tNode temp = head;\n\t\twhile (temp != null)\n\t\t{\n\t\t\tConsole.Write(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2502": "static void insertAtMid(int x)\n\t{\n\t\tif (head == null)\n\t\thead = new Node(x);\n\t\telse\n\t\t{\n\t\t\tNode newNode = new Node(x);\n\t\t\tNode slow = head;\n\t\t\tNode fast = head.next;\n\t\t\twhile (fast != null && fast.next != null)\n\t\t\t{\n\t\t\t\tslow = slow.next;\n\t\t\t\tfast = fast.next.next;\n\t\t\t}\n\t\t\tnewNode.next = slow.next;\n\t\t\tslow.next = newNode;\n\t\t}\n\t}\nstatic void display()\n\t{\n\t\tNode temp = head;\n\t\twhile (temp != null)\n\t\t{\n\t\t\tConsole.Write(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2518": "static Node getNode(int data)\n{\n\tNode newNode = new Node();\n\tnewNode.data = data;\n\tnewNode.prev = newNode.next = null;\n\treturn newNode;\n}\nstatic Node sortedInsert(Node head_ref, Node newNode)\n{\n\tNode current;\n\tif (head_ref == null)\n\t\thead_ref = newNode;\n\telse if ((head_ref).data >= newNode.data)\n\t{\n\t\tnewNode.next = head_ref;\n\t\tnewNode.next.prev = newNode;\n\t\thead_ref = newNode;\n\t}\n\telse\n\t{\n\t\tcurrent = head_ref;\n\t\twhile (current.next != null && current.next.data < newNode.data)\n\t\t\tcurrent = current.next;\n\t\tnewNode.next = current.next;\n\t\tif (current.next != null)\n\t\t\tnewNode.next.prev = newNode;\n\t\tcurrent.next = newNode;\n\t\tnewNode.prev = current;\n\t}\n\treturn head_ref;\n}\nstatic Node insertionSort(Node head_ref)\n{\n\tNode sorted = null;\n\tNode current = head_ref;\n\twhile (current != null)\n\t{\n\t\tNode next = current.next;\n\t\tcurrent.prev = current.next = null;\n\t\tsorted = sortedInsert(sorted, current);\n\t\tcurrent = next;\n\t}\n\thead_ref = sorted;\n\treturn head_ref;\n}\nstatic void printList(Node head)\n{\n\twhile (head != null)\n\t{\n\t\tConsole.Write(head.data + \" \");\n\t\thead = head.next;\n\t}\n}\nstatic Node push(Node head_ref, int new_data)\n{\n\tNode new_node = new Node();\n\tnew_node.data = new_data;\n\tnew_node.next = (head_ref);\n\tnew_node.prev = null;\n\tif ((head_ref) != null)\n\t\t(head_ref).prev = new_node;\n\t(head_ref) = new_node;\n\treturn head_ref;\n}", "2575": "public static void reverse(int []arr, int s, int e)\n{\n while(s < e)\n {\n\tint tem = arr[s];\n\tarr[s] = arr[e];\n\tarr[e] = tem;\n\ts = s + 1;\n\te = e - 1;\n }\n}\npublic static void fun(int []arr, int k)\n{\n int n = 4 - 1;\n int v = n - k;\n if (v >= 0)\n {\n\treverse(arr, 0, v);\n\treverse(arr, v + 1, n);\n\treverse(arr, 0, n);\n }\n}", "2578": "static void build(int node, int l, int r, int []a)\n{\n\tif (l == r)\n\t\tseg[node] = a[l];\n\telse\n\t{\n\t\tint mid = (l + r) / 2;\n\t\tbuild(2 * node, l, mid, a);\n\t\tbuild(2 * node + 1, mid + 1, r, a);\n\t\tseg[node] = (seg[2 * node] seg[2 * node + 1]);\n\t}\n}\nstatic int query(int node, int l, int r, int start, int end, int []a)\n{\n\tif (l > end r < start)\n\t\treturn 0;\n\tif (start <= l && r <= end)\n\t\treturn seg[node];\n\tint mid = (l + r) / 2;\n\treturn ((query(2 * node, l, mid, start, end, a)) |\n\t\t\t(query(2 * node + 1, mid + 1, r, start, end, a)));\n}\nstatic void orsum(int []a, int n, int q, int []k)\n{\n\tbuild(1, 0, n - 1, a);\n\tfor(int j = 0; j < q; j++)\n\t{\n\t\tint i = k[j] % (n / 2);\n\t\tint sec = query(1, 0, n - 1, n / 2 - i, n - i - 1, a);\n\t\tint first = (query(1, 0, n - 1, 0, n / 2 - 1 - i, a) |\n\t\t\t\t\tquery(1, 0, n - 1, n - i, n - 1, a));\n\t\tint temp = sec + first;\n\t\tConsole.Write(temp + \"\\n\");\n\t}\n}", "2579": "static void maximumEqual(int[] a, int[] b, int n)\n{\n\tint[] store = new int[(int) 1e5];\n\tfor(int i = 0; i < n; i++)\n\t{\n\tstore[b[i]] = i + 1;\n\t}\n\tint[] ans = new int[(int) 1e5];\n\tfor(int i = 0; i < n; i++)\n\t{\n\tint d = Math.Abs(store[a[i]] - (i + 1));\n\tif (store[a[i]] < i + 1)\n\t{\n\t\td = n - d;\n\t}\n\tans[d]++;\n\t}\n\tint finalans = 0;\n\tfor(int i = 0; i < 1e5; i++)\n\tfinalans = Math.Max(finalans, ans[i]);\n\tConsole.Write(finalans + \"\\n\");\n}", "2583": "static void RightRotate(int []a, int n, int k)\n{\n\tk = k % n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tif(i < k)\n\t{\n\t\tConsole.Write(a[n + i - k] + \" \");\n\t}\n\telse\n\t{\n\t\tConsole.Write(a[i - k] + \" \");\n\t}\n\t}\n\tConsole.WriteLine();\n}", "2615": "static void restoreSortedArray(int []arr, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > arr[i + 1])\n\t\t{\n\t\t\treverse(arr,0,i);\n\t\t\treverse(arr , i + 1, n);\n\t\t\treverse(arr,0, n);\n\t\t}\n\t}\n}\nstatic void reverse(int[] arr, int i, int j)\n{\n\tint temp;\n\twhile(i < j)\n\t{\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t\ti++;\n\t\tj--;\n\t}\n}\nstatic void printArray(int []arr, int size)\n{\n\tfor (int i = 0; i < size; i++)\n\t\tConsole.Write(arr[i] + \" \");\n}", "2616": "static int findStartIndexOfArray(int []arr, int low, int high)\n\t{\n\t\tif (low > high)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tif (low == high)\n\t\t{\n\t\t\treturn low;\n\t\t}\n\t\tint mid = low + (high - low) / 2;\n\t\tif (arr[mid] > arr[mid + 1])\n\t\t{\n\t\t\treturn mid + 1;\n\t\t}\n\t\tif (arr[mid - 1] > arr[mid])\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\tif (arr[low] > arr[mid])\n\t\t{\n\t\t\treturn findStartIndexOfArray(arr, low, mid - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn findStartIndexOfArray(arr, mid + 1, high);\n\t\t}\n\t}\nstatic void restoreSortedArray(int []arr, int n)\n\t{\n\t\tif (arr[0] < arr[n - 1])\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint start = findStartIndexOfArray(arr, 0, n - 1);\n\t\tArray.Sort(arr, 0, start);\n\t\tArray.Sort(arr, start, n);\n\t\tArray.Sort(arr);\n\t}\nstatic void printArray(int []arr, int size)\n\t{\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\t}\n\t}", "2623": "static String leftrotate(String str, int d)\n\t{\n\t\t\tString ans = str.Substring(d,str.Length-d) + str.Substring(0, d);\n\t\t\treturn ans;\n\t}\nstatic String rightrotate(String str, int d)\n\t{\n\t\t\treturn leftrotate(str, str.Length - d);\n\t}", "2673": "static Node insertNode(Node start, int value)\n\t{\n\t\tNode new_node = new Node();\n\t\tif (start == null)\n\t\t{\n\t\t\tnew_node.data = value;\n\t\t\tnew_node.next = new_node.prev = new_node;\n\t\t\tstart = new_node;\n\t\t\treturn new_node;\n\t\t}\n\t\tNode last = (start).prev;\n\t\tnew_node = new Node();\n\t\tnew_node.data = value;\n\t\tnew_node.next = start;\n\t\t(start).prev = new_node;\n\t\tnew_node.prev = last;\n\t\tlast.next = new_node;\n\t\treturn start;\n\t}\nstatic void displayList(Node start)\n\t{\n\t\tNode temp = start;\n\t\twhile (temp.next != start)\n\t\t{\n\t\t\tConsole.Write(\"{0} \", temp.data);\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tConsole.Write(\"{0} \", temp.data);\n\t}\nstatic int searchList(Node start, int search)\n\t{\n\t\tNode temp = start;\n\t\tint count = 0, flag = 0, value;\n\t\tif(temp == null)\n\t\t\treturn -1;\n\t\telse\n\t\t{\n\t\t\twhile(temp.next != start)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tif(temp.data == search)\n\t\t\t\t{\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tcount--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttemp = temp.next;\n\t\t\t}\n\t\t\tif(temp.data == search)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t\tif(flag == 1)\n\t\t\t\tConsole.WriteLine(\"\\n\"+search +\" found at location \"+ count);\n\t\t\telse\n\t\t\t\tConsole.WriteLine(\"\\n\"+search +\" not found\");\n\t\t}\n\t\treturn -1;\n\t}", "2675": "static Node getNode(int data)\n{\n\tNode newNode = new Node();\n\tnewNode.data = data;\n\treturn newNode;\n}\nstatic Node insertEnd(Node head, Node new_node)\n{\n\tif (head == null)\n\t{\n\t\tnew_node.next = new_node.prev = new_node;\n\t\thead = new_node;\n\t\treturn head;\n\t}\n\tNode last = (head).prev;\n\tnew_node.next = head;\n\t(head).prev = new_node;\n\tnew_node.prev = last;\n\tlast.next = new_node;\n\treturn head;\n}\nstatic Node reverse(Node head)\n{\n\tif (head == null)\n\t\treturn null;\n\tNode new_head = null;\n\tNode last = head.prev;\n\tNode curr = last, prev;\n\twhile (curr.prev != last)\n\t{\n\t\tprev = curr.prev;\n\t\tnew_head=insertEnd(new_head, curr);\n\t\tcurr = prev;\n\t}\n\tnew_head=insertEnd(new_head, curr);\n\treturn new_head;\n}\nstatic void display(Node head)\n{\n\tif (head == null)\n\t\treturn;\n\tNode temp = head;\n\tConsole.Write( \"Forward direction: \");\n\twhile (temp.next != head)\n\t{\n\t\tConsole.Write( temp.data + \" \");\n\t\ttemp = temp.next;\n\t}\n\t\tConsole.Write( temp.data + \" \");\n\tNode last = head.prev;\n\ttemp = last;\n\tConsole.Write( \"\\nBackward direction: \");\n\twhile (temp.prev != last)\n\t{\n\t\tConsole.Write( temp.data + \" \");\n\t\ttemp = temp.prev;\n\t}\n\t\tConsole.Write( temp.data + \" \");\n}", "2696": "static void addEdge(int u, int v)\n{\n\tadj[u].Add(v);\n\tadj[v].Add(u);\n}\nstatic void dfs(int cur, int prev)\n{\n\tparent[cur] = prev;\n\tdepth[cur] = depth[prev] + 1;\n\tfor(int i = 0; i < adj[cur].Count; i++)\n\t\tif ((int)adj[cur][i] != prev)\n\t\t\tdfs((int)adj[cur][i], cur);\n}\nstatic void preprocess()\n{\n\tdepth[0] = -1;\n\tdfs(1, 0);\n}\nstatic int LCANaive(int u, int v)\n{\n\tif (u == v)\n\t\treturn u;\n\tif (depth[u] > depth[v])\n\t{\n\t\tint temp = u;\n\t\tu = v;\n\t\tv = temp;\n\t}\n\tv = parent[v];\n\treturn LCANaive(u, v);\n}", "2697": "static void addEdge(int u, int v)\n {\n\tadj[u].Add(v);\n\tadj[v].Add(u);\n }\nstatic int LCANaive(int u, int v)\n {\n\tif (u == v) return u;\n\tif (depth[u] > depth[v])\n\t{\n\tint t = u;\n\tu = v;\n\tv = t;\n\t}\t\n\tv = parent[v];\n\treturn LCANaive(u, v);\n }\nstatic void dfs(int cur, int prev)\n {\n\tdepth[cur] = depth[prev] + 1;\n\tparent[cur] = prev;\n\tif (depth[cur] % block_sz == 0)\n\tjump_parent[cur] = parent[cur];\n\telse\n\tjump_parent[cur] = jump_parent[prev];\n\tfor (int i = 0; i < adj[cur].Count; ++i)\n\tif (adj[cur][i] != prev)\n\t\tdfs(adj[cur][i], cur);\n }\nstatic int LCASQRT(int u, int v)\n {\n\twhile (jump_parent[u] != jump_parent[v])\n\t{\n\tif (depth[u] > depth[v])\n\t{\n\t\tint t = u;\n\t\tu = v;\n\t\tv = t;\n\t}\n\tv = jump_parent[v];\n\t}\n\treturn LCANaive(u, v);\n }\nstatic void preprocess(int height)\n {\n\tblock_sz = (int)Math.Sqrt(height);\n\tdepth[0] = -1;\n\tdfs(1, 0);\n }", "2740": "static int find_permutations(ArrayList arr)\n{\n\tint cnt = 0;\n\tint max_ind = -1, min_ind = 10000000;\n\tint n = arr.Count;\n\tDictionary<int,\n\t\t\tint> index_of = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tindex_of[(int)arr[i]] = i + 1;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tmax_ind = Math.Max(max_ind, index_of[i]);\n\t\tmin_ind = Math.Min(min_ind, index_of[i]);\n\t\tif (max_ind - min_ind + 1 == i)\n\t\t\tcnt++;\n\t}\n\treturn cnt;\n}", "2753": "", "2773": "static int countOfNum( int n, int a, int b)\n\t{\n\t\tint cnt_of_a, cnt_of_b, cnt_of_ab, sum;\n\t\tcnt_of_a = n / a;\n\t\tcnt_of_b = n / b;\n\t\tsum = cnt_of_b + cnt_of_a;\n\t\tcnt_of_ab = n / (a * b);\n\t\tsum = sum - cnt_of_ab;\n\t\treturn sum;\n\t}\nstatic int sumOfNum( int n, int a, int b)\n\t{\n\t\tint i;\n\t\tint sum = 0;\n\t\tHashSet< int> ans = new HashSet<int>();\n\t\tfor (i = a; i <= n; i = i + a) {\n\t\t\tans.Add(i);\n\t\t}\n\t\tfor (i = b; i <= n; i = i + b) {\n\t\t\tans.Add(i);\n\t\t}\n\t\tforeach (int it in ans) {\n\t\t\tsum = sum + it;\n\t\t}\n\t\treturn sum;\n\t}", "2783": "static void maximumArea(int l, int b, int x, int y)\n{\n\tint left, right, above, below;\n\tleft = x * b;\n\tright = (l - x - 1) * b;\n\tabove = l * y;\n\tbelow = (b - y - 1) * l;\n\tConsole.Write(Math.Max(Math.Max(left, right),\n\t\t\t\tMath.Max(above, below)));\n}", "2802": "static void precompute()\n{\n\tF[1] = 2;\n\tF[2] = 3;\n\tF[3] = 4;\n\tfor (int i = 4; i < N; i++)\n\t\tF[i] = (F[i - 1] + F[i - 2]) % MOD;\n}", "2804": "static double get(double L, double R)\n{\n\tdouble x = 1.0 / L;\n\tdouble y = 1.0 / (R + 1.0);\n\treturn (x - y);\n}", "2809": "static int upper_bound(List<int> ar, int k)\n{\n\tint s = 0;\n\tint e = ar.Count;\n\twhile (s != e)\n\t{\n\t\tint mid = s + e >> 1;\n\t\tif (ar[mid] <= k)\n\t\t{\n\t\t\ts = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te = mid;\n\t\t}\n\t}\n\tif (s == ar.Count)\n\t{\n\t\treturn -1;\n\t}\n\treturn s;\n}\nstatic int consecutiveOnes(int x)\n{\n\tint p = 0;\n\twhile (x > 0)\n\t{\n\t\tif (x % 2 == 1 && p == 1)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tp = x % 2;\n\t\tx /= 2;\n\t}\n\treturn 0;\n}\nstatic void preCompute()\n{\n\tfor(int i = 0; i <= MAX; i++)\n\t{\n\t\tif (consecutiveOnes(i) == 0)\n\t\t{\n\t\t\tv.Add(i);\n\t\t}\n\t}\n}\nstatic int nextValid(int n)\n{\n\tint it = upper_bound(v, n);\n\tint val = v[it];\n\treturn val;\n}\nstatic void performQueries(int[] queries, int q)\n{\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tConsole.WriteLine(nextValid(queries[i]));\n\t}\n}", "2816": "static int changeToOnes(String str)\n{\n\tint i, l, ctr = 0;\n\tl = str.Length;\n\tfor (i = l - 1; i >= 0; i--)\n\t{\n\t\tif (str[i] == '1')\n\t\t\tctr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn l - ctr;\n}\nstatic String removeZeroesFromFront(String str)\n{\n\tString s;\n\tint i = 0;\n\twhile (i < str.Length && str[i] == '0')\n\t\ti++;\n\tif (i == str.Length)\n\t\ts = \"0\";\n\telse\n\t\ts = str.Substring(i, str.Length - i);\n\treturn s;\n}", "2818": "static int calgcd(int a, int b)\n\t{\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn calgcd(b, a % b);\n\t}\nstatic int getCount(int [] a, int n)\n\t{\n\t\tint gcd = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tgcd = calgcd(gcd, a[i]);\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i * i <= gcd; i++)\n\t\t{\n\t\t\tif (gcd % i == 0)\n\t\t\t{\n\t\t\t\tif (i * i == gcd)\n\t\t\t\t\tcnt++;\n\t\t\t\telse\n\t\t\t\t\tcnt += 2;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}", "2827": "static int MinDeletion(int []a, int n)\n{\n\tDictionary<int,\n\t\t\tint> mp = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tfor (int i = 0 ; i < n; i++)\n\t{\n\t\tif(mp.ContainsKey(a[i]))\n\t\t{\n\t\t\tvar val = mp[a[i]];\n\t\t\tmp.Remove(a[i]);\n\t\t\tmp.Add(a[i], val + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.Add(a[i], 1);\n\t\t}\n\t}\n\tint ans = 0;\n\tforeach(KeyValuePair<int, int> i in mp)\n\t{\n\t\tint x = i.Key;\n\t\tint frequency = i.Value;\n\t\tif (x <= frequency)\n\t\t{\n\t\t\tans += (frequency - x);\n\t\t}\n\t\telse\n\t\t\tans += frequency;\n\t}\n\treturn ans;\n}", "2831": "static int maxCountAB(string []s, int n)\n\t{\n\t\tint A = 0, B = 0, BA = 0, ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tstring S = s[i];\n\t\t\tint L = S.Length;\n\t\t\tfor (int j = 0; j < L - 1; j++)\n\t\t\t{\n\t\t\t\tif (S[j] == 'A' && S[j + 1] == 'B')\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S[0] == 'B' && S[L - 1] == 'A')\n\t\t\t\tBA++;\n\t\t\telse if (S[0] == 'B')\n\t\t\t\tB++;\n\t\t\telse if (S[L - 1] == 'A')\n\t\t\t\tA++;\n\t\t}\n\t\tif (BA == 0)\n\t\t\tans += Math.Min(B, A);\n\t\telse if (A + B == 0)\n\t\t\tans += BA - 1;\n\t\telse\n\t\t\tans += BA + Math.Min(B, A);\n\t\treturn ans;\n\t}", "2832": "static int MinOperations(int n, int x, int[] arr)\n{\n\tint total = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (arr[i] > x)\n\t\t{\n\t\t\tint difference = arr[i] - x;\n\t\t\ttotal = total + difference;\n\t\t\tarr[i] = x;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint LeftNeigbouringSum = arr[i] + arr[i - 1];\n\t\tif (LeftNeigbouringSum > x)\n\t\t{\n\t\t\tint current_diff = LeftNeigbouringSum - x;\n\t\t\tarr[i] = Math.Max(0, arr[i] - current_diff);\n\t\t\ttotal = total + current_diff;\n\t\t}\n\t}\n\treturn total;\n}", "2847": "static void findNumbers(int []arr, int n)\n\t{\n\t\tint sumN = (n * (n + 1)) / 2;\n\t\tint sumSqN = (n * (n + 1) * (2 * n + 1)) / 6;\n\t\tint sum = 0, sumSq = 0, i;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tsum += arr[i];\n\t\t\tsumSq += (int)Math.Pow(arr[i], 2);\n\t\t}\n\t\tint B = (((sumSq - sumSqN) / (sum - sumN)) + sumN - sum) / 2;\n\t\tint A = sum - sumN + B;\n\t\tConsole.WriteLine(\"A = \" + A + \"\\nB = \" + B);\n\t}", "2883": "static bool is_prefix(string temp, string str)\n\t{\n\t\tif (temp.Length < str.Length)\n\t\t\treturn false;\n\t\telse {\n\t\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\t\tif (str[i] != temp[i])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\nstatic string lexicographicallyString(string[] input, int n, string str)\n\t{\n\t\tArray.Sort(input);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring temp = input[i];\n\t\t\tif (is_prefix(temp, str)) {\n\t\t\t\treturn temp;\n\t\t\t}\n\t\t}\n\t\treturn \"-1\";\n\t}", "2892": "static void Rearrange(int []arr, int K, int N)\n {\n\tint []ans = new int[N + 1];\n\tint f = -1;\n\tfor (int i = 0; i < N; i++) {\n\tans[i] = -1;\n\t}\n\tfor (int i = 0; i < arr.Length; i++)\n\t{\n\tif (arr[i] == K)\n\t{\n\t\tK = i;\n\t\tbreak;\n\t}\n\t}\n\tList<int> smaller = new List<int>();\n\tList<int> greater = new List<int>();\n\tfor (int i = 0; i < N; i++) {\n\tif (arr[i] < arr[K])\n\t\tsmaller.Add(arr[i]);\n\telse if (arr[i] > arr[K])\n\t\tgreater.Add(arr[i]);\n\t}\n\tint low = 0, high = N - 1;\n\twhile (low <= high) {\n\tint mid = (low + high) / 2;\n\tif (mid == K) {\n\t\tans[mid] = arr[K];\n\t\tf = 1;\n\t\tbreak;\n\t}\n\telse if (mid < K) {\n\t\tif (smaller.Count == 0) {\n\t\tbreak;\n\t\t}\n\t\tans[mid] = smaller[smaller.Count-1];\n\t\tsmaller.RemoveAt(smaller.Count-1);\n\t\tlow = mid + 1;\n\t}\n\telse {\n\t\tif (greater.Count == 0) {\n\t\tbreak;\n\t\t}\n\t\tans[mid] = greater[greater.Count-1];\n\t\tgreater.RemoveAt(greater.Count-1);\n\t\thigh = mid - 1;\n\t}\n\t}\n\tif (f == -1) {\n\tConsole.WriteLine(-1 );\n\treturn;\n\t}\n\tfor (int i = 0; i < N; i++) {\n\tif (ans[i] == -1) {\n\t\tif (smaller.Count>0) {\n\t\tans[i] = smaller[smaller.Count-1];\n\t\tsmaller.RemoveAt(smaller.Count-1);\n\t\t}\n\t\telse if (greater.Count>0) {\n\t\tans[i] = greater[greater.Count-1];\n\t\tgreater.RemoveAt(greater.Count-1);\n\t\t}\n\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\tConsole.Write(ans[i] +\" \");\n\tConsole.WriteLine();\n }", "2923": "static void minimumK(List<int> arr, int M, int N)\n{\n\tint good = (int)((N * 1.0) / ((M + 1) * 1.0))+1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tint K = i;\n\t\tint candies = N;\n\t\tint taken = 0;\n\t\twhile (candies > 0) {\n\t\t\ttaken += Math.Min(K, candies);\n\t\t\tcandies -= Math.Min(K, candies);\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tint consume = (arr[j] * candies) / 100;\n\t\t\t\tcandies -= consume;\n\t\t\t}\n\t\t}\n\t\tif (taken >= good) {\n\t\t\tConsole.Write(i);\n\t\t\treturn;\n\t\t}\n\t}\n}", "2940": "static void calcTotalTime(string path)\n{\n\tint time = 0;\n\tint x = 0, y = 0;\n\tHashSet<string> s = new HashSet<string>();\n\tfor(int i = 0; i < path.Length; i++)\n\t{\n\t\tint p = x;\n\t\tint q = y;\n\t\tif (path[i] == 'N')\n\t\t\ty++;\n\t\telse if (path[i] == 'S')\n\t\t\ty--;\n\t\telse if (path[i] == 'E')\n\t\t\tx++;\n\t\telse if (path[i] == 'W')\n\t\t\tx--;\n\t\tstring o = (p + x) + \" \" + (q + y);\n\t\tif (s.Contains(o) == false)\n\t\t{\n\t\t\ttime += 2;\n\t\t\ts.Add(o);\n\t\t}\n\t\telse\n\t\t\ttime += 1;\n\t}\n\tConsole.Write(time);\n}", "2950": "static void calcPsquare(int N)\n\t{\n\t\tfor (int i = 1; i * i <= N; i++)\n\t\t\tpsquare.Add(i * i);\n\t}\nstatic int countWays(int index, int target)\n\t{\n\t\tif (target == 0)\n\t\t\treturn 1;\n\t\tif (index < 0 target < 0)\n\t\t\treturn 0;\n\t\tint inc = countWays(index,\n\t\t\t\t\t\t\ttarget - (int)psquare[index]);\n\t\tint exc = countWays(index - 1, target);\n\t\treturn inc + exc;\n\t}", "2983": "static int findCost(int []A, int N)\n{\n\tint totalCost = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (A[i] == 0)\n\t\t{\n\t\t\tA[i] = 1;\n\t\t\ttotalCost += i;\n\t\t}\n\t}\n\treturn totalCost;\n}", "3003": "static int countNumbers(int L, int R, int K)\n{\n\tList<int> list = new List<int>();\n\tfor(int i = L; i <= R; i++)\n\t{\n\t\tif (isPalindrome(i))\n\t\t{\n\t\t\tlist.Add(i);\n\t\t}\n\t}\n\tint count = 0;\n\tfor(int i = 0; i < list.Count; i++)\n\t{\n\t\tint right_index = search(list, list[i] + K - 1);\n\t\tif (right_index != -1)\n\t\t\tcount = Math.Max(count, right_index - i + 1);\n\t}\n\treturn count;\n}\nstatic int search(List<int> list, int num)\n{\n\tint low = 0, high = list.Count - 1;\n\tint ans = -1;\n\twhile (low <= high)\n\t{\n\t\tint mid = low + (high - low) / 2;\n\t\tif (list[mid] <= num)\n\t\t{\n\t\t\tans = mid;\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn ans;\n}\nstatic bool isPalindrome(int n)\n{\n\tint rev = 0;\n\tint temp = n;\n\twhile (n > 0)\n\t{\n\t\trev = rev * 10 + n % 10;\n\t\tn /= 10;\n\t}\n\treturn rev == temp;\n}", "3010": "public static int peakIndex(int[] arr)\n{\n\tint N = arr.Length;\n\tif (arr.Length < 3)\n\t\treturn -1;\n\tint i = 0;\n\twhile (i + 1 < N)\n\t{\n\t\tif (arr[i + 1] < arr[i] arr[i] == arr[i + 1])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i == 0 i == N - 1)\n\t\treturn -1;\n\tint ans = i;\n\twhile (i < N - 1)\n\t{\n\t\tif (arr[i] < arr[i + 1] arr[i] == arr[i + 1])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i == N - 1)\n\t\treturn ans;\n\treturn -1;\n}", "3053": "static void hasArrayTwoPairs(int[] nums, int n, int target)\n\t{\n\t\tArray.Sort(nums);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x = target - nums[i];\n\t\t\tint low = 0, high = n - 1;\n\t\t\twhile (low <= high)\n\t\t\t{\n\t\t\t\tint mid = low + ((high - low) / 2);\n\t\t\t\tif (nums[mid] > x) {\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t\telse if (nums[mid] < x) {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (mid == i) {\n\t\t\t\t\t\tif ((mid - 1 >= 0) && nums[mid - 1] == x) {\n\t\t\t\t\t\t\tConsole.Write(nums[i] + \", \");\n\t\t\t\t\t\t\tConsole.Write( nums[mid - 1]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((mid + 1 < n) && nums[mid + 1] == x) {\n\t\t\t\t\t\t\tConsole.Write( nums[i] + \", \");\n\t\t\t\t\t\t\tConsole.Write( nums[mid + 1]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tConsole.Write( nums[i] + \", \");\n\t\t\t\t\t\tConsole.Write(nums[mid]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.Write(-1);\n\t}", "3096": "static TreeNode newNode(int data)\n{\n\tTreeNode Node = new TreeNode();\n\tNode.data = data;\n\tNode.left = null;\n\tNode.right = null;\n\treturn (Node);\n}\nstatic pair sumofsubtree(TreeNode root)\n{\n\tpair p = new pair(1, 0);\n\tif (root.left != null)\n\t{\n\t\tpair ptemp\n\t\t\t= sumofsubtree(root.left);\n\t\tp.second += ptemp.first\n\t\t\t\t\t+ ptemp.second;\n\t\tp.first += ptemp.first;\n\t}\n\tif (root.right != null)\n\t{\n\t\tpair ptemp\n\t\t\t= sumofsubtree(root.right);\n\t\tp.second += ptemp.first\n\t\t\t\t\t+ ptemp.second;\n\t\tp.first += ptemp.first;\n\t}\n\troot.size = p.first;\n\treturn p;\n}\nstatic void distance(TreeNode root, int target, int distancesum, int n)\n{\n\tif (root.data == target)\n\t{\n\t\tsum = distancesum;\n\t}\n\tif (root.left != null)\n\t{\n\t\tint tempsum = distancesum\n\t\t\t\t\t- root.left.size\n\t\t\t\t\t+ (n - root.left.size);\n\t\tdistance(root.left, target, tempsum, n);\n\t}\n\tif (root.right != null)\n\t{\n\t\tint tempsum = distancesum\n\t\t\t\t\t- root.right.size\n\t\t\t\t\t+ (n - root.right.size);\n\t\tdistance(root.right, target, tempsum, n);\n\t}\n}", "3120": "public static int delCost(string s, int[] cost)\n{\n\tbool[] visited = new bool[s.Length];\n\tint ans = 0;\n\tfor(int i = 0; i < s.Length; i++)\n\t{\n\t\tif (visited[i] != false)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint maxDel = 0;\n\t\tint totalCost = 0;\n\t\tvisited[i] = true;\n\t\tfor(int j = i; j < s.Length; j++)\n\t\t{\n\t\t\tif (s[i] == s[j])\n\t\t\t{\n\t\t\t\tmaxDel = Math.Max(maxDel, cost[j]);\n\t\t\t\ttotalCost += cost[j];\n\t\t\t\tvisited[j] = true;\n\t\t\t}\n\t\t}\n\t\tans += totalCost - maxDel;\n\t}\n\treturn ans;\n}", "3121": "static int delCost(string s, int[] cost)\n {\n\tint ans = 0;\n\tDictionary<int, int> forMax = new Dictionary<int, int>();\n\tDictionary<int, int> forTot = new Dictionary<int, int>();\n\tfor(int i = 0; i < s.Length; i++)\n\t{\n\tif(!forMax.ContainsKey(s[i]))\n\t{\n\t\tforMax[s[i]] = cost[i];\n\t}\n\telse\n\t{\n\t\tforMax[s[i]] = Math.Max(cost[i], forMax[s[i]]);\n\t}\n\tif(!forTot.ContainsKey(s[i]))\n\t{\n\t\tforTot[s[i]] = cost[i];\n\t}\n\telse\n\t{\n\t\tforTot[s[i]] += cost[i];\n\t}\n\t}\n\tforeach(KeyValuePair<int, int> i in forMax)\n\t{\n\tans += forTot[i.Key] - i.Value;\n\t}\n\treturn ans;\n }", "3128": "static void findClosest(int N, int target)\n {\n\tint closest = -1;\n\tint diff = Int32.MaxValue;\n\tfor (int i = 1; i <= Math.Sqrt(N); i++) {\n\tif (N % i == 0) {\n\t\tif (N / i == i) {\n\t\tif (Math.Abs(target - i) < diff)\n\t\t{\n\t\t\tdiff = Math.Abs(target - i);\n\t\t\tclosest = i;\n\t\t}\n\t\t}\n\t\telse {\n\t\tif (Math.Abs(target - i) < diff)\n\t\t{\n\t\t\tdiff = Math.Abs(target - i);\n\t\t\tclosest = i;\n\t\t}\n\t\tif (Math.Abs(target - N / i) < diff)\n\t\t{\n\t\t\tdiff = Math.Abs(target - N / i);\n\t\t\tclosest = N / i;\n\t\t}\n\t\t}\n\t}\n\t}\n\tConsole.Write(closest);\n }", "3129": "static void computeDivisors()\n{\n\tfor (int i = 1; i <= MAX; i++)\n\t{\n\t\tfor (int j = i; j <= MAX; j += i)\n\t\t{\n\t\t\tdivisors[j].Add(i);\n\t\t}\n\t}\n}\nstatic int getClosest(int val1, int val2, int target)\n{\n\tif (target - val1 >= val2 - target)\n\t\treturn val2;\n\telse\n\t\treturn val1;\n}\nstatic int findClosest(List<int> array, int n, int target)\n{\n\tint []arr = array.ToArray();\n\tif (target <= arr[0])\n\t\treturn arr[0];\n\tif (target >= arr[n - 1])\n\t\treturn arr[n - 1];\n\tint i = 0, j = n, mid = 0;\n\twhile (i < j)\n\t{\n\t\tmid = (i + j) / 2;\n\t\tif (arr[mid] == target)\n\t\t\treturn arr[mid];\n\t\tif (target < arr[mid])\n\t\t{\n\t\t\tif (mid > 0 && target > arr[mid - 1])\n\t\t\t\treturn getClosest(arr[mid - 1], arr[mid], target);\n\t\t\tj = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mid < n - 1 && target < arr[mid + 1])\n\t\t\t\treturn getClosest(arr[mid], arr[mid + 1], target);\n\t\t\ti = mid + 1;\n\t\t}\n\t}\n\treturn arr[mid];\n}\nstatic void printClosest(int N, int X)\n{\n\tcomputeDivisors();\n\tint ans\n\t\t= findClosest(divisors[N], divisors[N].Count, X);\n\tConsole.Write(ans);\n}", "3135": "static void countTriplets(int []arr, int N)\n{\n\tList<int> zero_i = new List<int>();\n\tList<int> one_i = new List<int>();\n\tDictionary<int,\n\t\t\tint> mp = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t\tzero_i.Add(i + 1);\n\t\telse if (arr[i] == 1)\n\t\t\tone_i.Add(i + 1);\n\t\telse\n\t\t\tmp.Add(i + 1, 1);\n\t}\n\tint total = zero_i.Count *\n\t\t\t\tone_i.Count * mp.Count;\n\tfor(int i = 0; i < zero_i.Count; i++)\n\t{\n\t\tfor(int j = 0; j < one_i.Count; j++)\n\t\t{\n\t\t\tint p = zero_i[i];\n\t\t\tint q = one_i[j];\n\t\t\tint r = 2 * p - q;\n\t\t\tif (mp.ContainsKey(r) && mp[r] > 0)\n\t\t\t\ttotal--;\n\t\t\tr = 2 * q - p;\n\t\t\tif (mp.ContainsKey(r) && mp[r] > 0)\n\t\t\t\ttotal--;\n\t\t\tr = (p + q) / 2;\n\t\t\tif (mp.ContainsKey(r) &&\n\t\t\t\t\tmp[r] > 0 &&\n\t\t\t\tMath.Abs(r - p) == Math.Abs(r - q))\n\t\t\t\ttotal--;\n\t\t}\n\t}\n\tConsole.Write(total);\n}", "3138": "static int power(int A, int N)\n{\n\tint count = 0;\n\tif (A == 1)\n\t\treturn 0;\n\twhile (N > 0)\n\t{\n\t\tcount++;\n\t\tN /= A;\n\t}\n\treturn count;\n}\nstatic void Pairs(int N, int A, int B)\n{\n\tint powerA, powerB;\n\tpowerA = power(A, N);\n\tpowerB = power(B, N);\n\tint intialB = B, intialA = A;\n\tA = 1;\n\tfor(int i = 0; i <= powerA; i++)\n\t{\n\t\tB = 1;\n\t\tfor(int j = 0; j <= powerB; j++)\n\t\t{\n\t\t\tif (B == N - A)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(i + \" \" + j);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tB *= intialB;\n\t\t}\n\t\tA *= intialA;\n\t}\n\tConsole.WriteLine(\"-1\");\n\treturn;\n}", "3142": "public static int findNonMultiples(int[] arr, int n, int k)\n{\n\tHashSet<int> multiples = new HashSet<int>();\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tif (!multiples.Contains(arr[i]))\n\t\t{\n\t\t\tfor(int j = 1; j <= k / arr[i]; j++)\n\t\t\t{\n\t\t\t\tmultiples.Add(arr[i] * j);\n\t\t\t}\n\t\t}\n\t}\n\treturn k - multiples.Count;\n}\npublic static int countValues(int[] arr, int N, int L, int R)\n{\n\treturn findNonMultiples(arr, N, R) -\n\t\tfindNonMultiples(arr, N, L - 1);\n}", "3163": "static int maxMatch(int[] A, int[] B)\n{\n\tDictionary<int,\n\t\t\tint> Aindex = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\t\tint>(); \n\tDictionary<int,\n\t\t\tint> diff = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\tint>(); \n\tfor(int i = 0; i < A.Length; i++)\n\t{\n\t\tAindex[A[i]] = i ;\n\t}\n\tfor(int i = 0; i < B.Length; i++)\n\t{\n\t\tif (i - Aindex[B[i]] < 0)\n\t\t{\t\n\t\t\tif (!diff.ContainsKey(A.Length + i - Aindex[B[i]]))\n\t\t\t{\n\t\t\t\tdiff[A.Length + i - Aindex[B[i]]] = 1;\n\t\t\t}\t\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiff[A.Length + i - Aindex[B[i]]] += 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!diff.ContainsKey(i - Aindex[B[i]]))\n\t\t\t{\n\t\t\t\tdiff[i - Aindex[B[i]]] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiff[i - Aindex[B[i]]] += 1;\n\t\t\t}\n\t\t}\n\t}\n\tint max = 0;\n\tforeach(KeyValuePair<int, int> ele in diff)\n\t{\n\t\tif (ele.Value > max)\n\t\t{\n\t\t\tmax = ele.Value;\n\t\t}\n\t}\n\treturn max;\n}", "3176": "static void checkXOR(int[] arr, int N)\n{\n\tif (N % 2 == 0)\n\t{\n\t\tint xro = 0;\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\txro ^= arr[i];\n\t\t}\n\t\tif (xro != 0)\n\t\t{\n\t\t\tConsole.WriteLine(-1);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < N - 3; i += 2)\n\t\t{\n\t\t\tConsole.WriteLine(i + \" \" + (i + 1) +\n\t\t\t\t\t\t\t\t\" \" + (i + 2));\n\t\t}\n\t\tfor(int i = 0; i < N - 3; i += 2)\n\t\t{\n\t\t\tConsole.WriteLine(i + \" \" + (i + 1) +\n\t\t\t\t\t\t\t\t\" \" + (N - 1));\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i = 0; i < N - 2; i += 2)\n\t\t{\n\t\t\tConsole.WriteLine(i + \" \" + (i + 1) +\n\t\t\t\t\t\t\t\t\" \" + (i + 2));\n\t\t}\n\t\tfor(int i = 0; i < N - 2; i += 2)\n\t\t{\n\t\t\tConsole.WriteLine(i + \" \" + (i + 1) +\n\t\t\t\t\t\t\t\t\" \" + (N - 1));\n\t\t}\n\t}\n}", "3179": "static int make_array_element_even(int []arr, int N)\n {\n\tint res = 0;\n\tint odd_cont_seg = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\tif (arr[i] % 2 == 1)\n\t{\n\t\todd_cont_seg++;\n\t}\n\telse\n\t{\n\t\tif (odd_cont_seg > 0)\n\t\t{\n\t\tif (odd_cont_seg % 2 == 0)\n\t\t{\n\t\t\tres += odd_cont_seg / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += (odd_cont_seg / 2) + 2;\n\t\t}\n\t\todd_cont_seg = 0;\n\t\t}\n\t}\n\t}\n\tif (odd_cont_seg > 0)\n\t{\n\tif (odd_cont_seg % 2 == 0)\n\t{\n\t\tres += odd_cont_seg / 2;\n\t}\n\telse\n\t{\n\t\tres += odd_cont_seg / 2 + 2;\n\t}\n\t}\n\treturn res;\n }", "3183": "static void minCollectingSpeed(int[] piles, int H)\n {\n\tint ans = -1; \n\tint low = 1, high;\t\n\tArray.Sort(piles);\n\thigh = piles[piles.Length - 1 ];\n\twhile (low <= high)\n\t{\n\tint K = low + (high - low) / 2;\n\tint time = 0;\n\tforeach(int ai in piles)\n\t{\n\t\ttime += (ai + K - 1) / K;\n\t}\n\tif (time <= H)\n\t{\n\t\tans = K;\n\t\thigh = K - 1;\n\t}\n\telse\n\t{\n\t\tlow = K + 1;\n\t}\n\t}\n\tConsole.Write(ans);\n }", "3198": "static int cntDisPairs(int []arr, int N, int K)\n{\n\tint cntPairs = 0;\n\tArray.Sort(arr);\n\tint i = 0;\n\tint j = N - 1;\n\twhile (i < j)\n\t{\n\t\tif (arr[i] + arr[j] == K)\n\t\t{\n\t\t\twhile (i < j && arr[i] == arr[i + 1])\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (i < j && arr[j] == arr[j - 1])\n\t\t\t{\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tcntPairs += 1;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse if (arr[i] + arr[j] < K)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj--;\n\t\t}\n\t}\n\treturn cntPairs;\n}", "3199": "static int cntDisPairs(int []arr, int N, int K)\n {\n\tint cntPairs = 0;\n\tDictionary<int,int> cntFre = new Dictionary<int,int>();\n\tfor (int i = 0; i < N; i++)\n\t{\n\tif(cntFre.ContainsKey(arr[i]))\n\t\tcntFre[arr[i]] = cntFre[arr[i]] + 1;\n\telse\n\t\tcntFre.Add(arr[i], 1);\n\t}\n\tforeach (KeyValuePair<int,int> it in cntFre)\n\t{\n\tint i = it.Key;\n\tif (2 * i == K)\n\t{\n\t\tif (cntFre[i] > 1)\n\t\tcntPairs += 2;\n\t}\n\telse\n\t{\n\t\tif (cntFre.ContainsKey(K - i))\n\t\t{\n\t\tcntPairs += 1;\n\t\t}\n\t}\n\t}\n\tcntPairs = cntPairs / 2;\n\treturn cntPairs;\n }", "3229": "static Node push(Node head_ref, int new_data)\n{\n\tNode new_node = new Node();\n\tnew_node.data = new_data;\n\tnew_node.prev = null;\n\tnew_node.next = head_ref;\n\tif (head_ref != null)\n\t{\n\t\thead_ref.prev = new_node;\n\t}\n\thead_ref = new_node;\n\treturn head_ref;\n}\nstatic int search(Node head_ref, int x)\n{\n\tNode temp = head_ref;\n\tint pos = 0;\n\twhile (temp.data != x && temp.next != null)\n\t{\n\t\tpos++;\n\t\ttemp = temp.next;\n\t}\n\tif (temp.data != x)\n\t\treturn -1;\n\treturn (pos + 1);\n}", "3234": "static void longestSubsequence(int N, int Q, int []arr, int [,]Queries)\n{\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tint x = Queries[i, 0];\n\t\tint y = Queries[i, 1];\n\t\tarr[x - 1] = y;\n\t\tint count = 1;\n\t\tfor(int j = 1; j < N; j++)\n\t\t{\n\t\t\tif (arr[j] != arr[j - 1])\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tConsole.Write(count +\" \");\n\t}\n}", "3235": "static void longestSubsequence(int N, int Q, int []arr, int [,]Queries)\n{\n\tint count = 1;\n\tfor(int i = 1; i < N; i++)\n\t{\n\t\tif (arr[i] != arr[i - 1])\n\t\t{\n\t\t\tcount += 1;\n\t\t}\n\t}\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tint x = Queries[i, 0];\n\t\tint y = Queries[i, 1];\n\t\tif (x > 1)\n\t\t{\n\t\t\tif (arr[x - 1] != arr[x - 2])\n\t\t\t{\n\t\t\t\tcount -= 1;\n\t\t\t}\n\t\t\tif (arr[x - 2] != y)\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tif (x < N)\n\t\t{\n\t\t\tif (arr[x] != arr[x - 1])\n\t\t\t{\n\t\t\t\tcount -= 1;\n\t\t\t}\n\t\t\tif (y != arr[x])\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tConsole.Write(count + \" \");\n\t\tarr[x - 1] = y;\n\t}\n}", "3253": "static void sum(int []arr, int n)\n{\n\tDictionary<int,\n\t\tList<int>> mp = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tList<int>>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tList<int> v = new List<int>();\n\t\tv.Add(i);\n\t\tif (mp.ContainsKey(arr[i]))\n\t\t\tv.AddRange(mp[arr[i]]);\n\t\tmp[arr[i]]= v;\n\t}\n\tint []ans = new int[n];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint sum = 0;\n\t\tforeach(int it in mp[arr[i]])\n\t\t{\n\t\t\tsum += Math.Abs(it - i);\n\t\t}\n\t\tans[i] = sum;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tConsole.Write(ans[i] + \" \");\n\t}\n\treturn;\n}", "3270": "static int[] reverse(int []a)\n{\n int i, n = a.Length, t;\n for(i = 0; i < n / 2; i++)\n {\n\tt = a[i];\n\ta[i] = a[n - i - 1];\n\ta[n - i - 1] = t;\n }\n return a;\n}\nstatic void rearrangeArray(int []A, int []B, int N, int K)\n{ \n Array.Sort(B);\n B = reverse(B);\n bool flag = true;\n for(int i = 0; i < N; i++)\n {\n\tif (A[i] + B[i] > K)\n\t{\n\tflag = false;\n\tbreak;\n\t}\n }\n if (!flag)\n {\n\tConsole.Write(\"-1\" + \"\\n\");\n }\n else\n {\n\tfor(int i = 0; i < N; i++)\n\t{\n\tConsole.Write(B[i] + \" \");\n\t}\n }\n}", "3311": "static bool isinRange(int[, ] board)\n{\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (board[i, j] <= 0 board[i, j] > 9)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nstatic bool isValidSudoku(int[, ] board)\n{\n\tif (isinRange(board) == false)\n\t{\n\t\treturn false;\n\t}\n\tbool[] unique = new bool[N + 1];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tArray.Fill(unique, false);\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tint Z = board[i, j];\n\t\t\tif (unique[Z])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tunique[Z] = true;\n\t\t}\n\t}\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tArray.Fill(unique, false);\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tint Z = board[j, i];\n\t\t\tif (unique[Z])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tunique[Z] = true;\n\t\t}\n\t}\n\tfor(int i = 0; i < N - 2; i += 3)\n\t{\n\t\tfor(int j = 0; j < N - 2; j += 3)\n\t\t{\n\t\t\tArray.Fill(unique, false);\n\t\t\tfor(int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tfor(int l = 0; l < 3; l++)\n\t\t\t\t{\n\t\t\t\t\tint X = i + k;\n\t\t\t\t\tint Y = j + l;\n\t\t\t\t\tint Z = board[X, Y];\n\t\t\t\t\tif (unique[Z])\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tunique[Z] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "3332": "static void conVowUpp(char[] str)\n{\n int N = str.Length;\n for (int i = 0; i < N; i++)\n {\n\tif (str[i] == 'a' str[i] == 'e' str[i] == 'i' str[i] == 'o' str[i] == 'u')\n\t{\n\tchar c = char.ToUpperInvariant(str[i]);\n\tstr[i] = c;\n\t}\n }\n foreach(char c in str)\n\tConsole.Write(c);\n}", "3337": "public static int zvalue(int[] nums)\n{\n int m = max_element(nums);\n int cnt = 0;\n for(int i = 0; i <= m; i++)\n {\n\tcnt = 0;\n\tfor(int j = 0; j < nums.Length; j++)\n\t{\n\tif (nums[j] >= i)\n\t\tcnt++;\n\t}\n\tif (cnt == i)\n\treturn i;\n }\n return -1;\n}\npublic static int max_element(int[] nums)\n{\n int max = nums[0];\n for(int i = 1; i < nums.Length; i++)\n\tmax = Math.Max(max, nums[i]);\n return max;\n}", "3345": "public static bool palindrome(int[] a, int i, int j)\n{\n\twhile (i < j)\n\t{\n\t\tif (a[i] != a[j])\n\t\t\treturn false;\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\nstatic int findSubArray(int[] arr, int k)\n{\n\tint n = arr.Length;\n\tfor(int i = 0; i <= n - k; i++)\n\t{\n\t\tif (palindrome(arr, i, i + k - 1))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}", "3346": "static bool helper(int mid)\n{\n int cnt = 0;\n foreach(KeyValuePair<int, int> i in mp)\n {\n\tint temp = i.Value;\n\twhile (temp >= mid)\n\t{\n\ttemp -= mid;\n\tcnt++;\n\t}\n }\n return cnt >= N;\n}\nstatic int findMaximumDays(int []arr)\n{\n for(int i = 0; i < P; i++)\n {\n\tif (mp.ContainsKey(arr[i]))\n\t{\n\tmp[arr[i]] = mp[arr[i]] + 1;\n\t}\n\telse\n\t{\n\tmp.Add(arr[i], 1);\n\t}\n }\n int start = 0, end = P, ans = 0;\n while (start <= end)\n {\n\tint mid = start +\n\t\t\t((end - start) / 2);\n\tif (mid != 0 && helper(mid))\n\t{\n\tans = mid;\n\tstart = mid + 1;\n\t}\n\telse if (mid == 0)\n\t{\n\tstart = mid + 1;\n\t}\n\telse\n\t{\n\tend = mid - 1;\n\t}\n }\n return ans;\n}", "3374": "static void countSubarrays(int[] a, int n, int k)\n{\n\tint ans = 0;\n\tList<int> pref = new List<int>();\n\tpref.Add(0);\n\tfor(int i = 0; i < n; i++)\n\t\tpref.Add((a[i] + pref[i]) % k);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = i; j <= n; j++)\n\t\t{\n\t\t\tif ((pref[j] - pref[i - 1] + k) % k == j - i + 1)\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tConsole.WriteLine(ans);\n}", "3375": "static void countSubarrays(int []a, int n, int k)\n{\n Dictionary<int,\n\t\t\tint> cnt = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tint>();\n long ans = 0;\n List<int> pref = new List<int>();\n pref.Add(0);\n for(int i = 0; i < n; i++)\n\tpref.Add((a[i] + pref[i]) % k);\n cnt.Add(0, 1);\n for(int i = 1; i <= n; i++)\n {\n\tint remIdx = i - k;\n\tif (remIdx >= 0)\n\t{\n\tif (cnt.ContainsKey((pref[remIdx] - remIdx % k + k) % k))\n\t\tcnt[(pref[remIdx] - remIdx % k + k) % k] = cnt[(pref[remIdx] - remIdx % k + k) % k] - 1;\n\telse\n\t\tcnt.Add((pref[remIdx] - remIdx % k + k) % k, -1);\n\t}\n\tif (cnt.ContainsKey((pref[i] - i % k + k) % k))\n\tans += cnt[(pref[i] - i % k + k) % k];\n\tif (cnt.ContainsKey((pref[i] - i % k + k) % k))\n\tcnt[(pref[i] - i % k + k) % k] = cnt[(pref[i] - i % k + k) % k] + 1;\n\telse\n\tcnt.Add((pref[i] - i % k + k) % k, 1);\n }\n Console.WriteLine(ans);\n}", "3398": "static void countRows(int[,] mat)\n{\n int n = mat.GetLength(0);\n int m = mat.GetLength(1);\n int count = 0;\n int totalSum = 0;\n for (int i = 0; i < n; i++)\n {\n\tfor (int j = 0; j < m; j++)\n\t{\n\ttotalSum += mat[i, j];\n\t}\n }\n for (int i = 0; i < n; i++)\n {\n\tint currSum = 0;\n\tfor (int j = 0; j < m; j++)\n\t{\n\tcurrSum += mat[i, j];\n\t}\n\tif (currSum > totalSum - currSum)\n\tcount++;\n }\n Console.WriteLine(count);\n}", "3417": "static void isCrossed(String path)\n{\n\tif (path.Length == 0)\n\t\treturn;\n\tbool ans = false;\n\tHashSet<KeyValuePair<int, int>> mySet =\n\tnew HashSet<KeyValuePair<int, int>>();\n\tint x = 0, y = 0;\n\tmySet.Add(new KeyValuePair<int, int>(x, y));\n\tfor(int i = 0; i < path.Length; i++)\n\t{\n\t\tif (path[i] == 'N')\n\t\t\tmySet.Add(\n\t\t\t\tnew KeyValuePair<int, int>(x, y++));\n\t\tif (path[i] == 'S')\n\t\t\tmySet.Add(\n\t\t\t\tnew KeyValuePair<int, int>(x, y--));\n\t\tif (path[i] == 'E')\n\t\t\tmySet.Add(\n\t\t\t\tnew KeyValuePair<int, int>(x++, y));\n\t\tif (path[i] == 'W')\n\t\t\tmySet.Add(\n\t\t\t\tnew KeyValuePair<int, int>(x--, y));\n\t\tif (mySet.Contains(\n\t\t\t\tnew KeyValuePair<int, int>(x, y)))\n\t\t{\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ans)\n\t\tConsole.Write(\"Crossed\");\n\telse\n\t\tConsole.Write(\"Not Crossed\");\n}", "3427": "static int maxWidth(int N, int M, List<int> cost, List<List<int>> s)\n{\n\tList<List<int>> adj = new List<List<int>>();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tadj.Add(new List<int>());\n\t}\n\tfor(int i = 0; i < M; i++)\n\t{\n\t\tadj[s[i][0]].Add(s[i][1]);\n\t}\n\tint result = 0;\n\tQueue<int> q = new Queue<int>();\n\tq.Enqueue(0);\n\twhile (q.Count != 0)\n\t{\n\t\tint count = q.Count;\n\t\tresult = Math.Max(count, result);\n\t\twhile (count-- > 0)\n\t\t{\n\t\t\tint temp = q.Dequeue();\n\t\t\tfor(int i = 0; i < adj[temp].Count; i++)\n\t\t\t{\n\t\t\t\tq.Enqueue(adj[temp][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "3463": "static void SieveOfEratosthenes()\n{\n\tArray.Fill(isPrime, true);\n\tfor(int p = 2; p * p <= MAX; p++)\n\t{\n\t\tif (isPrime[p] == true)\n\t\t{\n\t\t\tfor(int i = p * p; i <= MAX; i += p)\n\t\t\t\tisPrime[i] = false;\n\t\t}\n\t}\n\tfor(int p = 2; p <= MAX; p++)\n\t\tif (isPrime[p])\n\t\t\tprimes.Add(p);\n}\nstatic int prime_search(ArrayList primes, int diff)\n{\n\tint low = 0;\n\tint high = primes.Count - 1;\n\tint res = -1;\n\twhile (low <= high)\n\t{\n\t\tint mid = (low + high) / 2;\n\t\tif ((int)primes[mid] == diff)\n\t\t{\n\t\t\treturn (int)primes[mid];\n\t\t}\n\t\telse if ((int)primes[mid] < diff)\n\t\t{\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres = (int)primes[mid];\n\t\t\thigh = mid - 1;\n\t\t}\n\t}\n\treturn res;\n}\nstatic int minCost(int []arr, int n)\n{\n\tSieveOfEratosthenes();\n\tint res = 0;\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tif (arr[i] < arr[i - 1])\n\t\t{\n\t\t\tint diff = arr[i - 1] - arr[i];\n\t\t\tint closest_prime = prime_search(primes, diff);\n\t\t\tres += closest_prime;\n\t\t\tarr[i] += closest_prime;\n\t\t}\n\t}\n\treturn res;\n}", "3464": "static Tuple<string, int> lexico_smallest(string s1, string s2)\n\t{\n\t\tDictionary<char, int> M = new Dictionary<char, int>();\n\t\tHashSet<char> S = new HashSet<char>();\n\t\tTuple<string, int> pr;\n\t\tfor (int i = 0; i <= s1.Length - 1; ++i) {\n\t\t\tif(M.ContainsKey(s1[i]))\n\t\t\t{\n\t\t\t\tM[s1[i]]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tM[s1[i]] = 1;\n\t\t\t}\n\t\t\tS.Add(s1[i]);\n\t\t}\n\t\tfor (int i = 0; i <= s2.Length - 1; ++i) {\n\t\t\tif(M.ContainsKey(s2[i]))\n\t\t\t{\n\t\t\t\tM[s2[i]]--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tM[s2[i]] = -1;\n\t\t\t}\n\t\t}\n\t\tchar c = s2[0];\n\t\tint index = 0;\n\t\tstring res = \"\";\n\t\tforeach(char x in S) {\n\t\t\tif (x != c) {\n\t\t\t\tfor (int i = 1; i <= M[x]; ++i) {\n\t\t\t\t\tres += x;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint j = 0;\n\t\t\t\tindex = res.Length;\n\t\t\t\twhile (s2[j] == x) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (s2[j] < c) {\n\t\t\t\t\tres += s2;\n\t\t\t\t\tfor (int i = 1; i <= M[x]; ++i) {\n\t\t\t\t\t\tres += x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int i = 1; i <= M[x]; ++i) {\n\t\t\t\t\t\tres += x;\n\t\t\t\t\t}\n\t\t\t\t\tindex += M[x];\n\t\t\t\t\tres += s2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = \"aageeksgghmnpt\";\n\t\tpr = new Tuple<string,int>(res, index);\n\t\treturn pr;\n\t}\nstatic string lexico_largest(string s1, string s2)\n\t{\n\t\tTuple<string, int> pr = lexico_smallest(s1, s2);\n\t\tstring d1 = \"\";\n\t\tfor (int i = pr.Item2 - 1; i >= 0; i--) {\n\t\t\td1 += pr.Item1[i];\n\t\t}\n\t\tstring d2 = \"\";\n\t\tfor (int i = pr.Item1.Length - 1; i >= pr.Item2 + s2.Length; --i) {\n\t\t\td2 += pr.Item1[i];\n\t\t}\n\t\tstring res = d2 + s2 + d1;\n\t\treturn res;\n\t}", "3468": "static void addEdge(List<int> []v, int x, int y)\n{\n\tv[x].Add(y);\n\tv[y].Add(x);\n}\nstatic void dfs(List<int> []tree, List<int> temp, int []ancestor, int u, int parent, int k)\n{\n\ttemp.Add(u);\n\tforeach(int i in tree[u])\n\t{\n\t\tif (i == parent)\n\t\t\tcontinue;\n\t\tdfs(tree, temp, ancestor, i, u, k);\n\t}\n\ttemp.RemoveAt(temp.Count - 1);\n\tif (temp.Count < k)\n\t{\n\t\tancestor[u] = -1;\n\t}\n\telse\n\t{\n\t\tancestor[u] = temp[temp.Count - k];\n\t}\n}\nstatic void KthAncestor(int N, int K, int E, int [,]edges)\n{\n\tList<int> []tree = new List<int>[N + 1];\n\tfor(int i = 0; i < tree.Length; i++)\n\t\ttree[i] = new List<int>();\n\tfor(int i = 0; i < E; i++)\n\t{\n\t\taddEdge(tree, edges[i, 0], edges[i, 1]);\n\t}\n\tList<int> temp = new List<int>();\n\tint []ancestor = new int[N + 1];\n\tdfs(tree, temp, ancestor, 1, 0, K);\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tConsole.Write(ancestor[i] + \" \");\n\t}\n}", "3471": "static void build(ArrayList sum, ArrayList a, int l, int r, int rt)\n{\n\tif (l == r)\n\t{\n\t\tsum[rt] = a[l - 1];\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tbuild(sum, a, l, m, rt << 1);\n\tbuild(sum, a, m + 1, r, rt << 1 1);\n}\nstatic void pushDown(ArrayList sum, ArrayList add, int rt, int ln, int rn)\n{\n\tif ((int)add[rt] != 0)\n\t{\n\t\tadd[rt << 1] = (int)add[rt << 1] +\n\t\t\t\t\t(int)add[rt];\n\t\tadd[rt << 1 1] = (int)add[rt << 1 1] +\n\t\t\t\t\t\t(int)add[rt];\n\t\tsum[rt << 1] = (int)sum[rt << 1] +\n\t\t\t\t\t(int)add[rt] * ln;\n\t\tsum[rt << 1 1] = (int)sum[rt << 1 1] +\n\t\t\t\t\t\t(int)add[rt] * rn;\n\t\tadd[rt] = 0;\n\t}\n}\nstatic void update(ArrayList sum, ArrayList add, int L, int R, int C, int l, int r, int rt)\n{\n\tif (L <= l && r <= R)\n\t{\n\t\tsum[rt] = (int)sum[rt] +\n\t\t\t\t\tC * (r - l + 1);\n\t\tadd[rt] = (int)add[rt] + C;\n\t\treturn;\n\t}\n\tint m = (l + r) >> 1;\n\tpushDown(sum, add, rt, m - l + 1, r - m);\n\tif (L <= m)\n\t\tupdate(sum, add, L, R, C, l, m, rt << 1);\n\tif (R > m)\n\t\tupdate(sum, add, L, R, C, m + 1, r, rt << 1 1);\n}\nstatic int query(ArrayList sum, ArrayList add, int L, int R, int l, int r, int rt)\n{\n\tif (L <= l && r <= R)\n\t{\n\t\treturn (int)sum[rt];\n\t}\n\tint m = (l + r) >> 1;\n\tpushDown(sum, add, rt, m - l + 1, r - m);\n\tint ans = 0;\n\tif (L <= m)\n\t\tans += query(sum, add, L, R, l, m, rt << 1);\n\tif (R > m)\n\t\tans += query(sum, add, L, R, m + 1, r, rt << 1 1);\n\treturn ans;\n}\nstatic void sequenceMaintenance(int n, int q, ArrayList a, ArrayList b, int m)\n{\n\ta.Sort();\n\tArrayList sum = new ArrayList();\n\tArrayList add = new ArrayList();\n\tArrayList ans = new ArrayList();\n\tfor(int i = 0; i < (n << 2); i++)\n\t{\n\t\tsum.Add(0);\n\t\tadd.Add(0);\n\t}\n\tbuild(sum, a, 1, n, 1);\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint l = 1, r = n, pos = -1;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tm = (l + r) >> 1;\n\t\t\tif (query(sum, add, m, m, 1, n, 1) >= (int)b[i])\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t\tpos = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1)\n\t\t\tans.Add(0);\n\t\telse\n\t\t{\n\t\t\tans.Add(n - pos + 1);\n\t\t\tupdate(sum, add, pos, n, -m, 1, n, 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < ans.Count; i++)\n\t{\n\t\tConsole.Write(ans[i] + \" \");\n\t}\n}", "3487": "static int count(String s)\n{\n\tint cnt = 0;\n\tforeach(char c in s.ToCharArray())\n\t{\n\t\tcnt += c == '0' ? 1 : 0;\n\t}\n\tif (cnt % 3 != 0)\n\t\treturn 0;\n\tint res = 0, k = cnt / 3, sum = 0;\n\tDictionary<int,\n\t\t\tint> map = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < s.Length; i++)\n\t{\n\t\tsum += s[i] == '0' ? 1 : 0;\n\t\tif (sum == 2 * k && map.ContainsKey(k) && i < s.Length - 1 && i > 0)\n\t\t{\n\t\t\tres += map[k];\n\t\t}\n\t\tif(map.ContainsKey(sum))\n\t\t\tmap[sum] = map[sum] + 1;\n\t\telse\n\t\t\tmap.Add(sum, 1);\n\t}\n\treturn res;\n}", "3488": "static int splitstring(string s)\n{\n\tint n = s.Length;\n\tint zeros = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tif (s[i] == '0')\n\t\t\tzeros++;\n\tif (zeros % 3 != 0)\n\t\treturn 0;\n\tif (zeros == 0)\n\t\treturn ((n - 1) * (n - 2)) / 2;\n\tint zerosInEachSubstring = zeros / 3;\n\tint waysOfFirstCut = 0;\n\tint waysOfSecondCut = 0;\n\tint count = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (s[i] == '0')\n\t\t\tcount++;\n\t\tif (count == zerosInEachSubstring)\n\t\t\twaysOfFirstCut++;\n\t\telse if (count == 2 * zerosInEachSubstring)\n\t\t\twaysOfSecondCut++;\n\t}\n\treturn waysOfFirstCut * waysOfSecondCut;\n}", "3495": "static bool check(String s, int k)\n{\n int n = s.Length;\n for (int i = 0; i < k; i++)\n {\n\tfor (int j = i; j < n; j += k)\n\t{\n\tif (s[i] != s[j])\n\t\treturn false;\n\t}\n }\n int c = 0;\n for (int i = 0; i < k; i++)\n {\n\tif (s[i] == '0')\n\tc++;\n\telse\n\tc--;\n }\n if (c == 0)\n\treturn true;\n else\n\treturn false;\n}", "3503": "static void addEdge(int a, int b)\n{\n tree[a].Add(b);\n tree[b].Add(a);\n}\nstatic void dfs(int x)\n{\n vis[x] = true;\n subtreeSize[x] = 1;\n foreach (int i in tree[x])\n {\n\tif (!vis[i])\n\t{\n\tdfs(i);\n\tsubtreeSize[x] += subtreeSize[i];\n\t}\n }\n}\nstatic void countPairs(int a, int b)\n{\n int sub = Math.Min(subtreeSize[a], subtreeSize[b]);\n Console.Write(sub * (n - sub) + \"\\n\");\n}", "3516": "static int revNum(int N)\n{\n\tint x = 0;\n\twhile (N != 0)\n\t{\n\t\tx = x * 10 + N % 10;\n\t\tN = N / 10;\n\t}\n\treturn x;\n}\nstatic int ctNonPalin(int[] arr, int N)\n{\n\tint Res = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tint x = revNum(arr[i]);\n\t\tif (x == arr[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(arr[i] % 10 == x % 10)\n\t\t\t\tRes += 1;\n\t\t}\n\t}\n\treturn Res;\n}", "3520": "static bool isSame(String str, int n)\n{\n\tDictionary<int,\n\t\t\tint> mp = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tfor (int i = 0; i < str.Length; i++)\n\t{\n\t\tif(mp.ContainsKey(str[i] - 'a'))\n\t\t{\n\t\t\tmp[str[i] - 'a'] =\n\t\t\t\tmp[str[i] - 'a'] + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.Add(str[i] - 'a', 1);\n\t\t}\n\t}\n\tforeach (KeyValuePair<int, int> it in mp)\n\t{\n\t\tif ((it.Value) >= n)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "3531": "static bool canTransform(string str1, string str2)\n{\n\tstring s1 = \"\";\n\tstring s2 = \"\";\n\tforeach(char c in str1.ToCharArray())\n\t{\n\t\tif (c != 'C')\n\t\t{\n\t\t\ts1 += c;\n\t\t}\n\t}\n\tforeach(char c in str2.ToCharArray())\n\t{\n\t\tif (c != 'C')\n\t\t{\n\t\t\ts2 += c;\n\t\t}\n\t}\n\tif (s1 != s2)\n\t\treturn false;\n\tint i = 0;\n\tint j = 0;\n\tint n = str1.Length;\n\twhile (i < n && j < n)\n\t{\n\t\tif (str1[i] == 'C')\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\telse if (str2[j] == 'C')\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((str1[i] == 'A' && i < j) ||\n\t\t\t\t(str1[i] == 'B' && i > j))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn true;\n}", "3540": "static double func(double a, double b, double c, double x)\n{\n\treturn a * x * x + b * x + c;\n}\nstatic double findRoot(double a, double b, double c, double low, double high)\n{\n\tdouble x = -1;\n\twhile (Math.Abs(high - low) > eps)\n\t{\n\t\tx = (low + high) / 2;\n\t\tif (func(a, b, c, low) *\n\t\t\tfunc(a, b, c, x) <= 0)\n\t\t{\n\t\t\thigh = x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlow = x;\n\t\t}\n\t}\n\treturn x;\n}\nstatic void solve(double a, double b, double c, double A, double B)\n{\n\tif (func(a, b, c, A) * func(a, b, c, B) > 0)\n\t{\n\t\tConsole.WriteLine(\"No solution\");\n\t}\n\telse\n\t{\n\t\tConsole.Write(\"{0:F4}\", findRoot( a, b, c, A, B));\n\t}\n}", "3550": "static int __gcd(int a, int b) \n{ \n\treturn b == 0 ? a : __gcd(b, a % b);\t\n}\nstatic bool hasCoprimePair(int []arr, int n)\n{\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif ((__gcd(arr[i], arr[j])) == 1)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}", "3555": "static int findPermutation(HashSet<int>arr, int N)\n{\n\tint pos = arr.Count + 1;\n\tif (pos > N)\n\t\treturn 1;\n\tint res = 0;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tif (! arr.Contains(i))\n\t\t{\n\t\t\tif (i % pos == 0 pos % i == 0)\n\t\t\t{\n\t\t\t\tarr.Add(i);\n\t\t\t\tres += findPermutation(arr, N);\n\t\t\t\tarr.Remove(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "3562": "static void solve(int []arr, int n, int X, int Y)\n{\n\tint diff = Y - X;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] != 1)\n\t\t{\n\t\t\tdiff = diff % (arr[i] - 1);\n\t\t}\n\t}\n\tif (diff == 0)\n\t\tConsole.Write(\"Yes\");\n\telse\n\t\tConsole.Write(\"No\");\n}", "3564": "static int Numberofways(int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int a = 1; a < n; a++) {\n\t\t\tfor (int b = 1; b < n; b++) {\n\t\t\t\tint c = n - (a + b);\n\t\t\t\tif (a + b > c && a + c > b && b + c > a) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "3567": "static int maxsubStringLength(char[] S, int N)\n{\n\tint []arr = new int[N];\n\tfor(int i = 0; i < N; i++)\n\tif (S[i] == 'a' S[i] == 'e' S[i] == 'i' S[i] == 'o' S[i] == 'u')\n\t\tarr[i] = 1;\n\telse\n\t\tarr[i] = -1;\n\tint maxLen = 0;\n\tint curr_sum = 0;\n\tDictionary<int,\n\t\t\t\tint> hash = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tcurr_sum += arr[i];\n\t\tif (curr_sum == 0)\n\t\t\tmaxLen = Math.Max(maxLen, i + 1);\n\t\tif (hash.ContainsKey(curr_sum))\n\t\t\tmaxLen = Math.Max(maxLen, i - hash[curr_sum]);\n\t\telse\n\t\t\thash.Add(curr_sum, i);\n\t}\n\treturn maxLen;\n}", "3584": "public static int findMaximumSum(int[] a, int n)\n{\n\tint []prev_smaller = findPrevious(a, n);\n\tint []next_smaller = findNext(a, n);\n\tint max_value = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\tmax_value = Math.Max(max_value,\n\t\t\t\ta[i] * (next_smaller[i] - prev_smaller[i] - 1));\n\t}\n\treturn max_value;\n}\npublic static int[] findPrevious(int[] a, int n)\n{\n\tint []ps = new int[n];\n\tps[0] = -1;\n\tStack<int> stack = new Stack<int>();\n\tstack.Push(0);\n\tfor (int i = 1; i < a.Length; i++)\n\t{\n\twhile (stack.Count > 0 &&\n\t\t\ta[stack.Peek()] >= a[i])\n\t\tstack.Pop();\n\tps[i] = stack.Count > 0 ? stack.Peek() : -1;\n\tstack.Push(i);\n\t}\n\treturn ps;\n}\npublic static int[] findNext(int[] a, int n)\n{\n\tint []ns = new int[n];\n\tns[n - 1] = n;\n\tStack<int> stack = new Stack<int>();\n\tstack.Push(n - 1);\n\tfor (int i = n - 2; i >= 0; i--)\n\t{\n\twhile (stack.Count > 0 &&\n\t\t\ta[stack.Peek()] >= a[i])\n\t\tstack.Pop();\n\tns[i] = stack.Count > 0 ? stack.Peek()\n\t\t: a.Length;\n\tstack.Push(i);\n\t}\n\treturn ns;\n}", "3601": "static bool possible(long mid, int[] a)\n{\n\tlong n = a.Length;\n\tlong total = (n * (n - 1)) / 2;\n\tlong need = (total + 1) / 2;\n\tlong count = 0;\n\tlong start = 0, end = 1;\n\twhile (end < n)\n\t{\n\t\tif (a[(int)end] - a[(int)start] <= mid)\n\t\t{\n\t\t\tend++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount += (end - start - 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\tif (end == n && start < end &&\n\t\ta[(int)end - 1] - a[(int)start] <= mid)\n\t{\n\t\tlong t = end - start - 1;\n\t\tcount += (t * (t + 1) / 2);\n\t}\n\tif (count >= need)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nstatic long findMedian(int[] a)\n{\n\tlong n = a.Length;\n\tlong low = 0, high = a[(int)n - 1] - a[0];\n\twhile (low <= high)\n\t{\n\t\tlong mid = (low + high) / 2;\n\t\tif (possible(mid, a))\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\treturn high + 1;\n}", "3605": "static void FindMinimumDistance()\n{\n\tQueue<pair> q = new Queue<pair>();\n\tq.Enqueue(new pair(x, y));\n\tmat[x, y] = 0;\n\twhile (q.Count != 0)\n\t{\n\t\tx = q.Peek().first;\n\t\ty = q.Peek().second;\n\t\tq.Dequeue();\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tint a = x + dx[i];\n\t\t\tint b = y + dy[i];\n\t\t\tif (a < 0 a >= r b >= c b < 0)\n\t\t\t\tcontinue;\n\t\t\tif (mat[a, b] == 0)\n\t\t\t{\n\t\t\t\tmat[a, b] = mat[x, y] + 1;\n\t\t\t\tq.Enqueue(new pair(a, b));\n\t\t\t}\n\t\t}\n\t}\n}", "3629": "static void addEdge(int u, int v)\n{\n\tadj[u].Add(v);\n\tadj[v].Add(u);\n}\nstatic void dfs1(int cur, int par)\n{\n\tforeach(int u in adj[cur])\n\t{\n\t\tif (u != par)\n\t\t{\n\t\t\tdfs1(u, cur);\n\t\t\theight[cur] = Math.Max(height[cur], height[u]);\n\t\t}\n\t}\n\theight[cur] += 1;\n}\nstatic void dfs2(int cur, int par)\n{\n\tint max1 = 0;\n\tint max2 = 0;\n\tforeach(int u in adj[cur])\n\t{\n\t\tif (u != par)\n\t\t{\n\t\t\tif (height[u] >= max1)\n\t\t\t{\n\t\t\t\tmax2 = max1;\n\t\t\t\tmax1 = height[u];\n\t\t\t}\n\t\t\telse if (height[u] > max2)\n\t\t\t{\n\t\t\t\tmax2 = height[u];\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tforeach(int u in adj[cur])\n\t{\n\t\tif (u != par)\n\t\t{\n\t\t\tsum = ((max1 == height[u]) ? max2 : max1);\n\t\t\tif (max1 == height[u])\n\t\t\t\tdist[u] = 1 + Math.Max(1 + max2, dist[cur]);\n\t\t\telse\n\t\t\t\tdist[u] = 1 + Math.Max(1 + max1, dist[cur]);\n\t\t\tdfs2(u, cur);\n\t\t}\n\t}\n}", "3644": "static void countPairs(int N, int[] arr)\n {\n\tint count = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\tif (i == arr[arr[i] - 1] - 1)\n\t{\n\t\tcount++;\n\t}\n\t}\n\tConsole.Write(count / 2);\n }", "3664": "public static int minOperations(String S, int K)\n{\n\tint ans = 0;\n\tfor(int i = 0; i < K; i++)\n\t{\n\t\tint zero = 0, one = 0;\n\t\tfor(int j = i; j < S.Length; j += K)\n\t\t{\n\t\t\tif (S[j] == '0')\n\t\t\t\tzero++;\n\t\t\telse\n\t\t\t\tone++;\n\t\t}\n\t\tans += Math.Min(zero, one);\n\t}\n\treturn ans;\n}", "3678": "static void UniversalSubset(List<String> A, List<String> B)\n{\n\tint n1 = A.Count;\n\tint n2 = B.Count;\n\tList<String> res = new List<String>();\n\tint[,] A_fre = new int[n1, 26];\n\tfor(int i = 0; i < n1; i++)\n\t{\n\t\tfor(int j = 0; j < 26; j++)\n\t\t\tA_fre[i, j] = 0;\n\t}\n\tfor(int i = 0; i < n1; i++)\n\t{\n\t\tfor(int j = 0; j < A[i].Length; j++)\n\t\t{\n\t\t\tA_fre[i, A[i][j] - 'a']++;\n\t\t}\n\t}\n\tint[] B_fre = new int[26];\n\tfor(int i = 0; i < n2; i++)\n\t{\n\t\tint[] arr = new int[26];\n\t\tfor(int j = 0; j < B[i].Length; j++)\n\t\t{\n\t\t\tarr[B[i][j] - 'a']++;\n\t\t\tB_fre[B[i][j] - 'a'] = Math.Max( B_fre[B[i][j] - 'a'], arr[B[i][j] - 'a']);\n\t\t}\n\t}\n\tfor(int i = 0; i < n1; i++)\n\t{\n\t\tint flag = 0;\n\t\tfor(int j = 0; j < 26; j++)\n\t\t{\n\t\t\tif (A_fre[i, j] < B_fre[j])\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0)\n\t\t\tres.Add(A[i]);\n\t}\n\tif (res.Count != 0)\n\t{\n\t\tfor(int i = 0; i < res.Count; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < res[i].Length; j++)\n\t\t\t\tConsole.Write(res[i][j]);\n\t\t}\n\t\tConsole.Write(\" \");\n\t}\n\telse\n\t\tConsole.Write(\"-1\");\n}", "3692": "public static void findPair(int []a, int n)\n{\n\tint min_dist = int.MaxValue;\n\tint index_a = -1, index_b = -1;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (j - i < min_dist)\n\t\t\t{\n\t\t\t\tif (a[i] % a[j] == 0 a[j] % a[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tmin_dist = j - i;\n\t\t\t\t\tindex_a = i;\n\t\t\t\t\tindex_b = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (index_a == -1)\n\t{\n\t\tConsole.WriteLine(\"-1\");\n\t}\n\telse\n\t{\n\t\tConsole.Write(\"(\" + a[index_a] + \", \" + a[index_b] + \")\");\n\t}\n}", "3704": "static void printNum(int L, int R)\n{\n\tfor(int i = L; i <= R; i++)\n\t{\n\t\tint temp = i;\n\t\tint c = 10;\n\t\tint flag = 0;\n\t\twhile (temp > 0)\n\t\t{\n\t\t\tif (temp % 10 >= c)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = temp % 10;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tif (flag == 0)\n\t\t\tConsole.Write(i + \" \");\n\t}\n}", "3742": "static int findMissing(int []arr, int left, int right, int diff)\n{\n\tif (right <= left)\n\t\treturn 0;\n\tint mid = left + (right - left) / 2;\n\tif (arr[mid + 1] - arr[mid] != diff)\n\t\treturn (arr[mid] + diff);\n\tif (mid > 0 && arr[mid] - arr[mid - 1] != diff)\n\t\treturn (arr[mid - 1] + diff);\n\tif (arr[mid] == arr[0] + mid * diff)\n\t\treturn findMissing(arr, mid + 1, right, diff);\n\treturn findMissing(arr, left, mid - 1, diff);\n}\nstatic int missingElement(int []arr, int n)\n{\n\tArray.Sort(arr);\n\tint diff = (arr[n - 1] - arr[0]) / n;\n\treturn findMissing(arr, 0, n - 1, diff);\n}", "3743": "static int missingElement(int[] arr, int n)\n{\n\tint max_ele = arr[0];\n\tint min_ele = arr[0];\n\tint x = 0;\n\tint d;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tif (arr[i] > max_ele)\n\t\tmax_ele = arr[i];\n\tif (arr[i] < min_ele)\n\t\tmin_ele = arr[i];\n\t}\n\td = (max_ele - min_ele) / n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\tx = x ^ arr[i];\n\t}\n\tfor(int i = 0; i <= n; i++)\n\t{\n\tx = x ^ (min_ele + (i * d));\n\t}\n\treturn x;\n}", "3752": "static int power(int x, int y)\n{\n\tint temp;\n\tif (y == 0)\n\t\treturn 1;\n\ttemp = power(x, y / 2);\n\tif (y % 2 == 0)\n\t\treturn temp * temp;\n\telse\n\t\treturn x * temp * temp;\n}\nstatic int nthRootSearch(int low, int high, int N, int K)\n{\n\tif (low <= high)\n\t{\n\t\tint mid = (low + high) / 2;\n\t\tif ((power(mid, K) <= N) &&\n\t\t\t(power(mid + 1, K) > N))\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\telse if (power(mid, K) < N)\n\t\t{\n\t\t\treturn nthRootSearch(mid + 1, high, N, K);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn nthRootSearch(low, mid - 1, N, K);\n\t\t}\n\t}\n\treturn low;\n}", "3755": "static int get_subset_count(int []arr, int K, int N)\n{\n\tArray.Sort(arr);\n\tint left, right;\n\tleft = 0;\n\tright = N - 1;\n\tint ans = 0;\n\twhile (left <= right)\n\t{\n\t\tif (arr[left] + arr[right] < K)\n\t\t{\n\t\t\tans += 1 << (right - left);\n\t\t\tleft++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tright--;\n\t\t}\n\t}\n\treturn ans;\n}", "3765": "static int minMaxDiff(int []arr, int n, int k)\n{\n\tint max_adj_dif = int.MinValue;\n\tfor(int i = 0; i < n - 1; i++)\n\t\tmax_adj_dif = Math.Max(max_adj_dif,\n\t\t\t\t\tMath.Abs(arr[i] - arr[i + 1]));\n\tif (max_adj_dif == 0)\n\t\treturn 0;\n\tint best = 1;\n\tint worst = max_adj_dif;\n\tint mid, required;\n\twhile (best < worst)\n\t{\n\t\tmid = (best + worst) / 2;\n\t\trequired = 0;\n\t\tfor(int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\trequired += (Math.Abs(arr[i] - arr[i + 1]) - 1) / mid;\n\t\t}\n\t\tif (required > k)\n\t\t\tbest = mid + 1;\n\t\telse\n\t\t\tworst = mid;\n\t}\n\treturn worst;\n}", "3773": "static void checkMin(int []arr, int len)\n{\n\tint smallest = int.MaxValue;\n\tint secondSmallest = int.MaxValue;\n\tfor(int i = 0; i < len; i++)\n\t{\n\tif (arr[i] < smallest)\n\t{\n\t\tsecondSmallest = smallest;\n\t\tsmallest = arr[i];\n\t}\n\telse if (arr[i] < secondSmallest)\n\t{\n\t\tsecondSmallest = arr[i];\n\t}\n\t}\n\tif (2 * smallest <= secondSmallest)\n\t\tConsole.Write(\"Yes\");\n\telse\n\t\tConsole.Write(\"No\");\n}", "3798": "static void createHash(HashSet<int> hash, int maxElement)\n{\n\tint prev = 0, curr = 1;\n\thash.Add(prev);\n\thash.Add(curr);\n\twhile (curr <= maxElement) {\n\t\tint temp = curr + prev;\n\t\thash.Add(temp);\n\t\tprev = curr;\n\t\tcurr = temp;\n\t}\n}\nstatic void fibonacci(int []arr, int n)\n{\n\tint max_val= arr.Max();\n\tHashSet<int> hash = new HashSet<int>();\n\tcreateHash(hash, max_val);\n\tint minimum = int.MaxValue;\n\tint maximum = int.MinValue;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (hash.Contains(arr[i])) {\n\t\t\tminimum = Math.Min(minimum, arr[i]);\n\t\t\tmaximum = Math.Max(maximum, arr[i]);\n\t\t}\n\t}\n\tConsole.Write(minimum+ \", \" + maximum +\"\\n\");\n}", "3814": "static bool isValidLen(String s, int len, int k)\n\t{\n\t\tint n = s.Length;\n\t\tDictionary<char,\n\t\t\t\tint> mp = new Dictionary<char,\n\t\t\t\t\t\t\t\t\t\t\tint>();\n\t\tint right = 0;\n\t\twhile (right < len)\n\t\t{\n\t\t\tif (mp.ContainsKey(s[right]))\n\t\t\t{\n\t\t\t\tmp[s[right]] = mp[s[right]] + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.Add(s[right], 1);\n\t\t\t}\n\t\t\tright++;\n\t\t}\n\t\tif (mp.Count <= k)\n\t\t\treturn true;\n\t\twhile (right < n)\n\t\t{\n\t\t\tif (mp.ContainsKey(s[right]))\n\t\t\t{\n\t\t\t\tmp[s[right]] = mp[s[right]] + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.Add(s[right], 1);\n\t\t\t}\n\t\t\tif (mp.ContainsKey(s[right - len]))\n\t\t\t{\n\t\t\t\tmp[s[right - len]] = mp[s[right - len]] - 1;\n\t\t\t}\n\t\t\tif (mp[s[right - len]] == 0)\n\t\t\t\tmp.Remove(s[right - len]);\n\t\t\tif (mp.Count <= k)\n\t\t\t\treturn true;\n\t\t\tright++;\n\t\t}\n\t\treturn mp.Count <= k;\n\t}\nstatic int maxLenSubStr(String s, int k)\n\t{\n\t\tHashSet<char> uni = new HashSet<char>();\n\t\tforeach (char x in s.ToCharArray())\n\t\t\tuni.Add(x);\n\t\tif (uni.Count < k)\n\t\t\treturn -1;\n\t\tint n = s.Length;\n\t\tint lo = -1, hi = n + 1;\n\t\twhile (hi - lo > 1)\n\t\t{\n\t\t\tint mid = lo + hi >> 1;\n\t\t\tif (isValidLen(s, mid, k))\n\t\t\t\tlo = mid;\n\t\t\telse\n\t\t\t\thi = mid;\n\t\t}\n\t\treturn lo;\n\t}", "3822": "static bool isSquarePossible(int []arr, int n, int l)\n\t{\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] >= l)\n\t\t\t\tcnt++;\n\t\t\tif (cnt >= l)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\nstatic int maxArea(int []arr, int n)\n\t{\n\t\tint l = 0, r = n;\n\t\tint len = 0;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint m = l + ((r - l) / 2);\n\t\t\tif (isSquarePossible(arr, n, m))\n\t\t\t{\n\t\t\t\tlen = m;\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tr = m - 1;\n\t\t}\n\t\treturn (len * len);\n\t}", "3825": "static bool kOverlap(List<Tuple<int,int>> pairs, int k)\n{\n\tList<Tuple<int,int>> vec = new List<Tuple<int,int>>();\n\tfor(int i = 0; i < pairs.Count; i++)\n\t{\n\t\tvec.Add(new Tuple<int,int>(pairs[i].Item1,-1));\n\t\tvec.Add(new Tuple<int,int>(pairs[i].Item2,1));\n\t}\n\tvec.Sort();\n\tStack st = new Stack();\n\tfor(int i = 0; i < vec.Count; i++)\n\t{\n\t\tTuple<int,int> cur = vec[i];\n\t\tif (cur.Item2 == -1)\n\t\t{\n\t\t\tst.Push(cur);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tst.Pop();\n\t\t}\n\t\tif (st.Count >= k)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "3829": "static void insertNames(String []arr, int n)\n{\n\tHashSet<String> set = new HashSet<String>();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (!set.Contains(arr[i]))\n\t\t{\n\t\t\tConsole.Write(\"No\\n\");\n\t\t\tset.Add(arr[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConsole.Write(\"Yes\\n\");\n\t\t}\n\t}\n}", "3871": "static int countLessThan(int []arr, int n, int key)\n\t{\n\t\tint l = 0, r = n - 1;\n\t\tint index = -1;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (arr[m] < key)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t\tindex = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t}\n\t\t}\n\t\treturn (index + 1);\n\t}\nstatic int countGreaterThan(int []arr, int n, int key)\n\t{\n\t\tint l = 0, r = n - 1;\n\t\tint index = -1;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (arr[m] <= key)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t\tindex = m;\n\t\t\t}\n\t\t}\n\t\tif (index == -1)\n\t\t\treturn 0;\n\t\treturn (n - index);\n\t}\nstatic int countTriplets(int n, int []a, int []b, int []c)\n\t{\n\t\tArray.Sort(a) ;\n\t\tArray.Sort(b);\n\t\tArray.Sort(c);\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint current = b[i];\n\t\t\tint low = countLessThan(a, n, current);\n\t\t\tint high = countGreaterThan(c, n, current);\n\t\t\tcount += (low * high);\n\t\t}\n\t\treturn count;\n\t}", "3885": "static void Printksubstring(String str, int n, int k)\n\t{\n\t\tint total = (n * (n + 1)) / 2;\n\t\tif (k > total)\n\t\t{\n\t\t\tConsole.Write(\"-1\\n\");\n\t\t\treturn;\n\t\t}\n\t\tint []substring = new int[n + 1];\n\t\tsubstring[0] = 0;\n\t\tint temp = n;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tsubstring[i] = substring[i - 1] + temp;\n\t\t\ttemp--;\n\t\t}\n\t\tint l = 1;\n\t\tint h = n;\n\t\tint start = 0;\n\t\twhile (l <= h)\n\t\t{\n\t\t\tint m = (l + h) / 2;\n\t\t\tif (substring[m] > k)\n\t\t\t{\n\t\t\t\tstart = m;\n\t\t\t\th = m - 1;\n\t\t\t}\n\t\t\telse if (substring[m] < k)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint end = n - (substring[start] - k);\n\t\tfor (int i = start - 1; i < end; i++)\n\t\t{\n\t\t\tConsole.Write(str[i]);\n\t\t}\n\t}", "3932": "static int LowerInsertionPoint(int []arr, int n, int X)\n\t{\n\tif (X < arr[0])\n\t\treturn 0;\n\telse if (X > arr[n - 1])\n\t\treturn n;\n\tint lowerPnt = 0;\n\tint i = 1;\n\twhile (i < n && arr[i] < X) {\n\t\tlowerPnt = i;\n\t\ti = i * 2;\n\t}\n\twhile (lowerPnt < n && arr[lowerPnt] < X)\n\t\tlowerPnt++;\n\treturn lowerPnt;\n\t}", "3967": "static int LongestFibSubseq(int []A, int n)\n\t{\n\t\tSortedSet<int> S = new SortedSet<int>();\n\t\tforeach (int t in A)\n\t\t{\n\t\t\tS.Add(t);\n\t\t}\n\t\tint maxLen = 0, x, y;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\t{\n\t\t\t\tx = A[j];\n\t\t\t\ty = A[i] + A[j];\n\t\t\t\tint length = 3;\n\t\t\t\twhile (S.Contains(y) && y != last(S))\n\t\t\t\t{\n\t\t\t\t\tint z = x + y;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = z;\n\t\t\t\t\tmaxLen = Math.Max(maxLen, ++length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxLen >= 3 ? maxLen : 0;\n\t}\nstatic int last(SortedSet<int> S)\n\t{\n\t\tint ans = 0;\n\t\tforeach(int a in S)\n\t\t\tans = a;\n\t\treturn ans;\n\t}", "4039": "static int getCount(int M, int N)\n\t{\n\t\tint count = 0;\n\t\tif (M == 1)\n\t\t\treturn N;\n\t\tif (N == 1)\n\t\t\treturn M;\n\t\tif (N > M) {\n\t\t\tfor (int i = 1; i <= M; i++) {\n\t\t\t\tint numerator = N * i - N + M - i;\n\t\t\t\tint denominator = M - 1;\n\t\t\t\tif (numerator % denominator == 0) {\n\t\t\t\t\tint j = numerator / denominator;\n\t\t\t\t\tif (j >= 1 && j <= N)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tint numerator = M * j - M + N - j;\n\t\t\t\tint denominator = N - 1;\n\t\t\t\tif (numerator % denominator == 0) {\n\t\t\t\t\tint i = numerator / denominator;\n\t\t\t\t\tif (i >= 1 && i <= M)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "4048": "static bool swapElement(int[] arr1, int[] arr2, int n)\n{\n\tint wrongIdx = 0;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (arr1[i] < arr1[i - 1])\n\t\t{\n\t\t\twrongIdx = i;\n\t\t}\n\t}\n\tint maximum = int.MinValue;\n\tint maxIdx = -1;\n\tbool res = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr2[i] > maximum && arr2[i] >= arr1[wrongIdx - 1])\n\t\t{\n\t\t\tif (wrongIdx + 1 <= n - 1 && arr2[i] <= arr1[wrongIdx + 1])\n\t\t\t{\n\t\t\t\tmaximum = arr2[i];\n\t\t\t\tmaxIdx = i;\n\t\t\t\tres = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (res)\n\t{\n\t\tswap(arr1, wrongIdx, arr2, maxIdx);\n\t}\n\treturn res;\n}\nstatic void swap(int[] a, int wrongIdx, int[] b, int maxIdx)\n{\n\tint c = a[wrongIdx];\n\ta[wrongIdx] = b[maxIdx];\n\tb[maxIdx] = c;\n}\nstatic void getSortedArray(int []arr1, int []arr2, int n)\n{\n\tif (swapElement(arr1, arr2, n))\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tConsole.Write(arr1[i] + \" \");\n\t\t}\n\t}\n\telse\n\t{\n\t\tConsole.Write(\"Not Possible\");\n\t}\n}", "4052": "static int costToBalance(string s)\n\t{\n\t\tif (s.Length == 0)\n\t\t\tConsole.WriteLine(0);\n\t\tint ans = 0;\n\t\tint o = 0, c = 0;\n\t\tfor (int i = 0; i < s.Length; i++)\n\t\t{\n\t\t\tif (s[i] == '(')\n\t\t\t\to++;\n\t\t\tif (s[i] == ')')\n\t\t\t\tc++;\n\t\t}\n\t\tif (o != c)\n\t\t\treturn -1;\n\t\tint []a = new int[s.Length];\n\t\tif (s[0] == '(')\n\t\t\ta[0] = 1;\n\t\telse\n\t\t\ta[0] = -1;\n\t\tif (a[0] < 0)\n\t\t\tans += Math.Abs(a[0]);\n\t\tfor (int i = 1; i < s.Length; i++)\n\t\t{\n\t\t\tif (s[i] == '(')\n\t\t\t\ta[i] = a[i - 1] + 1;\n\t\t\telse\n\t\t\t\ta[i] = a[i - 1] - 1;\n\t\t\tif (a[i] < 0)\n\t\t\t\tans += Math.Abs(a[i]);\n\t\t}\n\t\treturn ans;\n\t}", "4079": "public static int middleOfThree(int a, int b, int c)\n\t{\n\t\tif ((a < b && b < c) || (c < b && b < a))\n\t\t\treturn b;\n\t\telse if ((b < a && a < c) || (c < a && a < b))\n\t\treturn a;\n\t\telse\n\t\treturn c;\n\t}", "4080": "public static int middleOfThree(int a, int b, int c)\n\t{\n\t\tif (a > b)\n\t\t{\n\t\t\tif (b > c)\n\t\t\t\treturn b;\n\t\t\telse if (a > c)\n\t\t\t\treturn c;\n\t\t\telse\n\t\t\t\treturn a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a > c)\n\t\t\t\treturn a;\n\t\t\telse if (b > c)\n\t\t\t\treturn c;\n\t\t\telse\n\t\t\t\treturn b;\n\t\t}\n\t}", "4081": "public static int middleOfThree(int a, int b, int c)\n\t{\n\t\tint x = a - b;\n\t\tint y = b - c;\n\t\tint z = a - c;\n\t\tif (x * y > 0)\n\t\t\treturn b;\n\t\telse if (x * z > 0)\n\t\t\treturn c;\n\t\telse\n\t\t\treturn a;\n\t}", "4099": "public static void missing4(int[] arr)\n\t{\n\t\tint[] helper = new int[4];\n\t\tfor (int i = 0; i < arr.Length; i++) {\n\t\t\tint temp = Math.Abs(arr[i]);\n\t\t\tif (temp <= arr.Length)\n\t\t\t\tarr[temp - 1] *= (-1);\n\t\t\telse if (temp > arr.Length) {\n\t\t\t\tif (temp % arr.Length != 0)\n\t\t\t\t\thelper[temp % arr.Length - 1] = -1;\n\t\t\t\telse\n\t\t\t\t\thelper[(temp % arr.Length) + arr.Length - 1] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < arr.Length; i++)\n\t\t\tif (arr[i] > 0)\n\t\t\t\tConsole.Write(i + 1 + \" \");\t\n\t\tfor (int i = 0; i < helper.Length; i++)\n\t\t\tif (helper[i] >= 0)\n\t\t\t\tConsole.Write(arr.Length + i + 1 + \" \");\t\t\n\t\treturn;\n\t}", "4129": "static void lexiMiddleSmallest(int K, int N)\n\t{\n\t\tif (K % 2 == 0) {\n\t\t\tConsole.Write(K / 2 + \" \");\n\t\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\t\tConsole.Write(K + \" \");\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\treturn;\n\t\t}\n\t\tList<int> a = new List<int>();\n\t\tfor (int i = 0; i < N / 2; ++i) {\n\t\t\tif (a[a.Count - 1] == 1) {\n\t\t\t\ta.Remove(a.Count - 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[a.Count - 1] -= 1;\n\t\t\t\twhile ((int)a.Count < N) {\n\t\t\t\t\ta.Add(K);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tforeach(int i in a) { Console.Write(i + \" \"); }\n\t\tConsole.WriteLine();\n\t}", "4169": "static void largestArea(int N, int M, int[] H, int[] V)\n\t{\n\t\tHashSet<int> s1 = new HashSet<int>();\n\t\tHashSet<int> s2 = new HashSet<int>();\n\t\tfor (int i = 1; i <= N + 1; i++)\n\t\t\ts1.Add(i);\n\t\tfor (int i = 1; i <= M + 1; i++)\n\t\t\ts2.Add(i);\n\t\tfor (int i = 0; i < H.Length; i++) {\n\t\t\ts1.Remove(H[i]);\n\t\t}\n\t\tfor (int i = 0; i < V.Length; i++) {\n\t\t\ts2.Remove(V[i]);\n\t\t}\n\t\tint[] list1 = new int[s1.Count];\n\t\tint[] list2 = new int[s2.Count];\n\t\tint I = 0;\n\t\tforeach(int it1 in s1)\n\t\t{\n\t\t\tlist1[I++] = it1;\n\t\t}\n\t\tI = 0;\n\t\tforeach(int it2 in s2)\n\t\t{\n\t\t\tlist2[I++] = it2;\n\t\t}\n\t\tArray.Sort(list1);\n\t\tArray.Sort(list2);\n\t\tint maxH = 0, p1 = 0, maxV = 0, p2 = 0;\n\t\tfor (int j = 0; j < list1.Length; j++) {\n\t\t\tmaxH = Math.Max(maxH, list1[j] - p1);\n\t\t\tp1 = list1[j];\n\t\t}\n\t\tfor (int j = 0; j < list2.Length; j++) {\n\t\t\tmaxV = Math.Max(maxV, list2[j] - p2);\n\t\t\tp2 = list2[j];\n\t\t}\n\t\tConsole.WriteLine(maxV * maxH);\n\t}", "4179": "static void findLastElement(int []arr, int N)\n {\n\tArray.Sort(arr);\n\tint i = 0;\n\tfor (i = 1; i < N; i++)\n\t{\n\tif (arr[i] - arr[i - 1] != 0 && arr[i] - arr[i - 1] != 2)\n\t{\n\t\tConsole.WriteLine(\"-1\");\n\t\treturn;\n\t}\n\t}\n\tConsole.WriteLine(arr[N - 1]);\n }", "4185": "static bool checkifSorted(int []A, int []B, int N)\n\t{\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\tif (A[i] > A[i + 1]) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) {\n\t\t\treturn true;\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (B[i] == 0) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (B[i] == 1)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (count == 2)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "4186": "static void maxDivisions(int[] arr, int N, int X)\n {\n\tArray.Sort(arr);\n\tArray.Reverse(arr);\n\tint maxSub = 0;\n\tint size = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\tsize++;\n\tif (arr[i] * size >= X)\n\t{\n\t\tmaxSub++;\n\t\tsize = 0;\n\t}\n\t}\n\tConsole.WriteLine(maxSub);\n }", "4194": "public static void maxPossibleSum(int[] arr, int N)\n {\n\tArray.Sort(arr);\n\tint sum = 0;\n\tint j = N - 3;\n\twhile (j >= 0)\n\t{\n\tsum += arr[j];\n\tj -= 3;\n\t}\n\tConsole.WriteLine(sum);\n }", "4197": "static int minSteps(StringBuilder A, StringBuilder B, int M, int N)\n {\n\tif (A[0] > B[0])\n\treturn 0;\n\tif (B[0] > A[0])\n\t{\n\treturn 1;\n\t}\n\tif (M <= N && A[0] == B[0]\n\t\t&& count(A, A[0]) == M\n\t\t&& count(B, B[0]) == N)\n\treturn -1;\n\tfor (int i = 1; i < N; i++)\n\t{\n\tif (B[i] > B[0])\n\t\treturn 1;\n\t}\n\tfor (int i = 1; i < M; i++)\n\t{\n\tif (A[i] < A[0])\n\t\treturn 1;\n\t}\n\tfor (int i = 1; i < M; i++)\n\t{\n\tif (A[i] > A[0])\n\t{\n\t\tswap(A, i, B, 0);\n\t\tswap(A, 0, B, 0);\n\t\treturn 2;\n\t}\n\t}\n\tfor (int i = 1; i < N; i++)\n\t{\n\tif (B[i] < B[0])\n\t{\n\t\tswap(A, 0, B, i);\n\t\tswap(A, 0, B, 0);\n\t\treturn 2;\n\t}\n\t}\n\treturn 0;\n }\nstatic int count(StringBuilder a, char c)\n {\n\tint count = 0;\n\tfor(int i = 0; i < a.Length; i++)\n\tif(a[i] == c)\n\t\tcount++; \n\treturn count; \n }\nstatic void swap(StringBuilder s1, int index1, StringBuilder s2, int index2)\n {\n\tchar c = s1[index1];\n\ts1[index1] = s2[index2];\n\ts2[index2] = c;\n }", "4209": "static int CountMaximum(int[] arr, int n, int k)\n {\n\tArray.Sort(arr);\n\tint sum = 0, count = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\tsum += arr[i];\n\tif (sum > k)\n\t\tbreak;\n\tcount++;\n\t}\n\treturn count;\n }", "4210": "static int CountMaximum(int[] arr, int n, int k)\n {\n\tArray.Sort(arr);\n\tint sum = 0, count = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\tsum += arr[i];\n\tif (sum > k)\n\t\tbreak;\n\tcount++;\n\t}\n\treturn count;\n }", "4219": "static void insertionSort(int[] arr, int n)\n\t{\n\t\tint i, key, j;\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tkey = arr[i];\n\t\t\tj = i - 1;\n\t\t\twhile (j >= 0 && arr[j] > key)\n\t\t\t{\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tj = j - 1;\n\t\t\t}\n\t\t\tarr[j + 1] = key;\n\t\t}\n\t}\nstatic void printArray(int[] arr, int n)\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\t}\n\t\tConsole.WriteLine();\n\t}", "4220": "static void selectionSort(int []arr, int n)\n{\n\tint i, j, min_idx;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tmin_idx = i;\n\t\tfor (j = i + 1; j < n; j++)\n\t\t\tif (arr[j] < arr[min_idx])\n\t\t\t\tmin_idx = j;\n\t\tint temp = arr[min_idx];\n\t\tarr[min_idx]= arr[i];\n\t\tarr[i] = temp;\n\t}\n}\nstatic void printArray(int []arr, int size)\n{\n\tint i;\n\tfor (i = 0; i < size; i++) {\n\t\tConsole.Write(arr[i]+ \" \");\n\t}\n\tConsole.WriteLine();\n}", "4237": "static void getPairs(int []arr, int N, int K)\n{\n\tint count = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (arr[i] > K * arr[i + 1])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tConsole.Write(count);\n}", "4238": "static int merge(int[] arr, int[] temp, int l, int m, int r, int K)\n {\n\tint i = l;\n\tint j = m + 1;\n\tint cnt = 0;\n\tfor (i = l; i <= m; i++) {\n\tbool found = false;\n\twhile (j <= r) {\n\t\tif (arr[i] >= K * arr[j]) {\n\t\tfound = true;\n\t\t}\n\t\telse\n\t\tbreak;\n\t\tj++;\n\t}\n\tif (found == true) {\n\t\tcnt += j - (m + 1);\n\t\tj--;\n\t}\n\t}\n\tint k = l;\n\ti = l;\n\tj = m + 1;\n\twhile (i <= m && j <= r)\n\t{\n\tif (arr[i] <= arr[j])\n\t\ttemp[k++] = arr[i++];\n\telse\n\t\ttemp[k++] = arr[j++];\n\t}\n\twhile (i <= m)\n\ttemp[k++] = arr[i++];\n\twhile (j <= r)\n\ttemp[k++] = arr[j++];\n\tfor (i = l; i <= r; i++)\n\tarr[i] = temp[i];\n\treturn cnt;\n }\nstatic int mergeSortUtil(int[] arr, int[] temp, int l, int r, int K)\n {\n\tint cnt = 0;\n\tif (l < r) {\n\tint m = (l + r) / 2;\n\tcnt += mergeSortUtil(arr, temp, l, m, K);\n\tcnt += mergeSortUtil(arr, temp, m + 1, r, K);\n\tcnt += merge(arr, temp, l, m, r, K);\n\t}\n\treturn cnt;\n }\nstatic void mergeSort(int[] arr, int N, int K)\n {\n\tint[] temp = new int[N];\n\tConsole.WriteLine(\n\tmergeSortUtil(arr, temp, 0, N - 1, K));\n }", "4249": "static void minRemovals(int []A, int N)\n\t{\n\t\tArray.Sort(A);\n\t\tint mx = A[N - 1];\n\t\tint sum = 1;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tsum += A[i];\n\t\t}\n\t\tif (sum - mx >= mx) \n\t\t{\n\t\t\tConsole.WriteLine(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConsole.WriteLine(2 * mx - sum);\n\t\t}\n\t}", "4250": "static void rearrangeArray(int []a, int n)\n{\n\tArray.Sort(a);\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tif (a[i] == i + 1)\n\t\t{\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[i + 1];\n\t\t\ta[i + 1] = temp;\n\t\t}\n\t}\n\tif (a[n - 1] == n)\n\t{\n\t\tint temp = a[n - 1];\n\t\ta[n - 1] = a[n - 2];\n\t\ta[n - 2] = temp;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tConsole.Write(a[i] + \" \");\n\t}\n}", "4256": "static bool checkStr1CanConStr2(String str1, String str2)\n{\n\tint N = str1.Length;\n\tint M = str2.Length;\n\tHashSet<int> st1 = new HashSet<int>();\n\tHashSet<int> st2 = new HashSet<int>();\n\tint []hash1 = new int[256];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\thash1[str1[i]]++;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tst1.Add(str1[i]);\n\t}\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tst2.Add(str2[i]);\n\t}\n\tif (st1.Equals(st2))\n\t{\n\t\treturn false;\n\t}\n\tint []hash2 = new int[256];\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\thash2[str2[i]]++;\n\t}\n\tArray.Sort(hash1);\n\tArray.Sort(hash2);\n\tfor (int i = 0; i < 256; i++)\n\t{\n\t\tif (hash1[i] != hash2[i])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "4305": "static int minOperations(int[] arr1, int[] arr2, int i, int j)\n{\n\tif (arr1.Equals(arr2))\n\t\treturn 0;\n\tif (i >= arr1.Length j >= arr2.Length)\n\t\treturn 0;\n\tif (arr1[i] < arr2[j])\n\t\treturn 1 + minOperations(arr1, arr2, i + 1, j + 1);\n\treturn Math.Max(minOperations(arr1, arr2, i, j + 1),\n\t\t\t\t\tminOperations(arr1, arr2, i + 1, j));\n}\nstatic void minOperationsUtil(int[] arr)\n{\n\tint[] brr = new int[arr.Length];\n\tfor(int i = 0; i < arr.Length; i++)\n\t\tbrr[i] = arr[i];\n\tArray.Sort(brr);\n\tif (arr.Equals(brr))\n\t\tConsole.Write(\"0\");\n\telse\n\t\tConsole.WriteLine(minOperations(arr, brr, 0, 0));\n}", "4310": "static void canTransform(String s, String t)\n{\n int n = s.Length;\n List<int> []occur = new List<int>[26];\n for(int i = 0; i < occur.Length; i++)\n\toccur[i] = new List<int>();\n for(int x = 0; x < n; x++)\n {\n\tchar ch = (char)(s[x] - 'a');\n\toccur[ch].Add(x);\n }\n int []idx = new int[26];\n bool poss = true;\n for(int x = 0; x < n; x++)\n {\n\tchar ch = (char)(t[x] - 'a');\n\tif (idx[ch] >= occur[ch].Count)\n\t{\n\tposs = false;\n\tbreak;\n\t}\n\tfor(int small = 0; small < ch; small++)\n\t{\n\tif (idx[small] < occur[small].Count && occur[small][idx[small]] < occur[ch][idx[ch]])\n\t{\n\t\tposs = false;\n\t\tbreak;\n\t}\n\t}\n\tidx[ch]++;\n }\n if (poss)\n {\n\tConsole.Write(\"Yes\" + \"\\n\");\n }\n else\n {\n\tConsole.Write(\"No\" + \"\\n\");\n }\n}", "4326": "static int getMaxSum(int i, int j, int k, int []arr1, int []arr2, int []arr3)\n{\n\tint cnt = 0;\n\tif (i >= n1)\n\t\tcnt++;\n\tif (j >= n2)\n\t\tcnt++;\n\tif (k >= n3)\n\t\tcnt++;\n\tif (cnt >= 2)\n\t\treturn 0;\n\tif (dp[i, j, k] != -1)\n\t\treturn dp[i, j, k];\n\tint ans = 0;\n\tif (i < n1 && j < n2)\n\t\tans = Math.Max(ans,\n\t\t\t\t\tgetMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j]);\n\tif (i < n1 && k < n3)\n\t\tans = Math.Max(ans,\n\t\t\t\t\tgetMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k]);\n\tif (j < n2 && k < n3)\n\t\tans = Math.Max(ans,\n\t\t\t\t\tgetMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k]);\n\tdp[i, j, k] = ans;\n\treturn dp[i, j, k];\n}\nstatic void reverse(int[] tmp)\n{\n\tint i, t;\n\tint n = tmp.Length;\n\tfor(i = 0; i < n / 2; i++)\n\t{\n\t\tt = tmp[i];\n\t\ttmp[i] = tmp[n - i - 1];\n\t\ttmp[n - i - 1] = t;\n\t}\n}\nstatic int maxProductSum(int []arr1, int []arr2, int []arr3)\n{\n\tfor(int i = 0; i < maxN; i++)\n\t\tfor(int j = 0; j < maxN; j++)\n\t\t\tfor(int k = 0; k < maxN; k++)\n\t\t\t\tdp[i, j, k] = -1;\n\tArray.Sort(arr1);\n\treverse(arr1);\n\tArray.Sort(arr2);\n\treverse(arr2);\n\tArray.Sort(arr3);\n\treverse(arr3);\n\treturn getMaxSum(0, 0, 0, arr1, arr2, arr3);\n}", "4347": "static void findTriplet(int []arr, int N)\n{\n\tArray.Sort(arr);\n\tint flag = 0, i;\n\tfor(i = N - 1; i - 2 >= 0; i--)\n\t{\n\t\tif (arr[i - 2] + arr[i - 1] > arr[i])\n\t\t{\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag != 0)\n\t{\n\t\tConsole.Write(arr[i - 2] + \" \" + arr[i - 1] + \" \" + arr[i] );\n\t}\n\telse\n\t{\n\t\tConsole.Write(-1);\n\t}\n}", "4354": "static int inversionCount(String s)\n{\n\tint[] freq = new int[26];\n\tint inv = 0;\n\tfor(int i = 0; i < s.Length; i++)\n\t{\n\t\tint temp = 0;\n\t\tfor(int j = 0;\n\t\t\t\tj < (int)(s[i] - 'a'); j++)\n\t\ttemp += freq[j];\n\t\tinv += (i - temp);\n\t\tfreq[s[i] - 'a']++;\n\t}\n\treturn inv;\n}\nstatic bool haveRepeated(String S1, String S2)\n{\n\tint[] freq = new int[26];\n\tforeach(char i in S1.ToCharArray())\n\t{\n\t\tif (freq[i - 'a'] > 0)\n\t\t\treturn true;\n\t\tfreq[i - 'a']++;\n\t}\n\tfor(int i = 0; i < 26; i++)\n\t\tfreq[i] = 0;\n\tforeach(char i in S2.ToCharArray())\n\t{\n\t\tif (freq[i - 'a'] > 0)\n\t\t\treturn true;\n\t\tfreq[i - 'a']++;\n\t}\n\treturn false;\n}\nstatic void checkToMakeEqual(String S1, String S2)\n{\n\tint[] freq = new int[26];\n\tfor(int i = 0; i < S1.Length; i++)\n\t{\n\t\tfreq[S1[i] - 'a']++;\n\t}\n\tbool flag = false;\n\tfor(int i = 0; i < S2.Length; i++)\n\t{\n\t\tif (freq[S2[i] - 'a'] == 0)\n\t\t{\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t\tfreq[S2[i] - 'a']--;\n\t}\n\tif (flag == true)\n\t{\n\t\tConsole.WriteLine(\"No\");\n\t\treturn;\n\t}\n\tint invCount1 = inversionCount(S1);\n\tint invCount2 = inversionCount(S2);\n\tif (invCount1 == invCount2 ||\n\t(invCount1 & 1) == (invCount2 & 1) ||\n\t\thaveRepeated(S1, S2))\n\t{\n\t\tConsole.WriteLine(\"Yes\");\n\t}\n\telse\n\tConsole.WriteLine(\"No\");\n}", "4357": "static int numberofpairs(int []arr, int N)\n{\n\tint answer = 0;\n\tArray.Sort(arr);\n\tint minDiff = 10000000;\n\tfor(int i = 0; i < N - 1; i++)\n\t\tminDiff = Math.Min(minDiff, arr[i + 1] - arr[i]);\n\tfor(int i = 0; i < N - 1; i++)\n\t{\n\t\tif (arr[i + 1] - arr[i] == minDiff)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "4360": "static void sortArr(int []a, int n)\n{\n\tint i, k;\n\tk = (int)(Math.Log(n) / Math.Log(2));\n\tk = (int) Math.Pow(2, k);\n\twhile (k > 0)\n\t{\n\t\tfor(i = 0; i + k < n; i++)\n\t\t\tif (a[i] > a[i + k])\n\t\t\t{\n\t\t\t\tint tmp = a[i];\n\t\t\t\ta[i] = a[i + k];\n\t\t\t\ta[i + k] = tmp;\n\t\t\t}\n\t\tk = k / 2;\n\t}\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tConsole.Write(a[i] + \" \");\n\t}\n}", "4362": "static void maximumSum(int []arr, int n, int k)\n{\n\tint elt = n / k;\n\tint sum = 0;\n\tArray.Sort(arr);\n\tint count = 0;\n\tint i = n - 1;\n\twhile (count < k)\n\t{\n\t\tsum += arr[i];\n\t\ti--;\n\t\tcount++;\n\t}\n\tcount = 0;\n\ti = 0;\n\twhile (count < k)\n\t{\n\t\tsum += arr[i];\n\t\ti += elt - 1;\n\t\tcount++;\n\t}\n\tConsole.WriteLine(sum);\n}", "4369": "static int findMinSum(int []arr, int K, int L, int size)\n{\n\tif (K * L > size)\n\t\treturn -1;\n\tint minsum = 0;\n\tArray.Sort(arr); \n\tfor(int i = 0; i < K; i++)\n\t\tminsum += arr[i];\n\treturn minsum;\n}", "4371": "static void find_max_length(int []arr, int index, int sum, int k)\n{\n\tsum = sum + arr[index];\n\tstore.Add(arr[index]);\n\tif (sum == k)\n\t{\n\t\tif (max_length < store.Count)\n\t\t{\n\t\t\tmax_length = store.Count;\n\t\t\tans = store;\n\t\t}\n\t}\n\tfor(int i = index + 1; i < arr.Length; i++)\n\t{\n\t\tif (sum + arr[i] <= k)\n\t\t{\n\t\t\tfind_max_length(arr, i, sum, k);\n\t\t\tstore.RemoveAt(store.Count - 1);\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\treturn;\n}\nstatic int longestSubsequence(int []arr, int n, int k)\n{\n\tArray.Sort(arr);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (max_length >= n - i)\n\t\t\tbreak;\n\t\tstore.Clear();\n\t\tfind_max_length(arr, i, 0, k);\n\t}\n\treturn max_length;\n}", "4378": "static int findKthSmallest(int[] arr, int n, int k)\n{\n int max = 0;\n for (int i = 0; i < n; i++)\n {\n\tif (arr[i] > max)\n\tmax = arr[i];\n }\n int[] counter = new int[max + 1];\n int smallest = 0;\n for (int i = 0; i < n; i++)\n {\n\tcounter[arr[i]]++;\n }\n for (int num = 1; num <= max; num++)\n {\n\tif (counter[num] > 0)\n\t{\n\tsmallest += counter[num];\n\t}\n\tif (smallest >= k)\n\t{\n\treturn num;\n\t}\n }\n return -1;\n}", "4385": "static void lexNumbers(int n)\n{\n\tList<String> s = new List<String>();\n\tfor(int i = 1; i <= n; i++)\n\t{\n\ts.Add(String.Join(\"\", i));\n\t}\n\ts.Sort();\n\tList<int> ans = new List<int>();\n\tfor(int i = 0; i < n; i++)\n\tans.Add(Int32.Parse(s[i]));\n\tfor(int i = 0; i < n; i++)\n\tConsole.Write(ans[i] + \" \");\n}", "4386": "public static void lexNumbers(int n)\n{\n\tList<int> sol = new List<int>();\n\tdfs(1, n, sol);\n\tConsole.WriteLine(\"[\" + string.Join(\", \", sol) + \"]\");\n}\npublic static void dfs(int temp, int n, List<int> sol)\n{\n\tif (temp > n)\n\t\treturn;\n\tsol.Add(temp);\n\tdfs(temp * 10, n, sol);\n\tif (temp % 10 != 9)\n\t\tdfs(temp + 1, n, sol);\n}", "4392": "static void func(int[,]a)\n{\n\tint i, j, k;\n\tfor(i = 0; i < N; i++)\n\t{\n\tif (i % 2 == 0)\n\t{\n\t\tfor(j = 0; j < N; j++)\n\t\t{\n\t\t\tfor(k = j + 1; k < N; ++k)\n\t\t\t{\n\t\t\t\tif (a[i, j] > a[i, k])\n\t\t\t\t{\n\t\t\t\t\tint temp = a[i, j];\n\t\t\t\t\ta[i, j] = a[i, k];\n\t\t\t\t\ta[i, k] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(j = 0; j < N; j++)\n\t\t{\n\t\t\tfor(k = j + 1; k < N; ++k)\n\t\t\t{\n\t\t\t\tif (a[i, j] < a[i, k])\n\t\t\t\t{\n\t\t\t\t\tint temp = a[i, j];\n\t\t\t\t\ta[i, j] = a[i, k];\n\t\t\t\t\ta[i, k] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tfor(i = 0; i < N; i++)\n\t{\n\tfor(j = 0; j < N; j++)\n\t{\n\t\tConsole.Write(a[i, j] + \" \");\n\t}\n\tConsole.Write(\"\\n\");\n\t}\n}", "4400": "static int partition(int []arr, int l, int h)\n{\n\tint pivot = arr[l];\n\tint i = l + 1;\n\tint j = h;\n\twhile (i <= j)\n\t{\n\t\twhile (i <= h && arr[i] < pivot)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\twhile (j > l && arr[j] > pivot)\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\tif (i < j)\n\t\t{\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[l] = arr[j];\n\tarr[j] = pivot;\n\treturn j;\n}\nstatic void sortArray(int []arr, int l, int h)\n{\n\tif (l >= h)\n\t\treturn;\n\tint pivot = partition(arr, l, h);\n\tsortArray(arr, l, pivot - 1);\n\tsortArray(arr, pivot + 1, h);\n}\nstatic int findMaxIntervals(int []start, int []end, int n, int R)\n{\n\tint ans = 0;\n\tint prev = 0;\n\tint currActive = 0;\n\tint i = 0;\n\tint j = 0;\n\tif (start[0] > 0)\n\t\tans++;\n\twhile (i < n && j < n)\n\t{\n\t\tif (start[i] < end[j])\n\t\t{\n\t\t\ti++;\n\t\t\tcurrActive++;\n\t\t}\n\t\telse if (start[i] > end[j])\n\t\t{\n\t\t\tj++;\n\t\t\tcurrActive--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tif (currActive == 0)\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\tif (end[n - 1] < R)\n\t\tans++;\n\treturn ans;\n}", "4401": "static void sortArray(int []A, int N)\n{\n\tint x = 0, y = 0, z = 0;\n\tif (N % 4 == 0 N % 4 == 1)\n\t{\n\t\tfor(int i = 0; i < N / 2; i++)\n\t\t{\n\t\t\tx = i;\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\ty = N - i - 2;\n\t\t\t\tz = N - i - 1;\n\t\t\t}\n\t\t\tA[z] = A[y];\n\t\t\tA[y] = A[x];\n\t\t\tA[x] = x + 1;\n\t\t}\n\t\tConsole.Write(\"Sorted Array: \");\n\t\tfor(int i = 0; i < N; i++)\n\t\tConsole.Write(A[i] + \" \");\n\t}\n\telse\n\t{\n\t\tConsole.Write(\"-1\");\n\t}\n}", "4412": "static void dfs(int x)\n{\n ArrayList v = new ArrayList();\n ns.Clear();\n foreach (int it in s)\n {\n\tif (g[x].ContainsKey(it))\n\t{\n\tv.Add(it);\n\t}\n\telse\n\t{\n\tns.Add(it);\n\t}\n }\n s = ns; \n foreach(int i in v)\n {\n\tdfs(i);\n }\n}\nstatic void weightOfMST(int N)\n{\n int cnt = 0;\n for (int i = 1; i <= N; ++i)\n {\n\ts.Add(i);\n }\n ArrayList qt = new ArrayList();\n foreach(int t in s)\n\tqt.Add(t);\n while (qt.Count != 0)\n {\n\t++cnt;\n\tint t = (int)qt[0];\n\tqt.RemoveAt(0);\n\tdfs(t);\n }\n Console.Write(cnt - 4);\n}", "4420": "static int countPairs(int [] A, int [] B)\n{\n\tint n = A.Length;\n\tint ans = 0;\n\tArray.Sort(A);\n\tArray.Sort(B);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] > B[ans])\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4455": "", "4459": "static int findK(int []arr, int size, int N)\n\t{\n\t\tArray.Sort(arr);\n\t\tint temp_sum = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\ttemp_sum += arr[i];\n\t\t\tif (N - temp_sum == arr[i] * (size - i - 1))\n\t\t\t{\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "4460": "static int minimumSwaps(int[] arr)\n\t{\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile (i < arr.Length)\n\t\t{\n\t\t\tif (arr[i] != i + 1)\n\t\t\t{\n\t\t\t\twhile (arr[i] != i + 1)\n\t\t\t\t{\n\t\t\t\t\tint temp = 0;\n\t\t\t\t\ttemp = arr[arr[i] - 1];\n\t\t\t\t\tarr[arr[i] - 1] = arr[i];\n\t\t\t\t\tarr[i] = temp;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn count;\n\t}", "4482": "static int max_element(int []arr, int n)\n\t{\n\t\tint max = arr[0];\n\t\tfor(int i = 1; i < n ; i++)\n\t\t{\n\t\t\tif (max < arr[i])\n\t\t\t\tmax = arr[i];\n\t\t}\n\t\treturn max;\n\t}\nstatic int maxMod(int []arr, int n)\n\t{\n\t\tint maxVal = max_element(arr, n);\n\t\tint secondMax = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] < maxVal && arr[i] > secondMax)\n\t\t\t{\n\t\t\t\tsecondMax = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn secondMax;\n\t}", "4493": "static bool isPossible(int []A, int []B, int n, int m, int x, int y)\n\t{\n\t\tif (x > n y > m)\n\t\t\treturn false;\n\t\tArray.Sort(A);\n\t\tArray.Sort(B);\n\t\tif (A[x - 1] < B[m - y])\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "4507": "static int Min_Replace(int [] arr, int n, int k)\n\t{\n\t\tArray.Sort(arr);\n\t\tint [] freq = new int[MAX];\n\t\tint p = 0;\n\t\tfreq[p] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] == arr[i - 1])\n\t\t\t\t++freq[p];\n\t\t\telse\n\t\t\t\t++freq[++p];\n\t\t}\n\t\tArray.Sort(freq);\n\t\tArray.Reverse(freq);\n\t\tint ans = 0;\n\t\tfor (int i = k; i <= p; i++)\n\t\t\tans += freq[i];\n\t\treturn ans;\n\t}", "4508": "static Node append(Node head_ref, int new_data)\n\t{\n\t\tNode new_node = new Node();\n\t\tNode last = head_ref;\n\t\tnew_node.data = new_data;\n\t\tnew_node.next = null;\n\t\tif (head_ref == null)\n\t\t{\n\t\t\tnew_node.prev = null;\n\t\t\thead_ref = new_node;\n\t\t\treturn head_ref;\n\t\t}\n\t\twhile (last.next != null)\n\t\t\tlast = last.next;\n\t\tlast.next = new_node;\n\t\tnew_node.prev = last;\n\t\treturn head_ref;\n\t}\nstatic void printList(Node node)\n\t{\n\t\tNode last;\n\t\twhile (node != null)\n\t\t{\n\t\t\tConsole.Write(node.data + \" \");\n\t\t\tlast = node;\n\t\t\tnode = node.next;\n\t\t}\n\t}\nstatic Node mergeList(Node p, Node q)\n\t{\n\t\tNode s = null;\n\t\tif (p == null q == null)\n\t\t{\n\t\t\treturn (p == null ? q : p);\n\t\t}\n\t\tif (p.data < q.data)\n\t\t{\n\t\t\tp.prev = s;\n\t\t\ts = p;\n\t\t\tp = p.next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tq.prev = s;\n\t\t\ts = q;\n\t\t\tq = q.next;\n\t\t}\n\t\tNode head = s;\n\t\twhile (p != null && q != null)\n\t\t{\n\t\t\tif (p.data < q.data)\n\t\t\t{\n\t\t\t\ts.next = p;\n\t\t\t\tp.prev = s;\n\t\t\t\ts = s.next;\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts.next = q;\n\t\t\t\tq.prev = s;\n\t\t\t\ts = s.next;\n\t\t\t\tq = q.next;\n\t\t\t}\n\t\t}\n\t\tif (p == null)\n\t\t{\n\t\t\ts.next = q;\n\t\t\tq.prev = s;\n\t\t}\n\t\tif (q == null)\n\t\t{\n\t\t\ts.next = p;\n\t\t\tp.prev = s;\n\t\t}\n\t\treturn head;\n\t}\nstatic Node mergeAllList(Node []head, int k)\n\t{\n\t\tNode finalList = null;\n\t\tfor (int i = 0; i < k; i++)\n\t\t{\n\t\t\tfinalList = mergeList(finalList, head[i]);\n\t\t}\n\t\treturn finalList;\n\t}", "4510": "static int Segment(int []x, int []l, int n)\n{\n\tif (n == 1)\n\t\treturn 1;\n\tint ans = 2;\n\tfor (int i = 1; i < n - 1; i++)\n\t{\n\t\tif (x[i] - l[i] > x[i - 1])\n\t\t\tans++;\n\t\telse if (x[i] + l[i] < x[i + 1])\n\t\t{\n\t\t\tx[i] = x[i] + l[i];\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4529": "static bool existsTriplet(int []a, int []b, int []c, int x, int l1, int l2, int l3)\n{\n\tif (l2 <= l1 && l2 <= l3)\n\t{\n\t\tswap(l2, l1);\n\t\tswap(a, b);\n\t}\n\telse if (l3 <= l1 && l3 <= l2)\n\t{\n\t\tswap(l3, l1);\n\t\tswap(a, c);\n\t}\n\tfor (int i = 0; i < l1; i++)\n\t{\n\t\tint j = 0, k = l3 - 1;\n\t\twhile (j < l2 && k >= 0)\n\t\t{\n\t\t\tif (a[i] + b[j] + c[k] == x)\n\t\t\t\treturn true;\n\t\t\tif (a[i] + b[j] + c[k] < x)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tk--;\n\t\t}\n\t}\n\treturn false;\n}\nprivate static void swap(int x, int y)\n{\n\tint temp = x;\n\tx = y;\n\ty = temp;\n}\nprivate static void swap(int []x, int []y)\n{\n\tint []temp = x;\n\tx = y;\n\ty = temp;\n}", "4570": "static int MinimizeleftOverSum(int []a, int n)\n{\n\tList<int> v1 = new List<int>(),\n\t\t\tv2 = new List<int>();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] % 2 == 1)\n\t\t\tv1.Add(a[i]);\n\t\telse\n\t\t\tv2.Add(a[i]);\n\t}\n\tif (v1.Count > v2.Count)\n\t{\n\t\tv1.Sort();\n\t\tv2.Sort();\n\t\tint x = v1.Count - v2.Count - 1;\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile (i < x)\n\t\t{\n\t\t\tsum += v1[i++];\n\t\t}\n\t\treturn sum;\n\t}\n\telse if (v2.Count > v1.Count)\n\t{\n\t\tv1.Sort();\n\t\tv2.Sort();\n\t\tint x = v2.Count - v1.Count - 1;\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile (i < x)\n\t\t{\n\t\t\tsum += v2[i++];\n\t\t}\n\t\treturn sum;\n\t}\n\telse\n\t\treturn 0;\n}", "4578": "public static void printArr(int[] arr, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tConsole.Write(arr[i]);\n\t}\npublic static int compare(int num1, int num2)\n\t{\n\t\tString A = num1.ToString();\n\t\tString B = num2.ToString();\n\t\treturn (A+B).CompareTo(B+A);\n\t}\npublic static void printSmallest(int N, int[] arr)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tif (compare(arr[i], arr[j]) > 0)\n\t\t\t\t{\n\t\t\t\t\tint temp = arr[i];\n\t\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\tarr[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintArr(arr, N);\n\t}", "4585": "static double getMaxMedian(int []arr, int n, int k)\n{\n\tint size = n + k;\n\tArray.Sort(arr);\n\tif (size % 2 == 0)\n\t{\n\t\tdouble median = (double)(arr[(size / 2) - 1] + arr[size / 2])\n\t\t\t\t\t/ 2;\n\t\treturn median;\n\t}\n\tdouble median1 = arr[size / 2];\n\treturn median1;\n}", "4591": "static void minOperation(string S, int N, int K)\n\t{\n\t\tif (N % K != 0)\n\t\t{\n\t\t\tConsole.WriteLine(\"Not Possible\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint [] count = new int[26];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tcount[(S[i] - 97)]++;\n\t\t\t}\n\t\t\tint E = N / K;\n\t\t\tList<int> greaterE = new List<int>();\n\t\t\tList<int> lessE = new List<int>();\n\t\t\tfor (int i = 0; i < 26; i++)\n\t\t\t{\n\t\t\t\tif (count[i] < E)\n\t\t\t\t\tlessE.Add(E - count[i]);\n\t\t\t\telse\n\t\t\t\t\tgreaterE.Add(count[i] - E);\n\t\t\t}\n\t\t\tgreaterE.Sort();\n\t\t\tlessE.Sort();\n\t\t\tint mi = Int32.MaxValue;\n\t\t\tfor (int i = 0; i <= K; i++)\n\t\t\t{\n\t\t\t\tint set1 = i;\n\t\t\t\tint set2 = K - i;\n\t\t\t\tif (greaterE.Count >= set1 && lessE.Count >= set2)\n\t\t\t\t{\n\t\t\t\t\tint step1 = 0;\n\t\t\t\t\tint step2 = 0;\n\t\t\t\t\tfor (int j = 0; j < set1; j++)\n\t\t\t\t\t\tstep1 += greaterE[j];\n\t\t\t\t\tfor (int j = 0; j < set2; j++)\n\t\t\t\t\t\tstep2 += lessE[j];\n\t\t\t\t\tmi = Math.Min(mi, Math.Max(step1, step2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(mi);\n\t\t}\n\t}", "4620": "static void partSort(int[] arr, int N, int a, int b)\n\t{\n\t\tint l = Math.Min(a, b);\n\t\tint r = Math.Max(a, b);\n\t\tint[] temp = new int[r - l + 1];\n\t\tint j = 0;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\ttemp[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\tArray.Sort(temp);\n\t\tj = 0;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tarr[i] = temp[j];\n\t\t\tj++;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\t}\n\t}", "4621": "static void partSort(int[] arr, int N, int a, int b)\n\t{\n\t\tint l = Math.Min(a, b);\n\t\tint r = Math.Max(a, b);\n\t\tArray.Sort(arr, l, r);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tConsole.Write(arr[i] + \" \");\n\t}", "4622": "static int minMovesToSort(int []arr, int n)\n{\n\tint moves = 0;\n\tint i, mn = arr[n - 1];\n\tfor (i = n - 2; i >= 0; i--)\n\t{\n\t\tif (arr[i] > mn)\n\t\t\tmoves += arr[i] - mn;\n\t}\n\treturn moves;\n}", "4624": "static void sortByRow(int[,] mat, int n, bool descending)\n{\n\tint temp = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (descending == true)\n\t\t{\n\t\t\tint t = i;\n\t\t\tfor (int p = 0; p < n; p++)\n\t\t\t{\n\t\t\t\tfor (int j = p + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (mat[t, p] < mat[t, j])\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp = mat[t, p];\n\t\t\t\t\t\tmat[t, p] = mat[t, j];\n\t\t\t\t\t\tmat[t, j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tsortByRow(mat, i, n);\n\t}\n}\nstatic void sortByRow(int [,]mat, int row, int n)\n{\n\tfor (int i = row; i < row + 1; i++)\n\t{\n\t\tfor(int j = 0; j < n - 1; j++)\n\t\t{\n\t\t\tif(mat[i, j] > mat[i, j + 1])\n\t\t\t{\n\t\t\t\tvar temp = mat[i, j];\n\t\t\t\tmat[i, j] = mat[i, j + 1];\n\t\t\t\tmat[i, j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void transpose(int [,]mat, int n)\n{\n\tint temp = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\ttemp = mat[i, j];\n\t\t\tmat[i, j] = mat[j, i];\n\t\t\tmat[j, i] = temp;\n\t\t}\n\t}\n}\nstatic void sortMatRowAndColWise(int [,]mat, int n)\n{\n\tsortByRow(mat, n, true);\n\ttranspose(mat, n);\n\tsortByRow(mat, n, false);\n\ttranspose(mat, n);\n}\nstatic void printMat(int [,]mat, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tConsole.Write(mat[i, j] + \" \");\n\t\tConsole.WriteLine();\n\t}\n}", "4648": "static void SieveOfEratosthenes(int n)\n\t{\n\t\tfor(int i = 0; i < 100005; i++)\n\t\t\tprime[i] = true;\n\t\tprime[1] = false;\n\t\tfor (int p = 2; p * p <= n; p++)\n\t\t{\n\t\t\tif (prime[p])\n\t\t\t{\n\t\t\t\tfor (int i = p * 2; i < n; i += p)\n\t\t\t\t{\n\t\t\t\t\tprime[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nstatic void sortPrimes(int []arr, int n)\n\t{\n\t\tSieveOfEratosthenes(100005);\n\t\tList<int> v = new List<int>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (prime[arr[i]])\n\t\t\t{\n\t\t\t\tv.Add(arr[i]);\n\t\t\t}\n\t\t}\n\t\tv.Sort();\n\t\tv.Reverse();\n\t\tint j = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (prime[arr[i]])\n\t\t\t{\n\t\t\t\tarr[i] = v[j++];\n\t\t\t}\n\t\t}\n\t}", "4701": "static void findOptimalPairs(int []arr, int N)\n{\n\tArray.Sort(arr);\n\tfor (int i = 0, j = N - 1; i <= j; i++, j--)\n\t\tConsole.Write( \"(\" + arr[i] + \", \" + arr[j] + \")\" + \" \");\n}", "4740": "static void stableSelectionSort(int[] a, int n)\n\t{\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tint min = i;\n\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\tif (a[min] > a[j])\n\t\t\t\t\tmin = j;\n\t\t\tint key = a[min];\n\t\t\twhile (min > i)\n\t\t\t{\n\t\t\t\ta[min] = a[min - 1];\n\t\t\t\tmin--;\n\t\t\t}\n\t\t\ta[i] = key;\n\t\t}\n\t}\nstatic void printArray(int[] a, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\tConsole.Write(a[i] + \" \");\n\t\tConsole.WriteLine();\n\t}", "4762": "static int minIndex(int []a, int i, int j)\n\t{\n\t\tif (i == j)\n\t\t\treturn i;\n\t\tint k = minIndex(a, i + 1, j);\n\t\treturn (a[i] < a[k])? i : k;\n\t}\nstatic void recurSelectionSort(int []a, int n, int index)\n\t{\n\t\tif (index == n)\n\t\treturn;\n\t\tint k = minIndex(a, index, n - 1);\n\t\tif (k != index)\n\t\t{\n\t\t\tint temp = a[k];\n\t\t\ta[k] = a[index];\n\t\t\ta[index] = temp;\n\t\t}\n\t\trecurSelectionSort(a, n, index + 1);\n\t}", "4783": "static void printSorted(int a, int b, int c)\n\t{\n\t\tint get_max = Math.Max(a, Math.Max(b, c));\n\t\tint get_min = -Math.Max(-a, Math.Max(-b, -c));\n\t\tint get_mid = (a + b + c) -\n\t\t\t\t\t(get_max + get_min);\n\tConsole.Write(get_min + \" \" + get_mid + \" \" + get_max);\n\t}", "4786": "static void insertionSortRecursive(int []arr, int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn;\n\t\tinsertionSortRecursive(arr, n - 1);\n\t\tint last = arr[n - 1];\n\t\tint j = n - 2;\n\t\twhile (j >= 0 && arr[j] > last)\n\t\t{\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj--;\n\t\t}\n\t\tarr[j + 1] = last;\n\t}", "4793": "static void bubbleSort(int []arr, int n)\n{\n\tif (n == 1)\n\t\treturn;\n\tfor (int i = 0; i < n - 1; i++)\n\t\tif (arr[i] > arr[i + 1])\n\t\t{\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[i + 1];\n\t\t\tarr[i + 1] = temp;\n\t\t}\n\tbubbleSort(arr, n - 1);\n}", "4804": "static bool isPossible(int []a, int []b, int n, int k)\n{\n\tArray.Sort(a);\n\tArray.Reverse(b);\n\tfor (int i = 0; i < n; i++)\n\tif (a[i] + b[i] < k)\n\t\treturn false;\n\treturn true;\n}", "4817": "static int countBits(int a)\n {\n\tint count = 0;\n\twhile (a > 0)\n\t{\n\tif ((a & 1) > 0)\n\t\tcount += 1;\n\ta = a >> 1;\n\t}\n\treturn count;\n }\nstatic void insertionSort(int []arr, int []aux, int n)\n {\n\tfor (int i = 1; i < n; i++)\n\t{\n\tint key1 = aux[i];\n\tint key2 = arr[i];\n\tint j = i - 1;\n\twhile (j >= 0 && aux[j] < key1)\n\t{\n\t\taux[j + 1] = aux[j];\n\t\tarr[j + 1] = arr[j];\n\t\tj = j - 1;\n\t}\n\taux[j + 1] = key1;\n\tarr[j + 1] = key2;\n\t}\n }\nstatic void sortBySetBitCount(int []arr, int n)\n {\n\tint []aux = new int[n];\n\tfor (int i = 0; i < n; i++)\n\taux[i] = countBits(arr[i]);\n\tinsertionSort(arr, aux, n);\n }\nstatic void printArr(int []arr, int n)\n {\n\tfor (int i = 0; i < n; i++)\n\tConsole.Write(arr[i] + \" \");\n }", "4819": "static int countBits(int a)\n{\n int count = 0;\n while (a > 0)\n {\n\tif ((a & 1) > 0 )\n\tcount += 1;\n\ta = a >> 1;\n }\n return count;\n}\nstatic void sortBySetBitCount(int []arr, int n)\n{\n List<int> []count =\n\tnew List<int>[32];\n for (int i = 0; i < count.Length; i++)\n\tcount[i] = new List<int>();\n int setbitcount = 0;\n for (int i = 0; i < n; i++)\n {\n\tsetbitcount = countBits(arr[i]);\n\tcount[setbitcount].Add(arr[i]);\n }\n int j = 0; \n for (int i = 31; i >= 0; i--)\n {\n\tList<int> v1 = count[i];\n\tfor (int p = 0; p < v1.Count; p++)\n\tarr[j++] = v1[p];\n }\n}\nstatic void printArr(int []arr, int n)\n{\n for (int i = 0; i < n; i++)\n\tConsole.Write(arr[i] + \" \");\n}", "4820": "static int setBitCount(int num){\n\t\tint count = 0;\n\t\twhile ( num != 0)\n\t\t{\n\t\t\tif ( (num & 1) != 0)\n\t\t\tcount++;\n\t\t\tnum >>= 1;\n\t\t}\n\t\treturn count;\n\t}\nstatic void sortBySetBitCount(int[] arr, int n)\n\t{ \n\t\tList<Tuple<int, int>> count = new List<Tuple<int, int>>(); \n\t\tfor( int i = 0 ; i < n ; ++i )\n\t\t{\n\t\t\tcount.Add(new Tuple<int,int>((-1) * setBitCount(arr[i]), arr[i]));\n\t\t}\n\t\tcount.Sort();\n\t\tforeach(Tuple<int, int> i in count)\n\t\t{\n\t\t\tConsole.Write(i.Item2 + \" \");\n\t\t}\n\t\tConsole.WriteLine();\n\t}", "4847": "static int binarySearch(int []a, int item, int low, int high)\n{\n\twhile (low <= high) {\n\t\tint mid = low + (high - low) / 2;\n\t\tif (item == a[mid])\n\t\t\treturn mid + 1;\n\t\telse if (item > a[mid])\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn low;\n}\nstatic void insertionSort(int []a, int n)\n{\n\tint i, loc, j, selected;\n\tfor (i = 1; i < n; ++i) {\n\t\tj = i - 1;\n\t\tselected = a[i];\n\t\tloc = binarySearch(a, selected, 0, j);\n\t\twhile (j >= loc) {\n\t\t\ta[j + 1] = a[j];\n\t\t\tj--;\n\t\t}\n\t\ta[j + 1] = selected;\n\t}\n}", "4855": "void sort(int[] arr)\n\t{\n\t\tint n = arr.Length;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tint key = arr[i];\n\t\t\tint j = i - 1;\n\t\t\twhile (j >= 0 && arr[j] > key) {\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tj = j - 1;\n\t\t\t}\n\t\t\tarr[j + 1] = key;\n\t\t}\n\t}\nstatic void printArray(int[] arr)\n\t{\n\t\tint n = arr.Length;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\tConsole.Write(\"\\n\");\n\t}", "4859": "static int canReach(String s, int L, int R)\n\t{\n\t\tint[] dp = new int[s.Length];\n\t\tdp[0] = 1;\n\t\tint pre = 0;\n\t\tfor (int i = 1; i < s.Length; i++)\n\t\t{\n\t\t\tif (i >= L)\n\t\t\t{\n\t\t\t\tpre += dp[i - L];\n\t\t\t}\n\t\t\tif (i > R)\n\t\t\t{\n\t\t\t\tpre -= dp[i - R - 1];\n\t\t\t}\n\t\t\tif (pre > 0 && s[i] == '0')\n\t\t\t\tdp[i] = 1;\n\t\t\telse\n\t\t\t\tdp[i] = 0;\n\t\t}\n\t\treturn dp[s.Length - 1];\n\t}", "4889": "static void generateString(int k1, int k2, char[] s)\n{\n\tint C1s = 0, C0s = 0;\n\tint flag = 0;\n\tList<int> pos = new List<int>();\n\tfor (int i = 0; i < s.Length; i++) {\n\t\tif (s[i] == '0') {\n\t\t\tC0s++;\n\t\t\tif ((i + 1) % k1 != 0\n\t\t\t\t&& (i + 1) % k2 != 0) {\n\t\t\t\tpos.Add(i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tC1s++;\n\t\t}\n\t\tif (C0s >= C1s) {\n\t\t\tif (pos.Count == 0) {\n\t\t\t\tConsole.WriteLine(-1);\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint k = pos[(pos.Count - 1)];\n\t\t\t\ts[k] = '1';\n\t\t\t\tC0s--;\n\t\t\t\tC1s++;\n\t\t\t\tpos.Remove(pos.Count - 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\tConsole.WriteLine(s);\n\t}\n}", "4893": "static void maximizeProduct(int N)\n{\n\tint MSB = (int)(Math.Log(N) / Math.Log(2));\n\tint X = 1 << MSB;\n\tint Y = N - (1 << MSB);\n\tfor (int i = 0; i < MSB; i++) {\n\t\tif ((N & (1 << i))==0) {\n\t\t\tX += 1 << i;\n\t\t\tY += 1 << i;\n\t\t}\n\t}\n\tConsole.Write(X+\" \"+Y);\n}", "4899": "static bool check(int num)\n{\n\tint sm = 0;\n\tint num2 = num * num;\n\twhile (num>0) {\n\t\tsm += num % 10;\n\t\tnum /= 10;\n\t}\n\tint sm2 = 0;\n\twhile (num2>0) {\n\t\tsm2 += num2 % 10;\n\t\tnum2 /= 10;\n\t}\n\treturn ((sm * sm) == sm2);\n}\nstatic int convert(string s)\n{\n\tint val = 0;\n\tchar[] charArray = s.ToCharArray();\n\tArray.Reverse( charArray );\n\ts = new string( charArray );\n\tint cur = 1;\n\tfor (int i = 0; i < s.Length; i++) {\n\t\tval += ((int)s[i] - (int)'0') * cur;\n\t\tcur *= 10;\n\t}\n\treturn val;\n}\nstatic void generate(string s, int len, HashSet<int> uniq)\n{\n\tif (s.Length == len) {\n\t\tif (check(convert(s))) {\n\t\t\tuniq.Add(convert(s));\n\t\t}\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= 3; i++) {\n\t\tgenerate(s + Convert.ToChar(i + (int)'0'), len, uniq);\n\t}\n}\nstatic int totalNumbers(int L, int R)\n{\n\tint ans = 0;\n\tint max_len = (int)Math.Log10(R) + 1;\n\tHashSet<int> uniq = new HashSet<int>();\n\tfor (int i = 1; i <= max_len; i++) {\n\t\tgenerate(\"\", i, uniq);\n\t}\n\tforeach (int x in uniq) {\n\t\tif (x >= L && x <= R) {\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4906": "static int maxSumAfterPartition(int []arr, int n)\n{\n\tList<int> pos = new List<int>();\n\tList<int> neg = new List<int>();\n\tint zero = 0;\n\tint pos_sum = 0;\n\tint neg_sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (arr[i] > 0) {\n\t\t\tpos.Add(arr[i]);\n\t\t\tpos_sum += arr[i];\n\t\t}\n\t\telse if (arr[i] < 0) {\n\t\t\tneg.Add(arr[i]);\n\t\t\tneg_sum += arr[i];\n\t\t}\n\t\telse {\n\t\t\tzero++;\n\t\t}\n\t}\n\tint ans = 0;\n\tpos.Sort();\n\tneg.Sort();\n\tneg.Reverse();\n\tif (pos.Count > 0 && neg.Count > 0) {\n\t\tans = (pos_sum - neg_sum);\n\t}\n\telse if (pos.Count > 0) {\n\t\tif (zero > 0) {\n\t\t\tans = (pos_sum);\n\t\t}\n\t\telse {\n\t\t\tans = (pos_sum - 2 * pos[0]);\n\t\t}\n\t}\n\telse {\n\t\tif (zero > 0) {\n\t\t\tans = (-1 * neg_sum);\n\t\t}\n\t\telse {\n\t\t\tans = (neg[0] - (neg_sum - neg[0]));\n\t\t}\n\t}\n\treturn ans;\n}", "4916": "static int validPermutations(String str)\n\t{\n\t\tDictionary<char, int> m\n\t\t\t= new Dictionary<char, int>();\n\t\tint count = str.Length, ans = 0;\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tif(m.ContainsKey(str[i]))\n\t\t\t\tm[str[i]]=m[str[i]]+1;\n\t\t\telse\n\t\t\t\tm.Add(str[i], 1);\n\t\t}\n\t\tfor (int i = 0; i < str.Length; i++) {\n\t\t\tans += count - m[str[i]];\n\t\t\tif(m.ContainsKey(str[i]))\n\t\t\t\tm[str[i]]=m[str[i]]-1;\n\t\t\tcount--;\n\t\t}\n\t\treturn ans + 1;\n\t}", "4961": "public static int num_candyTypes(int []candies)\n{\n\tDictionary<int,int> s = new Dictionary<int,int>();\n\tfor(int i = 0; i < candies.Length; i++)\n\t{\n\t\tif(!s.ContainsKey(candies[i]))\n\t\t\ts.Add(candies[i], 1);\n\t}\n\treturn s.Count;\n}\npublic static void distribute_candies(int []candies)\n{\n\tint allowed = candies.Length / 2;\n\tint types = num_candyTypes(candies);\n\tif (types < allowed)\n\t\tConsole.WriteLine(types);\n\telse\n\t\tConsole.WriteLine(allowed);\n}", "4962": "static void convertXintoY(int X, int Y)\n{\n\twhile (Y > X) \n\t{\n\t\tif (Y % 2 == 0)\n\t\t\tY /= 2;\n\t\telse if (Y % 10 == 1)\n\t\t\tY /= 10;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (X == Y)\n\t\tConsole.Write(\"Yes\");\n\telse\n\t\tConsole.Write(\"No\");\n}", "4964": "static int maxXORUtil(int[] arr, int N, int xrr, int orr)\n\t{\n\t\tif (N == 0)\n\t\t\treturn xrr ^ orr;\n\t\tint x\n\t\t\t= maxXORUtil(arr, N - 1, xrr ^ orr, arr[N - 1]);\n\t\tint y\n\t\t\t= maxXORUtil(arr, N - 1, xrr, orr arr[N - 1]);\n\t\treturn Math.Max(x, y);\n\t}\nstatic int maximumXOR(int[] arr, int N)\n\t{\n\t\treturn maxXORUtil(arr, N, 0, 0);\n\t}", "4965": "static int MaxXOR(int []arr, int N)\n{\n\tint res = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tres |= arr[i];\n\t}\n\treturn res;\n}", "4989": "static void generateString(int K)\n{\n\tstring s = \"\";\n\tfor(int i = 97; i < 97 + K; i++)\n\t{\n\t\ts = s + (char)(i);\n\t\tfor(int j = i + 1; j < 97 + K; j++)\n\t\t{\n\t\t\ts += (char)(i);\n\t\t\ts += (char)(j);\n\t\t}\n\t}\n\ts += (char)(97);\n\tConsole.Write(s);\n}", "4990": "static int countEqual(int[] A, int[] B, int N)\n{\n\tint first = 0;\n\tint second = N - 1;\n\tint count = 0;\n\twhile (first < N && second >= 0)\n\t{\n\t\tif (A[first] < B[second])\n\t\t{\n\t\t\tfirst++;\n\t\t}\n\t\telse if (B[second] < A[first])\n\t\t{\n\t\t\tsecond--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t\tfirst++;\n\t\t\tsecond--;\n\t\t}\n\t}\n\treturn count;\n}", "5016": "public static void findEquation(int S, int M)\n{\n\tConsole.Write(\"1 \" + ((-1) * S) + \" \" + M); \n}", "5030": "static bool isPalindrome(int N)\n{\n\tint temp = N;\n\tint res = 0;\n\twhile (temp != 0)\n\t{\n\t\tint rem = temp % 10;\n\t\tres = res * 10 + rem;\n\t\ttemp /= 10;\n\t}\n\tif (res == N)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nstatic int sumOfDigits(int N)\n{\n\tint sum = 0;\n\twhile (N != 0)\n\t{\n\t\tsum += N % 10;\n\t\tN /= 10;\n\t}\n\treturn sum;\n}\nstatic bool isPrime(int n)\n{\n\tif (n <= 1)\n\t{\n\t\treturn false;\n\t}\n\tfor(int i = 2; i <= n / 2; ++i)\n\t{\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nstatic void precompute()\n{\n\tfor(int i = 1; i <= 100000; i++)\n\t{\n\t\tif (isPalindrome(i))\n\t\t{\n\t\t\tint sum = sumOfDigits(i);\n\t\t\tif (isPrime(sum))\n\t\t\t\tarr[i] = 1;\n\t\t\telse\n\t\t\t\tarr[i] = 0;\n\t\t}\n\t\telse\n\t\t\tarr[i] = 0;\n\t}\n\tfor(int i = 1; i <= 100000; i++)\n\t{\n\t\tarr[i] = arr[i] + arr[i - 1];\n\t}\n}\nstatic void countNumbers(int[, ] Q, int N)\n{\n\tprecompute();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tConsole.WriteLine((arr[Q[i, 1]] - arr[Q[i, 0] - 1]));\n\t}\n}", "5038": "static int minSteps(List<int> a, int n)\n{\n\tint []prefix_sum = new int[n];\n\tprefix_sum[0] = a[0];\n\tfor (int i = 1; i < n; i++)\n\t\tprefix_sum[i] += prefix_sum[i - 1] + a[i];\n\tint mx = -1;\n\tforeach (int subgroupsum in prefix_sum)\n\t{\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\tint grp_count = 0;\n\t\twhile (i < n)\n\t\t{\n\t\t\tsum += a[i];\n\t\t\tif (sum == subgroupsum)\n\t\t\t{\n\t\t\t\tgrp_count += 1;\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\telse if(sum > subgroupsum)\n\t\t\t{\n\t\t\t\tgrp_count = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t\tif (grp_count > mx)\n\t\t\tmx = grp_count;\n\t}\n\treturn n - mx;\n}", "5056": "public static void maxOccuringCharacter(string s)\n {\n\tint count0 = 0, count1 = 0;\n\tfor (int i = 0; i < s.Length; i++) {\n\tif (s[i] == '1') {\n\t\tcount1++;\n\t}\n\telse if (s[i] == '0') {\n\t\tcount0++;\n\t}\n\t}\n\tint prev = -1;\n\tfor (int i = 0; i < s.Length; i++) {\n\tif (s[i] == '1') {\n\t\tprev = i;\n\t\tbreak;\n\t}\n\t}\n\tfor (int i = prev + 1; i < s.Length; i++) {\n\tif (s[i] != 'X') {\n\t\tif (s[i] == '1') {\n\t\tcount1 += i - prev - 1;\n\t\tprev = i;\n\t\t}\n\t\telse {\n\t\tbool flag = true;\n\t\tfor (int j = i + 1; j < s.Length; j++) {\n\t\t\tif (s[j] == '1') {\n\t\t\tflag = false;\n\t\t\tprev = j;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) {\n\t\t\ti = prev;\n\t\t}\n\t\telse {\n\t\t\ti = s.Length;\n\t\t}\n\t\t}\n\t}\n\t}\n\tprev = -1;\n\tfor (int i = 0; i < s.Length; i++) {\n\tif (s[i] == '0') {\n\t\tprev = i;\n\t\tbreak;\n\t}\n\t}\n\tfor (int i = prev + 1; i < s.Length; i++) {\n\tif (s[i] != 'X') {\n\t\tif (s[i] == '0') {\n\t\tcount0 += i - prev - 1;\n\t\tprev = i;\n\t\t}\n\t\telse {\n\t\tbool flag = true;\n\t\tfor (int j = i + 1; j < s.Length; j++) {\n\t\t\tif (s[j] == '0') {\n\t\t\tprev = j;\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) {\n\t\t\ti = prev;\n\t\t}\n\t\telse {\n\t\t\ti = s.Length;\n\t\t}\n\t\t}\n\t}\n\t}\n\tif (s[0] == 'X') {\n\tint count = 0;\n\tint i = 0;\n\twhile (s[i] == 'X') {\n\t\tcount++;\n\t\ti++;\n\t}\n\tif (s[i] == '1') {\n\t\tcount1 += count;\n\t}\n\t}\n\tif (s[s.Length - 1] == 'X') {\n\tint count = 0;\n\tint i = s.Length - 1;\n\twhile (s[i] == 'X') {\n\t\tcount++;\n\t\ti--;\n\t}\n\tif (s[i] == '0') {\n\t\tcount0 += count;\n\t}\n\t}\n\tif (count0 == count1) {\n\tConsole.WriteLine(\"X\");\n\t}\n\telse if (count0 > count1) {\n\tConsole.WriteLine(0);\n\t}\n\telse\n\tConsole.WriteLine(1);\n }", "5062": "static void winner(int []arr, int N)\n{\n\tif (N % 2 == 1)\n\t{\n\t\tConsole.Write(\"A\");\n\t}\n\telse\n\t{\n\t\tConsole.Write(\"B\");\n\t}\n}", "5090": "static int maxSheets(int A, int B)\n\t{\n\t\tint area = A * B;\n\t\tint count = 1;\n\t\twhile (area % 2 == 0)\n\t\t{\n\t\t\tarea /= 2;\n\t\t\tcount *= 2;\n\t\t}\n\t\treturn count;\n\t}", "5093": "static void findMinMoves(int a, int b)\n {\n\tint ans = 0;\n\tif (a == b || Math.Abs(a - b) == 1)\n\t{\n\tans = a + b;\n\t}\n\telse\n\t{\n\tint k = Math.Min(a, b);\n\tint j = Math.Max(a, b);\n\tans = 2 * k + 2 * (j - k) - 1;\n\t}\n\tConsole.Write(ans);\n }", "5102": "static long cntEvenSumPairs(long X, long Y)\n{\n\tlong cntXEvenNums = X / 2;\n\tlong cntXOddNums = (X + 1) / 2;\n\tlong cntYEvenNums = Y / 2;\n\tlong cntYOddNums = (Y + 1) / 2;\n\tlong cntPairs = (cntXEvenNums * cntYEvenNums) +\n\t\t\t\t\t(cntXOddNums * cntYOddNums);\n\treturn cntPairs;\n}", "5118": "static int minMoves(List<int> arr)\n{\n\tint N = arr.Count;\n\tif (N <= 2)\n\t\treturn 0;\n\tint ans = Int32.MaxValue;\n\tfor(int i = -1; i <= 1; i++)\n\t{\n\t\tfor(int j = -1; j <= 1; j++)\n\t\t{\n\t\t\tint num1 = arr[0] + i;\n\t\t\tint num2 = arr[1] + j;\n\t\t\tint flag = 1;\n\t\t\tint moves = Math.Abs(i) + Math.Abs(j);\n\t\t\tfor(int idx = 2; idx < N; idx++)\n\t\t\t{\n\t\t\t\tint num = num1 + num2;\n\t\t\t\tif (Math.Abs(arr[idx] - num) > 1)\n\t\t\t\t\tflag = 0;\n\t\t\t\telse\n\t\t\t\t\tmoves += Math.Abs(arr[idx] - num);\n\t\t\t\tnum1 = num2;\n\t\t\t\tnum2 = num;\n\t\t\t}\n\t\t\tif (flag != 0)\n\t\t\t\tans = Math.Min(ans, moves);\n\t\t}\n\t}\n\tif (ans == Int32.MaxValue)\n\t\treturn -1;\n\treturn ans;\n}", "5119": "static void querySum(int []arr, int N, int [,]Q, int M)\n {\n\tfor(int i = 0; i < M; i++)\n\t{\n\tint x = Q[i, 0];\n\tint y = Q[i, 1];\n\tint sum = 0;\n\twhile (x < N)\n\t{\n\t\tsum += arr[x];\n\t\tx += y;\n\t}\n\tConsole.Write(sum + \" \");\n\t}\n }", "5120": "static void precomputeExpressionForAllVal(int []arr, int N, int [,]dp)\n{\n\tfor(int i = N - 1; i >= 0; i--)\n\t{\n\t\tfor(int j = 1; j <= Math.Sqrt(N); j++)\n\t\t{\n\t\t\tif (i + j < N)\n\t\t\t{\n\t\t\t\tdp[i, j] = arr[i] + dp[i + j, j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i, j] = arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void querySum(int []arr, int N, int [,]Q, int M)\n{\n\tint [,]dp = new int[sz, sqr];\n\tprecomputeExpressionForAllVal(arr, N, dp);\n\tfor(int i = 0; i < M; i++)\n\t{\n\t\tint x = Q[i, 0];\n\t\tint y = Q[i, 1];\n\t\tif (y <= Math.Sqrt(N))\n\t\t{\n\t\t\tConsole.Write(dp[x, y] + \" \");\n\t\t\tcontinue;\n\t\t}\n\t\tint sum = 0;\n\t\twhile (x < N)\n\t\t{\n\t\t\tsum += arr[x];\n\t\t\tx += y;\n\t\t}\n\t\tConsole.Write(sum + \" \");\n\t}\n}", "5167": "static void construct_tree(int[] weights, int n)\n{\n\tint minimum = weights.Min();\n\tint maximum = weights.Max();\n\tif (minimum == maximum)\n\t{\n\t\tConsole.WriteLine(\"No\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tConsole.WriteLine(\"Yes\");\n\t}\n\tint root = weights[0];\n\tvisited[1] = 1;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] != root && visited[i + 1] == 0)\n\t\t{\n\t\t\tConsole.WriteLine(1 + \" \" + (i + 1) + \" \");\n\t\t\tvisited[i + 1] = 1;\n\t\t}\n\t}\n\tint notroot = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] != root)\n\t\t{\n\t\t\tnotroot = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] == root && visited[i + 1] == 0)\n\t\t{\n\t\t\tConsole.WriteLine(notroot + \" \" +\n\t\t\t\t\t\t\t\t\t(i + 1));\n\t\t\tvisited[i + 1] = 1;\n\t\t}\n\t}\n}", "5170": "static int findBitwiseORGivenXORAND(int X, int Y)\n{\n\treturn X + Y;\n}", "5198": "static int GCD(int a, int b)\n{\n if (b == 0)\n\treturn a;\n return GCD(b, a % b);\n}\nstatic void canReach(int N, int A, int B, int K)\n{\n int gcd = GCD(N, K);\n if (Math.Abs(A - B) % gcd == 0)\n {\n\tConsole.WriteLine(\"Yes\");\n }\n else\n {\n\tConsole.WriteLine(\"No\");\n }\n}", "5199": "static int sum(int n)\n{\n\tint res = 0;\n\twhile (n > 0)\n\t{\n\t\tres += n % 10;\n\t\tn /= 10;\n\t}\n\treturn res;\n}\nstatic int smallestNumber(int n, int s)\n{\n\tif (sum(n) <= s)\n\t{\n\t\treturn n;\n\t}\n\tint ans = n, k = 1;\n\tfor(int i = 0; i < 9; ++i)\n\t{\n\t\tint digit = (ans / k) % 10;\n\t\tint add = k * ((10 - digit) % 10);\n\t\tans += add;\n\t\tif (sum(ans) <= s)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tk *= 10;\n\t}\n\treturn ans;\n}", "5218": "static void countOfSubarray(int []arr, int N)\n{ \n Dictionary<int,\n\t\t\tint> mp = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tint>(); \n int answer = 0;\n int sum = 0;\n mp[1] = 1;\n for(int i = 0; i < N; i++)\n {\n\tsum += arr[i];\n\tif (mp.ContainsKey(sum - i))\n\tanswer += mp[sum - i];\n\tif(mp.ContainsKey(sum - 1))\n\tmp[sum - 1]++;\n\telse\n\tmp[sum - 1] = 1;\n }\n Console.Write(answer - 2);\n}", "5227": "static void minCost(string s, int k)\n{\n\tint n = s.Length;\n\tint ans = 0;\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tint[] a = new int[26];\n\t\tfor(int j = i; j < n; j += k)\n\t\t{\n\t\t\ta[s[j] - 'a']++;\n\t\t}\n\t\tint min_cost = Int32.MaxValue;\n\t\tfor(int ch = 0; ch < 26; ch++)\n\t\t{\n\t\t\tint cost = 0;\n\t\t\tfor(int tr = 0; tr < 26; tr++)\n\t\t\t\tcost += Math.Abs(ch - tr) * a[tr];\n\t\t\tmin_cost = Math.Min(min_cost, cost);\n\t\t}\n\t\tans += min_cost;\n\t}\n\tConsole.WriteLine(ans);\n}", "5233": "static int minAbsDiff(int N)\n{\n\tint sumSet1 = 0;\n\tint sumSet2 = 0;\n\tfor(int i = N; i > 0; i--)\n\t{\n\t\tif (sumSet1 <= sumSet2)\n\t\t{\n\t\t\tsumSet1 += i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsumSet2 += i;\n\t\t}\n\t}\n\treturn Math.Abs(sumSet1 - sumSet2);\n}", "5234": "static int minAbsDiff(int N)\n{\n if (N % 4 == 0 N % 4 == 3)\n {\n\treturn 0;\n }\n return 1;\n}", "5250": "static bool checkDigits(int n)\n{\n do\n {\n\tint r = n % 10;\n\tif (r == 3 r == 4 r == 6 r == 7 r == 9)\n\treturn false;\n\tn /= 10;\n } while (n != 0);\n return true;\n}\nstatic bool isPrime(int n)\n{\n if (n <= 1)\n\treturn false;\n for (int i = 2; i * i <= n; i++)\n {\n\tif (n % i == 0)\n\treturn false;\n }\n return true;\n}\nstatic bool isAllPrime(int n)\n{\n return isPrime(n) &&\n\t\tcheckDigits(n);\n}", "5262": "static int maximumSubarrays(int []arr, int N, int target)\n{\n int ans = 0;\n int availIdx = -1;\n int cur_sum = 0;\n Dictionary<int,\n\t\t\tint> mp = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tint>();\n mp.Add(0, 1);\n for(int i = 0; i < N; i++)\n {\n\tcur_sum += arr[i];\n\tif (mp.ContainsKey(cur_sum - target) && mp[cur_sum - target] >= availIdx)\n\t{\n\tans++;\n\tavailIdx = i;\n\t}\n\tif(mp.ContainsKey(cur_sum))\n\tmp[cur_sum] = i;\n\telse\n\tmp.Add(cur_sum, i);\n }\n return ans;\n}", "5291": "public static int getMinOps(int[] arr)\n{\n\tint res = 0;\n\tfor(int i = 0; i < arr.Length - 1; i++)\n\t{\n\t\tres += Math.Max(arr[i + 1] - arr[i], 0);\n\t}\n\treturn res;\n}", "5310": "static void minCost(String str, int a, int b)\n{\n\tint openUnbalanced = 0;\n\tint closedUnbalanced = 0;\n\tint openCount = 0;\n\tint closedCount = 0;\n\tfor(int i = 0; i < str.Length; i++)\n\t{\n\t\tif (str[i] == '(')\n\t\t{\n\t\t\topenUnbalanced++;\n\t\t\topenCount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (openUnbalanced == 0)\n\t\t\t\tclosedUnbalanced++;\n\t\t\telse\n\t\t\t\topenUnbalanced--;\n\t\t\tclosedCount++;\n\t\t}\n\t}\n\tint result = a * (Math.Abs(openCount - closedCount));\n\tif (closedCount > openCount)\n\t\tclosedUnbalanced -= (closedCount - openCount);\n\tif (openCount > closedCount)\n\t\topenUnbalanced -= (openCount - closedCount);\n\tresult += Math.Min(a * (openUnbalanced + closedUnbalanced), b * closedUnbalanced);\n\tConsole.Write(result + \"\\n\");\n}", "5322": "public static void countEvenSum(int low, int high, int k)\n{\n\tint even_count = high / 2 - (low - 1) / 2;\n\tint odd_count = (high + 1) / 2 - low / 2;\n\tlong even_sum = 1;\n\tlong odd_sum = 0;\n\tfor(int i = 0; i < k; i++)\n\t{\n\t\tlong prev_even = even_sum;\n\t\tlong prev_odd = odd_sum;\n\t\teven_sum = (prev_even * even_count) +\n\t\t\t\t\t(prev_odd * odd_count);\n\t\todd_sum = (prev_even * odd_count) +\n\t\t\t\t(prev_odd * even_count);\n\t}\n\tConsole.WriteLine(even_sum);\n}", "5329": "static double[] Length_Diagonals(int a, double theta)\n{\n\tdouble p = a * Math.Sqrt(2 + (2 *\n\t\t\t\tMath.Cos(theta * (Math.PI / 180))));\n\tdouble q = a * Math.Sqrt(2 - (2 *\n\t\t\t\tMath.Cos(theta * (Math.PI / 180))));\n\treturn new double[]{ p, q };\n}", "5333": "static void AddEdge(int u, int v)\n{\n\tadj[u].Add(v);\n\tadj[v].Add(u);\n}\nstatic void Matching_dfs(int u, int p)\n{\n\tfor(int i = 0; i < adj[u].Count; i++)\n\t{\n\t\tif (adj[u][i] != p)\n\t\t{\n\t\t\tMatching_dfs(adj[u][i], u);\n\t\t}\n\t}\n\tif (used[u] == 0 && used[p] == 0 && p != 0)\n\t{\n\t\tmax_matching++;\n\t\tused[u] = used[p] = 1;\n\t}\n}\nstatic void maxMatching()\n{\n\tMatching_dfs(1, 0);\n\tConsole.Write(max_matching + \"\\n\");\n}", "5353": "static String balancedMatrix(int [, ]mat)\n\t{\n\t\tbool is_balanced = true;\n\t\tfor (int i = 0; i < N && is_balanced; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M && is_balanced; j++)\n\t\t\t{\n\t\t\t\tif ((i == 0 i == N - 1) &&\n\t\t\t\t\t(j == 0 j == M - 1))\n\t\t\t\t{\n\t\t\t\t\tif (mat[i, j] >= 2)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t\telse if (i == 0 i == N - 1 j == 0 j == M - 1)\n\t\t\t\t{\n\t\t\t\t\tif (mat[i, j] >= 3)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (mat[i, j] >= 4)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (is_balanced)\n\t\t\treturn \"Balanced\";\n\t\telse\n\t\t\treturn \"Unbalanced\";\n\t}", "5361": "static int getMinCost(int[] A, int[] B, int N)\n\t{\n\t\tint mini = int.MaxValue;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tmini = Math.Min(mini, Math.Min(A[i], B[i]));\n\t\t}\n\t\treturn mini * (2 * N - 1);\n\t}", "5370": "static int maxSubsequences(int []arr, int n)\n{\n\tDictionary<int,\n\t\t\tint> map = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tint maxCount = 0;\n\tint count;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (map.ContainsKey(arr[i]))\n\t\t{\n\t\t\tcount = map[arr[i]];\n\t\t\tif (count > 1)\n\t\t\t{\n\t\t\t\tmap.Add(arr[i], count - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmap.Remove(arr[i]);\n\t\t\tif (arr[i] - 1 > 0)\n\t\t\t\tif (map.ContainsKey(arr[i] - 1))\n\t\t\t\t\tmap[arr[i] - 1]++;\n\t\t\t\telse\n\t\t\t\t\tmap.Add(arr[i] - 1, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmaxCount++;\n\t\t\tif (arr[i] - 1 > 0)\n\t\t\t\tif (map.ContainsKey(arr[i] - 1))\n\t\t\t\t\tmap[arr[i] - 1]++;\n\t\t\t\telse\n\t\t\t\t\tmap.Add(arr[i] - 1, 1);\n\t\t}\n\t}\n\treturn maxCount;\n}", "5373": "public static void count(int n, int k)\n {\n\tlong count = (long)(Math.Pow(10, k) -\n\t\t\t\t\t\tMath.Pow(10, k - 1));\n\tConsole.Write(count);\n }", "5380": "static int func(int N, int P)\n{\n\tint sumUptoN = (N * (N + 1) / 2);\n\tint sumOfMultiplesOfP;\n\tif (N < P)\n\t{\n\t\treturn sumUptoN;\n\t}\n\telse if ((N / P) == 1)\n\t{\n\t\treturn sumUptoN - P + 1;\n\t}\n\tsumOfMultiplesOfP = ((N / P) * (2 * P +\n\t\t\t\t\t\t(N / P - 1) * P)) / 2;\n\treturn (sumUptoN + func(N / P, P) - sumOfMultiplesOfP);\n}", "5383": "static String removeOcc(String s, char ch)\n{\n\tfor (int i = 0; i < s.Length; i++)\n\t{\n\t\tif (s[i] == ch)\n\t\t{\n\t\t\ts = s.Substring(0, i) +\n\t\t\t\ts.Substring(i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = s.Length - 1; i > -1; i--)\n\t{\n\t\tif (s[i] == ch)\n\t\t{\n\t\t\ts = s.Substring(0, i) +\n\t\t\t\ts.Substring(i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s;\n}", "5388": "public static void findShifts(int[] A, int N)\n{\n\tint[] shift = new int[N];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (i == A[i] - 1)\n\t\t\tshift[i] = 0;\n\t\telse\n\t\t\tshift[i] = (A[i] - 1 - i + N) % N;\n\t}\n\tfor(int i = 0; i < N; i++)\n\t\tConsole.Write(shift[i] + \" \");\n}", "5398": "static void printList(List<int> arr)\n{\n\tif (arr.Count != 1)\n\t{\n\t\tfor(int i = 0; i < arr.Count; i++)\n\t\t{\n\t\t\tConsole.Write(arr[i] + \" \");\n\t\t}\n\t\tConsole.WriteLine();\n\t}\n}\nstatic void findWays(List<int> arr, int i, int n)\n{\n\tif (n == 0)\n\t\tprintList(arr);\n\tfor(int j = i; j <= n; j++)\n\t{\n\t\tarr.Add(j);\n\t\tfindWays(arr, j, n - j);\n\t\tarr.RemoveAt(arr.Count - 1);\n\t}\n}", "5405": "public static void Maximum_subsequence(int[] A, int N)\n{\n\tDictionary<int,\n\t\t\tint> frequency = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\t\tint>();\n\tint max_freq = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (frequency.ContainsKey(A[i]))\n\t\t{\n\t\t\tfrequency[A[i]] = frequency[A[i]] + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfrequency.Add(A[i], 1);\n\t\t}\n\t}\n\tforeach(KeyValuePair<int, int> it in frequency)\n\t{\n\t\tif ((int)it.Value > max_freq)\n\t\t{\n\t\t\tmax_freq = (int)it.Value;\n\t\t}\n\t}\n\tConsole.WriteLine(max_freq);\n}", "5407": "public static void minSteps(int N, int[] increasing, int[] decreasing)\n{\n\tint min = int.MaxValue;\n\tforeach(int i in increasing)\n\t{\n\t\tif (min > i)\n\t\t\tmin = i;\n\t}\n\tint max = int.MinValue;\n\tforeach(int i in decreasing)\n\t{\n\t\tif (max < i)\n\t\t\tmax = i;\n\t}\n\tint minSteps = Math.Max(max, N - min);\n\tConsole.WriteLine(minSteps);\n}", "5416": "public static void constructmatrix(int N)\n{\n\tbool check = true;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tfor(int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t{\n\t\t\t\tConsole.Write(\"1 \");\n\t\t\t}\n\t\t\telse if (check)\n\t\t\t{\n\t\t\t\tConsole.Write(\"2 \");\n\t\t\t\tcheck = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsole.Write(\"-2 \");\n\t\t\t\tcheck = true;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine();\n\t}\n}", "5418": "static int countChanges(int [,]matrix, int n, int m)\n{\n\tint dist = n + m - 1;\n\tint [,]freq = new int[dist, 10];\n\tfor(int i = 0; i < dist; i++)\n\t{\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tfreq[i, j] = 0;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tfreq[i + j, matrix[i, j]]++;\n\t\t}\n\t}\n\tint min_changes_sum = 0;\n\tfor(int i = 0; i < dist / 2; i++)\n\t{\n\t\tint maximum = 0;\n\t\tint total_values = 0;\n\t\tfor(int j = 0; j < 10; j++)\n\t\t{\n\t\t\tmaximum = Math.Max(maximum, freq[i, j] + freq[n + m - 2 - i, j]);\n\t\t\ttotal_values += (freq[i, j] + freq[n + m - 2 - i, j]);\n\t\t}\n\t\tmin_changes_sum += (total_values - maximum);\n\t}\n\treturn min_changes_sum;\n}", "5440": "public static void DivideString(string s, int n, int k)\n{\n\tint i, c = 0, no = 1;\n\tint c1 = 0, c2 = 0;\n\tint[] fr = new int[26];\n\tchar[] ans = new char[n];\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tfr[s[i] - 'a']++;\n\t}\n\tchar ch = 'a', ch1 = 'a';\n\tfor(i = 0; i < 26; i++)\n\t{\n\t\tif (fr[i] == k)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t\tif (fr[i] > k && fr[i] != 2 * k)\n\t\t{\n\t\t\tc1++;\n\t\t\tch = (char)(i + 'a');\n\t\t}\n\t\tif (fr[i] == 2 * k)\n\t\t{\n\t\t\tc2++;\n\t\t\tch1 = (char)(i + 'a');\n\t\t}\n\t}\n\tfor(i = 0; i < n; i++)\n\t\tans[i] = '1';\n\tDictionary<char,\n\t\t\tint> mp = new Dictionary<char,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tif (c % 2 == 0 c1 > 0 c2 > 0)\n\t{\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tif (fr[s[i] - 'a'] == k)\n\t\t\t{\n\t\t\t\tif (mp.ContainsKey(s[i]))\n\t\t\t\t{\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (no <= (c / 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tans[i] = '2';\n\t\t\t\t\t\tno++;\n\t\t\t\t\t\tmp[s[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( (c % 2 == 1) && (c1 > 0) )\n\t\t{\n\t\t\tno = 1;\n\t\t\tfor(i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (s[i]== ch && no <= k)\n\t\t\t\t{\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tno++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c % 2 == 1 && c1 == 0)\n\t\t{\n\t\t\tno = 1;\n\t\t\tint flag = 0;\n\t\t\tfor(i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == ch1 && no <= k)\n\t\t\t\t{\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tno++;\n\t\t\t\t}\n\t\t\t\tif (fr[s[i] - 'a'] == k && flag == 0 && ans[i] == '1')\n\t\t\t\t{\n\t\t\t\t\tans[i] = '2';\n\t\t\t\t\tflag = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.Write(ans);\n\t}\n\telse\n\t{\n\t\tConsole.Write(\"NO\");\n\t}\n}", "5447": "static int check(int unit_digit, int X)\n{\n\tint times, digit;\n\tfor (times = 1; times <= 10; times++)\n\t{\n\t\tdigit = (X * times) % 10;\n\t\tif (digit == unit_digit)\n\t\t\treturn times;\n\t}\n\treturn -1;\n}\nstatic int getNum(int N, int X)\n{\n\tint unit_digit;\n\tunit_digit = N % 10;\n\tint times = check(unit_digit, X);\n\tif (times == -1)\n\t\treturn times;\n\telse\n\t{\n\t\tif (N >= (times * X))\n\t\t\treturn times;\n\t\telse\n\t\t\treturn -1;\n\t}\n}", "5455": "static int minPoints(int n, int m)\n{\n\tint ans = 0;\n\tif ((n % 2 != 0) && (m % 2 != 0))\n\t{\n\t\tans = ((n * m) / 2) + 1;\n\t}\n\telse\n\t{\n\t\tans = (n * m) / 2;\n\t}\n\treturn ans;\n}", "5468": "static void solve(int []P, int n)\n{\n\tint []arr = new int[n + 1];\n\tarr[0] = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tarr[i + 1] = P[i];\n\tint cnt = 0;\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tif (arr[i] == i)\n\t\t{\n\t\t\tint t = arr[i + 1];\n\t\t\tarr[i + 1] = arr[i];\n\t\t\tarr[i] = t;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif (arr[n] == n)\n\t{\n\t\tint t = arr[n - 1];\n\t\tarr[n - 1] = arr[n];\n\t\tarr[n] = t;\n\t\tcnt++;\n\t}\n\tConsole.WriteLine(cnt);\n}", "5482": "static int __builtin_popcount(int n)\n\t{\n\t\tint count = 0;\n\t\twhile (n > 0) {\n\t\t\tcount += n & 1;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn count;\n\t}\nstatic void countEvenOdd(int []arr, int n, int K)\n\t{\n\t\tint even = 0, odd = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = __builtin_popcount(arr[i]);\n\t\t\tif (x % 2 == 0)\n\t\t\t\teven++;\n\t\t\telse\n\t\t\t\todd++;\n\t\t}\n\t\tint y;\n\t\ty = __builtin_popcount(K);\n\t\tif ((y & 1) != 0) {\n\t\t\tConsole.WriteLine(\"Even = \"+ odd + \", Odd = \" + even);\n\t\t}\n\t\telse {\n\t\t\tConsole.WriteLine(\"Even = \" + even + \", Odd = \" + odd);\n\t\t}\n\t}", "5495": "static String check(int S, int []prices, int []type, int n)\n{\n\tfor(int j = 0; j < n; j++)\n\t{\n\tfor(int k = j + 1; k < n; k++)\n\t{ \n\t\tif ((type[j] == 0 && type[k] == 1) ||\n\t\t\t(type[j] == 1 && type[k] == 0))\n\t\t{\n\t\t\tif (prices[j] + prices[k] <= S)\n\t\t\t{\n\t\t\t\treturn \"Yes\";\n\t\t\t}\n\t\t}\n\t}\n\t}\n\treturn \"No\";\n}", "5501": "static String getLargestString(String s, int k)\n{\n int []frequency_array = new int[26];\n for (int i = 0; i < s.Length; i++)\n {\n\tfrequency_array[s[i] - 'a']++;\n }\n String ans = \"\";\n for (int i = 25; i >= 0;)\n {\n\tif (frequency_array[i] > k)\n\t{\n\tint temp = k;\n\tString st = String.Join(\"\",\n\t\t\t\t(char)(i + 'a'));\n\twhile (temp > 0)\n\t{\n\t\tans += st;\n\t\ttemp--;\n\t}\n\tfrequency_array[i] -= k;\n\tint j = i - 1;\n\twhile (frequency_array[j] <= 0 && j >= 0)\n\t{\n\t\tj--;\n\t}\n\tif (frequency_array[j] > 0 && j >= 0)\n\t{\n\t\tString str = String.Join(\"\",\n\t\t\t\t\t(char)(j + 'a'));\n\t\tans += str;\n\t\tfrequency_array[j] -= 1;\n\t}\n\telse\n\t{\n\t\tbreak;\n\t}\n\t}\n\telse if (frequency_array[i] > 0)\n\t{\n\tint temp = frequency_array[i];\n\tfrequency_array[i] -= temp;\n\tString st = String.Join(\"\",\n\t\t\t\t(char)(i + 'a'));\n\twhile (temp > 0)\n\t{\n\t\tans += st;\n\t\ttemp--;\n\t}\n\t}\n\telse\n\t{\n\ti--;\n\t}\n }\n return ans;\n}", "5512": "static int minOperations(int []a, int []b, int n)\n{\n\tint minA = a.Max();\n\tfor(int x = minA; x >= 0; x--)\n\t{\n\tbool check = true;\n\tint operations = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (x % b[i] == a[i] % b[i])\n\t\t{\n\t\t\toperations += (a[i] - x) / b[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcheck = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (check)\n\t\treturn operations;\n\t}\n\treturn -1;\n}", "5538": "static int getLargestSum(int N)\n\t{\n\t\tint max_sum = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\t\tif (i * j % (i + j) == 0)\n\t\t\t\t\tmax_sum = Math.Max(max_sum, i + j);\n\t\t\t}\n\t\t}\n\t\treturn max_sum;\n\t}", "5539": "static int getLargestSum(int N)\n{\n\tint max_sum = 0;\n\tfor(int i = 1; i * i <= N; i++)\n\t{\n\tfor(int j = i + 1; j * j <= N; j++)\n\t{\n\t\tint k = N / j;\n\t\tint a = k * i;\n\t\tint b = k * j;\n\t\tif (a <= N && b <= N &&\n\t\t\ta * b % (a + b) == 0)\n\t\t\tmax_sum = Math.Max(max_sum, a + b);\n\t\t}\n\t}\n\treturn max_sum;\n}", "5544": "static int maxSubArraySum(int []a, int size)\n\t{\n\t\tint max_so_far = int.MinValue,\n\t\t\tmax_ending_here = 0;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tmax_ending_here =\n\t\t\t\tmax_ending_here + a[i];\n\t\t\tif (max_ending_here < 0)\n\t\t\t\tmax_ending_here = 0;\n\t\t\tif (max_so_far < max_ending_here)\n\t\t\t\tmax_so_far = max_ending_here;\n\t\t}\n\t\treturn max_so_far;\n\t}\nstatic int maxSum(int []a, int n)\n\t{\n\t\tint S = 0;\n\t\tint i;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tS += a[i];\n\t\tint X = maxSubArraySum(a, n);\n\t\treturn 2 * X - S;\n\t}", "5548": "static bool isPrime(int n)\n{\n\tint flag = 1;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tflag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (flag == 1 ? true : false);\n}\nstatic bool isPerfectSquare(int x)\n{\n\tdouble sr = Math.Sqrt(x);\n\treturn ((sr - Math.Floor(sr)) == 0);\n}\nstatic int countInterestingPrimes(int n)\n{\n\tint answer = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isPrime(i)) {\n\t\t\tfor (int j = 1; j * j * j * j <= i; j++) {\n\t\t\t\tif (\n\t\t\t\t\tisPerfectSquare( i - j * j * j * j)) {\n\t\t\t\t\tanswer++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn answer;\n}", "5549": "static void SieveOfEratosthenes( int n, HashSet<int> allPrimes)\n{\n\tbool []prime = new bool[n + 1];\n\tfor(int i = 0; i < n + 1; i++)\n\t\tprime[i] = true;\n\tfor (int p = 2; p * p <= n; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tallPrimes.Add(p);\n}\nstatic int countInterestingPrimes(int n)\n{\n\tHashSet<int> allPrimes = new HashSet<int>();\n\tSieveOfEratosthenes(n, allPrimes);\n\tHashSet<int> intersetingPrimes = new HashSet<int>();\n\tList<int> squares = new List<int>()\n\t\t\t, quadruples = new List<int>();\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tsquares.Add(i * i);\n\t}\n\tfor (int i = 1; i * i * i * i <= n; i++) {\n\t\tquadruples.Add(i * i * i * i);\n\t}\n\tforeach (int a in squares) {\n\t\tforeach (int b in quadruples) {\n\t\t\tif (allPrimes.Contains(a + b))\n\t\t\t\tintersetingPrimes.Add(a + b);\n\t\t}\n\t}\n\treturn intersetingPrimes.Count;\n}", "5585": "static void decBinary(int []arr, int n)\n\t{\n\t\tint k = (int)(Math.Log(n) /\n\t\t\t\t\tMath.Log(2));\n\t\twhile (n > 0)\n\t\t{\n\t\t\tarr[k--] = n % 2;\n\t\t\tn /= 2;\n\t\t}\n\t}\nstatic int binaryDec(int []arr, int n)\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans += arr[i] << (n - i - 1);\n\t\treturn ans;\n\t}\nstatic int maxNum(int n, int k)\n\t{\n\t\tint l = (int)(Math.Log(n) /\n\t\t\t\t\tMath.Log(2)) + 1;\n\t\tint []a = new int[l];\n\t\tdecBinary(a, n);\n\t\tint cn = 0;\n\t\tfor (int i = 0; i < l; i++)\n\t\t{\n\t\t\tif (a[i] == 0 && cn < k)\n\t\t\t{\n\t\t\t\ta[i] = 1;\n\t\t\t\tcn++;\n\t\t\t}\n\t\t}\n\t\treturn binaryDec(a, l);\n\t}", "5588": "static void findSubSeq(int []arr, int n, int sum)\n\t{\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (sum < arr[i])\n\t\t\t\tarr[i] = -1;\n\t\t\telse\n\t\t\t\tsum -= arr[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] != -1)\n\t\t\t\tConsole.Write(arr[i] + \" \");\n\t\t}\n\t}", "5594": "static char maxAlpha(String str, int len)\n{\n\tint []first = new int[MAX];\n\tint []last = new int[MAX];\n\tfor (int i = 0; i < MAX; i++)\n\t{\n\t\tfirst[i] = -1;\n\t\tlast[i] = -1;\n\t}\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tint index = (str[i] - 'a');\n\t\tif (first[index] == -1)\n\t\t\tfirst[index] = i;\n\t\tlast[index] = i;\n\t}\n\tint ans = -1, maxVal = -1;\n\tfor (int i = 0; i < MAX; i++)\n\t{\n\t\tif (first[i] == -1)\n\t\t\tcontinue;\n\t\tif ((last[i] - first[i]) > maxVal)\n\t\t{\n\t\t\tmaxVal = last[i] - first[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn (char)(ans + 'a');\n}", "5621": "static void find_distinct(int []a, int n, int q, int []queries)\n{\n\tint []check = new int[MAX];\n\tint []idx = new int[MAX];\n\tint cnt = 1;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tif (check[a[i]] == 0)\n\t\t{\n\t\t\tidx[i] = cnt;\n\t\t\tcheck[a[i]] = 1;\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tidx[i] = cnt - 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++)\n\t{\n\t\t\tint m = queries[i];\n\t\t\tConsole.Write(idx[m] + \" \");\n\t}\n}", "5627": "static int countOp(int x)\n{\n\tint []arr = new int[MAX];\n\tarr[0] = 1;\n\tfor (int i = 1; i < MAX; i++)\n\t\tarr[i] = arr[i - 1] * 2;\n\tint temp = x;\n\tbool flag = true;\n\tint ans = 0;\n\tint operations = 0;\n\tbool flag2 = false;\n\tfor (int i = 0; i < MAX; i++)\n\t{\n\t\tif (arr[i] - 1 == x)\n\t\t\tflag2 = true;\n\t\tif (arr[i] > x)\n\t\t{\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag2)\n\t\treturn 0;\n\twhile (flag)\n\t{\n\t\tif (arr[ans] < x)\n\t\t\tans++;\n\t\toperations++;\n\t\tfor (int i = 0; i < MAX; i++)\n\t\t{\n\t\t\tint take = x ^ (arr[i] - 1);\n\t\t\tif (take <= arr[ans] - 1)\n\t\t\t{\n\t\t\t\tif (take > temp)\n\t\t\t\t\ttemp = take;\n\t\t\t}\n\t\t}\n\t\tif (temp == arr[ans] - 1)\n\t\t{\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t\ttemp++;\n\t\toperations++;\n\t\tx = temp;\n\t\tif (x == arr[ans] - 1)\n\t\t\tflag = false;\n\t}\n\treturn operations;\n}", "5636": "static int minOperations(int[] arr, int n)\n\t{\n\t\tint maxi, result = 0;\n\t\tint[] freq = new int[1000001];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint x = arr[i];\n\t\t\tfreq[x]++;\n\t\t}\n\t\tmaxi = arr.Max();\n\t\tfor (int i = 1; i <= maxi; i++)\n\t\t{\n\t\t\tif (freq[i] != 0)\n\t\t\t{\n\t\t\t\tfor (int j = i * 2; j <= maxi; j = j + i)\n\t\t\t\t{\n\t\t\t\t\tfreq[j] = 0;\n\t\t\t\t}\n\t\t\t\tresult++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "5675": "static String encryptString(String str, int n)\n{\n\tint i = 0, cnt = 0;\n\tString encryptedStr = \"\";\n\twhile (i < n)\n\t{\n\t\tcnt = i + 1;\n\t\twhile (cnt-- >0)\n\t\t\tencryptedStr += str[i];\n\t\ti++;\n\t}\n\treturn encryptedStr;\n}", "5676": "static int __gcd(int a, int b)\n\t{\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn __gcd(b % a, a);\n\t}\nstatic int minGCD(int [] arr, int n)\n\t{\n\t\tint minGCD = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tminGCD = __gcd(minGCD, arr[i]);\n\t\treturn minGCD;\n\t}\nstatic int minLCM(int [] arr, int n)\n\t{\n\t\tint minLCM = arr[0];\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tminLCM = Math.Min(minLCM, arr[i]);\n\t\treturn minLCM;\n\t}", "5687": "static String formStringMinOperations(char[] s)\n\t{\n\t\tint []count = new int[3];\n\t\tforeach (char c in s)\n\t\t{\n\t\t\tcount[(int)c - 48] += 1;\n\t\t}\n\t\tint []processed = new int[3];\n\t\tint reqd = (int) s.Length / 3;\n\t\tfor (int i = 0; i < s.Length; i++)\n\t\t{\n\t\t\tif (count[s[i] - '0'] == reqd)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[i] == '0' && count[0] > reqd && processed[0] >= reqd)\n\t\t\t{\n\t\t\t\tif (count[1] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '1';\n\t\t\t\t\tcount[1]++;\n\t\t\t\t\tcount[0]--;\n\t\t\t\t}\n\t\t\t\telse if (count[2] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '2';\n\t\t\t\t\tcount[2]++;\n\t\t\t\t\tcount[0]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '1' && count[1] > reqd)\n\t\t\t{\n\t\t\t\tif (count[0] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '0';\n\t\t\t\t\tcount[0]++;\n\t\t\t\t\tcount[1]--;\n\t\t\t\t}\n\t\t\t\telse if (count[2] < reqd && processed[1] >= reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '2';\n\t\t\t\t\tcount[2]++;\n\t\t\t\t\tcount[1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[i] == '2' && count[2] > reqd)\n\t\t\t{\n\t\t\t\tif (count[0] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '0';\n\t\t\t\t\tcount[0]++;\n\t\t\t\t\tcount[2]--;\n\t\t\t\t}\n\t\t\t\telse if (count[1] < reqd)\n\t\t\t\t{\n\t\t\t\t\ts[i] = '1';\n\t\t\t\t\tcount[1]++;\n\t\t\t\t\tcount[2]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed[s[i] - '0']++;\n\t\t}\n\t\treturn String.Join(\"\",s);\n\t}", "5730": "static int minDiff(int n, int x, int []A)\n\t{\n\t\tint mn = A[0], mx = A[0];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tmn = Math.Min(mn, A[i]);\n\t\t\tmx = Math.Max(mx, A[i]);\n\t\t}\n\t\treturn Math.Max(0, mx - mn - 2 * x);\n\t}", "5739": "", "5742": "static bool isWaveArray(int []arr, int n)\n{\n\tbool result = true;\n\tif (arr[1] > arr[0] && arr[1] > arr[2])\n\t{\n\t\tfor (int i = 1; i < n - 1; i += 2)\n\t\t{\n\t\t\tif (arr[i] > arr[i - 1] && arr[i] > arr[i + 1])\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (result == true && n % 2 == 0)\n\t\t{\n\t\t\tif (arr[n - 1] <= arr[n - 2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (arr[1] < arr[0] && arr[1] < arr[2])\n\t{\n\t\tfor (int i = 1; i < n - 1; i += 2)\n\t\t{\n\t\t\tif (arr[i] < arr[i - 1] && arr[i] < arr[i + 1])\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (result == true && n % 2 == 0)\n\t\t{\n\t\t\tif (arr[n - 1] >= arr[n - 2])\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "5762": "static int findMinimumAdjacentSwaps(int []arr, int N)\n\t{\n\t\tbool[] visited = new bool[N + 1];\n\t\tint minimumSwaps = 0;\n\t\tfor (int i = 0; i < 2 * N; i++)\n\t\t{\n\t\t\tif (visited[arr[i]] == false)\n\t\t\t{\n\t\t\t\tvisited[arr[i]] = true;\n\t\t\t\tint count = 0;\n\t\t\t\tfor (int j = i + 1; j < 2 * N; j++)\n\t\t\t\t{\n\t\t\t\t\tif (visited[arr[j]] == false)\n\t\t\t\t\t\tcount++;\n\t\t\t\t\telse if (arr[i] == arr[j])\n\t\t\t\t\t\tminimumSwaps += count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn minimumSwaps;\n\t}", "5772": "static bool possibility(Dictionary<int, int> m, int length, string s)\n{\n\tint countodd = 0;\n\tfor(int i = 0; i < length; i++)\n\t{\n\t\tif ((m[s[i] - '0'] & 1) != 0)\n\t\t\tcountodd++;\n\t\tif (countodd > 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nstatic void largestPalindrome(string s)\n{\n\tint l = s.Length;\n\tDictionary<int,\n\t\t\tint> m = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < 10; i++)\n\t\tm[i] = 0;\n\tfor(int i = 0; i < l; i++)\n\t\tm[s[i] - '0']++;\n\tif (possibility(m, l, s) == false)\n\t{\n\t\tConsole.Write(\"Palindrome cannot be formed\");\n\t\treturn;\n\t}\n\tchar []largest = new char[l];\n\tint front = 0;\n\tfor(int i = 9; i >= 0; i--)\n\t{\n\t\tif ((m[i] & 1) != 0)\n\t\t{\n\t\t\tlargest[l / 2] = (char)(i + '0');\n\t\t\tm[i]--;\n\t\t\twhile (m[i] > 0)\n\t\t\t{\n\t\t\t\tlargest[front] = (char)(i + '0');\n\t\t\t\tlargest[l - front - 1] = (char)(i + '0');\n\t\t\t\tm[i] -= 2;\n\t\t\t\tfront++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (m[i] > 0)\n\t\t\t{\n\t\t\t\tlargest[front] = (char)(i + '0');\n\t\t\t\tlargest[l - front - 1] = (char)(i + '0');\n\t\t\t\tm[i] -= 2;\n\t\t\t\tfront++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < l; i++)\n\t{\n\t\tConsole.Write(largest[i]);\n\t}\n}", "5797": "static long swapCount(string s)\n{\n\tList<int> pos = new List<int>();\n\tfor(int i = 0; i < s.Length; i++)\n\t{\n\t\tif (s[i] == '[')\n\t\t{\n\t\t\tpos.Add(i);\n\t\t}\n\t}\n\tint count = 0;\n\tint p = 0;\n\tlong sum = 0;\n\tchar[] S = s.ToCharArray();\n\tfor(int i = 0; i < S.Length; i++)\n\t{\n\t\tif (S[i] == '[')\n\t\t{\n\t\t\t++count;\n\t\t\t++p;\n\t\t}\n\t\telse if (S[i] == ']')\n\t\t{\n\t\t\t--count;\n\t\t}\n\t\tif (count < 0)\n\t\t{\n\t\t\tsum += pos[p]-i;\n\t\t\tchar temp = S[i];\n\t\t\tS[i] = S[pos[p]];\n\t\t\tS[pos[p]] = temp;\n\t\t\t++p;\n\t\t\tcount = 1;\n\t\t}\n\t}\n\treturn sum;\n}", "5798": "public static long swapCount(string s)\n{\n\tchar[] chars = s.ToCharArray();\n\tint countLeft = 0, countRight = 0;\n\tint swap = 0, imbalance = 0;\n\tfor (int i = 0; i < chars.Length; i++)\n\t{\n\t\tif (chars[i] == '[')\n\t\t{\n\t\t\tcountLeft++;\n\t\t\tif (imbalance > 0)\n\t\t\t{\n\t\t\t\tswap += imbalance;\n\t\t\t\timbalance--;\n\t\t\t}\n\t\t}\n\t\telse if (chars[i] == ']')\n\t\t{\n\t\t\tcountRight++;\n\t\t\timbalance = (countRight - countLeft);\n\t\t}\n\t}\n\treturn swap;\n}", "5811": "static void minimizeWithKSwaps(int []arr, int n, int k)\n\t{\n\t\tfor (int i = 0; i < n-1 && k > 0; ++i)\n\t\t{\n\t\t\tint pos = i;\n\t\t\tfor (int j = i+1; j < n ; ++j)\n\t\t\t{\n\t\t\t\tif (j - i > k)\n\t\t\t\t\tbreak;\n\t\t\t\tif (arr[j] < arr[pos])\n\t\t\t\t\tpos = j;\n\t\t\t}\n\t\t\tint temp;\n\t\t\tfor (int j = pos; j>i; --j)\n\t\t\t{\n\t\t\t\ttemp=arr[j];\n\t\t\t\tarr[j]=arr[j-1];\n\t\t\t\tarr[j-1]=temp;\n\t\t\t}\n\t\t\tk -= pos-i;\n\t\t}\n\t}", "5816": "static int minimumCostOfBreaking(int[] X, int[] Y, int m, int n)\n\t{\n\t\tint res = 0;\n\t\tArray.Sort<int>(X, new Comparison<int>(\n\t\t\t\t(i1, i2) => i2.CompareTo(i1)));\n\t\tArray.Sort<int>(Y, new Comparison<int>(\n\t\t\t\t(i1, i2) => i2.CompareTo(i1)));\n\t\tint hzntl = 1, vert = 1;\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n)\n\t\t{\n\t\t\tif (X[i] > Y[j])\n\t\t\t{\n\t\t\t\tres += X[i] * vert;\n\t\t\t\thzntl++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += Y[j] * hzntl;\n\t\t\t\tvert++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tint total = 0;\n\t\twhile (i < m)\n\t\t\ttotal += X[i++];\n\t\tres += total * vert;\n\t\ttotal = 0;\n\t\twhile (j < n)\n\t\t\ttotal += Y[j++];\n\t\tres += total * hzntl;\n\t\treturn res;\n\t}", "5865": "static int getMin(int x, int y, int z)\n{\n\treturn Math.Min(Math.Min(x, y), z);\n}\nstatic int editDistance(string str1, string str2, int m, int n)\n{\n\tint [,]dp = new int[m + 1,n + 1];\n\tfor (int i = 0; i <= m; i++)\n\t{\n\t\tfor (int j = 0; j <= n; j++)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t\tdp[i,j] = j;\n\t\t\telse if (j == 0)\n\t\t\t\tdp[i,j] = i;\n\t\t\telse if (str1[i - 1] == str2[j - 1])\n\t\t\t\tdp[i,j] = dp[i - 1,j - 1];\n\t\t\telse {\n\t\t\t\tdp[i,j] = 1\n\t\t\t\t\t\t+ getMin( dp[i,j - 1], dp[i - 1,j], dp[i - 1,j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[m,n];\n}\nstatic void minimumSteps(string S, int N)\n{\n\tint ans = int.MaxValue;\n\tfor (int i = 1; i < N; i++) {\n\t\tstring S1 = S.Substring(0, i);\n\t\tstring S2 = S.Substring(i);\n\t\tint count = editDistance( S1, S2, S1.Length, S2.Length);\n\t\tans = Math.Min(ans, count);\n\t}\n\tConsole.Write(ans);\n}", "5872": "static int minimumOperations(int N)\n\t{\n\t\tint[] dp = new int[N + 1];\n\t\tint i;\n\t\tfor (i = 0; i <= N; i++) {\n\t\t\tdp[i] = (int)1e9;\n\t\t}\n\t\tdp[2] = 0;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tif (dp[i] == (int)1e9)\n\t\t\t\tcontinue;\n\t\t\tif (i * 5 <= N) {\n\t\t\t\tdp[i * 5] = Math.Min(dp[i * 5], dp[i] + 1);\n\t\t\t}\n\t\t\tif (i + 3 <= N) {\n\t\t\t\tdp[i + 3] = Math.Min(dp[i + 3], dp[i] + 1);\n\t\t\t}\n\t\t}\n\t\tif (dp[N] == 1e9)\n\t\t\treturn -1;\n\t\treturn dp[N];\n\t}", "5880": "static int MaxProfit(int[] arr, int n, int transactionFee)\n\t{\n\t\tint buy = -arr[0];\n\t\tint sell = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint temp = buy;\n\t\t\tbuy = Math.Max(buy, sell - arr[i]);\n\t\t\tsell = Math.Max(sell, temp + arr[i] - transactionFee);\n\t\t}\n\t\treturn Math.Max(sell, buy);\n\t}", "5904": "static void countPossiblities(int[] arr, int n)\n\t{\n\t\tint[] lastOccur = new int[100000];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlastOccur[i] = -1;\n\t\t}\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint curEle = arr[i - 1];\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (lastOccur[curEle] != -1 & lastOccur[curEle] < i - 1) {\n\t\t\t\tdp[i] += dp[lastOccur[curEle]];\n\t\t\t}\n\t\t\tlastOccur[curEle] = i;\n\t\t}\n\t\tConsole.WriteLine(dp[n]);\n\t}", "5919": "public static int longestSubSequence(int[,] A, int N, int ind, int lastf, int lasts)\n{\n\tind = (ind > 0 ? ind : 0);\n\tlastf = (lastf > 0 ? lastf: Int32.MinValue);\n\tlasts = (lasts > 0 ? lasts: Int32.MaxValue);\n\tif (ind == N)\n\t\treturn 0;\n\tint ans = longestSubSequence(A, N, ind + 1, lastf, lasts);\n\tif (A[ind, 0] > lastf && A[ind, 1] < lasts)\n\t\tans = Math.Max(ans, longestSubSequence(A, N, ind + 1, A[ind, 0], A[ind, 1]) + 1);\n\treturn ans;\n}", "5920": "static void longestSubSequence(int[,] A, int N)\n\t{\n\t\tint[] dp = new int[N];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tdp[i] = 1;\n\t\t\tfor(int j = 0; j < i; j++)\n\t\t\t{\n\t\t\t\tif (A[j,0] < A[i,0] && A[j,1] > A[i,1])\n\t\t\t\t{\n\t\t\t\t\tdp[i] = Math.Max(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.Write(dp[N - 1]);\n\t}", "5924": "static void calculateStart(int n, int m)\n{\n\tfor(int i = 1; i < m; ++i)\n\t{\n\t\tstart[0, i] += start[0, i - 1];\n\t}\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tstart[i, 0] += start[i - 1, 0];\n\t}\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tfor(int j = 1; j < m; ++j)\n\t\t{\n\t\t\tstart[i, j] += Math.Max(start[i - 1, j], start[i, j - 1]);\n\t\t}\n\t}\n}\nstatic void calculateEnd(int n, int m)\n{\n\tfor(int i = n - 2; i >= 0; --i)\n\t{\n\t\tending[i, m - 1] += ending[i + 1, m - 1];\n\t}\n\tfor(int i = m - 2; i >= 0; --i)\n\t{\n\t\tending[n - 1, i] += ending[n - 1, i + 1];\n\t}\n\tfor(int i = n - 2; i >= 0; --i)\n\t{\n\t\tfor(int j = m - 2; j >= 0; --j)\n\t\t{\n\t\t\tending[i, j] += Math.Max(ending[i + 1, j], ending[i, j + 1]);\n\t\t}\n\t}\n}\nstatic void maximumPathSum(int[,] mat, int n, int m, int q, int[,] coordinates)\n{\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tfor(int j = 0; j < m; ++j)\n\t\t{\n\t\t\tstart[i, j] = mat[i, j];\n\t\t\tending[i, j] = mat[i, j];\n\t\t}\n\t}\n\tcalculateStart(n, m);\n\tcalculateEnd(n, m);\n\tint ans = 0;\n\tfor(int i = 0; i < q; ++i)\n\t{\n\t\tint X = coordinates[i, 0] - 1;\n\t\tint Y = coordinates[i, 1] - 1;\n\t\tans = Math.Max(ans, start[X, Y] + ending[X, Y] - mat[X, Y]);\n\t}\n\tConsole.Write(ans);\n}", "5946": "static int MaxSubsetlength(string[] arr, int A, int B)\n {\n\tint[, ] dp = new int[A + 1, B + 1];\n\tforeach(string str in arr)\n\t{\n\tint zeros = 0, ones = 0;\n\tforeach(char ch in str.ToCharArray())\n\t{\n\t\tif (ch == '0')\n\t\tzeros++;\n\t\telse\n\t\tones++;\n\t}\n\tfor (int i = A; i >= zeros; i--)\n\t\tfor (int j = B; j >= ones; j--)\n\t\tdp[i, j] = Math.Max( dp[i, j], dp[i - zeros, j - ones] + 1);\n\t}\n\treturn dp[A, B];\n }", "5957": "static int numOfWays(int[,] a, int n, int i, HashSet<int> blue)\n{\n\tif (i == n)\n\t\treturn 1;\n\tint count = 0;\n\tfor(int j = 0; j < n; j++)\n\t{\n\t\tif (a[i, j] == 1 && !blue.Contains(j))\n\t\t{\n\t\t\tblue.Add(j);\n\t\t\tcount += numOfWays(a, n, i + 1, blue);\n\t\t\tblue.Remove(j);\n\t\t}\n\t}\n\treturn count;\n}", "5970": "static void minCost(int []arr, int n)\n {\n\tif (n < 3) {\n\tConsole.WriteLine(arr[0]);\n\treturn;\n\t}\n\tint []dp = new int[n];\n\tdp[0] = arr[0];\n\tdp[1] = dp[0] + arr[1] + arr[2];\n\tfor (int i = 2; i < n - 1; i++)\n\tdp[i] = Math.Min(dp[i - 2] + arr[i], dp[i - 1] + arr[i] + arr[i + 1]);\n\tdp[n - 1] = Math.Min(dp[n - 2], dp[n - 3] + arr[n - 1]);\n\tConsole.WriteLine(dp[n - 1]);\n }", "5995": "static int power(int X, int Y)\n {\n\tint res = 1;\n\tX = X % M;\n\tif (X == 0)\n\treturn 0;\n\twhile (Y > 0)\n\t{\n\tif ((Y & 1) != 0)\n\t{\n\t\tres = (res * X) % M;\n\t}\n\tY = Y >> 1;\n\tX = (X * X) % M;\n\t}\n\treturn res;\n }\nstatic int findValue(int n)\n {\n\tint X = 0;\n\tint pow_10 = 1;\n\twhile (n != 0)\n\t{\n\tif ((n & 1) != 0)\n\t{\n\t\tX += pow_10;\n\t}\n\tpow_10 *= 10;\n\tn /= 2;\n\t}\n\tX = (X * 2) % M;\n\tint res = power(2, X);\n\treturn res;\n }", "5996": "static long power(long X, long Y)\n {\n\tlong res = 1;\n\tX = X % M;\n\tif (X == 0)\n\treturn 0;\n\twhile (Y > 0)\n\t{\n\tif (Y % 2 == 1)\n\t{\n\t\tres = (res * X) % M;\n\t}\n\tY = Y >> 1;\n\tX = (X * X) % M;\n\t}\n\treturn res;\n }\nstatic long findValue(int N)\n {\n\tlong []dp = new long[N + 1];\n\tdp[1] = 2;\n\tdp[2] = 1024;\n\tfor (int i = 3; i <= N; i++)\n\t{\n\tint y = (i & (-i));\n\tint x = i - y;\n\tif (x == 0)\n\t{\n\t\tdp[i]\n\t\t= power(dp[i / 2], 10);\n\t}\n\telse\n\t{\n\t\tdp[i]\n\t\t= (dp[x] * dp[y]) % M;\n\t}\n\t}\n\treturn (dp[N] * dp[N]) % M;\n }", "6000": "static int countTriplets(int []A)\n{\n\tint cnt = 0;\n\tDictionary<int,int> tuples = new Dictionary<int,int>();\n\tforeach (int a in A)\n\t\tforeach (int b in A)\n\t\t{\n\t\t\tif(tuples.ContainsKey(a & b))\n\t\t\t\ttuples[a & b] = tuples[a & b] + 1;\n\t\t\telse\n\t\t\t\ttuples.Add(a & b, 1);\n\t\t}\n\tforeach (int a in A)\n\t\tforeach (KeyValuePair<int, int> t in tuples)\n\t\t\tif ((t.Key & a) == 0)\n\t\t\t\tcnt += t.Value;\n\treturn cnt;\n}", "6021": "static int findMinimum(int[] arr, int N, int pos, int turn)\n\t{\n\t\tTuple<int,int> x = new Tuple<int,int>(pos, turn);\n\t\tif (m.ContainsKey(x))\n\t\t{\n\t\t\treturn m[x];\n\t\t}\n\t\tif (pos >= N - 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (turn == 0)\n\t\t{\n\t\t\tint ans = Math.Min(\n\t\t\t\tfindMinimum(arr, N, pos + 1, 1) + arr[pos],\n\t\t\t\tfindMinimum(arr, N, pos + 2, 1) + arr[pos] + arr[pos + 1]);\n\t\t\tTuple<int,int> v = new Tuple<int,int>(pos, turn);\n\t\t\tm[v] = ans;\n\t\t\treturn ans;\n\t\t}\n\t\tif (turn != 0)\n\t\t{\n\t\t\tint ans = Math.Min(\n\t\t\t\tfindMinimum(arr, N, pos + 1, 0),\n\t\t\t\tfindMinimum(arr, N, pos + 2, 0));\n\t\t\tTuple<int,int> v = new Tuple<int,int>(pos, turn);\n\t\t\tm[v] = ans;\n\t\t\treturn ans;\n\t\t}\n\t\treturn 0;\n\t}\nstatic int countPenality(int[] arr, int N)\n\t{\n\t\tint pos = 0;\n\t\tint turn = 0;\n\t\treturn findMinimum(arr, N, pos, turn) + 1;\n\t}\nstatic void printAnswer(int[] arr, int N)\n\t{\n\t\tint a = countPenality(arr, N);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tsum += arr[i];\n\t\t}\n\t\tConsole.WriteLine(a);\n\t}", "6028": "static void maxSum(int[, ] arr, int n, int m)\n{\n\tint[, ] dp = new int[n, m + 1];\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tfor(int j = 0; j <= m; j++)\n\t\t{\n\t\t\tdp[i, j] = 0;\n\t\t}\n\t}\n\tdp[0, m - 1] = arr[0, m - 1];\n\tdp[1, m - 1] = arr[1, m - 1];\n\tfor(int j = m - 2; j >= 0; j--)\n\t{\n\t\tfor(int i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (i == 1)\n\t\t\t{\n\t\t\t\tdp[i, j] = Math.Max( arr[i, j] + dp[0, j + 1], arr[i, j] + dp[0, j + 2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i, j] = Math.Max( arr[i, j] + dp[1, j + 1], arr[i, j] + dp[1, j + 2]);\n\t\t\t}\n\t\t}\n\t}\n\tConsole.WriteLine(Math.Max(dp[0, 0], dp[1, 0]));\n}", "6029": "static void maxSum(int[, ] arr, int n)\n{\n\tint r1 = 0, r2 = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tint temp = r1;\n\t\tr1 = Math.Max(r1, r2 + arr[0, i]);\n\t\tr2 = Math.Max(r2, temp + arr[1, i]);\n\t}\n\tConsole.WriteLine(Math.Max(r1, r2));\n}", "6065": "static int Max_Sum(int[] arr, int K, int N)\n{\n\tint[] dp = new int[N + 1];\n\tArray.Fill(dp, 0);\n\tint[] prefix = new int[N + 1];\n\tprefix[0] = 0;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tprefix[i] = prefix[i - 1] + arr[i - 1];\n\t}\n\tdp[0] = 0;\n\tfor(int i = 1; i <= K - 1; i++)\n\t{\n\t\tdp[i] = prefix[i];\n\t}\n\tfor(int i = K; i <= N; ++i)\n\t{\n\t\tfor(int j = i; j >= (i - K + 1); j--)\n\t\t{\n\t\t\tdp[i] = Math.Max(dp[i], dp[j - 1] + prefix[i] - prefix[j]);\n\t\t}\n\t}\n\treturn dp[N];\n}", "6068": "static void Calculate_factorial()\n\t{\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= mx; i++)\n\t\t{\n\t\t\tfact[i] = i * fact[i - 1];\n\t\t\tfact[i] %= mod;\n\t\t}\n\t}\nstatic int UniModal_per(int a, int b)\n\t{\n\t\tint res = 1;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif (b % 2 != 0)\n\t\t\t\tres = res * a;\n\t\t\tres %= mod;\n\t\t\ta = a * a;\n\t\t\ta %= mod;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn res;\n\t}\nstatic void countPermutations(int n)\n\t{\n\t\tCalculate_factorial();\n\t\tint uni_modal = UniModal_per(2, n - 1);\n\t\tint nonuni_modal = fact[n] - uni_modal;\n\t\tConsole.Write(uni_modal + \" \" + nonuni_modal);\n\t\treturn;\n\t}", "6071": "static int findWays(int N)\n{\n if (N == 0)\n {\n\treturn 1;\n }\n int cnt = 0;\n for(int i = 1; i <= 6; i++)\n {\n\tif (N - i >= 0)\n\t{\n\tcnt = cnt + findWays(N - i);\n\t}\n }\n return cnt;\n}", "6072": "static int findWays(int N, int []dp)\n{\n if (N == 0)\n {\n\treturn 1;\n }\n if (dp[N] != -1)\n {\n\treturn dp[N];\n }\n int cnt = 0;\n for (int i = 1; i <= 6; i++)\n {\n\tif (N - i >= 0)\n\t{\n\tcnt = cnt + findWays(N - i, dp);\n\t}\n }\n return dp[N] = cnt;\n}", "6073": "static void findWays(int N)\n{\n int []dp = new int[N + 1];\n dp[0] = 1;\n for(int i = 1; i <= N; i++)\n {\n\tdp[i] = 0;\n\tfor(int j = 1; j <= 6; j++)\n\t{\n\tif (i - j >= 0)\n\t{\n\t\tdp[i] = dp[i] + dp[i - j];\n\t}\n\t}\n }\n Console.Write(dp[N]);\n}", "6082": "static int checkEqualSumUtil(int[] arr, int N, int sm1, int sm2, int sm3, int j)\n{\n if (j == N)\n {\n\tif (sm1 == sm2 && sm2 == sm3)\n\treturn 1;\n\telse\n\treturn 0;\n }\n else\n {\n\tint l = checkEqualSumUtil(arr, N, sm1 + arr[j], sm2, sm3, j + 1);\n\tint m = checkEqualSumUtil(arr, N, sm1, sm2 + arr[j], sm3, j + 1);\n\tint r = checkEqualSumUtil(arr, N, sm1, sm2, sm3 + arr[j], j + 1);\n\treturn Math.Max(Math.Max(l, m), r);\n }\n}\nstatic void checkEqualSum(int[] arr, int N)\n{\n int sum1, sum2, sum3;\n sum1 = sum2 = sum3 = 0;\n if (checkEqualSumUtil(arr, N, sum1, sum2, sum3, 0) == 1)\n {\n\tConsole.Write(\"Yes\");\n }\n else\n {\n\tConsole.Write(\"No\");\n }\n}", "6083": "static int checkEqualSumUtil(int []arr, int N, int sm1, int sm2, int sm3, int j)\n{\n\tstring s = sm1.ToString() + \"_\" +\n\t\t\tsm2.ToString() + j.ToString();\n\tif (j == N)\n\t{\n\t\tif (sm1 == sm2 && sm2 == sm3)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tif (dp.ContainsKey(s))\n\t\treturn dp[s];\n\telse\n\t{\n\t\tint l = checkEqualSumUtil(arr, N, sm1 + arr[j], sm2, sm3, j + 1);\n\t\tint m = checkEqualSumUtil(arr, N, sm1, sm2 + arr[j], sm3, j + 1);\n\t\tint r = checkEqualSumUtil(arr, N, sm1, sm2, sm3 + arr[j], j + 1);\n\t\tdp[s] = Math.Max(Math.Max(l, m), r);\n\t\treturn dp[s];\n\t}\n}\nstatic void checkEqualSum(int []arr, int N)\n{\n\tint sum1, sum2, sum3;\n\tsum1 = sum2 = sum3 = 0;\n\tif (checkEqualSumUtil(arr, N, sum1, sum2, sum3, 0) == 1)\n\t{\n\t\tConsole.Write(\"Yes\");\n\t}\n\telse\n\t{\n\t\tConsole.Write(\"No\");\n\t}\n}", "6113": "static void SieveOfEratosthenes()\n {\n\tArray.Fill(prime, 1);\n\tfor (int p = 2; p * p <= MAX; p++)\n\t{\n\tif (prime[p] == 1)\n\t{\n\t\tfor (int i = p * p; i <= MAX - 1; i += p)\n\t\tprime[i] = 0;\n\t}\n\t}\n }\nstatic int getMid(int s, int e)\n {\n\treturn s + (e - s) / 2;\n }\nstatic int getSumUtil(int[] st, int ss, int se, int qs, int qe, int si)\n {\n\tif (qs <= ss && qe >= se)\n\treturn st[si];\n\tif (se < qs ss > qe)\n\treturn 0;\n\tint mid = getMid(ss, se);\n\treturn getSumUtil(st, ss, mid, qs, qe, 2 * si + 1)\n\t+ getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2);\n }\nstatic void updateValueUtil(int[] st, int ss, int se, int i, int diff, int si)\n {\n\tif (i < ss i > se)\n\treturn;\n\tst[si] = st[si] + diff;\n\tif (se != ss)\n\t{\n\tint mid = getMid(ss, se);\n\tupdateValueUtil(st, ss, mid, i, diff, 2 * si + 1);\n\tupdateValueUtil(st, mid + 1, se, i, diff, 2 * si + 2);\n\t}\n }\nstatic void updateValue(int[] arr, int[] st, int n, int i, int new_val)\n {\n\tif (i < 0 i > n - 1)\n\t{\n\tConsole.Write(\"-1\");\n\treturn;\n\t}\n\tint diff = new_val - arr[i];\n\tint prev_val = arr[i];\n\tarr[i] = new_val;\n\tif ((prime[new_val] prime[prev_val]) != 0)\n\t{\n\tif (prime[prev_val] == 0)\n\t\tupdateValueUtil(st, 0, n - 1, i, new_val, 0);\n\telse if (prime[new_val] == 0)\n\t\tupdateValueUtil(st, 0, n - 1, i, -prev_val, 0);\n\telse\n\t\tupdateValueUtil(st, 0, n - 1, i, diff, 0);\n\t}\n }\nstatic int getSum(int[] st, int n, int qs, int qe)\n {\n\tif (qs < 0 qe > n - 1 qs > qe)\n\t{\n\tConsole.WriteLine( \"-1\");\n\treturn -1;\n\t}\n\treturn getSumUtil(st, 0, n - 1, qs, qe, 0);\n }\nstatic int constructSTUtil(int[] arr, int ss, int se, int[] st, int si)\n {\n\tif (ss == se) {\n\tif (prime[arr[ss]] != 0)\n\t\tst[si] = arr[ss];\n\telse\n\t\tst[si] = 0;\n\treturn st[si];\n\t}\n\tint mid = getMid(ss, se);\n\tst[si] = constructSTUtil(arr, ss, mid, st, si * 2 + 1)\n\t+ constructSTUtil(arr, mid + 1, se, st, si * 2 + 2);\n\treturn st[si];\n }\nstatic int[] constructST(int[] arr, int n)\n {\n\tint x = (int)(Math.Ceiling(Math.Log(n,2)));\n\tint max_size = 2 * (int)Math.Pow(2, x) - 1;\n\tint[] st = new int[max_size];\n\tconstructSTUtil(arr, 0, n - 1, st, 0);\n\treturn st;\n }", "6138": "static void precompute(int []nextpos, int []arr, int N)\n{\n\tnextpos[N - 1] = N;\n\tfor(int i = N - 2; i >= 0; i--)\n\t{\n\t\tif (arr[i] == arr[i + 1])\n\t\t\tnextpos[i] = nextpos[i + 1];\n\t\telse\n\t\t\tnextpos[i] = i + 1;\n\t}\n}\nstatic void findIndex(int [,]query, int []arr, int N, int Q)\n{\n\tint []nextpos = new int[N];\n\tprecompute(nextpos, arr, N);\n\tfor(int i = 0; i < Q; i++)\n\t{\n\t\tint l, r, x;\n\t\tl = query[i, 0];\n\t\tr = query[i, 1];\n\t\tx = query[i, 2];\n\t\tint ans = -1;\n\t\tif (arr[l] != x)\n\t\t\tans = l;\n\t\telse\n\t\t{\n\t\t\tint d = nextpos[l];\n\t\t\tif (d <= r)\n\t\t\t\tans = d;\n\t\t}\n\t\tConsole.Write(ans + \"\\n\");\n\t}\n}", "6151": "static long countWays(string s, string t, int k)\n{\n\tint n = s.Length;\n\tint a = 0, b = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tstring p = s.Substring(i, n - i) +\n\t\t\t\ts.Substring(0, i);\n\t\tif (p == t)\n\t\t\ta++;\n\t\telse\n\t\t\tb++;\n\t}\n\tlong []dp1 = new long[k + 1];\n\tlong []dp2 = new long[k + 1];\n\tif (s == t)\n\t{\n\t\tdp1[0] = 1;\n\t\tdp2[0] = 0;\n\t}\n\telse\n\t{\n\t\tdp1[0] = 0;\n\t\tdp2[0] = 1;\n\t}\n\tfor(int i = 1; i <= k; i++)\n\t{\n\t\tdp1[i] = ((dp1[i - 1] * (a - 1)) % mod +\n\t\t\t\t(dp2[i - 1] * a) % mod) % mod;\n\t\tdp2[i] = ((dp1[i - 1] * (b)) % mod +\n\t\t\t\t(dp2[i - 1] * (b - 1)) % mod) % mod;\n\t}\n\treturn dp1[k];\n}", "6169": "static void insert(int idx, String s, TrieNode root)\n{\n\tTrieNode temp = root;\n\tfor(int i = idx; i < s.Length; i++)\n\t{\t\n\t\tif (temp.child[s[i] - 'a'] == null)\n\t\t\ttemp.child[s[i] - 'a'] =\n\t\t\t\t\tnew TrieNode();\n\t\ttemp = temp.child[s[i] - 'a'];\n\t}\n}\nstatic int minCuts(String S1, String S2)\n{\n\tint n1 = S1.Length;\n\tint n2 = S2.Length;\n\tTrieNode root = new TrieNode();\n\tfor(int i = 0; i < n2; i++)\n\t{\t\n\t\tinsert(i, S2, root);\n\t}\n\tint []dp = new int[n1 + 1];\n\tfor(int i = 0; i <= n1; i++)\n\t\tdp[i] = INF;\n\tdp[0] = 0;\n\tfor(int i = 0; i < n1; i++)\n\t{\t\n\t\tTrieNode temp = root;\n\t\tfor(int j = i + 1; j <= n1; j++)\n\t\t{\n\t\t\tif (temp.child[S1[j-1] - 'a'] == null)\n\t\t\t\tbreak;\n\t\t\tdp[j] = Math.Min(dp[j], dp[i] + 1);\n\t\t\ttemp = temp.child[S1[j - 1] - 'a'];\n\t\t}\n\t}\n\tif (dp[n1] >= INF)\n\t\treturn -1;\n\telse\n\t\treturn dp[n1];\n}", "6174": "static int minOperation(int k)\n{\n\tint []dp = new int[k + 1];\n\tfor(int i = 1; i <= k; i++)\n\t{\n\t\tdp[i] = dp[i - 1] + 1;\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\tdp[i] = Math.Min(dp[i], dp[i / 2] + 1);\n\t\t}\n\t}\n\treturn dp[k];\n}", "6181": "static void longestSubseq(String s, int length)\n{\n\tint[] ones = new int[length + 1];\n\tint[] zeroes = new int[length + 1];\n\tfor(int i = 0; i < length; i++)\n\t{\n\t\tif (s[i] == '1')\n\t\t{\n\t\t\tones[i + 1] = ones[i] + 1;\n\t\t\tzeroes[i + 1] = zeroes[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tzeroes[i + 1] = zeroes[i] + 1;\n\t\t\tones[i + 1] = ones[i];\n\t\t}\n\t}\n\tint answer = int.MinValue;\n\tint x = 0;\n\tfor(int i = 0; i <= length; i++)\n\t{\n\t\tfor(int j = i; j <= length; j++)\n\t\t{\n\t\t\tx += ones[i];\n\t\t\tx += (zeroes[j] - zeroes[i]);\n\t\t\tx += (ones[length] - ones[j]);\n\t\t\tanswer = Math.Max(answer, x);\n\t\t\tx = 0;\n\t\t}\n\t}\n\tConsole.WriteLine(answer);\n}", "6209": "static void largestSquare(int [,]matrix, int R, int C, int []q_i, int []q_j, int K, int Q)\n{\n\tfor(int q = 0; q < Q; q++) \n\t{\n\tint i = q_i[q];\n\tint j = q_j[q];\n\tint min_dist = Math.Min(Math.Min(i, j), \n\t\t\t\t\t\t\tMath.Min(R - i - 1, C - j - 1));\n\tint ans = -1;\n\tfor(int k = 0; k <= min_dist; k++)\n\t{\n\t\tint count = 0;\n\t\tfor(int row = i - k; row <= i + k; row++)\n\t\t\tfor(int col = j - k; col <= j + k; col++)\n\t\t\t\tcount += matrix[row, col];\n\t\tif (count > K)\n\t\t\tbreak;\n\t\tans = 2 * k + 1;\n\t}\n\tConsole.Write(ans + \"\\n\");\n\t}\n}", "6210": "static void largestSquare(int [,]matrix, int R, int C, int []q_i, int []q_j, int K, int Q) \n{ \n\tint [,]countDP = new int[R, C]; \n\tcountDP[0, 0] = matrix[0, 0]; \n\tfor(int i = 1; i < R; i++) \n\t\tcountDP[i, 0] = countDP[i - 1, 0] + \n\t\t\t\t\t\t\tmatrix[i, 0];\n\tfor(int j = 1; j < C; j++) \n\t\tcountDP[0, j] = countDP[0, j - 1] + \n\t\t\t\t\t\tmatrix[0, j]; \n\tfor(int i = 1; i < R; i++) \n\t\tfor(int j = 1; j < C; j++) \n\t\t\tcountDP[i, j] = matrix[i, j] + \n\t\t\t\t\t\tcountDP[i - 1, j] + \n\t\t\t\t\t\tcountDP[i, j - 1] - \n\t\t\t\t\t\tcountDP[i - 1, j - 1]; \n\tfor(int q = 0; q < Q; q++) \n\t{ \n\t\tint i = q_i[q]; \n\t\tint j = q_j[q]; \n\t\tint min_dist = Math.Min(Math.Min(i, j), \n\t\t\t\t\tMath.Min(R - i - 1, C - j - 1)); \n\t\tint ans = -1; \n\t\tfor(int k = 0; k <= min_dist; k++) \n\t\t{ \n\t\t\tint x1 = i - k, x2 = i + k; \n\t\t\tint y1 = j - k, y2 = j + k; \n\t\t\tint count = countDP[x2, y2]; \n\t\t\tif (x1 > 0) \n\t\t\t\tcount -= countDP[x1 - 1, y2]; \n\t\t\tif (y1 > 0) \n\t\t\t\tcount -= countDP[x2, y1 - 1]; \n\t\t\tif (x1 > 0 && y1 > 0) \n\t\t\t\tcount += countDP[x1 - 1, y1 - 1]; \n\t\t\tif (count > K) \n\t\t\t\tbreak; \n\t\t\tans = 2 * k + 1; \n\t\t} \n\t\tConsole.Write(ans + \"\\n\"); \n\t} \n}", "6211": "static void largestSquare(int [,]matrix, int R, int C, int []q_i, int []q_j, int K, int Q)\n{ \n\tint [,]countDP = new int[R, C]; \n\tfor(int i = 0; i < R; i++)\n\t\tfor(int j = 0; j < C; j++)\n\t\t\tcountDP[i, j]=0; \n\tcountDP[0, 0] = matrix[0, 0]; \n\tfor(int i = 1; i < R; i++) \n\t\tcountDP[i, 0] = countDP[i - 1, 0] + \n\t\t\t\t\t\tmatrix[i, 0]; \n\tfor(int j = 1; j < C; j++) \n\t\tcountDP[0, j] = countDP[0, j - 1] + \n\t\t\t\t\t\tmatrix[0, j]; \n\tfor(int i = 1; i < R; i++) \n\t\tfor(int j = 1; j < C; j++) \n\t\t\tcountDP[i, j] = matrix[i, j] + \n\t\t\t\t\t\tcountDP[i - 1, j] + \n\t\t\t\t\t\tcountDP[i, j - 1] - \n\t\t\t\t\t\tcountDP[i - 1, j - 1]; \n\tfor(int q = 0; q < Q; q++)\n\t{ \n\t\tint i = q_i[q]; \n\t\tint j = q_j[q]; \n\t\tint min_dist = Math.Min(Math.Min(i, j), \n\t\t\t\t\t\t\t\tMath.Min(R - i - 1, C - j - 1));\n\t\tint ans = -1, l = 0, u = min_dist; \n\t\twhile (l <= u) \n\t\t{ \n\t\t\tint mid = (l + u) / 2; \n\t\t\tint x1 = i - mid, x2 = i + mid; \n\t\t\tint y1 = j - mid, y2 = j + mid; \n\t\t\tint count = countDP[x2, y2];\n\t\t\tif (x1 > 0) \n\t\t\t\tcount -= countDP[x1 - 1, y2]; \n\t\t\tif (y1 > 0) \n\t\t\t\tcount -= countDP[x2, y1 - 1]; \n\t\t\tif (x1 > 0 && y1 > 0) \n\t\t\t\tcount += countDP[x1 - 1, y1 - 1]; \n\t\t\tif (count <= K) \n\t\t\t{ \n\t\t\t\tans = 2 * mid + 1; \n\t\t\t\tl = mid + 1; \n\t\t\t} \n\t\t\telse\n\t\t\t\tu = mid - 1; \n\t\t} \n\t\tConsole.WriteLine(ans); \n\t} \n}", "6241": "static int count_special(int n)\n{\n\tint []fib = new int[n + 1];\n\tfib[0] = 1;\n\tfib[1] = 2;\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tfib[i] = (fib[i - 1] % mod + fib[i - 2] % mod) % mod;\n\t}\n\treturn fib[n];\n}", "6273": "static int maxSum(int p0, int p1, int []a, int pos, int n)\n\t{\n\t\tif (pos == n) {\n\t\t\tif (p0 == p1)\n\t\t\t\treturn p0;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tint ans = maxSum(p0, p1, a, pos + 1, n);\n\t\tans = Math.Max(ans, maxSum(p0 + a[pos], p1, a, pos + 1, n));\n\t\tans = Math.Max(ans, maxSum(p0, p1 + a[pos], a, pos + 1, n));\n\t\treturn ans;\n\t}", "6274": "static int maxSum(int []a, int n)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += a[i];\n\t\tint limit = 2 * sum + 1;\n\t\tint [,]dp = new int[n + 1,limit];\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\tfor (int j = 0; j < limit; j++)\n\t\t\t\tdp[i,j] = INT_MIN;\n\t\t}\n\t\tdp[0,sum] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j < limit; j++) {\n\t\t\t\tif ((j - a[i - 1]) >= 0 && dp[i - 1,j - a[i - 1]] != INT_MIN)\n\t\t\t\t\tdp[i,j] = Math.Max(dp[i,j], dp[i - 1,j - a[i - 1]] + a[i - 1]);\n\t\t\t\tif ((j + a[i - 1]) < limit && dp[i - 1,j + a[i - 1]] != INT_MIN)\n\t\t\t\t\tdp[i,j] = Math.Max(dp[i,j], dp[i - 1,j + a[i - 1]]);\n\t\t\t\tif (dp[i - 1,j] != INT_MIN)\n\t\t\t\t\tdp[i,j] = Math.Max(dp[i,j], dp[i - 1,j]);\n\t\t\t}\n\t\t}\n\t\treturn dp[n,sum];\n\t}", "6281": "static int calculate(int pos, int prev, String s, List<int> index)\n{\n\tif (pos == s.Length)\n\t\treturn 1;\n\tif (dp[pos,prev] != -1)\n\t\treturn dp[pos,prev];\n\tint answer = 0;\n\tfor (int i = 0; i < index.Count; i++) {\n\t\tif (index[i].CompareTo(prev) >= 0) {\n\t\t\tanswer = (answer % mod + calculate(pos + 1, index[i], s, index) % mod) % mod;\n\t\t}\n\t}\n\treturn dp[pos,prev] = answer;\n}\nstatic int countWays(List<String> a, String s)\n{\n\tint n = a.Count;\n\tList<int> []index = new List<int>[26];\n\tfor (int i = 0; i < 26; i++)\n\t\tindex[i] = new List<int>();\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < a[i].Length; j++) {\n\t\t\tindex[a[i][j] - 'a'].Add(j + 1);\n\t\t}\n\t}\n\tfor(int i = 0;i< 1000;i++)\n\t{\n\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\tdp[i,j] = -1;\n\t\t}\n\t}\n\treturn calculate(0, 0, s, index[0]);\n}", "6289": "static void computeFibonacci()\n\t{\n\t\tfib[0] = 1;\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i < 100005; i++) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t}\nstatic int countString(string str)\n\t{\n\t\tint ans = 1;\n\t\tint cnt = 1;\n\t\tfor (int i = 1; i < str.Length; i++) {\n\t\t\tif (str[i] == str[i - 1]) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = ans * fib[cnt];\n\t\t\t\tcnt = 1;\n\t\t\t}\n\t\t}\n\t\tans = ans * fib[cnt];\n\t\treturn ans;\n\t}", "6298": "static void printGolombSequence(int N)\n{\n\tint[] arr = new int[MAX];\n\tfor(int i = 0; i < MAX; i++)\n\t\tarr[i] = 0;\n\tint cnt = 0;\n\tarr[0] = 0;\n\tarr[1] = 1;\n\tDictionary<int,\n\t\t\tint> M = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tint>(); \n\tM.Add(2, 2);\n\tfor(int i = 2; i <= N; i++)\n\t{\n\t\tif (cnt == 0)\n\t\t{\n\t\t\tarr[i] = 1 + arr[i - 1];\n\t\t\tcnt = M[arr[i]];\n\t\t\tcnt--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarr[i] = arr[i - 1];\n\t\t\tcnt--;\n\t\t}\n\t\tif(M.ContainsKey(i))\n\t\t{\n\t\t\tM[i] = arr[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tM.Add(i, arr[i]);\n\t\t}\n\t}\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tConsole.Write(arr[i] + \" \");\n\t}\n}", "6299": "static int number_of_ways(int n)\n{\n\tint []includes_3 = new int[n + 1];\n\tint []not_includes_3 = new int[n + 1];\n\tincludes_3[3] = 1;\n\tnot_includes_3[1] = 1;\n\tnot_includes_3[2] = 2;\n\tnot_includes_3[3] = 3;\n\tfor (int i = 4; i <= n; i++)\n\t{\n\t\tincludes_3[i]\n\t\t\t= includes_3[i - 1] + includes_3[i - 2] +\n\t\t\tnot_includes_3[i - 3];\n\t\tnot_includes_3[i]\n\t\t\t= not_includes_3[i - 1] + not_includes_3[i - 2];\n\t}\n\treturn includes_3[n];\n}", "6301": "static void generateDivisors(int n)\n{\n\tfor (int i = 1; i <= Math.Sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (n / i == i)\n\t\t\t{\n\t\t\t\tdivisors[i]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdivisors[i]++;\n\t\t\t\tdivisors[n / i]++;\n\t\t\t}\n\t\t}\n\t}\n}\nstatic int findMaxMultiples(int []arr, int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tans = Math.Max(divisors[arr[i]], ans);\n\t\tgenerateDivisors(arr[i]);\n\t}\n\treturn ans;\n}", "6335": "static int countNum(int idx, int sum, int tight, List<int> num, int len, int k)\n{\n\tif (len == idx)\n\t{\n\t\tif (sum == 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tif (dp[idx, sum, tight] != -1)\n\t\treturn dp[idx, sum, tight];\n\tint res = 0, limit;\n\tif (tight == 0)\n\t{\n\t\tlimit = num[idx];\n\t}\n\telse\n\t{\n\t\tlimit = 9;\n\t}\n\tfor (int i = 0; i <= limit; i++)\n\t{\n\t\tint new_tight = tight;\n\t\tif (tight == 0 && i < limit)\n\t\t\tnew_tight = 1;\n\t\tres += countNum(idx + 1,\n\t\t\t\t\t(sum + i) % k, new_tight, num, len, k);\n\t\tres %= MOD;\n\t}\n\tif (res < 0)\n\t\tres += MOD;\n\treturn dp[idx, sum, tight] = res;\n}\nstatic List<int> process(String s)\n{\n\tList<int> num = new List<int>();\n\tfor (int i = 0; i < s.Length; i++)\n\t{\n\t\tnum.Add(s[i] - '0');\n\t}\n\treturn num;\n}", "6346": "static int MinCost(int []arr, int n)\n{\n\tint [,]dp = new int[n + 5, n + 5];\n\tint [,]sum = new int[n + 5, n + 5];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint k = arr[i];\n\t\tfor (int j = i; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tsum[i, j] = k;\n\t\t\telse\n\t\t\t{\n\t\t\t\tk += arr[j];\n\t\t\t\tsum[i, j] = k;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (int j = i; j < n; j++)\n\t\t{\n\t\t\tdp[i, j] = int.MaxValue;\n\t\t\tif (i == j)\n\t\t\t\tdp[i, j] = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int k = i; k < j; k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i, j] = Math.Min(dp[i, j], dp[i, k] + dp[k + 1, j] + sum[i, j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0, n - 1];\n}", "6364": "static int f(int i, int state, int []A, int [,]dp, int N)\n\t{\n\t\tif (i >= N)\n\t\t\treturn 0;\n\t\telse if (dp[i, state] != -1)\n\t\t{\n\t\t\treturn dp[i, state];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (i == N - 1)\n\t\t\t\tdp[i, state] = 1;\n\t\t\telse if (state == 1 && A[i] > A[i + 1])\n\t\t\t\tdp[i, state] = 1;\n\t\t\telse if (state == 2 && A[i] < A[i + 1])\n\t\t\t\tdp[i, state] = 1;\n\t\t\telse if (state == 1 && A[i] <= A[i + 1])\n\t\t\t\tdp[i, state] = 1 + f(i + 1, 2, A, dp, N);\n\t\t\telse if (state == 2 && A[i] >= A[i + 1])\n\t\t\t\tdp[i, state] = 1 + f(i + 1, 1, A, dp, N);\n\t\t\treturn dp[i, state];\n\t\t}\n\t}\nstatic int maxLenSeq(int []A, int N)\n\t{\n\t\tint i, j, tmp, y, ans;\n\t\tint [,]dp = new int[1000, 3];\n\t\tfor(i = 0; i < 1000; i++)\n\t\t\tfor(j = 0; j < 3; j++)\n\t\t\t\tdp[i, j] = -1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\ttmp = f(i, 1, A, dp, N);\n\t\t\ttmp = f(i, 2, A, dp, N);\n\t\t}\n\t\tans = -1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\ty = dp[i, 1];\n\t\t\tif (i + y >= N)\n\t\t\t\tans = Math.Max(ans, dp[i, 1] + 1);\n\t\t\telse if (y % 2 == 0)\n\t\t\t{\n\t\t\t\tans = Math.Max(ans, dp[i, 1] + 1 + dp[i + y, 2]);\n\t\t\t}\n\t\t\telse if (y % 2 == 1)\n\t\t\t{\n\t\t\t\tans = Math.Max(ans, dp[i, 1] + 1 + dp[i + y, 1]);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}", "6380": "static int ways(int i, int []arr, int n)\n{\n\tif (i == n - 1)\n\t\treturn 1;\n\tint sum = 0;\n\tfor (int j = 1; j + i < n && j <= arr[i]; j++)\n\t{\n\t\tsum += (ways(i + j, arr, n)) % mod;\n\t\tsum %= mod;\n\t}\n\treturn sum % mod;\n}", "6381": "static int ways(int []arr, int n)\n\t{\n\t\tint []dp = new int[n + 1];\n\t\tdp[n - 1] = 1;\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t{\n\t\t\tdp[i] = 0;\n\t\t\tfor (int j = 1; ((j + i) < n && j <= arr[i]); j++)\n\t\t\t{\n\t\t\t\tdp[i] += dp[i + j];\n\t\t\t\tdp[i] %= mod;\n\t\t\t}\n\t\t}\n\t\treturn dp[0] % mod;\n\t}", "6385": "public static int[] countSum(int []arr, int n)\n\t{\n\t\tint[] countODD = new int[n + 1];\n\t\tint[] countEVEN = new int[n + 1];\n\t\tcountODD[0] = 0;\n\t\tcountEVEN[0] = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (arr[i - 1] % 2 == 0)\n\t\t\t{\n\t\t\t\tcountEVEN[i] = countEVEN[i - 1] +\n\t\t\t\t\t\t\tcountEVEN[i - 1] + 1;\n\t\t\t\tcountODD[i] = countODD[i - 1] +\n\t\t\t\t\t\t\tcountODD[i - 1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcountEVEN[i] = countEVEN[i - 1] +\n\t\t\t\t\t\t\tcountODD[i - 1];\n\t\t\t\tcountODD[i] = countODD[i - 1] +\n\t\t\t\t\t\t\tcountEVEN[i - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tint[] ans = new int[2];\n\t\tans[0] = countEVEN[n];\n\t\tans[1] = countODD[n];\n\t\treturn ans;\n\t}", "6386": "static pair countSum(int []arr, int n)\n{\n\tint count_odd, count_even;\n\tcount_odd = 0;\n\tcount_even = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (arr[i - 1] % 2 == 0)\n\t\t{\n\t\t\tcount_even = count_even + count_even + 1;\n\t\t\tcount_odd = count_odd + count_odd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint temp = count_even;\n\t\t\tcount_even = count_even + count_odd;\n\t\t\tcount_odd = count_odd + temp + 1;\n\t\t}\n\t}\n\treturn new pair(count_even, count_odd );\n}", "6395": "static int gcd(int a, int b)\n\t{\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\nstatic int MaxGCD(int []a, int n)\n\t{\n\t\tint []Prefix = new int[n + 2];\n\t\tint []Suffix = new int[n + 2] ;\n\t\tPrefix[1] = a[0];\n\t\tfor (int i = 2; i <= n; i += 1)\n\t\t{\n\t\t\tPrefix[i] = gcd(Prefix[i - 1], a[i - 1]);\n\t\t}\n\t\tSuffix[n] = a[n - 1];\n\t\tfor (int i = n - 1; i >= 1; i -= 1)\n\t\t{\n\t\t\tSuffix[i] = gcd(Suffix[i + 1], a[i - 1]);\n\t\t}\n\t\tint ans = Math.Max(Suffix[2], Prefix[n - 1]);\n\t\tfor (int i = 2; i < n; i += 1)\n\t\t{\n\t\t\tans = Math.Max(ans, gcd(Prefix[i - 1], Suffix[i + 1]));\n\t\t}\n\t\treturn ans;\n\t}", "6396": "static List<int> numToVec(int N)\n{\n\tList<int> digit = new List<int>();\n\twhile (N != 0)\n\t{\n\t\tdigit.Add(N % 10);\n\t\tN = N / 10;\n\t}\n\tif (digit.Count == 0)\n\t\tdigit.Add(0);\n\tdigit.Reverse();\n\treturn digit;\n}\nstatic int solve(List<int> A, int B, int C)\n{\n\tList<int> digit = new List<int>();\n\tint d, d2;\n\tdigit = numToVec(C);\n\td = A.Count;\n\tif (B > digit.Count d == 0)\n\t\treturn 0;\n\telse if (B < digit.Count)\n\t{\n\t\tif (A[0] == 0 && B != 1)\n\t\t\treturn (int) ((d - 1) * Math.Pow(d, B - 1));\n\t\telse\n\t\t\treturn (int) Math.Pow(d, B);\n\t}\n\telse\n\t{\n\t\tint []dp = new int[B + 1];\n\t\tint []lower = new int[MAX + 1];\n\t\tfor (int i = 0; i < d; i++)\n\t\t\tlower[A[i] + 1] = 1;\n\t\tfor (int i = 1; i <= MAX; i++)\n\t\t\tlower[i] = lower[i - 1] + lower[i];\n\t\tBoolean flag = true;\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= B; i++)\n\t\t{\n\t\t\td2 = lower[digit[i-1]];\n\t\t\tdp[i] = dp[i - 1] * d;\n\t\t\tif (i == 1 && A[0] == 0 && B != 1)\n\t\t\t\td2 = d2 - 1;\n\t\t\tif (flag)\n\t\t\t\tdp[i] += d2;\n\t\t\tflag = (flag & (lower[digit[i-1] + 1] == lower[digit[i-1]] + 1));\n\t\t}\n\t\treturn dp[B];\n\t}\n}", "6442": "static int countWays(int i, int j, int x, int [,]arr)\n\t{\n\t\tif (i == n j == n)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tx = (x & arr[i, j]);\n\t\tif (x == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (i == n - 1 && j == n - 1)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tif (v[i, j, x] == 1)\n\t\t{\n\t\t\treturn dp[i, j, x];\n\t\t}\n\t\tv[i, j, x] = 1;\n\t\tdp[i, j, x] = countWays(i + 1, j, x, arr)\n\t\t\t\t\t+ countWays(i, j + 1, x, arr);\n\t\treturn dp[i, j, x];\n\t}", "6454": "static void pre_process(bool [,]dp, char[] s)\n\t{\n\t\tint n = s.Length;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tdp[i,j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tfor (int i = 0; i <= n - j; i++)\n\t\t\t{\n\t\t\t\tif (j <= 2)\n\t\t\t\t{\n\t\t\t\t\tif (s[i] == s[i + j - 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i,i + j - 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (s[i] == s[i + j - 1])\n\t\t\t\t{\n\t\t\t\t\tdp[i,i + j - 1] = dp[i + 1,i + j - 2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nstatic int countPairs(String s)\n\t{\n\t\tbool [,]dp = new bool[N,N];\n\t\tpre_process(dp, s.ToCharArray());\n\t\tint n = s.Length;\n\t\tint []left = new int[n];\n\t\tint []right = new int[n];\n\t\tleft[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j <= i; j++)\n\t\t\t{\n\t\t\t\tif (dp[j,i] == true)\n\t\t\t\t{\n\t\t\t\t\tleft[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tright[n - 1] = 1;\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t{\n\t\t\tright[i] = right[i + 1];\n\t\t\tfor (int j = n - 1; j >= i; j--)\n\t\t\t{\n\t\t\t\tif (dp[i,j] == true)\n\t\t\t\t{\n\t\t\t\t\tright[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tans += left[i] * right[i + 1];\n\t\t}\n\t\treturn ans;\n\t}", "6469": "static int FindMaximumSum(int ind, int kon, int []a, int []b, int []c, int n, int [,]dp)\n\t{\n\t\tif (ind == n)\n\t\t\treturn 0;\n\t\tif (dp[ind,kon] != -1)\n\t\t\treturn dp[ind,kon];\n\t\tint ans = (int) (-1e9 + 5);\n\t\tif (kon == 0)\n\t\t{\n\t\t\tans = Math.Max(ans, b[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 1, a, b,c, n, dp));\n\t\t\tans = Math.Max(ans, c[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 2, a, b,c, n, dp));\n\t\t}\n\t\telse if (kon == 1)\n\t\t{\n\t\t\tans = Math.Max(ans, a[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 0, a, b, c, n, dp));\n\t\t\tans = Math.Max(ans, c[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 2, a, b, c, n, dp));\n\t\t}\n\t\telse if (kon == 2)\n\t\t{\n\t\t\tans = Math.Max(ans, a[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 1, a, b, c, n, dp));\n\t\t\tans = Math.Max(ans, b[ind] +\n\t\t\t\tFindMaximumSum(ind + 1, 0, a, b, c, n, dp));\n\t\t}\n\t\treturn dp[ind,kon] = ans;\n\t}", "6471": "static int noOfBinaryStrings(int N, int k)\n{\n\tint []dp = new int[100002];\n\tfor (int i = 1; i <= k - 1; i++)\n\t{\n\t\tdp[i] = 1;\n\t}\n\tdp[k] = 2;\n\tfor (int i = k + 1; i <= N; i++)\n\t{\n\t\tdp[i] = (dp[i - 1] + dp[i - k]) % mod;\n\t}\n\treturn dp[N];\n}", "6478": "public static int findWaysToPair(int p)\n{\n\tint[] dp = new int[p + 1];\n\tdp[1] = 1;\n\tdp[2] = 2;\n\tfor (int i = 3; i <= p; i++)\n\t{\n\t\tdp[i] = dp[i - 1] + (i - 1) * dp[i - 2];\n\t}\n\treturn dp[p];\n}", "6480": "static int findSubarraySum(int ind, int flips, int n, int[] a, int k)\n\t{\n\t\tif (flips > k)\n\t\t\treturn -(int)1e9;\n\t\tif (ind == n)\n\t\t\treturn 0;\n\t\tif (dp[ind, flips] != -1)\n\t\t\treturn dp[ind, flips];\n\t\tint ans = 0;\n\t\tans = Math.Max(0, a[ind]\n\t\t\t\t\t\t\t+ findSubarraySum( ind + 1, flips, n, a, k));\n\t\tans = Math.Max(ans, -a[ind]\n\t\t\t\t\t\t\t\t+ findSubarraySum(ind + 1, flips + 1, n, a, k));\n\t\treturn dp[ind, flips] = ans;\n\t}\nstatic int findMaxSubarraySum(int[] a, int n, int k)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < k + 1; j++)\n\t\t\t\tdp[i, j] = -1;\n\t\tint ans = -(int)1e9;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans = Math.Max(ans,\n\t\t\t\t\t\tfindSubarraySum(i, 0, n, a, k));\n\t\tif (ans == 0 && k == 0)\n\t\t\treturn a.Max();\n\t\treturn ans;\n\t}", "6486": "static int maxWeight(int [] arr, int n, int w1_r, int w2_r, int i)\n\t{\n\t\tif (i == n)\n\t\t\treturn 0;\n\t\tif (dp[i ,w1_r, w2_r] != -1)\n\t\t\treturn dp[i, w1_r, w2_r];\n\t\tint fill_w1 = 0, fill_w2 = 0, fill_none = 0;\n\t\tif (w1_r >= arr[i])\n\t\t\tfill_w1 = arr[i] +\n\t\t\tmaxWeight(arr, n, w1_r - arr[i], w2_r, i + 1);\n\t\tif (w2_r >= arr[i])\n\t\t\tfill_w2 = arr[i] +\n\t\t\tmaxWeight(arr, n, w1_r, w2_r - arr[i], i + 1);\n\t\tfill_none = maxWeight(arr, n, w1_r, w2_r, i + 1);\n\t\tdp[i, w1_r, w2_r] = Math.Max(fill_none, Math.Max(fill_w1, fill_w2));\n\t\treturn dp[i, w1_r, w2_r];\n\t}", "6488": "static void findPrefixCount(int [,]p_arr, bool [,]set_bit)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (!set_bit[i, j])\n\t\t\t\tcontinue;\n\t\t\tif (j != n - 1)\n\t\t\t\tp_arr[i, j] += p_arr[i, j + 1];\n\t\t\tp_arr[i, j] += (set_bit[i, j]) ? 1 : 0;\n\t\t}\n\t}\n}\nstatic int matrixAllOne(bool [,]set_bit)\n{\n\tint [,]p_arr = new int[n, n];\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n;j++)\n\t\t\tp_arr[i, j] = 0;\n\tfindPrefixCount(p_arr, set_bit);\n\tint ans = 0;\n\tfor (int j = 0; j < n; j++)\n\t{\n\t\tint i = n - 1;\n\t\tStack<pair > q = new Stack<pair >();\n\t\tint to_sum = 0;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tint c = 0;\n\t\t\twhile (q.Count != 0 &&\n\t\t\t\t\tq.Peek().first > p_arr[i,j])\n\t\t\t{\n\t\t\t\tto_sum -= (q.Peek().second + 1) *\n\t\t\t\t\t\t\t(q.Peek().first - p_arr[i,j]);\n\t\t\t\tc += q.Peek().second + 1;\n\t\t\t\tq.Pop();\n\t\t\t}\n\t\t\tto_sum += p_arr[i,j];\n\t\t\tans += to_sum;\n\t\t\tq.Push(new pair( p_arr[i,j], c ));\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ans;\n}\nstatic int sumAndMatrix(int [,]arr)\n{\n\tint sum = 0;\n\tint mul = 1;\n\tfor (int i = 0; i < 30; i++)\n\t{\n\t\tbool [,]set_bit = new bool[n,n];\n\t\tfor (int R = 0; R < n; R++)\n\t\t\tfor (int C = 0; C < n; C++)\n\t\t\t\tset_bit[R, C] = ((arr[R, C] & (1 << i)) != 0);\n\t\tsum += (mul * matrixAllOne(set_bit));\n\t\tmul *= 2;\n\t}\n\treturn sum;\n}", "6525": "public static int solve(int[,] dp, int wt, int K, int M, int used)\n\t{\n\t\tif (wt < 0)\n\t\t\treturn 0;\n\t\tif (wt == 0) {\n\t\t\tif (used == 1)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp[wt,used] != -1)\n\t\t\treturn dp[wt,used];\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= K; i++) {\n\t\t\tif (i >= M)\n\t\t\t\tans += solve(dp, wt - i, K, M, used 1);\n\t\t\telse\n\t\t\t\tans += solve(dp, wt - i, K, M, used);\n\t\t}\n\t\treturn dp[wt,used] = ans;\n\t}", "6531": "static int sumOddFibonacci(int n)\n{\n\tint []Sum=new int[n + 1];\n\tSum[0] = 0;\n\tSum[1] = 1;\n\tSum[2] = 2;\n\tSum[3] = 5;\n\tSum[4] = 10;\n\tSum[5] = 23;\n\tfor (int i = 6; i <= n; i++) {\n\t\tSum[i] = ((Sum[i - 1] + (4 * Sum[i - 2]) % mod -\n\t\t\t\t(4 * Sum[i - 3]) % mod + mod) % mod +\n\t\t\t\t(Sum[i - 4] - Sum[i - 5] + mod) % mod) % mod;\n\t}\n\treturn Sum[n];\n}", "6536": "static int CountWays(int n)\n\t{\n\t\tif (n == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (n == 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (n == 2) {\n\t\t\treturn 1 + 1;\n\t\t}\n\t\treturn CountWays(n - 1) + CountWays(n - 3);\n\t}", "6538": "static int CountWays(int n) {\n\t\tint []noOfWays = new int[n + 3];\n\t\tnoOfWays[0] = 1;\n\t\tnoOfWays[1] = 1;\n\t\tnoOfWays[2] = 1 + 1;\n\t\tfor (int i = 3; i < n + 1; i++) {\n\t\t\tnoOfWays[i] =\n\t\t\t\t\tnoOfWays[3 - 1]\n\t\t\t\t\t\t\t+ noOfWays[3 - 3];\n\t\t\tnoOfWays[0] = noOfWays[1];\n\t\t\tnoOfWays[1] = noOfWays[2];\n\t\t\tnoOfWays[2] = noOfWays[i];\n\t\t}\n\t\treturn noOfWays[n];\n\t}", "6550": "public static long fun(int[] marks,int n)\n\t{\n\t\tlong[] dp = new long[n];\n\t\tlong temp;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tdp[i] = 1;\n\t\tfor(int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tif (marks[i] > marks[i + 1])\n\t\t\t{ \n\t\t\t\ttemp = i;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif ((marks[temp] > marks[temp + 1]) && temp >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[temp] > dp[temp + 1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttemp -= 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[temp] = dp[temp + 1] + 1;\n\t\t\t\t\t\t\ttemp -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak; \n\t\t\t\t} \n\t\t\t}\n\t\t\telse if( marks[i] < marks[i + 1])\n\t\t\t\tdp[i + 1] = dp[i] + 1;\n\t\t}\n\t\tlong sum = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tsum += dp[i];\n\t\treturn sum;\n\t}", "6553": "static void sieve(int []prime)\n{\n\tfor(int i = 2; i * i < MAX; i++)\n\t{\n\t\tif (prime[i] == 0)\n\t\t{\n\t\t\tfor (int j = i * i; j < MAX; j += i)\n\t\t\t\tprime[j] = 1;\n\t\t}\n\t}\n}\nstatic void dfs(int i, int j, int k, ref int q, int n, int m, int [,]mappedMatrix, int [,]mark, pair []ans)\n{\n\tif ((mappedMatrix[i, j] == 0 ? true : false) ||\n\t\t\t\t\t\t(i > n ? true : false) ||\n\t\t\t\t\t\t(j > m ? true : false) ||\n\t\t\t\t(mark[i, j] != 0 ? true : false) ||\n\t\t\t\t\t\t(q != 0 ? true : false))\n\t\treturn;\n\tmark[i, j] = 1;\n\tans[k] = new pair(i, j);\n\tif (i == n && j == m)\n\t{\n\t\t(q) = k;\n\t\treturn;\n\t}\n\tdfs(i + 1, j + 1, k + 1, ref q, n, m, mappedMatrix, mark, ans);\n\tdfs(i + 1, j, k + 1, ref q, n, m, mappedMatrix, mark, ans);\n\tdfs(i, j + 1, k + 1, ref q, n, m, mappedMatrix, mark, ans);\n}\nstatic void lexicographicalPath(int n, int m, int [,]mappedMatrix)\n{\n\tint q = 0;\n\tpair []ans = new pair[MAX];\n\tint [,]mark = new int[MAX, MAX];\n\tdfs(1, 1, 1, ref q, n, m, mappedMatrix, mark, ans);\n\tfor(int i = 1; i <= q; i++)\n\t\tConsole.WriteLine(ans[i].first + \" \" + ans[i].second);\n}\nstatic void countPrimePath(int [,]mappedMatrix, int n, int m)\n{\n\tint [,]dp = new int[MAX, MAX];\n\tfor(int i = 0; i < MAX; i++)\n\t{\n\t\tfor(int j = 0; j < MAX; j++)\n\t\t{\n\t\t\tdp[i, j] = 0;\n\t\t}\n\t}\n\tdp[1, 1] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tif (i == 1 && j == 1)\n\t\t\t\tcontinue;\n\t\t\tdp[i, j] = (dp[i - 1, j] + dp[i, j - 1] + dp[i - 1, j - 1]);\n\t\t\tif (mappedMatrix[i, j] == 0)\n\t\t\t\tdp[i, j] = 0;\n\t\t}\n\t}\n\tConsole.WriteLine(dp[n, m]);\n}\nstatic void preprocessMatrix(int [,]mappedMatrix, int [,]a, int n, int m)\n{\n\tint []prime = new int[MAX];\n\tsieve(prime);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tif (prime[a[i, j]] == 0)\n\t\t\t\tmappedMatrix[i + 1, j + 1] = 1;\n\t\t\telse\n\t\t\t\tmappedMatrix[i + 1, j + 1] = 0;\n\t\t}\n\t}\n}", "6554": "static long partitions(int n)\n\t{\n\t\tlong []p = new long[n + 1];\n\t\tp[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tint k = 1;\n\t\t\twhile ((k * (3 * k - 1)) / 2 <= i)\n\t\t\t{\n\t\t\t\tp[i] += (k % 2 != 0 ? 1 : -1) *\n\t\t\t\t\tp[i - (k * (3 * k - 1)) / 2];\n\t\t\t\tif (k > 0)\n\t\t\t\t{\n\t\t\t\t\tk *= -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tk = 1 - k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn p[n];\n\t}", "6586": "static List<int> factors(int n)\n{\n\tList<int> v = new List<int>();\n\tv.Add(1);\n\tfor (int i = 2;\n\t\t\ti <= Math.Sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tv.Add(i);\n\t\t\tif (n / i != i)\n\t\t\t{\n\t\t\t\tv.Add(n / i);\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\nstatic Boolean checkAbundant(int n)\n{\n\tList<int> v;\n\tint sum = 0;\n\tv = factors(n);\n\tfor (int i = 0; i < v.Count; i++)\n\t{\n\t\tsum += v[i];\n\t}\n\tif (sum > n)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nstatic Boolean checkSemiPerfect(int n)\n{\n\tList<int> v;\n\tv = factors(n);\n\tv.Sort();\n\tint r = v.Count;\n\tBoolean [,]subset = new Boolean[r + 1,n + 1];\n\tfor (int i = 0; i <= r; i++)\n\t\tsubset[i,0] = true;\n\tfor (int i = 1; i <= n; i++)\n\t\tsubset[0,i] = false;\n\tfor (int i = 1; i <= r; i++)\n\t{\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif (j < v[i-1])\n\t\t\t\tsubset[i,j] = subset[i - 1,j];\n\t\t\telse {\n\t\t\t\tsubset[i,j] = subset[i - 1,j] ||\n\t\t\t\t\t\t\tsubset[i - 1,j -\n\t\t\t\t\t\t\t\tv[i-1]];\n\t\t\t}\n\t\t}\n\t}\n\tif ((subset[r,n]) == false)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nstatic Boolean checkweird(int n)\n{\n\tif (checkAbundant(n) == true &&\n\t\tcheckSemiPerfect(n) == false)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "6589": "static int solve(int N, int K)\n{\n\tint[] combo;\n\tcombo = new int[50];\n\tcombo[0] = 1;\n\tfor (int i = 1; i <= K; i++)\n\t{\n\t\tfor (int j = 0; j <= N; j++)\n\t\t{\n\t\t\tif (j >= i)\n\t\t\t{\n\t\t\t\tcombo[j] += combo[j - i];\n\t\t\t}\n\t\t}\n\t}\n\treturn combo[N];\n}", "6679": "static int maxSubArraySumRepeated(int []a, int n, int k)\n{\n\tint max_so_far = 0;\n\tint max_ending_here=0;\n\tfor (int i = 0; i < n * k; i++)\n\t{\n\t\tmax_ending_here = max_ending_here +\n\t\t\t\t\t\t\t\ta[i % n];\n\t\tif (max_so_far < max_ending_here)\n\t\t\tmax_so_far = max_ending_here;\n\t\tif (max_ending_here < 0)\n\t\t\tmax_ending_here = 0;\n\t}\n\treturn max_so_far;\n}", "6712": "public static int longOddEvenIncSeq(int[] arr, int n)\n\t{\n\t\tint[] lioes = new int[n];\n\t\tint maxLen = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlioes[i] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tif (arr[i] > arr[j] &&\n\t\t\t\t(arr[i] + arr[j]) % 2 != 0 && lioes[i] < lioes[j] + 1)\n\t\t\t\t\tlioes[i] = lioes[j] + 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (maxLen < lioes[i])\n\t\t\t\tmaxLen = lioes[i];\n\t\treturn maxLen;\n\t}", "6725": "static int isSubsetSum(int[] set, int n, int sum)\n\t{\n\t\tbool[, ] subset = new bool[sum + 1, n + 1];\n\t\tint[, ] count = new int[sum + 1, n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsubset[0, i] = true;\n\t\t\tcount[0, i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= sum; i++) {\n\t\t\tsubset[i, 0] = false;\n\t\t\tcount[i, 0] = -1;\n\t\t}\n\t\tfor (int i = 1; i <= sum; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tsubset[i, j] = subset[i, j - 1];\n\t\t\t\tcount[i, j] = count[i, j - 1];\n\t\t\t\tif (i >= set[j - 1]) {\n\t\t\t\t\tsubset[i, j] = subset[i, j] ||\n\t\t\t\t\t\t\t\tsubset[i - set[j - 1], j - 1];\n\t\t\t\t\tif (subset[i, j])\n\t\t\t\t\t\tcount[i, j] = Math.Max(count[i, j - 1], count[i - set[j - 1], j - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count[sum, n];\n\t}", "6749": "static int LIP(int[, ] dp, int[, ] mat, int n, int m, int x, int y)\n\t{\n\t\tif (dp[x, y] < 0) {\n\t\t\tint result = 0;\n\t\t\tif (x == n - 1 && y == m - 1)\n\t\t\t\treturn dp[x, y] = 1;\n\t\t\tif (x == n - 1 y == m - 1)\n\t\t\t\tresult = 1;\n\t\t\tif (x + 1 < n && mat[x, y] < mat[x + 1, y])\n\t\t\t\tresult = 1 + LIP(dp, mat, n, m, x + 1, y);\n\t\t\tif (y + 1 < m && mat[x, y] < mat[x, y + 1])\n\t\t\t\tresult = Math.Max(result, 1 + LIP(dp, mat, n, m, x, y + 1));\n\t\t\tdp[x, y] = result;\n\t\t}\n\t\treturn dp[x, y];\n\t}\nstatic int wrapper(int[, ] mat, int n, int m)\n\t{\n\t\tint[, ] dp = new int[10, 10];\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tdp[i, j] = -1;\n\t\t\t}\n\t\t}\n\t\treturn LIP(dp, mat, n, m, 0, 0);\n\t}", "6787": "static int computeLIS(int []circBuff, int start, int end, int n)\n\t{\n\t\tint []LIS = new int[n+end-start];\n\t\tfor (int i = start; i < end; i++)\n\t\t\tLIS[i] = 1;\n\t\tfor (int i = start + 1; i < end; i++)\n\t\t\tfor (int j = start; j < i; j++ )\n\t\t\t\tif (circBuff[i] > circBuff[j] && LIS[i] < LIS[j] + 1)\n\t\t\t\t\tLIS[i] = LIS[j] + 1;\n\t\tint res = int.MinValue;\n\t\tfor (int i = start; i < end; i++)\n\t\t\tres = Math.Max(res, LIS[i]);\n\t\treturn res;\n\t}\nstatic int LICS(int []arr, int n)\n\t{\n\t\tint []circBuff = new int[2 * n];\n\t\tfor (int i = 0; i<n; i++)\n\t\t\tcircBuff[i] = arr[i];\n\t\tfor (int i = n; i < 2*n; i++)\n\t\t\tcircBuff[i] = arr[i-n];\n\t\tint res = int.MinValue;\n\t\tfor (int i=0; i<n; i++)\n\t\t\tres = Math.Max(computeLIS(circBuff, i, i + n, n), res);\n\t\treturn res;\n\t}", "6791": "static int countPaths(int n, int m)\n\t{\n\t\tif (n == 0 m == 0)\n\t\t\treturn 1;\n\t\treturn (countPaths(n - 1, m) \n\t\t\t\t+ countPaths(n, m - 1));\n\t}", "6792": "static int countPaths(int n, int m)\n\t{\n\t\tint [,]dp = new int[n + 1,m + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tdp[i,0] = 1;\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tdp[0,i] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1; j <= m; j++)\n\t\t\t\tdp[i,j] = dp[i - 1,j]\n\t\t\t\t\t\t+ dp[i,j - 1];\n\t\treturn dp[n,m];\n\t}", "6793": "static int binomialCoeff(int n, int k) \n{ \n\tint[] C = new int[k + 1];\n\tC[0] = 1;\n\tfor(int i = 1; i <= n; i++) \n\t{\n\t\tfor(int j = Math.Min(i, k); j > 0; j--) \n\t\t\tC[j] = C[j] + C[j - 1]; \n\t} \n\treturn C[k]; \n}", "6848": "static int getMaxGold(int[,] gold, int m, int n)\n\t{\n\t\tint[,] goldTable = new int[m, n];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tgoldTable[i, j] = 0;\n\t\tfor (int col = n - 1; col >= 0; col--)\n\t\t{\n\t\t\tfor (int row = 0; row < m; row++)\n\t\t\t{\n\t\t\t\tint right = (col == n - 1) ? 0 :\n\t\t\t\t\t\t\tgoldTable[row, col + 1];\n\t\t\t\tint right_up = (row == 0 col == n - 1)\n\t\t\t\t\t\t\t? 0 : goldTable[row-1,col+1];\n\t\t\t\tint right_down = (row == m - 1 col == n - 1)\n\t\t\t\t\t\t\t\t? 0 : goldTable[row + 1, col + 1];\n\t\t\t\tgoldTable[row, col] = gold[row, col] +\n\t\t\t\t\t\t\t\tMath.Max(right, Math.Max(right_up, right_down));\n\t\t\t}\n\t\t}\n\t\tint res = goldTable[0, 0];\n\t\tfor (int i = 1; i < m; i++)\n\t\t\tres = Math.Max(res, goldTable[i, 0]);\n\t\treturn res;\n\t}", "6885": "static bool isOperator(char op)\n {\n\treturn (op == '+' op == '*');\n }\nstatic void printMinAndMaxValueOfExp(string exp)\n {\n\tList<int> num = new List<int>();\n\tList<char> opr = new List<char>();\n\tstring tmp = \"\";\n\tfor (int i = 0; i < exp.Length; i++)\n\t{\n\tif (isOperator(exp[i]))\n\t{\n\t\topr.Add(exp[i]);\n\t\tnum.Add(int.Parse(tmp));\n\t\ttmp = \"\";\n\t}\n\telse\n\t{\n\t\ttmp += exp[i];\n\t}\n\t}\n\tnum.Add(int.Parse(tmp));\t\n\tint len = num.Count;\n\tint[,] minVal = new int[len,len];\n\tint[,] maxVal = new int[len,len];\n\tfor (int i = 0; i < len; i++)\n\t{\n\tfor (int j = 0; j < len; j++)\n\t{\n\t\tminVal[i, j] = Int32.MaxValue;\n\t\tmaxVal[i, j] = 0;\n\t\tif (i == j)\n\t\t{\n\t\tminVal[i, j] = maxVal[i, j] = num[i];\n\t\t}\n\t}\n\t}\n\tfor (int L = 2; L <= len; L++)\n\t{\n\tfor (int i = 0; i < len - L + 1; i++)\n\t{\n\t\tint j = i + L - 1;\n\t\tfor (int k = i; k < j; k++)\n\t\t{\n\t\tint minTmp = 0, maxTmp = 0;\n\t\tif (opr[k] == '+')\n\t\t{\n\t\t\tminTmp = minVal[i, k] + minVal[k + 1, j];\n\t\t\tmaxTmp = maxVal[i, k] + maxVal[k + 1, j];\n\t\t}\n\t\telse if (opr[k] == '*')\n\t\t{\n\t\t\tminTmp = minVal[i, k] * minVal[k + 1, j];\n\t\t\tmaxTmp = maxVal[i, k] * maxVal[k + 1, j];\n\t\t}\n\t\tif (minTmp < minVal[i, j])\n\t\t\tminVal[i, j] = minTmp;\n\t\tif (maxTmp > maxVal[i, j])\n\t\t\tmaxVal[i, j] = maxTmp;\n\t\t}\n\t}\n\t}\n\tConsole.Write(\"Minimum value : \" + minVal[0, len - 1] + \", Maximum value : \" + maxVal[0,len - 1]);\n }", "6907": "static int lcs(string str1, string str2, int len1, int len2, int i, int j)\n\t{\n\t\tint ret = dp[i, j];\n\t\tif (i == len1 j == len2)\n\t\t\treturn ret = 0;\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t\tret = 0;\n\t\tif (str1[i] == str2[j])\n\t\t\tret = 1 + lcs(str1, str2, len1, len2, i + 1, j + 1);\n\t\telse\n\t\t\tret = Math.Max(lcs(str1, str2, len1, len2, i + 1, j),\n\t\t\t\t\tlcs(str1, str2, len1, len2, i, j + 1));\n\t\treturn ret;\n\t}\nstatic void printAll(string str1, string str2, int len1, int len2, char[] data, int indx1, int indx2, int currlcs)\n\t{\n\t\tif (currlcs == lcslen)\n\t\t{\n\t\t\tdata[currlcs] = '\\0';\n\t\t\tConsole.WriteLine(new string(data));\n\t\t\treturn;\n\t\t}\n\t\tif (indx1 == len1 indx2 == len2)\n\t\t\treturn;\n\t\tfor (char ch='a'; ch<='z'; ch++)\n\t\t{\n\t\t\tbool done = false;\n\t\t\tfor (int i = indx1; i < len1; i++)\n\t\t\t{\n\t\t\t\tif (ch == str1[i])\n\t\t\t\t{\n\t\t\t\tfor (int j = indx2; j < len2; j++)\n\t\t\t\t{\n\t\t\t\t\tif (ch == str2[j] &&\n\t\t\t\t\tlcs(str1, str2, len1, len2, i, j) == lcslen-currlcs)\n\t\t\t\t\t{\n\t\t\t\t\tdata[currlcs] = ch;\n\t\t\t\t\tprintAll(str1, str2, len1, len2, data, i+1, j+1, currlcs+1);\n\t\t\t\t\tdone = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nstatic void prinlAllLCSSorted(string str1, string str2)\n\t{\n\t\tint len1 = str1.Length, len2 = str2.Length;\n\t\tfor(int i = 0; i < MAX; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < MAX; j++)\n\t\t\t{\n\t\t\t\tdp[i, j] = -1;\n\t\t\t}\n\t\t}\n\t\tlcslen = lcs(str1, str2, len1, len2, 0, 0);\n\t\tchar[] data = new char[MAX];\n\t\tprintAll(str1, str2, len1, len2, data, 0, 0, 0);\n\t}", "6933": "static int minAdjustmentCost(int []A, int n, int target)\n\t{\n\t\tint[,] dp = new int[n,M + 1];\n\t\tfor (int j = 0; j <= M; j++)\n\t\t\tdp[0,j] = Math.Abs(j - A[0]);\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j <= M; j++)\n\t\t\t{\n\t\t\t\tdp[i,j] = int.MaxValue;\n\t\t\t\tint k = Math.Max(j - target, 0);\n\t\t\t\tfor ( ; k <= Math.Min(M, j + target); k++)\n\t\t\t\t\tdp[i,j] = Math.Min(dp[i,j],\n\t\t\t\t\t\t\t\tdp[i - 1,k]\n\t\t\t\t\t\t+ Math.Abs(A[i] - j));\n\t\t\t}\n\t\t}\n\t\tint res = int.MaxValue;\n\t\tfor (int j = 0; j <= M; j++)\n\t\t\tres = Math.Min(res, dp[n - 1,j]);\n\t\treturn res;\n\t}", "6944": "static int LCIS(int []arr1, int n, int []arr2, int m)\n\t{\n\t\tint []table = new int[m];\n\t\tfor (int j = 0; j < m; j++)\n\t\t\ttable[j] = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint current = 0;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif (arr1[i] == arr2[j])\n\t\t\t\t\tif (current + 1 > table[j])\n\t\t\t\t\t\ttable[j] = current + 1;\n\t\t\t\tif (arr1[i] > arr2[j])\n\t\t\t\t\tif (table[j] > current)\n\t\t\t\t\t\tcurrent = table[j];\n\t\t\t}\n\t\t}\n\t\tint result = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif (table[i] > result)\n\t\t\tresult = table[i];\n\t\treturn result;\n\t}", "7051": "static int cutRod(int []price,int n)\n\t{\n\t\tint []val = new int[n + 1];\n\t\tval[0] = 0;\n\t\tfor (int i = 1; i<=n; i++)\n\t\t{\n\t\t\tint max_val = int.MinValue;\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tmax_val = Math.Max(max_val, price[j] + val[i - j - 1]);\n\t\t\tval[i] = max_val;\n\t\t}\n\t\treturn val[n];\n\t}", "7068": "static int MatrixChainOrder(int[] p, int i, int j)\n\t{\n\t\tif (i == j)\n\t\t\treturn 0;\n\t\tint min = int.MaxValue;\n\t\tfor (int k = i; k < j; k++)\n\t\t{\n\t\t\tint count = MatrixChainOrder(p, i, k)\n\t\t\t\t\t\t+ MatrixChainOrder(p, k + 1, j)\n\t\t\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\t\tif (count < min)\n\t\t\t\tmin = count;\n\t\t}\n\t\treturn min;\n\t}", "7069": "static int matrixChainMemoised(int[] p, int i, int j)\n {\n\tif (i == j) \n\t{\n\treturn 0;\n\t}\n\tif (dp[i, j] != -1) \n\t{\n\treturn dp[i, j];\n\t}\n\tdp[i, j] = Int32.MaxValue;\n\tfor (int k = i; k < j; k++) \n\t{\n\tdp[i, j] = Math.Min(\n\t\tdp[i, j], matrixChainMemoised(p, i, k)\n\t\t+ matrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n\t}\n\treturn dp[i,j];\n }\nstatic int MatrixChainOrder(int[] p, int n)\n {\n\tint i = 1, j = n - 1;\n\treturn matrixChainMemoised(p, i, j);\n }", "7071": "static int count( int []S, int m, int n )\n\t{\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\tif (n < 0)\n\t\t\treturn 0;\n\t\tif (m <=0 && n >= 1)\n\t\t\treturn 0;\n\t\treturn count( S, m - 1, n ) +\n\t\t\tcount( S, m, n - S[m - 1] );\n\t}", "7119": "static int totalCombination(int L, int R)\n {\n\tint count = 0;\n\tint K = R - L;\n\tif (K < L)\n\treturn 0;\n\tint ans = K - L;\n\tcount = ((ans + 1) * (ans + 2)) / 2;\n\treturn count;\n }", "7135": "static void printArrays(int n)\n{\n\tList<int> A = new List<int>();\n\tList<int> B = new List<int>();\n\tfor(int i = 1; i <= 2 * n; i++)\n\t{\n\t\tif (i % 2 == 0)\n\t\t\tA.Add(i);\n\t\telse\n\t\t\tB.Add(i);\n\t}\n\tConsole.Write(\"{ \");\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tConsole.Write(A[i]);\n\t\tif (i != n - 1)\n\t\t\tConsole.Write(\", \");\n\t}\n\tConsole.Write(\" }\\n\");\n\tConsole.Write(\"{ \");\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tConsole.Write(B[i]);\n\t\tif (i != n - 1)\n\t\t\tConsole.Write(\", \");\n\t}\n\tConsole.Write(\" }\");\n}", "7139": "static void flipBitsOfAandB(int A, int B)\n{\n\tfor(int i = 0; i < 32; i++)\n\t{\n\t\tif (((A & (1 << i)) &\n\t\t\t(B & (1 << i))) != 0)\n\t\t{\n\t\t\tA = A ^ (1 << i);\n\t\t\tB = B ^ (1 << i);\n\t\t}\n\t}\n\tConsole.Write(A + \" \" + B);\n}", "7140": "static void flipBitsOfAandB(int A, int B)\n{\n\tA = A ^ (A & B);\n\tB = B ^ (A & B);\n\tConsole.Write(A + \" \" + B);\n}", "7167": "static int TotalHammingDistance(int n)\n{\n\tint i = 1, sum = 0;\n\twhile (n / i > 0)\n\t{\n\t\tsum = sum + n / i;\n\t\ti = i * 2;\n\t}\n\treturn sum;\n}", "7176": "static void solve(long n)\n{\n long s = 0;\n for(int l = 1; l <= n;)\n {\n\tint r = (int)(n /(Math.Floor((double)n/l)));\n\tint x = (((r % m) *\n\t\t\t((r + 1) % m)) / 2) % m;\n\tint y = (((l % m) *\n\t\t\t((l - 1) % m)) / 2) % m;\n\tint p = (int)((n / l) % m);\n\ts = (s + (((x - y) % m) * p) % m + m) % m;\n\ts %= m;\n\tl = r + 1;\n }\n Console.Write((s + m) % m);\n}", "7187": "static int min_time_to_cut(int N)\n{\n\tif (N == 0)\n\t\treturn 0;\n\treturn (int)Math.Ceiling(Math.Log(N) /\n\t\t\t\t\t\t\tMath.Log(2));\n}", "7203": "static int findDistinctSums(int n)\n{\n\tHashSet<int> s = new HashSet<int>();\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = i; j <= n; j++)\n\t\t{\n\t\t\ts.Add(i + j);\n\t\t}\n\t}\n\treturn s.Count;\n}", "7204": "static int findDistinctSums(int N)\n{\n\treturn (2 * N - 1);\n}", "7234": "static int printPattern( int i, int j, int n)\n{\n\tif (j >= n) {\n\t\treturn 0;\n\t}\n\tif (i >= n) {\n\t\treturn 1;\n\t}\n\tif (j == i j == n - 1 - i) {\n\t\tif (i == n - 1 - j) {\n\t\t\tConsole.Write(\"/\");\n\t\t}\n\t\telse {\n\t\t\tConsole.Write(\"\\\\\");\n\t\t}\n\t}\n\telse {\n\t\tConsole.Write(\"*\");\n\t}\n\tif (printPattern(i, j + 1, n) == 1) {\n\t\treturn 1;\n\t}\n\tConsole.WriteLine();\n\treturn printPattern(i + 1, 0, n);\n}", "7248": "private static int[] zArray(int []arr)\n\t{\n\t\tint []z;\n\t\tint n = arr.Length;\n\t\tz = new int[n];\n\t\tint r = 0, l = 0;\n\t\tfor (int k = 1; k < n; k++)\n\t\t{\n\t\t\tif (k > r)\n\t\t\t{\n\t\t\t\tr = l = k;\n\t\t\t\twhile (r < n && arr[r] == arr[r - l])\n\t\t\t\t\tr++;\n\t\t\t\tz[k] = r - l;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint k1 = k - l;\n\t\t\t\tif (z[k1] < r - k + 1)\n\t\t\t\t\tz[k] = z[k1];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tl = k;\n\t\t\t\t\twhile (r < n && arr[r] == arr[r - l])\n\t\t\t\t\t\tr++;\n\t\t\t\t\tz[k] = r - l;\n\t\t\t\t\tr--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}\nprivate static int[] mergeArray(int []A, int []B)\n\t{\n\t\tint n = A.Length;\n\t\tint m = B.Length;\n\t\tint []z;\n\t\tint []c = new int[n + m + 1];\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tc[i] = B[i];\n\t\tc[m] = int.MaxValue;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tc[m + i + 1] = A[i];\n\t\tz = zArray(c);\n\t\treturn z;\n\t}\nprivate static void findZArray(int []A, int []B, int n)\n\t{\n\t\tint flag = 0;\n\t\tint []z;\n\t\tz = mergeArray(A, B);\n\t\tfor (int i = 0; i < z.Length; i++)\n\t\t{\n\t\t\tif (z[i] == n)\n\t\t\t{\n\t\t\t\tConsole.Write((i - n - 1) + \" \");\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0)\n\t\t{\n\t\t\tConsole.WriteLine(\"Not Found\");\n\t\t}\n\t}", "7276": "static int getCount(String a, String b)\n\t{\n\t\tif(b.Length % a.Length != 0)\n\t\t\treturn -1;\n\t\tint count = b.Length / a.Length;\n\t\tString str = \"\";\n\t\tfor(int i = 0; i < count; i++)\n\t\t{\n\t\t\tstr = str + a;\n\t\t}\n\t\tif(str.Equals(b))\n\t\t\treturn count;\n\t\treturn -1;\n\t}", "7287": "public static void printSpiral(int size)\n\t{\n\t\tint row = 0, col = 0;\n\t\tint boundary = size - 1;\n\t\tint sizeLeft = size - 1;\n\t\tint flag = 1;\n\t\tchar move = 'r';\n\t\tint[, ] matrix = new int[size, size];\n\t\tfor (int i = 1; i < size * size + 1; i++) {\n\t\t\tmatrix[row, col] = i;\n\t\t\tswitch (move) {\n\t\t\tcase 'r':\n\t\t\t\tcol += 1;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcol -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\trow -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\trow += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == boundary) {\n\t\t\t\tboundary += sizeLeft;\n\t\t\t\tif (flag != 2) {\n\t\t\t\t\tflag = 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tsizeLeft -= 1;\n\t\t\t\t}\n\t\t\t\tswitch (move) {\n\t\t\t\tcase 'r':\n\t\t\t\t\tmove = 'd';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tmove = 'l';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\tmove = 'u';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tmove = 'r';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (row = 0; row < size; row++) {\n\t\t\tfor (col = 0; col < size; col++) {\n\t\t\t\tint n = matrix[row, col];\n\t\t\t\tConsole.Write((n < 10)\n\t\t\t\t\t\t\t\t? (n + \" \")\n\t\t\t\t\t\t\t\t: (n + \" \"));\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t}\n\t}", "7298": "static bool check(String S1, String S2)\n{\n\tint n1 = S1.Length;\n\tint n2 = S2.Length;\n\tDictionary<int,int> mp =\n\t\tnew Dictionary<int,int>();\n\tfor (int i = 0; i < n1; i++)\n\t{\n\t\tif(mp.ContainsKey((int)S1[i]))\n\t\t{\n\t\t\tmp[(int)S1[i]] = mp[(int)S1[i]] + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.Add((int)S1[i], 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < n2; i++)\n\t{\n\t\tif(mp.ContainsKey((int)S2[i]))\n\t\t{\n\t\t\tmp[(int)S2[i]] = mp[(int)S2[i]] - 1;\n\t\t}\n\t\telse if (mp.ContainsKey(S2[i] - 1) &&\n\t\t\t\t\tmp.ContainsKey(S2[i] - 2))\n\t\t{\n\t\t\tmp[S2[i] - 1] = mp[S2[i] - 1] - 1;\n\t\t\tmp[S2[i] - 2] = mp[S2[i] - 2] - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "7309": "public static int countPattern(string str)\n{\n\tint len = str.Length;\n\tbool oneSeen = false;\n\tfor (int i = 0; i < len ; i++)\n\t{\n\t\tchar getChar = str[i];\n\t\tif (getChar == '1' && oneSeen == true)\n\t\t{\n\t\t\tif (str[i - 1] == '0')\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (getChar == '1' && oneSeen == false)\n\t\t{\n\t\t\toneSeen = true;\n\t\t}\n\t\tif (getChar != '0' && str[i] != '1')\n\t\t{\n\t\t\toneSeen = false;\n\t\t}\n\t}\n\treturn count;\n}", "7336": "public static int countSubstrings(string str)\n\t{\n\t\tint[] freq = new int[3];\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tfor (int j = 0; j < str.Length; j++) {\n\t\t\tfreq[str[j] - '0']++;\n\t\t\twhile (freq[0] > 0 && freq[1] > 0 && freq[2] > 0) {\n\t\t\t\tfreq[str[i++] - '0']--;\n\t\t\t}\n\t\t\tcount += i;\n\t\t}\n\t\treturn count;\n\t}", "7347": "static int minFlips(string str)\n{\n\tint count = 0;\n\tif (str.Length <= 2) {\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < str.Length - 2;) {\n\t\tif (str[i] == str[i+1] && str[i+2] == str[i+1]) {\n\t\t\ti = i + 3;\n\t\t\tcount++;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn count;\n}", "7382": "static string checkIfPossible(int N, string[] arr, string T)\n\t{\n\t\tint[] freqS = new int[256];\n\t\tint[] freqT = new int[256];\n\t\tforeach(char ch in T.ToCharArray())\n\t\t{\n\t\t\tfreqT[ch - 'a']++;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tforeach(char ch in arr[i].ToCharArray())\n\t\t\t{\n\t\t\t\tfreqS[ch - 'a']++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 256; i++) {\n\t\t\tif (freqT[i] == 0 && freqS[i] != 0) {\n\t\t\t\treturn \"No\";\n\t\t\t}\n\t\t\telse if (freqS[i] == 0 && freqT[i] != 0) {\n\t\t\t\treturn \"No\";\n\t\t\t}\n\t\t\telse if (freqT[i] != 0\n\t\t\t\t\t&& freqS[i] != (freqT[i] * N)) {\n\t\t\t\treturn \"No\";\n\t\t\t}\n\t\t}\n\t\treturn \"Yes\";\n\t}", "7390": "static string convertToHex(int num)\n\t{\n\t\tstring temp = \"\";\n\t\twhile (num != 0) {\n\t\t\tint rem = num % 16;\n\t\t\tchar c;\n\t\t\tif (rem < 10) {\n\t\t\t\tc = (char) (rem + 48);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = (char) (rem + 87);\n\t\t\t}\n\t\t\ttemp = temp + c;\n\t\t\tnum = num / 16;\n\t\t}\n\t\treturn temp;\n\t}\nstatic string encryptString(string S, int N)\n\t{\n\t\tstring ans = \"\";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tchar ch = S[i];\n\t\t\tint count = 0;\n\t\t\tstring hex;\n\t\t\twhile (i < N && S[i] == ch) {\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ti--;\n\t\t\thex = convertToHex(count);\n\t\t\tans = ans + ch;\n\t\t\tans = ans + hex;\n\t\t}\n\t\tchar[] Ans = ans.ToCharArray();\n\t\tArray.Reverse(Ans);\n\t\tans = new string(Ans);\n\t\treturn ans;\n\t}", "7401": "static int groupsOfOnes(string S, int N)\n{\n\tint count = 0;\n\tStack<int> st = new Stack<int>();\n\tfor (int i = 0; i < N; i++) {\n\t\tif (S[i] == '1')\n\t\t\tst.Push(1);\n\t\telse {\n\t\t\tif (st.Count > 0) {\n\t\t\t\tcount++;\n\t\t\t\twhile (st.Count > 0) {\n\t\t\t\t\tst.Pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (st.Count > 0)\n\t\tcount++;\n\treturn count;\n}", "7412": "static void generatePalindrome(string S)\n{\n\tDictionary<char,\n\t\t\tint> Hash = new Dictionary<char,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tforeach (char ch in S)\n\t{\n\t\tif (Hash.ContainsKey(ch))\n\t\t\tHash[ch]++;\n\t\telse\n\t\t\tHash.Add(ch, 1);\n\t}\n\tHashSet<string> st = new HashSet<string>();\n\tfor(char i = 'a'; i <= 'z'; i++)\n\t{\n\t\tif (Hash.ContainsKey(i) && Hash[i] == 2)\n\t\t{\n\t\t\tfor(char j = 'a'; j <= 'z'; j++)\n\t\t\t{\n\t\t\t\tstring s = \"\";\n\t\t\t\tif (Hash.ContainsKey(j) && i != j)\n\t\t\t\t{\n\t\t\t\t\ts += i;\n\t\t\t\t\ts += j;\n\t\t\t\t\ts += i;\n\t\t\t\t\tst.Add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Hash.ContainsKey(i) && Hash[i] >= 3)\n\t\t{\n\t\t\tfor(char j = 'a'; j <= 'z'; j++)\n\t\t\t{\n\t\t\t\tstring s = \"\";\n\t\t\t\tif (Hash.ContainsKey(j))\n\t\t\t\t{\n\t\t\t\t\ts += i;\n\t\t\t\t\ts += j;\n\t\t\t\t\ts += i;\n\t\t\t\t\tst.Add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tforeach(string ans in st)\n\t{\n\t\tConsole.WriteLine(ans);\n\t}\n}", "7423": "static void countOccurrences(string S, string X, string Y)\n\t{\n\t\tint count = 0;\n\t\tint N = S.Length, A = X.Length;\n\t\tint B = Y.Length;\n\t\tint P = Math.Min(A, Math.Min(N, B));\n\t\tfor (int i = 0; i < N - P + 1; i++) {\n\t\t\tif (S.Substring(i, Math.Min(N, B)).Equals(Y))\n\t\t\t\tcount++;\n\t\t\tif (S.Substring(i, Math.Min(N, A)).Equals(X))\n\t\t\t\tConsole.Write(count + \" \");\n\t\t}\n\t}", "7487": "static void findWinner(string a, int n)\n {\n\tList<int> v = new List<int>(); \n\tint c = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\tif (a[i] == '0')\n\t{\n\t\tc++;\n\t}\n\telse\n\t{\n\t\tif (c != 0)\n\t\tv.Add(c);\n\t\tc = 0;\n\t}\n\t}\n\tif (c != 0)\n\tv.Add(c);\n\tif (v.Count == 0)\n\t{\n\tConsole.Write(\"Player B\");\n\treturn;\n\t}\n\tif (v.Count == 1)\n\t{\n\tif ((v[0] & 1) != 0)\n\t\tConsole.Write(\"Player A\");\n\telse\n\t\tConsole.Write(\"Player B\");\n\treturn;\n\t}\n\tint first = Int32.MinValue;\n\tint second = Int32.MinValue;\n\tfor (int i = 0; i < v.Count; i++)\n\t{\n\tif (a[i] > first) {\n\t\tsecond = first;\n\t\tfirst = a[i];\n\t}\n\telse if (a[i] > second && a[i] != first)\n\t\tsecond = a[i];\n\t}\n\tif ((first & 1) != 0\n\t\t&& (first + 1) / 2 > second)\n\tConsole.Write(\"Player A\");\n\telse\n\tConsole.Write(\"Player B\");\n }", "7507": "static void DFA(string str, int N)\n {\n\tif (N <= 1)\n\t{\n\tConsole.Write(\"No\");\n\treturn;\n\t}\n\tint count = 0;\n\tif (str[0] == 'C') {\n\tcount++;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (str[i] == 'A' str[i] == 'B')\n\t\tcount++;\n\t\telse\n\t\tbreak;\n\t}\n\t}\n\telse {\n\tConsole.Write(\"No\");\n\treturn;\n\t}\n\tif (count == N)\n\tConsole.Write(\"Yes\");\n\telse\n\tConsole.Write(\"No\");\n }", "7542": "static void minMaxDigits(string str, int N)\n{\n\tint[] arr = new int[N];\n\tfor(int i = 0; i < N; i++)\n\t\tarr[i] = (str[i] - '0') % 3;\n\tint zero = 0, one = 0, two = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t\tzero++;\n\t\tif (arr[i] == 1)\n\t\t\tone++;\n\t\tif (arr[i] == 2)\n\t\t\ttwo++;\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tsum = (sum + arr[i]) % 3;\n\t}\n\tif (sum == 0)\n\t{\n\t\tConsole.Write(0 + \" \");\n\t}\n\tif (sum == 1)\n\t{\n\t\tif ((one != 0) && (N > 1))\n\t\t\tConsole.Write(1 + \" \");\n\t\telse if (two > 1 && N > 2)\n\t\t\tConsole.Write(2 + \" \");\n\t\telse\n\t\t\tConsole.Write(-1 + \" \");\n\t}\n\tif (sum == 2)\n\t{\n\t\tif (two != 0 && N > 1)\n\t\t\tConsole.Write(1 + \" \");\n\t\telse if (one > 1 && N > 2)\n\t\t\tConsole.Write(2 + \" \");\n\t\telse\n\t\t\tConsole.Write(-1 + \" \");\n\t}\n\tif (zero > 0)\n\t\tConsole.Write(N - 1 + \" \");\n\telse if (one > 0 && two > 0)\n\t\tConsole.Write(N - 2 + \" \");\n\telse if (one > 2 two > 2)\n\t\tConsole.Write(N - 3 + \" \");\n\telse\n\t\tConsole.Write(-1 + \" \");\n}", "7548": "static int findMinimumChanges(int N, int K, char[] S)\n{\n\tint ans = 0;\n\tfor(int i = 0; i < (K + 1) / 2; i++)\n\t{\n\t\tDictionary<char,\n\t\t\t\tint> mp = new Dictionary<char,\n\t\t\t\t\t\t\t\t\t\t\tint>();\n\t\tfor(int j = i; j < N; j += K)\n\t\t{\n\t\t\tif (mp.ContainsKey(S[j]))\n\t\t\t{\n\t\t\t\tmp[S[j]]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.Add(S[j], 1);\n\t\t\t}\n\t\t}\n\t\tfor(int j = N - i - 1; j >= 0; j -= K)\n\t\t{\n\t\t\tif (K % 2 == 1 && i == K / 2)\n\t\t\t\tbreak;\n\t\t\tif (mp.ContainsKey(S[j]))\n\t\t\t{\n\t\t\t\tmp[S[j]]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.Add(S[j], 1);\n\t\t\t}\n\t\t}\n\t\tint curr_max = int.MinValue;\n\t\tforeach(KeyValuePair<char, int> p in mp)\n\t\t{\n\t\t\tcurr_max = Math.Max(curr_max, p.Value);\n\t\t}\n\t\tif ((K % 2 == 1) && i == K / 2)\n\t\t\tans += (N / K - curr_max);\n\t\telse\n\t\t\tans += (N / K * 2 - curr_max);\n\t}\n\treturn ans;\n}", "7564": "static int longComPre(String []arr, int N)\n{\n int [,]freq = new int[N, 256];\n for (int i = 0; i < N; i++)\n {\n\tint M = arr[i].Length;\n\tfor (int j = 0; j < M; j++)\n\t{\n\tfreq[i, arr[i][j]]++;\n\t}\n }\n int maxLen = 0;\n for (int j = 0; j < 256; j++)\n {\n\tint minRowVal = int.MaxValue;\n\tfor (int i = 0; i < N; i++)\n\t{\n\tminRowVal = Math.Min(minRowVal, freq[i, j]);\n\t}\n\tmaxLen += minRowVal;\n }\n return maxLen;\n}", "7587": "static int binomialCoeff(int n, int k)\n{\n\tint res = 1;\n\tif (k > n - k)\n\t\tk = n - k;\n\tfor(int i = 0; i < k; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}\nstatic int countOfString(int N)\n{\n\tint Stotal = (int) Math.Pow(2, N);\n\tint Sequal = 0;\n\tif (N % 2 == 0)\n\t\tSequal = binomialCoeff(N, N / 2);\n\tint S1 = (Stotal - Sequal) / 2;\n\treturn S1;\n}", "7593": "static String removeCharRecursive(String str, char X)\n{\n\tif (str.Length == 0)\n\t{\n\t\treturn \"\";\n\t}\n\tif (str[0] == X)\n\t{\n\t\treturn removeCharRecursive(\n\t\t\tstr.Substring(1), X);\n\t}\n\treturn str[0] + removeCharRecursive(\n\t\t\t\t\tstr.Substring(1), X);\n}", "7594": "static String checkString(String s, int K)\n{\n\tint n = s.Length;\n\tDictionary<char,\n\t\t\tint> mp = new Dictionary<char,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(mp.ContainsKey(s[i]))\n\t\t\tmp[s[i]] = i;\n\t\telse\n\t\t\tmp.Add(s[i], i);\n\t}\n\tint f = 0;\n\tHashSet<char> st = new HashSet<char>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tst.Add(s[i]);\n\t\tif (st.Count > K)\n\t\t{\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (mp[s[i]] == i)\n\t\t\tst.Remove(s[i]);\n\t}\n\treturn (f == 1 ? \"Yes\" : \"No\");\n}", "7609": "static bool isValid(char a1, char a2, string str, int flag)\n{\n\tchar v1, v2;\n\tif (flag == 0)\n\t{\n\t\tv1 = str[4];\n\t\tv2 = str[3];\n\t}\n\telse\n\t{\n\t\tv1 = str[1];\n\t\tv2 = str[0];\n\t}\n\tif (v1 != a1 && v1 != '?')\n\t{\n\t\treturn false;\n\t}\n\tif (v2 != a2 && v2 != '?')\n\t{\n\t\treturn false;\n\t}\n\treturn true;\n}\nstatic bool inRange(int hh, int mm, int L, int R)\n{\n\tint a = Math.Abs(hh - mm);\n\tif (a < L a > R)\n\t{\n\t\treturn false;\n\t}\n\treturn true;\n}\nstatic void displayTime(int hh, int mm)\n{\n\tif (hh > 10)\n\t{\n\t\tConsole.Write(hh + \":\");\n\t}\n\telse if (hh < 10)\n\t{\n\t\tConsole.Write(\"0\" + hh + \":\");\n\t}\n\tif (mm > 10)\n\t{\n\t\tConsole.Write(mm);\n\t}\n\telse if (mm < 10)\n\t{\n\t\tConsole.Write(\"0\" + mm);\n\t}\n}\nstatic void maximumTimeWithDifferenceInRange( string str, int L, int R)\n{\n\tint i = 0, j = 0;\n\tint h1, h2, m1, m2;\n\tfor(i = 23; i >= 0; i--)\n\t{\n\t\th1 = i % 10;\n\t\th2 = i / 10;\n\t\tif (!isValid((char)h1, (char)h2, str, 1))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j = 59; j >= 0; j--)\n\t\t{\n\t\t\tm1 = j % 10;\n\t\t\tm2 = j / 10;\n\t\t\tif (!isValid((char)m1, (char)m2, str, 0))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (inRange(i, j, L, R))\n\t\t\t{\n\t\t\t\tdisplayTime(i, j);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (inRange(i, j, L, R))\n\t{\n\t\tdisplayTime(i, j);\n\t}\n\telse\n\t{\n\t\tConsole.WriteLine(\"-1\");\n\t}\n}", "7622": "static bool check(String s, int n)\n{\n\tStack<int> st = new Stack<int>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (st.Count != 0 &&\n\t\t\tst.Peek() == s[i])\n\t\t\tst.Pop();\n\t\telse\n\t\t\tst.Push(s[i]);\n\t}\n\tif (st.Count == 0)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}", "7646": "static bool can_Construct(String S, int K)\n{\t\n Dictionary<char,\n\t\t\tint> m = new Dictionary<char,\n\t\t\t\t\t\t\t\t\tint>();\n int p = 0;\n if (S.Length == K)\n\treturn true;\n for(int i = 0; i < S.Length; i++)\n\tif(!m.ContainsKey(S[i]))\n\tm.Add(S[i], 1);\n else\n\tm[S[i]] = m[S[i]] + 1;\n if (K > S.Length)\n\treturn false;\n else\n {\n\tforeach(int h in m.Values)\n\t{\n\tif (h % 2 != 0)\n\t\tp = p + 1;\n\t}\n }\n if (K < p)\n\treturn false;\n return true;\n}", "7688": "static void findNumOfValidWords(List<String> w, List<String> p)\n{\n Dictionary<int,\n\t\t\tint> m = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tint>();\n List<int> res = new List<int>();\n foreach (String s in w)\n {\n\tint val = 0;\n\tforeach (char c in s.ToCharArray())\n\t{\n\tval = val | (1 << (c - 'a'));\n\t}\n\tif(m.ContainsKey(val))\n\tm[val] = m[val] + 1;\n\telse\n\tm.Add(val, 1);\n }\n foreach (String s in p)\n {\n\tint val = 0;\n\tforeach (char c in s.ToCharArray())\n\t{\n\tval = val | (1 << (c - 'a'));\n\t}\n\tint temp = val;\n\tint first = s[0] - 'a';\n\tint count = 0;\n\twhile (temp != 0)\n\t{\n\tif (((temp >> first) & 1) == 1)\n\t{\n\t\tif (m.ContainsKey(temp))\n\t\t{\n\t\tcount += m[temp];\n\t\t}\n\t}\n\ttemp = (temp - 1) & val;\n\t}\n\tres.Add(count);\n }\n foreach (int it in res)\n {\n\tConsole.WriteLine(it);\n }\n}", "7693": "static String flip(char []s)\n{\n\tfor(int i = 0; i < s.Length; i++)\n\t{\n\tif (s[i] == '0')\n\t{\n\t\twhile (s[i] == '0')\n\t\t{\n\t\t\ts[i] = '1';\n\t\t\ti++;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\treturn new String(s);\n}", "7694": "public static void distinct(string[] S, int M)\n{\n\tint count = 0;\n\tfor(int i = 0; i < S.Length; i++)\n\t{\n\t\tHashSet<char> set = new HashSet<char>();\n\t\tfor(int j = 0; j < S[i].Length; j++)\n\t\t{\n\t\t\tif (!set.Contains(S[i][j]))\n\t\t\t\tset.Add(S[i][j]);\n\t\t}\n\t\tint c = set.Count;\n\t\tif (c <= M)\n\t\t\tcount += 1;\n\t}\n\tConsole.Write(count);\n}", "7734": "static string removeOddFrequencyCharacters(string s)\n{\n\tDictionary<char,\n\t\t\tint> m = new Dictionary<char,\n\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < s.Length; i++)\n\t{\n\t\tchar p = s[i];\n\t\tif (m.ContainsKey(p))\n\t\t{\n\t\t\tm[p]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm[p] = 1;\n\t\t}\n\t}\n\tstring new_string = \"\";\n\tfor(int i = 0; i < s.Length; i++)\n\t{\n\t\tif ((m[s[i]] & 1) == 1)\n\t\t\tcontinue;\n\t\tnew_string += s[i];\n\t}\n\treturn new_string;\n}", "7735": "static String removeChars(char []arr, int k)\n{\n\tint []hash = new int[MAX_CHAR];\n\tint n = arr.Length;\n\tfor (int i = 0; i < n; ++i)\n\t\thash[arr[i] - 'a']++;\n\tString ans = \"\";\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (hash[arr[i] - 'a'] != k) {\n\t\t\tans += arr[i];\n\t\t}\n\t}\n\treturn ans;\n}", "7753": "static int productAtKthLevel( String tree, int k, int level){\n\t\tif (tree[i++] == '(') {\n\t\t\tif (tree[i] == ')')\n\t\t\t\treturn 1;\n\t\t\tint product = 1;\n\t\t\tif (level == k)\n\t\t\t\tproduct = tree[i] - '0';\n\t\t\t++i;\n\t\t\tint leftproduct = productAtKthLevel( tree, k, level + 1);\n\t\t\t++i;\n\t\t\tint rightproduct =\n\t\t\tproductAtKthLevel(tree, k, level + 1);\n\t\t\t++i;\n\t\t\treturn product *\n\t\t\tleftproduct * rightproduct;\n\t\t}\n\t\treturn int.MinValue;\n\t}", "7758": "static void findMostOccurringChar(string []str)\n\t{\n\t\tint []hash = new int[26];\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < str[i].Length; j++)\n\t\t\t{\n\t\t\t\thash[str[i][j]-97]++;\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor (int i = 0; i < 26; i++)\n\t\t{\n\t\t\tmax = hash[i] > hash[max] ? i : max;\n\t\t}\n\t\tConsole.Write((char)(max + 97) +\"\\n\");\n\t}", "7788": "static void sub_segments(String str, int n)\n{\n\tint l = str.Length;\n\tfor (int x = 0; x < l; x += n)\n\t{\n\t\tString newlist = str.Substring(x, n);\n\t\tList<char> arr = new List<char>();\n\t\tforeach (char y in newlist.ToCharArray())\n\t\t{\n\t\t\tif (!arr.Contains(y))\n\t\t\t\tarr.Add(y);\n\t\t}\n\t\tforeach (char y in arr)\n\t\t\tConsole.Write(y);\n\t\tConsole.WriteLine();\n\t}\n}", "7816": "public static bool isPalindrome(float num)\n\t{\n\t\tstring s = num.ToString();\n\t\tint low = 0;\n\t\tint high = s.Length - 1;\n\t\twhile (low < high)\n\t\t{\n\t\t\tif (s[low] != s[high])\n\t\t\t\treturn false;\n\t\t\tlow++;\n\t\t\thigh--;\n\t\t}\n\t\treturn true;\n\t}", "7819": "static int maxSubStr(char []str1, int len1, char []str2, int len2)\n\t{\n\t\tif (len1 > len2)\n\t\t\treturn 0;\n\t\tint []freq1 = new int[MAX];\n\t\tfor (int i = 0; i < len1; i++)\n\t\t\tfreq1[i] = 0;\n\t\tfor (int i = 0; i < len1; i++)\n\t\t\tfreq1[str1[i] - 'a']++;\n\t\tint []freq2 = new int[MAX];\n\t\tfor (int i = 0; i < len2; i++)\n\t\t\tfreq2[i] = 0;\n\t\tfor (int i = 0; i < len2; i++)\n\t\t\tfreq2[str2[i] - 'a']++;\n\t\tint minPoss = int.MaxValue;\n\t\tfor (int i = 0; i < MAX; i++)\n\t\t{\n\t\t\tif (freq1[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (freq1[i] > freq2[i])\n\t\t\t\treturn 0;\n\t\t\tminPoss = Math.Min(minPoss, freq2[i] / freq1[i]);\n\t\t}\n\t\treturn minPoss;\n\t}", "7820": "static int cntWays(String str, int n)\n{\n\tint x = n + 1;\n\tint ways = x * x * (x * x - 1) / 12;\n\treturn ways;\n}", "7828": "static void findSubStr(String str, int cnt, int start)\n{\n\tif (start == str.Length)\n\t{\n\t\tminCnt = Math.Min(cnt, minCnt);\n\t}\n\tfor (int len = 1;\n\t\t\tlen <= (str.Length - start); len++)\n\t{\n\t\tString subStr = str.Substring(start, len);\n\t\tif (uSet.Contains(subStr))\n\t\t{\n\t\t\tfindSubStr(str, cnt + 1, start + len);\n\t\t}\n\t}\n}\nstatic void findMinSubStr(String []arr, int n, String str)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tuSet.Add(arr[i]);\n\tfindSubStr(str, 0, 0);\n}", "7851": "static int countSubStr(String s, int n)\n\t{\n\t\tint c1 = 0, c2 = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (i < n - 5 &&\n\t\t\t\t\"geeks\".Equals(s.Substring(i, 5)))\n\t\t\t{\n\t\t\t\tc1++;\n\t\t\t}\n\t\t\tif (i < n - 3 &&\n\t\t\t\t\"for\".Equals(s.Substring(i, 3)))\n\t\t\t{\n\t\t\t\tc2 = c2 + c1;\n\t\t\t}\n\t\t}\n\t\treturn c2;\n\t}", "7861": "public static void findWord(String c, int n)\n{\n\tint co = 0, i;\n\tchar []s = new char[n];\n\tfor (i = 0; i < n ; i++)\n\t{\n\t\tif (i < n / 2)\n\t\t\tco++;\n\t\telse\n\t\t\tco = n - i;\n\t\tif ((c[i] + co) <= 122)\n\t\t\ts[i] = (char)((int)c[i] + co);\n\t\telse\n\t\t\ts[i] = (char)((int)c[i] + co - 26);\n\t}\n\tString str = String.Join(\"\",s);\n\tConsole.WriteLine(str);\n}", "7864": "", "7868": "public static char[] encryptStr(String str, int n, int x)\n\t{\n\t\tx = x % MAX;\n\t\tchar[] arr = str.ToCharArray();\n\t\tint[] freq = new int[MAX];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfreq[arr[i] - 'a']++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (freq[arr[i] - 'a'] % 2 == 0)\n\t\t\t{\n\t\t\t\tint pos = (arr[i] - 'a' + x) % MAX;\n\t\t\t\tarr[i] = (char)(pos + 'a');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint pos = (arr[i] - 'a' - x);\n\t\t\t\tif (pos < 0)\n\t\t\t\t\tpos += MAX;\n\t\t\t\tarr[i] = (char)(pos + 'a');\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t}", "7889": "static void getOrgString(String s)\n\t{\n\t\tConsole.Write(s[0]);\n\t\tint i = 1;\n\t\twhile (i < s.Length)\n\t\t{\n\t\t\tif (s[i] >= 'A' && s[i] <= 'Z')\n\t\t\t\tConsole.Write(\" \"+ char.ToLower(s[i]));\n\t\t\telse\n\t\t\t\tConsole.Write(s[i]);\n\t\t\ti++;\n\t\t}\n\t}", "7892": "static Boolean isPossible(char[] str)\n\t{\n\t\tDictionary<char, int> freq = new Dictionary<char, int>();\n\t\tint max_freq = 0;\n\t\tfor (int j = 0; j < (str.Length); j++) {\n\t\t\tif (freq.ContainsKey(str[j])) {\n\t\t\t\tvar v = freq[str[j]] + 1;\n\t\t\t\tfreq.Remove(str[j]);\n\t\t\t\tfreq.Add(str[j], v);\n\t\t\t\tif (freq[str[j]] > max_freq)\n\t\t\t\t\tmax_freq = freq[str[j]];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfreq.Add(str[j], 1);\n\t\t\t\tif (freq[str[j]] > max_freq)\n\t\t\t\t\tmax_freq = freq[str[j]];\n\t\t\t}\n\t\t}\n\t\tif (max_freq <= (str.Length - max_freq + 1))\n\t\t\treturn true;\n\t\treturn false;\n\t}", "7899": "static void printUncommon(string str1, string str2)\n{\n\tint a1 = 0, a2 = 0;\n\tfor (int i = 0; i < str1.Length; i++)\n\t{\n\t\tint ch = (str1[i] - 'a');\n\t\ta1 = a1 | (1 << ch);\n\t}\n\tfor (int i = 0; i < str2.Length; i++)\n\t{\n\t\tint ch = (str2[i] - 'a');\n\t\ta2 = a2 | (1 << ch);\n\t}\n\tint ans = a1 ^ a2;\n\tint j = 0;\n\twhile (j < 26)\n\t{\n\t\tif (ans % 2 == 1)\n\t\t{\n\t\t\tConsole.Write((char)('a' + j));\n\t\t}\n\t\tans = ans / 2;\n\t\tj++;\n\t}\n}", "7900": "static bool isPalin(int i, int j, int k, int l, int p, int q, String s)\n\t{\n\t\tint start = i, end = q;\n\t\twhile (start < end)\n\t\t{\n\t\t\tif (s[start] != s[end])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstart++;\n\t\t\tif (start == j + 1)\n\t\t\t{\n\t\t\t\tstart = k;\n\t\t\t}\n\t\t\tend--;\n\t\t\tif (end == p - 1)\n\t\t\t{\n\t\t\t\tend = l;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\nstatic int countSubStr(String s)\n\t{\n\t\tint count = 0;\n\t\tint n = s.Length;\n\t\tfor (int i = 0; i < n - 2; i++)\n\t\t{\n\t\t\tfor (int j = i; j < n - 2; j++)\n\t\t\t{\n\t\t\t\tfor (int k = j + 1; k < n - 1; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = k; l < n - 1; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int p = l + 1; p < n; p++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int q = p; q < n; q++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isPalin(i, j, k, l, p, q, s))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "7938": "", "7939": "static bool equalIgnoreCase(String str1, String str2)\n\t{\n\t\tstr1 = str1.ToUpper();\n\t\tstr2 = str2.ToUpper();\n\t\tint x = str1.CompareTo(str2);\n\t\tif (x != 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\nstatic void equalIgnoreCaseUtil(String str1, String str2)\n\t{\n\t\tbool res = equalIgnoreCase(str1, str2);\n\t\tif (res == true)\n\t\t{\n\t\t\tConsole.WriteLine(\"Same\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConsole.WriteLine(\"Not Same\");\n\t\t}\n\t}", "7940": "static bool equalIgnoreCase(String str1, String str2)\n\t{\n\t\tstr1 = str1.ToUpper();\n\t\tstr2 = str2.ToUpper();\n\t\tint x = str1.CompareTo(str2);\n\t\tif (x != 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\nstatic void equalIgnoreCaseUtil(String str1, String str2)\n\t{\n\t\tbool res = equalIgnoreCase(str1, str2);\n\t\tif (res == true)\n\t\t{\n\t\t\tConsole.WriteLine(\"Same\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConsole.WriteLine(\"Not Same\");\n\t\t}\n\t}", "7966": "static int countMinReversals(String expr)\n{\n\tint len = expr.Length;\n\tif (len % 2 != 0)\n\t\treturn -1;\n\tint ans = 0;\n\tint i;\n\tint open = 0;\n\tint close = 0;\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tif (expr[i] == '{')\n\t\t\topen++;\n\t\telse\n\t\t{\n\t\t\tif (open == 0)\n\t\t\t\tclose++;\n\t\t\telse\n\t\t\t\topen--;\n\t\t}\n\t}\n\tans = (close / 2) + (open / 2);\n\tclose %= 2;\n\topen %= 2;\n\tif (close != 0)\n\t\tans += 2;\n\treturn ans;\n}", "7977": "static int totalPairs(String s1, String s2)\n\t{\n\t\tint a1 = 0, b1 = 0;\n\t\tfor (int i = 0; i < s1.Length; i++)\n\t\t{\n\t\t\tif ((int)s1[i] % 2 != 0)\n\t\t\t\ta1++;\n\t\t\telse\n\t\t\t\tb1++;\n\t\t}\n\t\tint a2 = 0, b2 = 0;\n\t\tfor (int i = 0; i < s2.Length; i++)\n\t\t{\n\t\t\tif ((int)s2[i] % 2 != 0)\n\t\t\t\ta2++;\n\t\t\telse\n\t\t\t\tb2++;\n\t\t}\n\t\treturn ((a1 * a2) + (b1 * b2));\n\t}", "7978": "public static string replaceConsonants(string str)\n\t{\n\t\tstring res = \"\";\n\t\tint i = 0, count = 0;\n\t\twhile (i < str.Length) {\n\t\t\tif (str[i] != 'a' && str[i] != 'e' && str[i] != 'i' && str[i] != 'o' && str[i] != 'u') {\n\t\t\t\ti++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tres += count;\n\t\t\t\t}\n\t\t\t\tres += str[i];\n\t\t\t\ti++;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\tres += count;\n\t\t}\n\t\treturn res;\n\t}", "7979": "static int prefixOccurrences(string str)\n\t{\n\t\tchar c = str[0];\n\t\tint countc = 0;\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t{\n\t\t\tif (str[i] == c)\n\t\t\t\tcountc++;\n\t\t}\n\t\treturn countc;\n\t}", "7989": "static int minOperations(string s, string t, int n)\n{\n\tint ct0 = 0, ct1 = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s[i] == t[i])\n\t\t\tcontinue;\n\t\tif (s[i] == '0')\n\t\t\tct0++;\n\t\telse\n\t\t\tct1++;\n\t}\n\treturn Math.Max(ct0, ct1);\n}", "7991": "static String maxValue(char []a, char []b)\n{\n\tArray.Sort(b);\n\tint n = a.Length;\n\tint m = b.Length;\n\tint j = m - 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (j < 0)\n\t\t\tbreak;\n\t\tif (b[j] > a[i])\n\t\t{\n\t\t\ta[i] = b[j];\n\t\t\tj--;\n\t\t}\n\t}\n\treturn String.Join(\"\",a);\n}", "8004": "static string decryptString(string str, int n)\n{\n\tint i = 0, jump = 1;\n\tstring decryptedStr = \"\";\n\twhile (i < n)\n\t{\n\t\tdecryptedStr += str[i];\n\t\ti += jump;\n\t\tjump++;\n\t}\n\treturn decryptedStr;\n}", "8015": "public static void steps(string str, int n)\n{\n\tbool flag = false;\n\tint x = 0;\n\tfor (int i = 0; i < str.Length; i++)\n\t{\n\t\tif (x == 0)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t\tif (x == n - 1)\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t\tfor (int j = 0; j < x; j++)\n\t\t{\n\t\t\tConsole.Write(\"*\");\n\t\t}\n\t\tConsole.Write(str[i] + \"\\n\");\n\t\tif (flag == true)\n\t\t{\n\t\t\tx++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx--;\n\t\t}\n\t}\n}", "8054": "static char bitToBeFlipped(String s)\n{\n\tchar last = s[s.Length - 1];\n\tchar first = s[0];\n\tif (last == first) {\n\t\tif (last == '0') {\n\t\t\treturn '1';\n\t\t}\n\t\telse {\n\t\t\treturn '0';\n\t\t}\n\t}\n\telse if (last != first) {\n\t\treturn last;\n\t}\n\treturn last;\n}", "8061": "static void SieveOfEratosthenes(bool []prime, int p_size)\n\t{\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\t\tfor (int p = 2; p * p <= p_size; p++)\n\t\t{\n\t\t\tif (prime[p])\n\t\t\t{\n\t\t\t\tfor (int i = p * 2; i < p_size; i += p)\n\t\t\t\t{\n\t\t\t\t\tprime[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nstatic void sumProdOfPrimeFreq(char[] s)\n\t{\n\t\tint i;\n\t\tbool[] prime = new bool[s.Length + 1];\n\t\tfor(i=0;i<s.Length + 1;i++){\n\t\t\tprime[i]=true;\n\t\t}\n\t\tSieveOfEratosthenes(prime, s.Length + 1);\n\t\tDictionary<char, int> mp = new Dictionary<char, int>();\n\t\tfor (i = 0 ; i < s.Length; i++)\n\t\t{\n\t\t\tif(mp.ContainsKey(s[i]))\n\t\t\t{\n\t\t\t\tvar val = mp[s[i]];\n\t\t\t\tmp.Remove(s[i]);\n\t\t\t\tmp.Add(s[i], val + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.Add(s[i], 1);\n\t\t\t}\n\t\t}\n\t\tint sum = 0, product = 1;\n\t\tforeach(KeyValuePair<char, int> it in mp)\n\t\t{\n\t\t\tif (prime[it.Value])\n\t\t\t{\n\t\t\t\tsum += it.Value;\n\t\t\t\tproduct *= it.Value;\n\t\t\t}\n\t\t}\n\t\tConsole.Write(\"Sum = \" + sum);\n\t\tConsole.WriteLine(\"\\nProduct = \" + product);\n\t}", "8078": "static int countChar(string str, char x)\n{\n\tint count = 0;\n\tint n = 10;\n\tfor (int i = 0; i < str.Length; i++)\n\t\tif (str[i] == x)\n\t\t\tcount++;\n\tint repetitions = n / str.Length;\n\tcount = count * repetitions;\n\tfor (int i = 0; i < n % str.Length; i++)\n\t{\n\t\tif (str[i] == x)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "8085": "public static Boolean multipleOrFactor(String s1, String s2)\n\t{\n\t\tDictionary<char, int> m1 = new Dictionary<char, int>();\n\t\tDictionary<char, int> m2 = new Dictionary<char, int>();\n\t\tfor (int i = 0; i < s1.Length; i++)\n\t\t{\n\t\t\tif (m1.ContainsKey(s1[i]))\n\t\t\t{\n\t\t\t\tvar x = m1[s1[i]];\n\t\t\t\tm1[s1[i]]= ++x;\n\t\t\t}\n\t\t\telse\n\t\t\t\tm1.Add(s1[i], 1);\n\t\t}\n\t\tfor (int i = 0; i < s2.Length; i++)\n\t\t{\n\t\t\tif (m2.ContainsKey(s2[i]))\n\t\t\t{\n\t\t\t\tvar x = m2[s2[i]];\n\t\t\t\tm2[s2[i]]= ++x;\n\t\t\t}\n\t\t\telse\n\t\t\t\tm2.Add(s2[i], 1);\n\t\t}\n\t\tforeach(KeyValuePair<char, int> entry in m1)\n\t\t{\n\t\t\tif (!m2.ContainsKey(entry.Key))\n\t\t\t\tcontinue;\n\t\t\tif (m2[entry.Key] != 0 &&\n\t\t\t(m2[entry.Key] % entry.Value == 0 entry.Value % m2[entry.Key] == 0))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}", "8099": "static bool checkIfUnequal(int n, int q)\n\t{\n\t\tstring s1 = n.ToString();\n\t\tint[] a = new int[26];\n\t\tfor (int i = 0; i < s1.Length; i++)\n\t\t\ta[s1[i] - '0']++;\n\t\tint prod = n * q;\n\t\tstring s2 = prod.ToString();\n\t\tfor (int i = 0; i < s2.Length; i++)\n\t\t{\n\t\t\tif (a[s2[i] - '0'])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\nstatic int countInRange(int l, int r, int q)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = l; i <= r; i++)\n\t\t{\n\t\t\tif (checkIfUnequal(i, q))\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "8110": "public static bool is_possible(String s)\n\t{\n\t\tint l = s.Length;\n\t\tint one = 0, zero = 0;\n\t\tfor (int i = 0; i < l; i++)\n\t\t{\n\t\t\tif (s[i] == '0')\n\t\t\t\tzero++;\n\t\t\telse\n\t\t\t\tone++;\n\t\t}\n\t\tif (l % 2 == 0)\n\t\t\treturn (one == zero);\n\t\telse\n\t\t\treturn (Math.Abs(one - zero) == 1);\n\t}", "8128": "static void solve(String s)\n\t{\n\t\tDictionary<char, int> m = new Dictionary<char, int>();\n\t\tfor (int i = 0; i < s.Length; i++)\n\t\t{\n\t\t\tif(m.ContainsKey(s[i]))\n\t\t\t{\n\t\t\t\tvar val = m[s[i]];\n\t\t\t\tm.Remove(s[i]);\n\t\t\t\tm.Add(s[i], val + 1);\n\t\t\t}\t\t\n\t\t\telse\n\t\t\t\tm.Add(s[i], 1);\n\t\t}\n\t\tString new_string = \"\";\n\t\tfor (int i = 0; i < s.Length; i++)\n\t\t{\n\t\t\tif (m[s[i]] % 2 == 0)\n\t\t\t\tcontinue;\n\t\t\tnew_string = new_string + s[i];\n\t\t}\n\t\tConsole.WriteLine(new_string);\n\t}", "8167": "static void countFreq(int []arr, int n)\n{\n\tBoolean []visited = new Boolean[n];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (visited[i] == true)\n\t\t\tcontinue;\n\t\tint count = 1;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (arr[i] == arr[j])\n\t\t\t{\n\t\t\t\tvisited[j] = true;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(arr[i] + \" \" + count);\n\t}\n}", "8168": "static void countFreq(int []arr, int n, int limit)\n{\n\tint []count = new int[limit + 1];\n\tfor (int i = 0; i < n; i++)\n\t\tcount[arr[i]]++;\n\tfor (int i = 0; i <= limit; i++)\n\tif (count[i] > 0)\n\t\t\tConsole.WriteLine(i + \" \" + count[i]);\n}", "8169": "static void countFreq(String str)\n{\n\tint []count = new int[limit + 1];\n\tfor (int i = 0; i < str.Length; i++)\n\t\tcount[str[i] - 'A']++;\n\tfor (int i = 0; i <= limit; i++)\n\tif (count[i] > 0)\n\t\tConsole.WriteLine((char)(i + 'A') + \" \" + count[i]);\n}", "8184": "static int __builtin_popcount(int n)\n\t{\n\t\tint count = 0;\n\t\twhile (n > 0) {\n\t\t\tcount += n & 1;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn count;\n\t}\nstatic void countEvenOdd(int []arr, int n, int K)\n\t{\n\t\tint even = 0, odd = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = __builtin_popcount(arr[i]);\n\t\t\tif (x % 2 == 0)\n\t\t\t\teven++;\n\t\t\telse\n\t\t\t\todd++;\n\t\t}\n\t\tint y;\n\t\ty = __builtin_popcount(K);\n\t\tif ((y & 1) != 0) {\n\t\t\tConsole.WriteLine(\"Even = \"+ odd + \", Odd = \" + even);\n\t\t}\n\t\telse {\n\t\t\tConsole.WriteLine(\"Even = \" + even + \", Odd = \" + odd);\n\t\t}\n\t}", "8213": "static bool check(string s, int m)\n{\n\tint l = s.Length;\n\tint c1 = 0;\n\tint c2 = 0;\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tif (s[i] == '0')\n\t\t{\n\t\t\tc2 = 0;\n\t\t\tc1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc1 = 0;\n\t\t\tc2++;\n\t\t}\n\t\tif (c1 == m c2 == m)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "8241": "static bool isDivisible(String str, int k)\n\t{\n\t\tint n = str.Length;\n\t\tint c = 0;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tif (str[n - i - 1] == '0')\t\n\t\t\t\tc++;\n\t\treturn (c == k);\n\t}", "8281": "static int productAtKthLevel(string tree, int k)\n\t{\n\t\tint level = -1;\n\t\tint product = 1;\n\t\tint n = tree.Length;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (tree[i] == '(')\n\t\t\t\tlevel++;\n\t\t\telse if (tree[i] == ')')\n\t\t\t\tlevel--;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (level == k)\n\t\t\t\t\tproduct *= (tree[i] - '0');\n\t\t\t}\n\t\t}\n\t\treturn product;\n\t}", "8296": "static bool isPalindrome(string str)\n\t{\n\t\tint i = 0, j = str.Length - 1;\n\t\twhile (i < j)\n\t\t{\n\t\t\tif (str[i++] != str[j--])\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\nstatic String removePalinWords(string str)\n\t{\n\t\tstring final_str = \"\", word = \"\";\n\t\tstr = str + \" \";\n\t\tint n = str.Length;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (str[i] != ' ')\n\t\t\t\tword = word + str[i];\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!(isPalindrome(word)))\n\t\t\t\t\tfinal_str += word + \" \";\n\t\t\t\tword = \"\";\n\t\t\t}\n\t\t}\n\t\treturn final_str;\n\t}", "8301": "static int findSubSequence(string s, int num)\n\t{\n\t\tint res = 0;\n\t\tint i = 0;\n\t\twhile (num > 0) {\n\t\t\tif ((num & 1) == 1)\n\t\t\t\tres += s[i] - '0';\n\t\t\ti++;\n\t\t\tnum = num >> 1;\n\t\t}\n\t\treturn res;\n\t}\nstatic int combinedSum(string s)\n\t{\n\t\tint n = s.Length;\n\t\tint c_sum = 0;\n\t\tint range = (1 << n) - 1;\n\t\tfor (int i = 0; i <= range; i++)\n\t\t\tc_sum += findSubSequence(s, i);\n\t\treturn c_sum;\n\t}", "8304": "static void findSubsequence(string str, int k)\n\t{\n\t\tint []a = new int[MAX_CHAR];\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t\ta[str[i] - 'a']++;\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t\tif (a[str[i] - 'a'] >= k)\n\t\t\t\tConsole.Write(str[i]);\n\t}", "8310": "static void findDuplciates(string []a, int n, int m)\n\t{\n\t\tbool [,]isPresent = new bool[n, m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[i][j] == a[k][j] && i != k)\n\t\t\t\t\t{\n\t\t\t\t\t\tisPresent[i, j] = true;\n\t\t\t\t\t\tisPresent[k, j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < m; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[i][j] == a[i][k] && j != k)\n\t\t\t\t\t{\n\t\t\t\t\t\tisPresent[i, j] = true;\n\t\t\t\t\t\tisPresent[i, k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tif (!isPresent[i, j])\n\t\t\t\t\tConsole.Write(a[i][j]);\n\t}", "8315": "static string convert(string str)\n\t{\n\t\tstring w = \"\", z = \"\";\n\t\tstr = str.ToUpper() + \" \";\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t{\n\t\t\tchar ch = str[i];\n\t\t\tif (ch != ' ')\n\t\t\t\tw = w + ch;\n\t\t\telse\n\t\t\t{\n\t\t\t\tz = z + (Char.ToLower(w[0])) +\n\t\t\t\t\t\tw.Substring(1) + \" \";\n\t\t\t\tw = \"\";\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}", "8316": "static String convert(String s)\n\t{\n\t\tint n = s.Length;\n\t\tString s1 = \"\";\n\t\ts1 = s1 + Char.ToLower(s[0]);\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (s[i] == ' ' && i < n)\n\t\t\t{\n\t\t\t\ts1 = s1 + \" \" + Char.ToLower\n\t\t\t\t\t\t\t\t(s[i + 1]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\ts1= s1 + Char.ToUpper(s[i]);\n\t\t}\n\t\treturn s1;\n\t}", "8317": "public static String change_case(string a)\n\t{\n\t\tstring temp = \"\";\n\t\tint l = a.Length;\n\t\tfor(int i = 0 ; i < l ; i++)\n\t\t{\n\t\t\tchar ch=a[i];\n\t\t\tif(ch >= 'a' &&ch <= 'z')\n\t\t\tch = (char)(65 + (int)(ch - 'a'));\n\t\t\telse if(ch >= 'A' &&ch <= 'Z')\n\t\t\tch = (char)(97 +\n\t\t\t\t(int)(ch - 'A'));\n\t\t\ttemp += ch;\n\t\t}\n\t\treturn temp;\n\t}\npublic static String delete_vowels(String a)\n\t{\n\t\tString temp = \"\";\n\t\tint l = a.Length;\n\t\tfor(int i = 0 ; i < l ; i++)\n\t\t{\n\t\t\tchar ch = a[i];\n\t\t\tif(ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' && ch != 'A' && ch != 'E' && ch != 'O' && ch != 'U'&&ch != 'I')\n\t\t\t\ttemp += ch;\n\t\t}\n\t\treturn temp;\n\t}\npublic static String insert_hash(String a)\n\t{\n\t\tString temp = \"\";\n\t\tint l = a.Length;\n\t\tchar hash = '#';\n\t\tfor(int i = 0 ; i < l ; i++)\n\t\t{\n\t\t\tchar ch=a[i];\n\t\t\tif((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= 'A' && ch <= 'Z'))\n\t\t\t\ttemp = temp + hash + ch;\n\t\t\telse\n\t\t\t\ttemp = temp + ch;\n\t\t}\n\t\treturn temp;\n\t}\npublic static void transformString(string a)\n\t{\n\t\tstring b = delete_vowels(a);\n\t\tstring c = change_case(b);\n\t\tstring d = insert_hash(c);\n\t\tConsole.WriteLine(d);\n\t}", "8366": "static bool isVowel(char c) {\n\t\treturn (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');\n\t}\nstatic String encryptString(String s, int n, int k) {\n\t\tint countVowels = 0;\n\t\tint countConsonants = 0;\n\t\tString ans = \"\";\n\t\tfor (int l = 0; l <= n - k; l++) {\n\t\t\tcountVowels = 0;\n\t\t\tcountConsonants = 0;\n\t\t\tfor (int r = l; r <= l + k - 1; r++) {\n\t\t\t\tif (isVowel(s[r]) == true) {\n\t\t\t\t\tcountVowels++;\n\t\t\t\t} else {\n\t\t\t\t\tcountConsonants++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += Convert.ToString(countVowels * countConsonants);\n\t\t}\n\t\treturn ans;\n\t}", "8367": "static bool isVowel(char c)\n\t{\n\t\treturn (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');\n\t}\nstatic String encryptString(char[] s, int n, int k)\n\t{\n\t\tint[] cv = new int[n];\n\t\tint[] cc = new int[n];\n\t\tif (isVowel(s[0]))\n\t\t\tcv[0] = 1;\n\t\telse\n\t\t\tcc[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tcv[i] = cv[i - 1] +\n\t\t\t\t(isVowel(s[i]) == true ? 1 : 0);\n\t\t\tcc[i] = cc[i - 1] +\n\t\t\t\t(isVowel(s[i]) == true ? 0 : 1);\n\t\t}\n\t\tString ans = \"\";\n\t\tint prod = 0;\n\t\tprod = cc[k - 1] * cv[k - 1];\n\t\tans += String.Join(\"\", prod);\n\t\tfor (int i = k; i < s.Length; i++)\n\t\t{\n\t\t\tprod = (cc[i] - cc[i - k]) *\n\t\t\t\t(cv[i] - cv[i - k]);\n\t\t\tans += String.Join(\"\", prod);\n\t\t}\n\t\treturn ans;\n\t}", "8374": "static int countOccurrences(string str, string word)\n{\n\tstring[] a = str.Split(' ');\n\tint count = 0;\n\tfor (int i = 0; i < a.Length; i++)\n\t{\n\tif (word.Equals(a[i]))\n\t\tcount++;\n\t}\n\treturn count;\n}", "8396": "static bool isValidISBN(string isbn)\n\t{\n\t\tint n = isbn.Length;\n\t\tif (n != 10)\n\t\t\treturn false;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 9; i++)\n\t\t{\n\t\t\tint digit = isbn[i] - '0';\n\t\t\tif (0 > digit 9 < digit)\n\t\t\t\treturn false;\n\t\t\tsum += (digit * (10 - i));\n\t\t}\n\t\tchar last = isbn[9];\n\t\tif (last != 'X' && (last < '0' last > '9'))\n\t\t\treturn false;\n\t\tsum += ((last == 'X') ? 10 :\n\t\t\t\t\t\t(last - '0'));\n\t\treturn (sum % 11 == 0);\n\t}", "8460": "static bool canFormPalindrome(string str)\n\t{\n\t\tint[] count = new int[NO_OF_CHARS];\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t\tcount[str[i]]++;\n\t\tint odd = 0;\n\t\tfor (int i = 0; i < NO_OF_CHARS; i++) {\n\t\t\tif ((count[i] & 1) != 0)\n\t\t\t\todd++;\n\t\t\tif (odd > 1)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}", "8490": "static void permute(String input)\n\t{\n\t\tint n = input.Length;\n\t\tint max = 1 << n;\n\t\tinput = input.ToLower();\n\t\tfor(int i = 0;i < max; i++)\n\t\t{\n\t\t\tchar []combination = input.ToCharArray();\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif(((i >> j) & 1) == 1)\n\t\t\t\t\tcombination[j] = (char) (combination[j] - 32);\n\t\t\t}\n\t\t\tConsole.Write(combination);\n\t\t\tConsole.Write(\" \");\n\t\t}\n\t}", "8501": "static bool isNumber(string s)\n\t{\n\t\tfor (int i = 0; i < s.Length; i++)\n\t\t\tif (char.IsDigit(s[i]) == false)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "8506": "static public void printString(string str, char ch, int count)\n\t{\n\t\tint occ = 0, i;\n\t\tif (count == 0) {\n\t\t\tConsole.WriteLine(str);\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 0; i < str.Length; i++)\n\t\t{\n\t\t\tif (str[i] == ch)\n\t\t\t\tocc++;\n\t\t\tif (occ == count)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < str.Length - 1)\n\t\t\tConsole.WriteLine(str.Substring(i + 1));\n\t\telse\n\t\t\tConsole.WriteLine(\"Empty string\");\n\t}", "8527": "static bool isVowel(char c)\n\t{\n\t\treturn (c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U');\n\t}\nstatic String reverseVowel(String str1)\n\t{\n\t\tint j = 0;\n\t\tchar[] str = str1.ToCharArray();\n\t\tString vowel = \"\";\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t{\n\t\t\tif (isVowel(str[i]))\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tvowel += str[i];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t{\n\t\t\tif (isVowel(str[i]))\n\t\t\t{\n\t\t\t\tstr[i] = vowel[--j];\n\t\t\t}\n\t\t}\n\t\treturn String.Join(\"\",str);\n\t}", "8528": "static Boolean isVowel(char c)\n\t{\n\t\treturn (c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U');\n\t}\nstatic String reverseVowel(String str)\n{\n\tint i = 0;\n\tint j = str.Length-1;\n\tchar[] str1 = str.ToCharArray();\n\twhile (i < j)\n\t{\n\t\tif (!isVowel(str1[i]))\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isVowel(str1[j]))\n\t\t{\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\t\tchar t = str1[i];\n\t\tstr1[i]= str1[j];\n\t\tstr1[j]= t;\n\t\ti++;\n\t\tj--;\n\t}\n\tString str2 = String.Join(\"\",str1);\n\treturn str2;\n}", "8538": "static String firstLetterWord(String str)\n\t{\n\t\tString result = \"\";\n\t\tbool v = true;\n\t\tfor (int i = 0; i < str.Length; i++)\n\t\t{\n\t\t\tif (str[i] == ' ')\n\t\t\t{\n\t\t\t\tv = true;\n\t\t\t}\n\t\t\telse if (str[i] != ' ' && v == true)\n\t\t\t{\n\t\t\t\tresult += (str[i]);\n\t\t\t\tv = false;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "8539": "public static String processWords(String input)\n{\n\t\tString []s = input.Split(' ');\n\t\tforeach(String values in s)\n\t\t{\n\t\t\tcharBuffer.Append(values[0]);\n\t\t}\n\treturn charBuffer.ToString();\n}", "8577": "static char largest_alphabet(String a, int n)\n\t{\n\t\tchar max = 'A';\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[i] > max)\n\t\t\t\tmax = a[i];\n\t\treturn max;\n\t}\nstatic char smallest_alphabet(String a, int n)\n\t{\n\t\tchar min = 'z';\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\tif (a[i] < min)\n\t\t\t\tmin = a[i];\n\t\treturn min;\n\t}", "8615": "static String maximumPalinUsingKChanges(String str, int k)\n {\n\tchar[] palin = str.ToCharArray();\n\tString ans = \"\";\n\tint l = 0;\n\tint r = str.Length - 1;\n\twhile (l < r) {\n\tif (str[l] != str[r]) {\n\t\tpalin[l] = palin[r]\n\t\t= (char)Math.Max(str[l], str[r]);\n\t\tk--;\n\t}\n\tl++;\n\tr--;\n\t}\n\tif (k < 0) {\n\treturn \"Not possible\";\n\t}\n\tl = 0;\n\tr = str.Length - 1;\n\twhile (l <= r) {\n\tif (l == r) {\n\t\tif (k > 0) {\n\t\tpalin[l] = '9';\n\t\t}\n\t}\n\tif (palin[l] < '9') {\n\t\tif (k >= 2 && palin[l] == str[l] && palin[r] == str[r]) {\n\t\tk -= 2;\n\t\tpalin[l] = palin[r] = '9';\n\t\t}\n\t\telse if (k >= 1\n\t\t\t\t&& (palin[l] != str[l] palin[r] != str[r])) {\n\t\tk--;\n\t\tpalin[l] = palin[r] = '9';\n\t\t}\n\t}\n\tl++;\n\tr--;\n\t}\n\tfor (int i = 0; i < palin.Length; i++)\n\tans += palin[i];\n\treturn ans;\n }", "8636": "static string toString(char[] a) {\n\tstring String = new string(a);\n\treturn String;\n }\nstatic void generate(int k, char[] ch, int n) {\n\tif (n == k) {\n\tConsole.Write(toString(ch)+\" \");\n\treturn;\n\t}\n\tif (ch[n - 1] == '0') {\n\tch[n] = '0';\n\tgenerate(k, ch, n + 1);\n\tch[n] = '1';\n\tgenerate(k, ch, n + 1);\n\t}\n\tif (ch[n - 1] == '1') {\n\tch[n] = '0';\n\tgenerate(k, ch, n + 1);\n\t}\n }\nstatic void fun(int k)\n {\n\tif (k <= 0)\n\t{\n\treturn;\n\t}\n\tchar[] ch = new char[k];\n\tch[0] = '0';\n\tgenerate(k, ch, 1);\n\tch[0] = '1';\n\tgenerate(k, ch, 1);\n }", "8702": "static int countTriplets(int []A)\n{\n\tint cnt = 0;\n\tDictionary<int,int> tuples = new Dictionary<int,int>();\n\tforeach (int a in A)\n\t\tforeach (int b in A)\n\t\t{\n\t\t\tif(tuples.ContainsKey(a & b))\n\t\t\t\ttuples[a & b] = tuples[a & b] + 1;\n\t\t\telse\n\t\t\t\ttuples.Add(a & b, 1);\n\t\t}\n\tforeach (int a in A)\n\t\tforeach (KeyValuePair<int, int> t in tuples)\n\t\t\tif ((t.Key & a) == 0)\n\t\t\t\tcnt += t.Value;\n\treturn cnt;\n}", "8705": "static bool isPalindrome(String str)\n\t{\n\t\tint l = 0;\n\t\tint h = str.Length - 1;\n\t\twhile (h > l)\n\t\t\tif (str[l++] != str[h--])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nstatic int minRemovals(String str)\n\t{\n\t\tif (str[0] == '')\n\t\t\treturn 0;\n\t\tif (isPalindrome(str))\n\t\t\treturn 1;\n\t\treturn 2;\n\t}", "8787": "", "8788": "public static String[] RevString(String[] s, int l)\n{\n\tif (l % 2 == 0)\n\t{\n\t\tint j = l / 2;\n\t\twhile (j <= l - 1)\n\t\t{\n\t\t\tString temp;\n\t\t\ttemp = s[l - j - 1];\n\t\t\ts[l - j - 1] = s[j];\n\t\t\ts[j] = temp;\n\t\t\tj += 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint j = (l / 2) + 1;\n\t\twhile (j <= l - 1)\n\t\t{\n\t\t\tString temp;\n\t\t\ttemp = s[l - j - 1];\n\t\t\ts[l - j - 1] = s[j];\n\t\t\ts[j] = temp;\n\t\t\tj += 1;\n\t\t}\n\t}\n\treturn s;\n}", "8795": "static void reverse(String str)\n\t{\n\t\tif ((str == null) || (str.Length <= 1))\n\t\tConsole.Write(str);\n\t\telse\n\t\t{\n\t\t\tConsole.Write(str[str.Length-1]);\n\t\t\treverse(str.Substring(0,(str.Length-1)));\n\t\t}\n\t}", "8823": "public static double getProbability(int[] balls)\n\t{\n\t\tfactorial(10);\n\t\tbox2 = balls.Length;\n\t\tint K = 0;\n\t\tfor (int i = 0; i < balls.Length; i++)\n\t\t\tK += balls[i];\n\t\tif (K % 2 == 1)\n\t\t\treturn 0;\n\t\tlong all = comb(K, K / 2);\n\t\tlong validPermutationss = validPermutations((K / 2), balls, 0, 0);\n\t\treturn (double)validPermutationss / all;\n\t}\nstatic long validPermutations(int n, int[] balls, int usedBalls, int i)\n\t{\n\t\tif (usedBalls == n)\n\t\t{\n\t\t\treturn box1 == box2 ? 1 : 0;\n\t\t}\n\t\tif (i >= balls.Length)\n\t\t\treturn 0;\n\t\tlong res = validPermutations(n, balls, usedBalls, i + 1);\n\t\tbox1++;\n\t\tfor (int j = 1; j <= balls[i]; j++)\n\t\t{\n\t\t\tif (j == balls[i])\n\t\t\t\tbox2--;\n\t\t\tlong combinations = comb(balls[i], j);\n\t\t\tres += combinations * validPermutations(n, balls, usedBalls + j, i + 1);\n\t\t}\n\t\tbox1--;\n\t\tbox2++;\n\t\treturn res;\n\t}\nstatic void factorial(int N)\n\t{\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= N; i++)\n\t\t\tfact[i] = fact[i - 1] * i;\n\t}\nstatic long comb(int n, int r)\n\t{\n\t\tlong res = fact[n] / fact[r];\n\t\tres /= fact[n - r];\n\t\treturn res;\n\t}", "8840": "static void parity(List<int> even, List<int> odd, List<int> v, int i) \n{ \n\tif (i == v.Count even.Count == 0 && odd.Count == 0) \n\t{\n\t\tint count = 0; \n\t\tfor(int j = 0; j < v.Count - 1; j++)\n\t\t{\n\t\t\tif (v[j] % 2 != v[j + 1] % 2) \n\t\t\t\tcount++; \n\t\t} \n\t\tif (count < min) \n\t\t\tmin = count; \n\t\treturn; \n\t} \n\tif (v[i] != -1) \n\t\tparity(even, odd, v, i + 1); \n\telse \n\t{\n\t\tif (even.Count != 0)\n\t\t{ \n\t\t\tint x = even[even.Count - 1]; \n\t\t\teven.RemoveAt(even.Count - 1); \n\t\t\tv[i] = x; \n\t\t\tparity(even, odd, v, i + 1); \n\t\t\teven.Add(x); \n\t\t} \n\t\tif (odd.Count != 0)\n\t\t{ \n\t\t\tint x = odd[odd.Count - 1]; \n\t\t\todd.RemoveAt(odd.Count - 1); \n\t\t\tv[i] = x; \n\t\t\tparity(even, odd, v, i + 1); \n\t\t\todd.Add(x); \n\t\t} \n\t} \n}\nstatic void minDiffParity(List<int> v, int n) \n{ \n\tList<int> even = new List<int>();\n\tList<int> odd = new List<int>();\n\tDictionary<int, \n\t\t\tint> m = new Dictionary<int, \n\t\t\t\t\t\t\t\t\tint>(); \n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif (m.ContainsKey(i))\n\t\t{\n\t\t\tm[i] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm.Add(i, 1);\n\t\t}\n\t}\n\tfor(int i = 0; i < v.Count; i++)\n\t{ \n\t\tif (v[i] != -1) \n\t\t\tm.Remove(v[i]); \n\t} \n\tforeach(KeyValuePair<int, int> i in m)\n\t{\t\n\t\tif (i.Key % 2 == 0) \n\t\t{\n\t\t\teven.Add(i.Key); \n\t\t}\n\t\telse\n\t\t{\n\t\t\todd.Add(i.Key);\n\t\t}\n\t} \n\tmin = 1000;\n\tparity(even, odd, v, 0); \n\tConsole.WriteLine(min); \n}", "8855": "static void dfs(int u, int count)\n\t{\n\t\tvisited[u] = true;\n\t\tint temp = 0;\n\t\tfor (int i = 0; i < adjacent[u].Count; i++)\n\t\t{\n\t\t\tif (!visited[adjacent[u][i]])\n\t\t\t{\n\t\t\t\ttemp++;\n\t\t\t\tdfs(adjacent[u][i], count + 1);\n\t\t\t}\n\t\t}\n\t\tif (temp == 0)\n\t\t{\n\t\t\tif (maxi < count)\n\t\t\t{\n\t\t\t\tmaxi = count;\n\t\t\t\tstartnode = u;\n\t\t\t}\n\t\t}\n\t}\nstatic void dfs1(int u, int count)\n\t{\n\t\tvisited[u] = true;\n\t\tint temp = 0;\n\t\tfor (int i = 0; i < adjacent[u].Count; i++)\n\t\t{\n\t\t\tif (!visited[adjacent[u][i]])\n\t\t\t{\n\t\t\t\ttemp++;\n\t\t\t\tparent[adjacent[u][i]] = u;\n\t\t\t\tdfs1(adjacent[u][i], count + 1);\n\t\t\t}\n\t\t}\n\t\tif (temp == 0)\n\t\t{\n\t\t\tif (maxi < count)\n\t\t\t{\n\t\t\t\tmaxi = count;\n\t\t\t\tendnode = u;\n\t\t\t}\n\t\t}\n\t}\nstatic void dfs2(int u, int count)\n\t{\n\t\tvisited[u] = true;\n\t\tint temp = 0;\n\t\tfor (int i = 0; i < adjacent[u].Count; i++)\n\t\t{\n\t\t\tif (!visited[adjacent[u][i]] && !vis[adjacent[u][i]])\n\t\t\t{\n\t\t\t\ttemp++;\n\t\t\t\tdfs2(adjacent[u][i], count + 1);\n\t\t\t}\n\t\t}\n\t\tif (temp == 0)\n\t\t{\n\t\t\tif (maxi < count)\n\t\t\t{\n\t\t\t\tmaxi = count;\n\t\t\t\tthirdnode = u;\n\t\t\t}\n\t\t}\n\t}\nstatic void findNodes()\n\t{\n\t\tdfs(1, 0);\n\t\tfor (int i = 0; i <= N; i++)\n\t\t\tvisited[i] = false;\n\t\tmaxi = -1;\n\t\tdfs1(startnode, 0);\n\t\tfor (int i = 0; i <= N; i++)\n\t\t\tvisited[i] = false;\n\t\tint x = endnode;\n\t\tvis[startnode] = true;\n\t\twhile (x != startnode)\n\t\t{\n\t\t\tvis[x] = true;\n\t\t\tx = parent[x];\n\t\t}\n\t\tmaxi = -1;\n\t\tfor (int i = 1; i <= N; i++)\n\t\t{\n\t\t\tif (vis[i])\n\t\t\t\tdfs2(i, 0);\n\t\t}\n\t}", "8858": "static void dfs(int i, int j, int[,] grid, bool[,] vis, int z, int z_count)\n {\n\tint n = grid.GetLength(0), m = grid.GetLength(1);\n\tvis[i,j] = true;\n\tif (grid[i,j] == 0)\n\tz++;\n\tif (grid[i,j] == 2)\n\t{\n\tif (z == z_count)\n\t\tans++;\n\tvis[i,j] = false;\n\treturn;\n\t}\n\tif (i >= 1 && !vis[i - 1,j] && grid[i - 1,j] != -1)\n\tdfs(i - 1, j, grid, vis, z, z_count);\n\tif (i < n - 1 && !vis[i + 1,j] && grid[i + 1,j] != -1)\n\tdfs(i + 1, j, grid, vis, z, z_count);\n\tif (j >= 1 && !vis[i,j - 1] && grid[i,j - 1] != -1)\n\tdfs(i, j - 1, grid, vis, z, z_count);\n\tif (j < m - 1 && !vis[i,j + 1] && grid[i,j + 1] != -1)\n\tdfs(i, j + 1, grid, vis, z, z_count);\n\tvis[i,j] = false;\n }\nstatic int uniquePaths(int[,] grid)\n {\n\tint n = grid.GetLength(0), m = grid.GetLength(1);\n\tbool[,] vis = new bool[n,m];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tvis[i,j] = false;\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\tfor (int j = 0; j < m; ++j)\n\t{\n\t\tif (grid[i,j] == 0)\n\t\tz_count++;\n\t\telse if (grid[i,j] == 1)\n\t\t{\n\t\tx = i;\n\t\ty = j;\n\t\t}\n\t}\n\t}\n\tdfs(x, y, grid, vis, 0, z_count);\n\treturn ans;\n }", "8907": "static int numPairs(int []a, int n)\n{\n\tint ans, i, index;\n\tans = 0;\n\tfor (i = 0; i < n; i++)\n\t\ta[i] = Math.Abs(a[i]);\n\tArray.Sort(a);\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tindex = 2;\n\t\tans += index - i - 1;\n\t}\n\treturn ans;\n}", "8939": "static int power(int x, int y, int p)\n\t{\n\t\tint res = 1;\n\t\tx = x % p;\n\t\twhile (y > 0)\n\t\t{\n\t\t\tif (y % 2 == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\ty = y >> 1;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\nstatic int findModuloByM(int X, int N, int M)\n\t{\n\t\tif (N < 6)\n\t\t{\n\t\t\tstring temp=\"\";\n\t\t\tfor(int i = 0; i< N ; i++)\n\t\t\t\ttemp = temp + (char)(X + 48);\n\t\t\tint res = Convert.ToInt32(temp) % M;\n\t\t\treturn res;\n\t\t}\n\t\tif (N % 2 == 0)\n\t\t{\n\t\t\tint half = findModuloByM(X, N / 2, M) % M;\n\t\t\tint res = (half * power(10, N / 2, M) + half)\n\t\t\t\t\t% M;\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint half = findModuloByM(X, N / 2, M) % M;\n\t\t\tint res = (half * power(10, N / 2 + 1, M) + half * 10 + X)\n\t\t\t\t\t% M;\n\t\t\treturn res;\n\t\t}\n\t}", "9007": "static bool check(circle []C)\n{\n\tdouble C1C2 = Math.Sqrt(\n\t\t(C[1].x - C[0].x) * (C[1].x - C[0].x) +\n\t\t(C[1].y - C[0].y) * (C[1].y - C[0].y));\n\tbool flag = false;\n\tif (C1C2 < (C[0].r + C[1].r))\n\t{\n\t\tif ((C[0].x + C[1].x) == 2 * C[2].x &&\n\t\t\t(C[0].y + C[1].y) == 2 * C[2].y)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t}\n\treturn flag;\n}\nstatic bool IsFairTriplet(circle []c)\n{\n\tbool f = false;\n\tf |= check(c);\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tswap(c[0], c[2]);\n\t\tf |= check(c);\n\t}\n\treturn f;\n}\nstatic void swap(circle circle1, circle circle2)\n{\n\tcircle temp = circle1;\n\tcircle1 = circle2;\n\tcircle2 = temp;\n}", "9009": "static double eccHyperbola(double A, double B)\n{\n\tdouble r = (double)B * B / A * A;\n\tr += 1;\n\treturn Math.Sqrt(r);\n}", "9012": "static float calculateArea(float A, float B, float C, float D)\n{\n\tfloat S = (A + B + C + D) / 2;\n\tfloat area = (float)Math.Sqrt((S - A) * (S - B) *\n\t\t\t\t\t\t\t\t(S - C) * (S - D));\n\treturn area;\n}", "9015": "static void triangleArea(int a, int b)\n{\n\tdouble ratio = (double)b / a;\n\tConsole.WriteLine(ratio);\n}", "9021": "static float distance(int m, int n, int p, int q)\n{\n\treturn (float)Math.Sqrt(Math.Pow(n - m, 2) +\n\t\t\t\t\t\t\tMath.Pow(q - p, 2) * 1.0);\n}\nstatic void Excenters(int x1, int y1, int x2, int y2, int x3, int y3)\n{\n\tfloat a = distance(x2, x3, y2, y3);\n\tfloat b = distance(x3, x1, y3, y1);\n\tfloat c = distance(x1, x2, y1, y2);\n\tpair[] excenter = new pair[4];\n\texcenter[1] = new pair((-(a * x1) + (b * x2) +\n\t\t\t\t\t\t\t(c * x3)) / (-a + b + c),\n\t\t\t\t\t\t(-(a * y1) + (b * y2) +\n\t\t\t\t\t\t\t(c * y3)) / (-a + b + c));\n\texcenter[2] = new pair(((a * x1) - (b * x2) +\n\t\t\t\t\t\t\t(c * x3)) / (a - b + c),\n\t\t\t\t\t\t((a * y1) - (b * y2) +\n\t\t\t\t\t\t\t(c * y3)) / (a - b + c));\n\texcenter[3] = new pair(((a * x1) + (b * x2) -\n\t\t\t\t\t\t\t(c * x3)) / (a + b - c),\n\t\t\t\t\t\t((a * y1) + (b * y2) -\n\t\t\t\t\t\t\t(c * y3)) / (a + b - c));\n\tfor (int i = 1; i <= 3; i++)\n\t{\n\t\tConsole.WriteLine((int)excenter[i].first + \" \" +\n\t\t\t\t\t\t(int)excenter[i].second);\n\t}\n}", "9035": "static void findHeight(float p1, float p2, float b, float c)\n{\n\tfloat a = Math.Max(p1, p2) - Math.Min(p1, p2);\n\tfloat s = (a + b + c) / 2;\n\tfloat area = (int)Math.Sqrt(s * (s - a)\n\t\t\t\t\t* (s - b) * (s - c));\n\tfloat height = (area * 2) / a;\n\tConsole.Write(\"Height is: \" + height);\n}", "9070": "static int areaOfSquare(int S)\n{\n\tint area = S * S;\n\treturn area;\n}", "9079": "static int maxPointOfIntersection(int x, int y)\n{\n\tint k = y * (y - 1) / 2;\n\tk = k + x * (2 * y + x - 1);\n\treturn k;\n}", "9113": "static int Icositetragonal_num(int n)\n{\n\treturn (22 * n * n - 20 * n) / 2;\n}", "9114": "static int Icosihenagonal_num(int n)\n{\n\treturn (19 * n * n - 17 * n) / 2;\n}", "9119": "static double area_of_circle(int m, int n) \n{ \n\tint square_of_radius = ( m * n ) / 4; \n\tdouble area = ( 3.141 * square_of_radius ); \n\treturn area; \n}", "9129": "static double area(int R)\n\t{\n\t\tdouble Base = 1.732 * R;\n\t\tdouble height = (1.5) * R;\n\t\tdouble area = 0.5 * Base * height;\n\t\treturn area;\n\t}", "9130": "static float circlearea(float R)\n\t{\n\t\tif (R < 0)\n\t\t\treturn -1;\n\t\tfloat a = (float)((3.14 * R * R) / 4);\n\t\treturn a;\n\t}", "9137": "static int countPairs(int []P, int []Q, int N, int M)\n\t{\n\t\tint []A = new int[2];\n\t\tint []B = new int[2];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tA[P[i] % 2]++;\n\t\tfor (int i = 0; i < M; i++)\n\t\t\tB[Q[i] % 2]++;\n\t\treturn (A[0] * B[0] + A[1] * B[1]);\n\t}", "9142": "static double[] find_Centroid(double [,]v) \n\t{ \n\t\tdouble []ans = new double[2]; \n\t\tint n = v.GetLength(0); \n\t\tdouble signedArea = 0; \n\t\tfor (int i = 0; i < n; i++)\n\t\t{ \n\t\t\tdouble x0 = v[i, 0], y0 = v[i, 1]; \n\t\t\tdouble x1 = v[(i + 1) % n, 0], \n\t\t\t\t\ty1 = v[(i + 1) % n, 1]; \n\t\t\tdouble A = (x0 * y1) - (x1 * y0); \n\t\t\tsignedArea += A; \n\t\t\tans[0] += (x0 + x1) * A; \n\t\t\tans[1] += (y0 + y1) * A; \n\t\t} \n\t\tsignedArea *= 0.5; \n\t\tans[0] = (ans[0]) / (6 * signedArea); \n\t\tans[1]= (ans[1]) / (6 * signedArea); \n\t\treturn ans; \n\t}", "9147": "static int countIntersections(int n)\n\t{\n\t\treturn n * (n - 1) / 2;\n\t}", "9169": "static void newvol(double x)\n{\n\tConsole.WriteLine( \"percentage increase in the\"\n\t\t+ \" volume of the sphere is \"\n\t\t+( Math.Pow(x, 3) / 10000 + 3 * x\n\t\t\t\t+ (3 * Math.Pow(x, 2)) / 100) + \"%\");\n}", "9177": "static double areaOfTriangle(float d)\n\t{\n\t\tfloat c = (float) (1.618 * d);\n\t\tfloat s = (d + c + c) / 2;\n\t\tdouble area = Math.Sqrt(s * (s - c)\n\t\t\t\t* (s - c) * (s - d));\n\t\treturn 5 * area;\n\t}\nstatic double areaOfRegPentagon(float d)\n\t{\n\t\tdouble cal = 4 * Math.Tan(PI / 5);\n\t\tdouble area = (5 * d * d) / cal;\n\t\treturn area;\n\t}\nstatic double areaOfPentagram(float d)\n\t{\n\t\treturn areaOfRegPentagon(d)\n\t\t\t\t+ areaOfTriangle(d);\n\t}", "9181": "static void anglequichord(int z)\n\t{\n\t\tConsole.WriteLine(\"The angle is \" + z + \" degrees\");\n\t}", "9187": "static void circle(int x1, int y1, int x2, int y2, int r1, int r2) \n\t{ \n\t\tint distSq = (int)Math.Sqrt(((x1 - x2) \n\t\t\t\t\t\t* (x1 - x2)) \n\t\t\t\t\t\t+ ((y1 - y2) \n\t\t\t\t\t\t\t* (y1 - y2))); \n\t\tif (distSq + r2 == r1) \n\t\t{\n\t\t\tConsole.WriteLine(\"The smaller circle lies completely\" + \" inside the bigger circle with \" + \"touching each other \" + \"at a point of circumference. \") ;\n\t\t}\n\t\telse if (distSq + r2 < r1) \n\t\t{\n\t\t\tConsole.WriteLine(\"The smaller circle lies completely\" + \" inside the bigger circle without\" + \" touching each other \" + \"at a point of circumference.\") ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConsole.WriteLine(\"The smaller does not lies inside\" + \" the bigger circle completely.\") ;\n\t\t}\n\t}", "9195": "static void lengtang(double r1, double r2, double d)\n\t{\n\t\tConsole.WriteLine(\"The length of the direct\"\n\t\t\t\t+ \" common tangent is \"\n\t\t\t\t+ (Math.Sqrt(Math.Pow(d, 2) -\n\t\t\t\t\tMath.Pow((r1 - r2), 2))));\n\t}", "9196": "static void rad(double d, double h)\n{\n\tConsole.WriteLine( \"The radius of the circle is \"\n\t\t+ ((d * d) / (8 * h) + h / 2));\n}", "9197": "static void shortdis(double r, double d)\n\t{\n\t\tConsole.WriteLine(\"The shortest distance \"\n\t\t\t+ \"from the chord to centre \"\n\t\t\t+ (Math.Sqrt((r * r) - ((d * d) / 4))));\n\t}", "9200": "static void lengtang(double r1, double r2, double d)\n\t{\n\t\tConsole.WriteLine(\"The length of the direct\"\n\t\t\t+\" common tangent is \"\n\t\t\t+(Math.Sqrt(Math.Pow(d, 2) -\n\t\t\tMath.Pow((r1 - r2), 2))));\n\t}", "9201": "static void length_of_chord(double r, double x)\n\t{\n\t\tConsole.WriteLine(\"The length of the chord\" +\n\t\t\t\t\t\t\" of the circle is \" +\n\t\t\t\t\t\t2 * r * Math.Sin(x * (3.14 / 180)));\n\t}", "9232": "static double square(double a)\n\t{\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tdouble x = 0.464 * a;\n\t\treturn x;\n\t}", "9238": "static double polyapothem(double n, double a)\n{\n\tif (a < 0 && n < 0)\n\t\treturn -1;\n\treturn (a / (2 * Math.Tan((180 / n) * 3.14159 / 180)));\n}", "9240": "static double polyarea(double n, double r)\n\t{\n\t\tif (r < 0 && n < 0)\n\t\t\treturn -1;\n\t\tdouble A = ((r * r * n) * Math.Sin((360 / n) * 3.14159 / 180)) / 2;\n\t\treturn A;\n\t}", "9241": "static float polyarea(float n, float a)\n{\n\tif (a < 0 && n < 0)\n\t\treturn -1;\n\tfloat A = (a * a * n) / (float)(4 * Math.Tan((180 / n) * 3.14159 / 180));\n\treturn A;\n}", "9247": "static double hexDiagonal(float a) \n\t{ \n\t\tif (a < 0) \n\t\t\treturn -1; \n\t\tdouble d = (double)1.73 * a; \n\t\treturn d; \n\t}", "9250": "static double calculateSide(double n, double r)\n\t{\n\t\tdouble theta, theta_in_radians;\n\t\ttheta = 360 / n;\n\t\ttheta_in_radians = theta * 3.14 / 180;\n\t\treturn Math.Round(2 * r * Math.Sin(theta_in_radians / 2),4);\n\t}", "9257": "static float cyl(float r, float R, float h)\n{\n\tif (h < 0 && r < 0 && R < 0)\n\t\treturn -1;\n\tfloat r1 = r;\n\tfloat h1 = h;\n\tfloat V = (float)(3.14 * Math.Pow(r1, 2) * h1);\n\treturn V;\n}", "9258": "static float findVolume(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat r = a / 2;\n\tfloat h = a;\n\tfloat V = (float)(3.14 * Math.Pow(r, 2) * h);\n\treturn V;\n}", "9290": "static double Perimeter(double s, int n)\n{\n\tdouble perimeter = 1;\n\tperimeter = n * s;\n\treturn perimeter;\n}", "9291": "static float area(float r)\n{\n\treturn (float)((0.5)*(3.14)*(r * r));\n}\nstatic float perimeter(float r)\n{\n\treturn (float)((3.14)*(r));\n}", "9302": "", "9305": "static float rhombusarea(float l, float b)\n{\n\tif (l < 0 b < 0)\n\t\treturn -1;\n\treturn (l * b) / 2;\n}", "9318": "static float area(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat area = (float)Math.Sqrt(a) / 6;\n\treturn area;\n}", "9329": "static double longestRodInCuboid(int length, int breadth, int height)\n{\n\tdouble result;\n\tint temp;\n\ttemp = length * length + breadth *\n\t\tbreadth + height * height;\n\tresult = Math.Sqrt(temp);\n\treturn result;\n}", "9346": "static void is_partition_possible(int n, int[] x, int[] y, int[] w)\n\t{\n\t\tDictionary<int,int> weight_at_x = new Dictionary<int,int>();\n\t\tint max_x = (int) -2e3, min_x = (int) 2e3;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tint new_x = x[i] - y[i];\n\t\t\tmax_x = Math.Max(max_x, new_x);\n\t\t\tmin_x = Math.Min(min_x, new_x);\n\t\t\tif(weight_at_x.ContainsKey(new_x))\n\t\t\t{\n\t\t\t\tweight_at_x[new_x]+=w[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tweight_at_x.Add(new_x,w[i]);\n\t\t\t}\n\t\t}\n\t\tList<int> sum_till = new List<int>();\n\t\tsum_till.Add(0);\n\t\tfor (int s = min_x; s <= max_x; s++)\n\t\t{\n\t\t\tif(!weight_at_x.ContainsKey(s))\n\t\t\t{\n\t\t\t\tsum_till.Add(sum_till[sum_till.Count - 1]);\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\tsum_till.Add(sum_till[sum_till.Count-1] + weight_at_x[s]);\n\t\t}\n\t\t}\n\t\tint total_sum = sum_till[sum_till.Count-1];\n\t\tint partition_possible = 0;\n\t\tfor (int i = 1; i < sum_till.Count; i++)\n\t\t{\n\t\t\tif (sum_till[i] == total_sum - sum_till[i])\n\t\t\t\tpartition_possible = 1;\n\t\t\tif (sum_till[i-1] == total_sum - sum_till[i])\n\t\t\t\tpartition_possible = 1;\n\t\t}\n\t\tConsole.WriteLine(partition_possible == 1 ? \"YES\" : \"NO\");\n\t}", "9348": "static bool LiesInsieRectangle(int a, int b, int x, int y)\n{\nif (x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0)\n\treturn true;\nreturn false;\n}", "9358": "static bool FindPoint(int x1, int y1, int x2, int y2, int x, int y)\n{\nif (x > x1 && x < x2 && y > y1 && y < y2)\n\treturn true;\nreturn false;\n}", "9359": "static void distance(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2)\n{\n\tfloat z1, d;\n\tif (a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2)\n\t{\n\t\tz1 =-d1 / c1;\n\t\td = Math.Abs((c2 * z1 + d2)) /\n\t\t\t(float)(Math.Sqrt(a2 * a2 + b2 * b2 + c2 * c2));\n\t\tConsole.Write(\"Perpendicular distance is \" + d);\n\t}\n\telse\n\t\tConsole.Write(\"Planes are not parallel\");\n}", "9362": "static void shortest_distance(float x1, float y1, float z1, float a, float b, float c, float d)\n{\n\td = Math.Abs((a * x1 + b * y1 + c * z1 + d));\n\tfloat e = (float)Math.Sqrt(a * a + b * b + c * c);\n\tConsole.Write(\"Perpendicular distance \" + \"is \" + d / e);\n}", "9369": "static float findVolume(float l, float b, float h)\n\t{\n\t\tfloat volume = (l * b * h) / 2;\n\t\treturn volume;\n\t}", "9405": "static double findPCSlope(double m)\n\t{\n\t\treturn -1.0 / m;\n\t}", "9423": "static bool isRectangle(int a, int b, int c, int d)\n\t{\n\t\tif (a == b && a == c && a == d && c == d && b == c && b == d)\n\t\t\treturn true;\n\t\telse if (a == b && c == d)\n\t\t\treturn true;\n\t\telse if (a == d && c == b)\n\t\t\treturn true;\n\t\telse if (a == c && d == b)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "9430": "static float area_of_segment(float radius, float angle)\n{\n\tfloat area_of_sector = pi * (radius * radius)\n\t\t\t\t\t\t\t* (angle / 360);\n\tfloat area_of_triangle =(float)1 / 2 * (radius * radius)\n\t\t\t\t\t\t\t*(float)Math.Sin((angle * pi) / 180);\n\treturn area_of_sector - area_of_triangle;\n}", "9432": "static void midpoint(int x1, int x2, int y1, int y2)\n\t{\n\t\tConsole.WriteLine((x1 + x2) / 2 +\n\t\t\t\t\t\t\" , \" + (y1 + y2) / 2) ;\n\t}", "9445": "static int maxvolume(int s)\n\t{\n\t\tint maxvalue = 0;\n\t\tfor (int i = 1; i <= s - 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= s - 1; j++)\n\t\t\t{\n\t\t\t\tint k = s - i - j;\n\t\t\t\tmaxvalue = Math.Max(maxvalue, i * j * k);\n\t\t\t}\n\t\t}\n\t\treturn maxvalue;\n\t}", "9446": "static int maxvolume(int s)\n\t{\n\t\tint length = s / 3;\n\t\ts -= length;\n\t\tint breadth = s / 2;\n\t\tint height = s - breadth;\n\t\treturn length * breadth * height;\n\t}", "9452": "public static float volumeTriangular(int a, int b, int h)\n\t{\n\t\tfloat vol = (float)(0.1666) * a * b * h;\n\t\treturn vol;\n\t}\npublic static float volumeSquare(int b, int h)\n\t{\n\t\tfloat vol = (float)(0.33) * b * b * h;\n\t\treturn vol;\n\t}\npublic static float volumePentagonal(int a, int b, int h)\n\t{\n\t\tfloat vol = (float)(0.83) * a * b * h;\n\t\treturn vol;\n\t}\npublic static float volumeHexagonal(int a, int b, int h)\n\t{\n\t\tfloat vol = (float)a * b * h;\n\t\treturn vol;\n\t}", "9457": "static double Area(int b1, int b2, int h)\n\t{\n\t\treturn ((b1 + b2) / 2) * h;\n\t}", "9458": "public static double hexagonArea(double s)\n\t{\n\t\treturn ((3 * Math.Sqrt(3) *\n\t\t\t\t(s * s)) / 2);\n\t}", "9467": "static double arcLength(double diameter, double angle)\n\t{\n\t\tdouble pi = 22.0 / 7.0;\n\t\tdouble arc;\n\t\tif (angle >= 360) {\n\t\t\tConsole.WriteLine(\"Angle cannot\" + \" be formed\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tarc = (pi * diameter) * (angle / 360.0);\n\t\t\treturn arc;\n\t\t}\n\t}", "9468": "static void SectorArea(double radius, double angle)\n\t{\n\t\tif (angle >= 360)\n\t\t\tConsole.WriteLine(\"Angle not possible\");\n\t\telse {\n\t\t\tdouble sector = ((22 * radius * radius) / 7)\n\t\t\t\t\t\t\t* (angle / 360);\n\t\t\tConsole.WriteLine(sector);\n\t\t}\n\t}", "9476": "static int maxSquare(int b, int m)\n\t{\n\t\treturn (b / m - 1) * (b / m) / 2;\n\t}", "9478": "static void checkCollision(int a, int b, int c, int x, int y, int radius)\n\t{\n\t\tdouble dist = (Math.Abs(a * x + b * y + c)) /\n\t\t\t\t\t\tMath.Sqrt(a * a + b * b);\n\t\tif (radius == dist)\n\t\t\tConsole.WriteLine (\"Touch\");\n\t\telse if (radius > dist)\n\t\t\tConsole.WriteLine(\"Intersect\");\n\t\telse\n\t\t\tConsole.WriteLine(\"Outside\");\n\t}", "9496": "static int numberOfDiagonals(int n)\n\t{\n\t\treturn n * (n - 3) / 2;\n\t}", "9505": "static void findRightAngle(double A, double H)\n\t{\n\t\tdouble D = Math.Pow(H, 4) - 16 * A * A;\n\t\tif (D >= 0) {\n\t\t\tdouble root1 = (H * H + Math.Sqrt(D)) / 2;\n\t\t\tdouble root2 = (H * H - Math.Sqrt(D)) / 2;\n\t\t\tdouble a = Math.Sqrt(root1);\n\t\t\tdouble b = Math.Sqrt(root2);\n\t\t\tif (b >= a)\n\t\t\t\tConsole.WriteLine(a + \" \" + b + \" \" + H);\n\t\t\telse\n\t\t\t\tConsole.WriteLine(b + \" \" + a + \" \" + H);\n\t\t}\n\t\telse\n\t\t\tConsole.WriteLine(\"-1\");\n\t}", "9507": "public static int numberOfSquares(int _base)\n\t{\n\t\t_base = (_base - 2);\n\t\t_base = _base / 2;\n\t\treturn _base * (_base + 1)/2;\n\t}", "9528": "static double polygonArea(double []X, double []Y, int n)\n\t{\n\t\tdouble area = 0.0;\n\t\tint j = n - 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tarea += (X[j] + X[i]) *\n\t\t\t\t\t\t(Y[j] - Y[i]);\n\t\t\tj = i;\n\t\t}\n\t\treturn Math.Abs(area / 2.0);\n\t}", "9567": "static int chk(int n)\n{\n\tList<int> v = new List<int>();\n\twhile (n != 0) {\n\t\tv.Add(n % 2);\n\t\tn = n / 2;\n\t}\n\tint j = 0;\n\tforeach(int i in v) {\n\t\tif (i == 1) {\n\t\t\treturn (int) Math.Pow(2.0, (double)j);\n\t\t}\n\t\tj++;\n\t}\n\treturn 0;\n}\nstatic void sumOfLSB(int[] arr, int N)\n{\n\tint[] lsb_arr = new int[N];\n\tfor (int i = 0; i < N; i++) {\n\t\tlsb_arr[i] = chk(arr[i]);\n\t}\n\tArray.Sort(lsb_arr);\n\tint ans = 0;\n\tfor (int i = 0; i < N - 1; i += 2) {\n\t\tans += (lsb_arr[i + 1]);\n\t}\n\tConsole.WriteLine(ans);\n}", "9574": "static int countSubsequences(int []arr, int N)\n\t{\n\t\tint odd = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((arr[i] & 1) % 2 == 1)\n\t\t\t\todd++;\n\t\t}\n\t\treturn (1 << odd) - 1;\n\t}", "9608": "static void performQuery(int []arr, int [,]Q)\n\t{\n\t\tfor (int i = 0; i < Q.Length; i++) {\n\t\t\tint or = 0;\n\t\t\tint x = Q[i,0];\n\t\t\tarr[x - 1] = Q[i,1];\n\t\t\tfor (int j = 0; j < arr.Length; j++) {\n\t\t\t\tor = or | arr[j];\n\t\t\t}\n\t\t\tConsole.Write(or + \" \");\n\t\t}\n\t}", "9638": "static int smallest(int k, int d)\n{\n\tint cnt = 1;\n\tint m = d % k;\n\tint [] v = new int[k];\n\tfor(int i=0;i<k;i++)\n\t\tv[i] = 0;\n\tv[m] = 1;\n\twhile (true) {\n\t\tif (m == 0)\n\t\t\treturn cnt;\n\t\tm = (((m * (10 % k)) % k) + (d % k)) % k;\n\t\tif ( v[m] == 1)\n\t\t\treturn -1;\n\t\tv[m] = 1;\n\t\tcnt++;\n\t}\n}", "9639": "static int getPairsCount(int[] arr, int n)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = arr[i] - (i % arr[i]); j < n; j += arr[i]) {\n\t\t\t\tif (i < j\n\t\t\t\t\t&& Math.Abs(arr[i] - arr[j])\n\t\t\t\t\t\t>= Math.Min(arr[i], arr[j])) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "9673": "static void check(int N)\n{\n\tint twos = 0, fives = 0;\n\twhile (N % 2 == 0) {\n\t\tN /= 2;\n\t\ttwos++;\n\t}\n\twhile (N % 5 == 0) {\n\t\tN /= 5;\n\t\tfives++;\n\t}\n\tif (N == 1 && twos <= fives) {\n\t\tConsole.Write( 2 * fives - twos);\n\t}\n\telse {\n\t\tConsole.Write(-1);\n\t}\n}", "9685": "static void rangeSum(int[] arr, int N, int L, int R)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = L - 1; i < R; i++) {\n\t\t\tsum += arr[i % N];\n\t\t}\n\t\tConsole.Write(sum);\n\t}", "9686": "static void rangeSum(int []arr, int N, int L, int R)\n{\n\tint []prefix = new int[N+1];\n\tprefix[0] = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tprefix[i] = prefix[i - 1]\n\t\t\t\t\t+ arr[i - 1];\n\t}\n\tint leftsum\n\t\t= ((L - 1) / N) * prefix[N]\n\t\t+ prefix[(L - 1) % N];\n\tint rightsum = (R / N) * prefix[N]\n\t\t\t\t+ prefix[R % N];\n\tConsole.Write( rightsum - leftsum);\n}", "9702": "static int ExpoFactorial(int N)\n{\n\tint res = 1;\n\tint mod = 1000000007;\n\tfor(int i = 2; i < N + 1; i++)\n\t\tres = (int)Math.Pow(i, res) % mod;\n\treturn res;\n}", "9704": "static int maxSubArraySumRepeated(int[] arr, int N, int K)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tsum += arr[i];\n\t\tint curr = arr[0];\n\t\tint ans = arr[0];\n\t\tif (K == 1) {\n\t\t\tfor (int i = 1; i < N; i++) {\n\t\t\t\tcurr = Math.Max(arr[i], curr + arr[i]);\n\t\t\t\tans = Math.Max(ans, curr);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tList<int> V = new List<int>();\n\t\tfor (int i = 0; i < 2 * N; i++) {\n\t\t\tV.Add(arr[i % N]);\n\t\t}\n\t\tint maxSuf = V[0];\n\t\tint maxPref = V[2 * N - 1];\n\t\tcurr = V[0];\n\t\tfor (int i = 1; i < 2 * N; i++) {\n\t\t\tcurr += V[i];\n\t\t\tmaxPref = Math.Max(maxPref, curr);\n\t\t}\n\t\tcurr = V[2 * N - 1];\n\t\tfor (int i = 2 * N - 2; i >= 0; i--) {\n\t\t\tcurr += V[i];\n\t\t\tmaxSuf = Math.Max(maxSuf, curr);\n\t\t}\n\t\tcurr = V[0];\n\t\tfor (int i = 1; i < 2 * N; i++) {\n\t\t\tcurr = Math.Max(V[i], curr + V[i]);\n\t\t\tans = Math.Max(ans, curr);\n\t\t}\n\t\tif (sum > 0) {\n\t\t\tint temp = sum * (K - 2);\n\t\t\tans = Math.Max(ans, Math.Max(temp + maxPref, temp + maxSuf));\n\t\t}\n\t\treturn ans;\n\t}", "9707": "static int factorial(int n)\n{\n\tif (n == 0)\n\t\treturn 1;\n\treturn n * factorial(n - 1);\n}\nstatic long numOfNecklace(int N)\n{\n\tlong ans = factorial(N) /\n\t\t\t(factorial(N / 2) *\n\t\t\tfactorial(N / 2));\n\tans = ans * factorial(N / 2 - 1);\n\tans = ans * factorial(N / 2 - 1);\n\tans /= 2;\n\treturn ans;\n}", "9726": "static int gcd(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\nstatic void countPairs(int[] arr, int N)\n{\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tint count = 0;\n\t\tfor(int x = 1; x <= arr[i]; x++)\n\t\t{\n\t\t\tfor(int y = x; y <= arr[i]; y++)\n\t\t\t{\n\t\t\t\tif (gcd(x, y) > 1)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tConsole.Write(count + \" \");\n\t}\n}", "9727": "static void preCalculate(int[] phi, int[] ans)\n{\n\tphi[0] = 0;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAX; i++)\n\t\tphi[i] = i;\n\tfor (int i = 2; i <= MAX; i++) {\n\t\tif (phi[i] == i) {\n\t\t\tfor (int j = i; j <= MAX; j += i)\n\t\t\t\tphi[j] -= (phi[j] / i);\n\t\t}\n\t}\n\tfor (int i = 1; i <= MAX; i++)\n\t\tans[i] = ans[i - 1] + (i - phi[i]);\n}\nstatic void countPairs(int[] arr, int N)\n{\n\tint[] phi = new int[100000];\n\tArray.Clear(phi, 0, 100000);\n\tint[] ans = new int[100000];\n\tArray.Clear(ans, 0, 100000);\n\tpreCalculate(phi, ans);\n\tfor (int i = 0; i < N; ++i) {\n\t\tConsole.Write(ans[arr[i]] + \" \");\n\t}\n}", "9735": "static void countSubarray(int []arr, int n)\n{\n\tint count = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = i; j < n; j++)\n\t\t{\n\t\t\tint mxSubarray = 0;\n\t\t\tint mxOther = 0;\n\t\t\tfor(int k = i; k <= j; k++)\n\t\t\t{\n\t\t\t\tmxSubarray = Math.Max(mxSubarray, arr[k]);\n\t\t\t}\n\t\t\tfor(int k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tmxOther = Math.Max(mxOther, arr[k]);\n\t\t\t}\n\t\t\tfor(int k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tmxOther = Math.Max(mxOther, arr[k]);\n\t\t\t}\n\t\t\tif (mxSubarray > (2 * mxOther))\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tConsole.Write(count);\n}", "9736": "static void countSubarray(int[] arr, int n)\n\t{\n\t\tint L = 0, R = 0;\n\t\tint mx = Int32.MinValue;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmx = Math.Max(mx, arr[i]);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] * 2 > mx) {\n\t\t\t\tL = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (arr[i] * 2 > mx) {\n\t\t\t\tR = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine((L + 1) * (n - R));\n\t}", "9738": "static bool isPrime(int X)\n{\n\tfor(int i = 2; i * i <= X; i++)\n\t\tif (X % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nstatic void printPrimes(int[] A, int N)\n{\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tfor(int j = A[i] - 1;; j--)\n\t\t{\n\t\t\tif (isPrime(j))\n\t\t\t{\n\t\t\t\tConsole.Write(j + \" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = A[i] + 1;; j++)\n\t\t{\n\t\t\tif (isPrime(j))\n\t\t\t{\n\t\t\t\tConsole.Write(j + \" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine();\n\t}\n}", "9759": "static int gcd(int a, int b)\n{\n\tif (b == 0)\n\t{\n\t\treturn a;\n\t}\n\treturn gcd(b, a % b);\n}\nstatic Dictionary<int, int> PrimeFactor(int N)\n{\n\tDictionary<int, \n\t\t\tint> primef = new Dictionary<int, \n\t\t\t\t\t\t\t\t\t\t\tint>(); \n\twhile (N % 2 == 0)\n\t{\n\t\tif (primef.ContainsKey(2))\n\t\t{\n\t\t\tprimef[2]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprimef[2] = 1;\n\t\t}\n\t\tN = N / 2;\n\t}\n\tfor(int i = 3; i <= Math.Sqrt(N); i++)\n\t{\n\t\twhile (N % i == 0)\n\t\t{\n\t\t\tif (primef.ContainsKey(i))\n\t\t\t{\n\t\t\t\tprimef[i]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprimef[i] = 1;\n\t\t\t}\n\t\t\tN = N / 2;\n\t\t}\n\t}\n\tif (N > 2)\n\t{\n\t\tprimef[N] = 1;\n\t}\n\treturn primef;\n}\nstatic int CountToMakeEqual(int X, int Y)\n{\n\tint gcdofXY = gcd(X, Y);\n\tint newX = Y / gcdofXY;\n\tint newY = X / gcdofXY;\n\tDictionary<int, int> primeX = PrimeFactor(newX);\n\tDictionary<int, int> primeY = PrimeFactor(newY);\n\tint ans = 0;\n\tforeach(KeyValuePair<int, int> keys in primeX)\n\t{\n\t\tif (X % keys.Key != 0)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tans += primeX[keys.Key];\n\t}\n\tforeach(KeyValuePair<int, int> keys in primeY)\n\t{\n\t\tif (Y % keys.Key != 0)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tans += primeY[keys.Key];\n\t}\n\treturn ans;\n}", "9777": "static string isDivisibleByDivisor(int S, int D)\n{\n\tS %= D;\n\tList<int> hashMap = new List<int>();;\n\thashMap.Add(S);\n\tfor (int i = 0; i <= D; i++) {\n\t\tS += (S % D);\n\t\tS %= D;\n\t\tif (hashMap.Contains(S)) {\n\t\t\tif (S == 0) {\n\t\t\t\treturn \"Yes\";\n\t\t\t}\n\t\t\treturn \"No\";\n\t\t}\n\t\telse\n\t\t\thashMap.Add(S);\n\t}\n\treturn \"Yes\";\n}", "9787": "static int KthSmallest(int []A, int []B, int N, int K)\n{\n\tint M = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tM = Math.Max(A[i], M);\n\t}\n\tint []freq = new int[M + 1];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tfreq[A[i]] += B[i];\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i <= M; i++)\n\t{\n\t\tsum += freq[i];\n\t\tif (sum >= K)\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "9804": "static void findbitwiseOR(int[] a, int n)\n\t{\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint curr_sub_array = a[i];\n\t\t\tres = res | curr_sub_array;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tcurr_sub_array = curr_sub_array & a[j];\n\t\t\t\tres = res | curr_sub_array;\n\t\t\t}\n\t\t}\n\t\tConsole.Write(res);\n\t}", "9805": "static void findbitwiseOR(int[] a, int n)\n{\n\tint res = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tres = res | a[i];\n\tConsole.Write(res);\n}", "9818": "static void check(int n)\n{\n\tint sumOfDigit = 0;\n\tint prodOfDigit = 1;\n\twhile (n > 0)\n\t{\n\t\tint rem;\n\t\trem = n % 10;\n\t\tsumOfDigit += rem;\n\t\tprodOfDigit *= rem;\n\t\tn /= 10;\n\t}\n\tif (sumOfDigit > prodOfDigit)\n\t\tConsole.WriteLine(\"Yes\");\n\telse\n\t\tConsole.WriteLine(\"No\");\n}", "9824": "static void evenOddBitwiseXOR(int N)\n{\n\tConsole.Write(\"Even: \" + 0 + \" \");\n\tfor(int i = 4; i <= N; i = i + 4)\n\t{\n\t\tConsole.Write(i + \" \");\n\t}\n Console.Write(\"\\n\");\n\tConsole.Write(\"Odd: \" + 1 + \" \");\n\tfor(int i = 4; i <= N; i = i + 4)\n\t{\n\t\tConsole.Write(i - 1 + \" \");\n\t}\n\tif (N % 4 == 2)\n\t\tConsole.Write(N + 1);\n\telse if (N % 4 == 3)\n\t\tConsole.Write(N);\n}", "9829": "static void findPermutation(int[] arr)\n{\n\tint N = arr.Length;\n\tint i = N - 2;\n\twhile (i >= 0 && arr[i] <= arr[i + 1])\n\t\ti--;\n\tif (i == -1)\n\t{\n\t\tConsole.Write(\"-1\");\n\t\treturn;\n\t}\n\tint j = N - 1;\n\twhile (j > i && arr[j] >= arr[i])\n\t\tj--;\n\twhile (j > i && arr[j] == arr[j - 1])\n\t{\n\t\tj--;\n\t}\n\tint temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n\tforeach(int it in arr)\n\t{\n\t\tConsole.Write(it + \" \");\n\t}\n}", "9849": "static void sieveOfEratosthenes(int N, int[] s)\n\t{\n\t\tbool[] prime = new bool[N + 1];\n\t\tfor (int i = 2; i <= N; i += 2)\n\t\t\ts[i] = 2;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (prime[i] == false) {\n\t\t\t\ts[i] = i;\n\t\t\t\tfor (int j = i; j * i <= N; j += 2) {\n\t\t\t\t\tif (!prime[i * j]) {\n\t\t\t\t\t\tprime[i * j] = true;\n\t\t\t\t\t\ts[i * j] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nstatic void findDifference(int N)\n\t{\n\t\tint[] s = new int[N + 1];\n\t\tsieveOfEratosthenes(N, s);\n\t\tint total = 1, odd = 1, even = 0;\n\t\tint curr = s[N];\n\t\tint cnt = 1;\n\t\twhile (N > 1) {\n\t\t\tN /= s[N];\n\t\t\tif (curr == s[N]) {\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curr == 2) {\n\t\t\t\ttotal = total * (cnt + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttotal = total * (cnt + 1);\n\t\t\t\todd = odd * (cnt + 1);\n\t\t\t}\n\t\t\tcurr = s[N];\n\t\t\tcnt = 1;\n\t\t}\n\t\teven = total - odd;\n\t\tConsole.Write(Math.Abs(even - odd));\n\t}", "9877": "static void findMedian(int Mean, int Mode)\n{\n\tdouble Median = (2 * Mean + Mode) / 3.0;\n\tConsole.Write(Median);\n}", "9889": "private static double vectorMagnitude(int x, int y, int z)\n{\n\tint sum = x * x + y * y + z * z;\n\treturn Math.Sqrt(sum);\n}", "9905": "public static void minimumSteps(int x, int y)\n{\n\tint cnt = 0;\n\twhile (x != 0 && y != 0)\n\t{\n\t\tif (x > y)\n\t\t{\n\t\t\tcnt += x / y;\n\t\t\tx %= y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcnt += y / x;\n\t\t\ty %= x;\n\t\t}\n\t}\n\tcnt--;\n\tif (x > 1 y > 1)\n\t\tcnt = -1;\n\tConsole.WriteLine(cnt);\n}", "9915": "static Node newNode(int L, int R, int V)\n{\n\tNode temp = new Node();\n\ttemp.L = L;\n\ttemp.R = R;\n\ttemp.V = V;\n\treturn temp;\n}\nstatic bool check(List<int> []Adj, int Src, int N, bool []visited)\n{\n\tint []color = new int[N];\n\tvisited[Src] = true;\n\tQueue<int> q = new Queue<int>();\n\tq.Enqueue(Src);\n\twhile (q.Count > 0)\n\t{\n\t\tint u = q.Peek();\n\t\tq.Dequeue();\n\t\tint Col = color[u];\n\t\tforeach (int x in Adj[u])\n\t\t{\n\t\t\tif (visited[x] == true && color[x] == Col)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (visited[x] == false)\n\t\t\t{\n\t\t\t\tvisited[x] = true;\n\t\t\t\tq.Enqueue(x);\n\t\t\t\tcolor[x] = 1 - Col;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nstatic void addEdge(List<int> []Adj, int u, int v)\n{\n\tAdj[u].Add(v);\n\tAdj[v].Add(u);\n}\nstatic void isPossible(Node []Arr, int N)\n{\n\tList<int> [] Adj = new List<int>[N];\n\tfor(int i = 0; i < N; i++)\n\t\tAdj[i] = new List<int>();\n\tfor(int i = 0; i < N - 1; i++)\n\t{\n\t\tfor(int j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (Arr[i].R < Arr[j].L Arr[i].L > Arr[j].R)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (Arr[i].V == Arr[j].V)\n\t\t\t\t{\n\t\t\t\t\taddEdge(Adj, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool []visited = new bool[N];\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (visited[i] == false && Adj[i].Count > 0)\n\t\t{\n\t\t\tif (check(Adj, i, N, visited) == false)\n\t\t\t{\n\t\t\t\tConsole.Write(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tConsole.Write(\"Yes\");\n}", "9935": "static int GCD(int a, int b)\n{\n\treturn b == 0 ? a : GCD(b, a % b);\n}\nstatic void checkCommonDivisor(int []arr, int N, int X)\n{\n\tint G = 0;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tG = GCD(G, arr[i]);\n\t}\n\tint copy_G = G;\n\tfor(int divisor = 2; divisor <= X; divisor++)\n\t{\n\t\twhile (G % divisor == 0)\n\t\t{\n\t\t\tG = G / divisor;\n\t\t}\n\t}\n\tif (G <= X)\n\t{\n\t\tConsole.WriteLine(\"Yes\");\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tConsole.Write(arr[i] / copy_G + \" \");\n\t\tConsole.Write(\"\\n\");\n\t}\n\telse\n\t\tConsole.WriteLine(\"No\");\n}", "9948": "static int multiplyByMersenne(int N, int M)\n {\n\tint x = (int)(Math.Log(M + 1) / Math.Log(2));\n\treturn ((N << x) - N);\n }", "9958": "static int perfectSquare(int num)\n{\n\tint sr = (int)(Math.Sqrt(num));\n\tint a = sr * sr;\n\tint b = (sr + 1) * (sr + 1);\n\tif ((num - a) < (b - num))\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn b;\n\t}\n}\nstatic int powerOfTwo(int num)\n{\n\tint lg = (int)(Math.Log(num) / Math.Log(2));\n\tint p = (int)(Math.Pow(2, lg));\n\treturn p;\n}\nstatic void uniqueElement(int[] arr, int N)\n{\n\tbool ans = true;\n\tDictionary<int,\n\t\t\tint> freq = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tif (freq.ContainsKey(arr[i]))\n\t\t{\n\t\t\tfreq[arr[i]] = freq[arr[i]] + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfreq[arr[i]] = 1;\n\t\t}\n\t}\n\tforeach(var el in freq.OrderBy(el => el.Key))\n\t{\n\t\tif (el.Value == 1)\n\t\t{\n\t\t\tans = false;\n\t\t\tint ps = perfectSquare(el.Key);\n\t\t\tConsole.Write(powerOfTwo(ps) + \" \");\n\t\t}\n\t}\n\tif (ans)\n\t\tConsole.Write(\"-1\");\n}", "9963": "static void partitionArray(int[] a, int n)\n {\n\tint[] min = new int[n];\n\tint mini = Int32.MaxValue;\n\tfor (int i = n - 1; i >= 0; i--) {\n\tmini = Math.Min(mini, a[i]);\n\tmin[i] = mini;\n\t}\n\tint maxi = Int32.MinValue;\n\tint ind = -1;\n\tfor (int i = 0; i < n - 1; i++) {\n\tmaxi = Math.Max(maxi, a[i]);\n\tif (maxi < min[i + 1]) {\n\t\tind = i;\n\t\tbreak;\n\t}\n\t}\n\tif (ind != -1) {\n\tfor (int i = 0; i <= ind; i++)\n\t\tConsole.Write(a[i] + \" \");\n\tConsole.WriteLine();\n\tfor (int i = ind + 1; i < n; i++)\n\t\tConsole.Write(a[i] + \" \");\n\t}\n\telse\n\tConsole.Write(\"Impossible\");\n }", "9971": "static int countPrimeFactors(int n)\n {\n\tint count = 0;\n\twhile (n % 2 == 0)\n\t{\n\tn = n / 2;\n\tcount++;\n\t}\n\tfor(int i = 3;\n\t\ti <= (int)Math.Sqrt(n); i = i + 2)\n\t{\n\twhile (n % i == 0)\n\t{\n\t\tn = n / i;\n\t\tcount++;\n\t}\n\t}\n\tif (n > 2)\n\tcount++;\n\treturn (count);\n }\nstatic int findSum(int n)\n {\n\tint sum = 0;\n\tfor(int i = 1, num = 2; i <= n; num++)\n\t{\n\tif (countPrimeFactors(num) == 2)\n\t{\n\t\tsum += num;\n\t\ti++;\n\t}\n\t}\n\treturn sum;\n }\nstatic void check(int n, int k)\n {\n\tint s = findSum(k - 1);\n\tif (s >= n)\n\tConsole.WriteLine(\"No\");\n\telse\n\tConsole.WriteLine(\"Yes\");\n }", "9979": "static int gcd(int a, int b)\n {\n\twhile (b > 0)\n\t{\n\tint rem = a % b;\n\ta = b;\n\tb = rem;\n\t}\n\treturn a;\n }\nstatic int countNumberOfWays(int n)\n {\n\tif (n == 1)\n\treturn -1;\n\tint g = 0;\n\tint power = 0;\n\twhile (n % 2 == 0)\n\t{\n\tpower++;\n\tn /= 2;\n\t}\n\tg = gcd(g, power);\n\tfor (int i = 3; i <= (int)Math.Sqrt(n); i += 2)\n\t{\n\tpower = 0;\n\twhile (n % i == 0)\n\t{\n\t\tpower++;\n\t\tn /= i;\n\t}\n\tg = gcd(g, power);\n\t}\n\tif (n > 2)\n\tg = gcd(g, 1);\n\tint ways = 1;\n\tpower = 0;\n\twhile (g % 2 == 0)\n\t{\n\tg /= 2;\n\tpower++;\n\t}\n\tways *= (power + 1);\n\tfor (int i = 3; i <= (int)Math.Sqrt(g); i += 2)\n\t{\n\tpower = 0;\n\twhile (g % i == 0)\n\t{\n\t\tpower++;\n\t\tg /= i;\n\t}\n\tways *= (power + 1);\n\t}\n\tif (g > 2)\n\tways *= 2;\n\treturn ways;\n }", "9989": "", "10030": "public static bool isPossible(int[] target)\n\t{\n\t\tint max = 0;\n\t\tint index = 0;\n\t\tfor (int i = 0; i < target.Length; i++) {\n\t\t\tif (max < target[i])\n\t\t\t{\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tif (max == 1)\n\t\t\treturn true;\n\t\tfor (int i = 0; i < target.Length; i++) {\n\t\t\tif (i != index) {\n\t\t\t\tmax -= target[i];\n\t\t\t\tif (max <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\ttarget[index] = max;\n\t\treturn isPossible(target);\n\t}", "10041": "static void convertToASCII(int N)\n{\n\tString num = N.ToString();\n\tforeach (char ch in num.ToCharArray()) {\n\t\tConsole.Write(ch + \" (\"\n\t\t\t+ (int)ch + \")\\n\");\n\t}\n}", "10049": "static void productExceptSelf(int[] arr, int N)\n{\n\tint product = 1;\n\tint z = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] != 0)\n\t\t\tproduct *= arr[i];\n\t\tif (arr[i] == 0)\n\t\t\tz += 1;\n\t}\n\tint a = Math.Abs(product);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (z == 1)\n\t\t{\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[i] = 0;\n\t\t\telse\n\t\t\t\tarr[i] = product;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (z > 1)\n\t\t{\n\t\t\tarr[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint b = Math.Abs(arr[i]);\n\t\tint curr = (int)Math.Round(Math.Exp(Math.Log(a) - Math.Log(b)));\n\t\tif (arr[i] < 0 && product < 0)\n\t\t\tarr[i] = curr;\n\t\telse if (arr[i] > 0 && product > 0)\n\t\t\tarr[i] = curr;\n\t\telse\n\t\t\tarr[i] = -1 * curr;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tConsole.Write(arr[i] + \" \");\n\t}\n}", "10054": "static void singleDigitSubarrayCount(int[] arr, int N)\n{\n\tint res = 0;\n\tint count = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] <= 9)\n\t\t{\n\t\t\tcount++;\n\t\t\tres += count;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tConsole.Write(res);\n}", "10057": "static int isPossible(int N)\n{\n\treturn (((N & (N - 1)) & N));\n}\nstatic void countElements(int N)\n{\n\tint count = 0;\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tif (isPossible(i) != 0)\n\t\t\tcount++;\n\t}\n\tConsole.Write(count);\n}", "10058": "static void countElements(int N)\n {\n\tint Cur_Ele = 1;\n\tint Count = 0;\n\twhile (Cur_Ele <= N)\n\t{\n\tCount++;\n\tCur_Ele = Cur_Ele * 2;\n\t}\n\tConsole.Write(N - Count);\n }", "10062": "static int minSum(int []A, int N)\n {\n\tDictionary<int,int> mp = new Dictionary<int,int>();\n\tint sum = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\tsum += A[i];\n\tif(mp.ContainsKey(A[i]))\n\t{\n\t\tmp[A[i]] = mp[A[i]] + 1;\n\t}\n\telse\n\t{\n\t\tmp.Add(A[i], 1);\n\t}\n\t}\n\tint minSum = int.MaxValue;\n\tforeach (KeyValuePair<int,int> it in mp)\n\t{\n\tminSum = Math.Min(\n\t\tminSum, sum - (it.Key * it.Value));\n\t}\n\treturn minSum;\n }", "10063": "static void maxAdjacent(int[] arr, int N)\n {\n\tList<int> res = new List<int>();\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\tint prev = arr[0];\n\tint maxi = Int32.MinValue;\n\tfor (int j = 1; j < N; j++)\n\t{\n\t\tif (i == j)\n\t\tcontinue;\n\t\tmaxi = Math.Max(maxi, Math.Abs(arr[j] - prev));\n\t\tprev = arr[j];\n\t}\n\tres.Add(maxi);\n\t}\n\tforeach (int x in res)\n\t{\n\tConsole.Write(x + \" \");\n\t}\n\tConsole.WriteLine();\n }", "10064": "static void maxAdjacent(int []arr, int N)\n {\n\tList<int> res = new List<int>();\n\tint arr_max = Int32.MinValue;\n\tfor (int i = 1; i < N; i++)\n\t{\n\tarr_max = Math.Max(arr_max,\n\t\t\t\t\t\tMath.Abs(arr[i - 1] - arr[i]));\n\t}\n\tfor (int i = 1; i < N - 1; i++)\n\t{\n\tint curr_max = Math.Abs(arr[i - 1] - arr[i + 1]);\n\tint ans = Math.Max(curr_max, arr_max);\n\tres.Add(ans);\n\t}\n\tforeach (int x in res)\n\tConsole.Write(x + \" \");\n\tConsole.WriteLine();\n }", "10071": "static int minimumIncrement(int[] arr, int N)\n{\n\tif (N % 2 != 0)\n\t{\n\t\tConsole.WriteLine( \"-1\");\n\t\tEnvironment.Exit(0);\n\t}\n\tint cntEven = 0;\n\tint cntOdd = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] % 2 == 0)\n\t\t{\n\t\t\tcntEven += 1;\n\t\t}\n\t}\n\tcntOdd = N - cntEven;\n\treturn Math.Abs(cntEven - cntOdd) / 2;\n}", "10076": "static int findSize(int N)\n{\n\tif (N == 0)\n\t\treturn 1;\n\tif (N == 1)\n\t\treturn 1;\n\tint Size = 2 * findSize(N / 2) + 1;\n\treturn Size;\n}\nstatic int CountOnes(int N, int L, int R)\n{\n\tif (L > R)\n\t{\n\t\treturn 0;\n\t}\n\tif (N <= 1)\n\t{\n\t\treturn N;\n\t}\n\tint ret = 0;\n\tint M = N / 2;\n\tint Siz_M = findSize(M);\n\tif (L <= Siz_M)\n\t{\n\t\tret += CountOnes(N / 2, L,\n\t\t\t\t\t\tMath.Min(Siz_M, R));\n\t}\n\tif (L <= Siz_M + 1 && Siz_M + 1 <= R)\n\t{\n\t\tret += N % 2;\n\t}\n\tif (Siz_M + 1 < R)\n\t{\n\t\tret += CountOnes(N / 2,\n\t\t\t\t\t\tMath.Max(1, L - Siz_M - 1), R - Siz_M - 1);\n\t}\n\treturn ret;\n}", "10114": "static void cntWaysConsArray(int []A, int N)\n{\n\tint total = 1;\n\tint oddArray = 1;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\ttotal = total * 3;\n\t\tif (A[i] % 2 == 0)\n\t\t{\n\t\t\toddArray *= 2;\n\t\t}\n\t}\n\tConsole.WriteLine(total - oddArray);\n}", "10120": "static void countNumberHavingKthBitSet(int N, int K)\n {\n\tint numbers_rightmost_setbit_K = 0;\n\tfor (int i = 1; i <= K; i++)\n\t{\n\tint numbers_rightmost_bit_i = (N + 1) / 2;\n\tN -= numbers_rightmost_bit_i;\n\tif (i == K)\n\t{\n\t\tnumbers_rightmost_setbit_K\n\t\t= numbers_rightmost_bit_i;\n\t}\n\t}\n\tConsole.WriteLine(numbers_rightmost_setbit_K);\n }", "10123": "static int countSetBits(int N)\n{\n\tint count = 0;\n\twhile (N != 0)\n\t{\n\t\tN = N & (N - 1);\n\t\tcount++;\n\t}\n\treturn count;\n}", "10124": "static void minMoves(int []arr, int N)\n {\n\tint odd_element_cnt = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\tif (arr[i] % 2 != 0)\n\t{\n\t\todd_element_cnt++;\n\t}\n\t}\n\tint moves = (odd_element_cnt) / 2;\n\tif (odd_element_cnt % 2 != 0)\n\tmoves += 2;\n\tConsole.Write(moves);\n }", "10145": "static void minimumSubsetDifference(int N)\n\t{\n\t\tint blockOfSize8 = N / 8;\n\t\tstring str = \"ABBABAAB\";\n\t\tint subsetDifference = 0;\n\t\tstring partition = \"\";\n\t\twhile (blockOfSize8-- > 0)\n\t\t{\n\t\t\tpartition += str;\n\t\t}\n\t\tint []A = new int[N];\n\t\tint []B = new int[N];\n\t\tint x = 0, y = 0;\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (partition[i] == 'A')\n\t\t\t{\n\t\t\t\tA[x++] = ((i + 1) * (i + 1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tB[y++] = ((i + 1) * (i + 1));\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(subsetDifference);\n\t\tfor(int i = 0; i < x; i++)\n\t\t\tConsole.Write(A[i] + \" \");\n\t\tConsole.WriteLine();\n\t\tfor(int i = 0; i < y; i++)\n\t\t\tConsole.Write(B[i] + \" \");\n\t}", "10155": "static void findTheGreatestX(int P, int Q)\n{\n\tDictionary<int,\n\t\t\tint> divisers = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 2; i * i <= Q; i++)\n\t{\n\t\twhile (Q % i == 0 && Q > 1)\n\t\t{\n\t\t\tQ /= i;\n\t\t\tif (divisers.ContainsKey(i))\n\t\t\t\tdivisers[i]++;\n\t\t\telse\n\t\t\t\tdivisers[i] = 1;\n\t\t}\n\t}\n\tif (Q > 1)\n\t{\n\t\tif (divisers.ContainsKey(Q))\n\t\t\tdivisers[Q]++;\n\t\telse\n\t\t\tdivisers[Q] = 1;\n\t}\n\tint ans = 0;\n\tvar val = divisers.Keys.ToList();\n\tforeach(var key in val)\n\t{\n\t\tint frequency = divisers[key];\n\t\tint temp = P;\n\t\tint cur = 0;\n\t\twhile (temp % key == 0)\n\t\t{\n\t\t\ttemp /= key;\n\t\t\tcur++;\n\t\t}\n\t\tif (cur < frequency)\n\t\t{\n\t\t\tans = P;\n\t\t\tbreak;\n\t\t}\n\t\ttemp = P;\n\t\tfor(int j = cur; j >= frequency; j--)\n\t\t{\n\t\t\ttemp /= key;\n\t\t}\n\t\tans = Math.Max(temp, ans);\n\t}\n\tConsole.WriteLine(ans);\n}", "10174": "static String checkRearrangements(int[,] mat, int N, int M)\n{\n for(int i = 0; i < N; i++)\n {\n\tfor(int j = 1; j < M; j++)\n\t{\n\tif (mat[i, 0] != mat[i, j])\n\t{\n\t\treturn \"Yes\";\n\t}\n\t}\n }\n return \"No\";\n}\nstatic String nonZeroXor(int[,] mat, int N, int M)\n{\n int res = 0;\n for(int i = 0; i < N; i++)\n {\n\tres = res ^ mat[i, 0];\n }\n if (res != 0)\n\treturn \"Yes\";\n else\n\treturn checkRearrangements(mat, N, M);\n}", "10186": "static void findPrimeNos(int L, int R, Dictionary<int, int> M, int K)\n{\n for (int i = L; i <= R; i++)\n {\n\tif(M.ContainsKey(i))\n\tM.Add(i, M[i] + 1);\n\telse\n\tM.Add(i, 1);\n }\n if (M[1] != 0)\n {\n\tM.Remove(1);\n }\n for (int i = 2;\n\t\ti <= Math.Sqrt(R); i++)\n {\n\tint multiple = 2;\n\twhile ((i * multiple) <= R)\n\t{\n\tif (M.ContainsKey(i * multiple))\n\t{\n\t\tM.Remove(i * multiple);\n\t}\n\tmultiple++;\n\t}\n }\n foreach (KeyValuePair<int, int> entry in M) \n {\n\tif (M.ContainsKey(entry.Key + K))\n\t{\n\tConsole.Write(\"(\" + entry.Key +\n\t\t\t\t\t\", \" + (entry.Key + K) + \") \");\n\t}\n }\n}\nstatic void getPrimePairs(int L, int R, int K)\n{\n Dictionary<int,\n\t\t\tint> M = new Dictionary<int,\n\t\t\t\t\t\t\t\t\tint>(); \n findPrimeNos(L, R, M, K);\n}", "10212": "static int functionMax(int []arr, int n)\n{\n\tList<int> []setBit = new List<int>[32 + 1];\n\tfor (int i = 0; i < setBit.Length; i++)\n\t\tsetBit[i] = new List<int>();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < size_int; j++)\n\t\t{\n\t\t\tif ((arr[i] & (1 << j)) > 0)\n\t\t\t\tsetBit[j].Add(i);\n\t\t}\n\t}\n\tfor (int i = size_int; i >= 0; i--)\n\t{\n\t\tif (setBit[i].Count == 1)\n\t\t{\n\t\t\tswap(arr, 0, setBit[i][0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint maxAnd = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tmaxAnd = maxAnd & (~arr[i]);\n\t}\n\treturn maxAnd;\n}\nstatic int[] swap(int []arr, int i, int j)\n{\n\tint temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n\treturn arr;\n}", "10228": "static bool prime(int n)\n{\n\tif (n == 1)\n\t\treturn false;\n\tfor(int i = 2; i * i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nstatic void minDivisior(int n)\n{\n\tif (prime(n))\n\t{\n\t\tConsole.Write(1 + \" \" + (n - 1));\n\t}\n\telse\n\t{\n\t\tfor(int i = 2; i * i <= n; i++)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tConsole.Write(n / i + \" \" +\n\t\t\t\t\t\t\t(n / i * (i - 1)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "10233": "static int gcd(int a, int b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b % a, a);\n}\nstatic int lcm(int a, int b)\n{\n\treturn (a * b) / gcd(a, b);\n}\nstatic void findLCM(List<int> arr)\n{\n\tint nth_lcm = arr[0];\n\tfor(int i = 1; i < arr.Count; i++)\n\t\tnth_lcm = lcm(nth_lcm, arr[i]);\n\tLandau = Math.Max(Landau, nth_lcm);\n}\nstatic void findWays(List<int> arr, int i, int n)\n{\n\tif (n == 0)\n\t\tfindLCM(arr);\n\tfor(int j = i; j <= n; j++)\n\t{\n\t\tarr.Add(j);\n\t\tfindWays(arr, j, n - j);\n\t\tarr.RemoveAt(arr.Count - 1);\n\t}\n}\nstatic void Landau_function(int n)\n{\n\tList<int> arr = new List<int>();\n\tfindWays(arr, 1, n);\n\tConsole.Write(Landau);\n}", "10237": "static int nCr(int n, int r)\n{\n\tint res = 1;\n\tif (r > n - r)\n\t\tr = n - r;\n\tfor (int i = 0; i < r; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}\nstatic int solve(int n, int m, int k)\n{\n\tint sum = 0;\n\tfor (int i = 0; i <= k; i++)\n\t\tsum += nCr(n, i)\n\t\t\t* nCr(m, k - i);\n\treturn sum;\n}", "10238": "static int nCr(int n, int r)\n{\n\tint res = 1;\n\tif (r > n - r)\n\t\tr = n - r;\n\tfor (int i = 0; i < r; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}", "10267": "static int powerOptimised(int a, int n)\n{\n\tint ans = 1;\n\twhile (n > 0)\n\t{\n\t\tint last_bit = (n & 1);\n\t\tif (last_bit > 0)\n\t\t{\n\t\t\tans = ans * a;\n\t\t}\n\t\ta = a * a;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}", "10269": "static int findMaximumGcd(int n)\n{ \n int max_gcd = 1;\n for(int i = 1; i * i <= n; i++)\n {\n\tif (n % i == 0)\n\t{\n\tif (i > max_gcd)\n\t\tmax_gcd = i;\n\tif ((n / i != i) &&\n\t\t(n / i != n) &&\n\t\t((n / i) > max_gcd))\n\t\tmax_gcd = n / i;\n\t}\n }\n return max_gcd;\n}", "10309": "static void sieve()\n{\n\tv[1] = 1;\n\tfor(int i = 2; i < x; i++)\n\t\tv[i] = i;\n\tfor(int i = 4; i < x; i += 2)\n\t\tv[i] = 2;\n\tfor(int i = 3; i * i < x; i++)\n\t{\n\t\tif (v[i] == i)\n\t\t{\n\t\t\tfor(int j = i * i; j < x; j += i)\n\t\t\t{\n\t\t\t\tif (v[j] == j)\n\t\t\t\t{\n\t\t\t\t\tv[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic int prime_factors(int n)\n{\n\tHashSet<int> s = new HashSet<int>();\n\twhile (n != 1)\n\t{\n\t\ts.Add(v[n]);\n\t\tn = n / v[n];\n\t}\n\treturn s.Count;\n}\nstatic void distinctPrimes(int m, int k)\n{\n\tList<int> result = new List<int>();\n\tfor (int i = 14; i < m + k; i++)\n\t{\n\t\tlong count = prime_factors(i);\n\t\tif (count == k)\n\t\t{\n\t\t\tresult.Add(i);\n\t\t}\n\t}\n\tint p = result.Count;\n\tfor(int index = 0; index < p - 1; index++)\n\t{\n\t\tlong element = result[index];\n\t\tint count = 1, z = index;\n\t\twhile (z < p - 1 && count <= k && result[z] + 1 == result[z + 1])\n\t\t{\n\t\t\tcount++;\n\t\t\tz++;\n\t\t}\n\t\tif (count >= k)\n\t\t\tConsole.Write(element + \" \");\n\t}\n}", "10325": "static void print_product(int a, int b, int c, int d)\n{\n\tint prod1 = a * c;\n\tint prod2 = b * d;\n\tint prod3 = (a + b) * (c + d);\n\tint real = prod1 - prod2;\n\tint imag = prod3 - (prod1 + prod2);\n\tConsole.Write(real + \" + \" + imag + \"i\");\n}", "10330": "static int reverse(int num)\n{\n\tint rev_num = 0;\n\twhile(num > 0)\n\t{\n\t\trev_num = rev_num * 10 + num % 10;\n\t\tnum = num / 10;\n\t}\n\treturn rev_num;\n}\nstatic int properDivSum(int num)\n{\n\tint result = 0;\n\tfor (int i = 2; i<= Math.Sqrt(num); i++)\n\t{\n\t\tif (num % i == 0)\n\t\t{\n\t\t\tif (i == (num / i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + num / i);\n\t\t}\n\t}\n\treturn (result + 1);\n}\nstatic bool isTcefrep(int n)\n{\n\treturn properDivSum(n) == reverse(n);\n}", "10335": "static bool isInsolite(int n)\n{\n\tint N = n;\n\tint sum = 0;\n\tint product = 1;\n\twhile (n != 0)\n\t{\n\t\tint r = n % 10;\n\t\tsum = sum + r * r;\n\t\tproduct = product * r * r;\n\t\tn = n / 10;\n\t}\n\treturn (N % sum == 0) &&\n\t\t(N % product == 0);\n}", "10337": "static int sigma(int n)\n{\n\tif (n == 1)\n\t\treturn 1;\n\tint result = 0;\n\tfor(int i = 2; i <= Math.Sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (i == (n / i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + n / i);\n\t\t}\n\t}\n\treturn (result + n + 1);\n}\nstatic bool isSuperabundant(int N)\n{\n\tfor(double i = 1; i < N; i++)\n\t{\n\t\tdouble x = sigma((int)(i)) / i;\n\t\tdouble y = sigma((int)(N)) / (N * 1.0);\n\t\tif (x > y)\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "10345": "static bool isDNum(int n)\n{\n\tif (n < 4)\n\t\treturn false;\n\tint numerator = 0, hcf = 0;\n\tfor(int k = 2; k <= n; k++)\n\t{\n\t\tnumerator = (int)(Math.Pow(k, n - 2) - k);\n\t\thcf = __gcd(n, k);\n\t}\n\tif (hcf == 1 && (numerator % n) != 0)\n\t\treturn false;\n\treturn true;\n}\nstatic int __gcd(int a, int b)\n{\n\treturn b == 0 ? a : __gcd(b, a % b);\t\n}", "10367": "static bool isPrime(int n)\n{\n\tif (n == 1)\n\t\treturn true;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor(int i = 5; i * i <= n; i = i + 6)\n\tif (n % i == 0 || n % (i + 2) == 0)\n\t\treturn false;\n\treturn true;\n}\nstatic void checkExpression(int n)\n{\n\tif (isPrime(n))\n\t\tConsole.Write(\"Yes\");\n\telse\n\t\tConsole.Write(\"No\");\n}", "10377": "static int Sum(int N)\n{\n\tint []SumOfPrimeDivisors = new int[N + 1];\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tif (SumOfPrimeDivisors[i] == 1)\n\t\t{\n\t\t\tfor (int j = i; j <= N; j += i)\n\t\t\t{\n\t\t\t\tSumOfPrimeDivisors[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\treturn SumOfPrimeDivisors[N];\n}\nstatic bool RuthAaronNumber(int n)\n{\n\tif (Sum(n) == Sum(n + 1))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "10394": "static void Is_possible(long N)\n{\n\tlong C = 0;\n\tlong D = 0;\n\twhile (N % 10 == 0)\n\t{\n\t\tN = N / 10;\n\t\tC += 1;\n\t}\n\tif(Math.Pow(2, (long)(Math.Log(N) /\n\t\t\t\t\t\t(Math.Log(2)))) == N)\n\t{\n\t\tD = (long)(Math.Log(N) / (Math.Log(2)));\n\t\tif (C >= D)\n\t\t\tConsole.WriteLine(\"YES\");\n\t\telse\n\t\t\tConsole.WriteLine(\"NO\");\n\t}\n\telse\n\t\tConsole.WriteLine(\"NO\");\n}", "10406": "static int maxAdjacentDifference(int N, int K)\n{\n\tif (N == 1)\n\t{\n\t\treturn 0;\n\t}\n\tif (N == 2) \n\t{\n\t\treturn K;\n\t}\n\treturn 2 * K;\n}", "10408": "public static int linearSum(int n)\n{\n\treturn (n * (n + 1) / 2) % mod;\n}\npublic static int rangeSum(int b, int a)\n{\n\treturn (linearSum(b) -\n\t\t\tlinearSum(a)) % mod;\n}\npublic static int totalSum(int n)\n{\n\tint result = 0;\n\tint i = 1;\n\twhile(true)\n\t{\n\t\tresult += rangeSum(n / i,\n\t\t\t\t\t\tn / (i + 1)) *\n\t\t\t\t\t\t(i % mod) % mod;\n\t\tresult %= mod;\n\t\tif (i == n)\n\t\t\tbreak;\n\t\ti = n / (n / (i + 1));\n\t}\n\treturn result;\n}", "10423": "static bool isDouble(int num)\n{\n\tString s = num.ToString();\n\tint l = s.Length;\n\tif(s[0] == s[1])\n\treturn false;\n\tif(l % 2 == 1)\n\t{\n\t\ts = s + s[1];\n\t\tl++;\n\t}\n\tString s1 = s.Substring(0, l / 2);\n\tString s2 = s.Substring(l / 2);\n\treturn s1.Equals(s2);\n}\nstatic bool isNontrivialUndulant(int N)\n{\n\treturn N > 100 && isDouble(N);\n}", "10434": "static void findNthTerm(int n)\n{\n\tConsole.Write(n * n - n + 1);\n}", "10438": "static int rev(int num)\n{\n\tint rev_num = 0;\n\twhile (num > 0)\n\t{\n\t\trev_num = rev_num * 10 +\n\t\t\t\t\tnum % 10;\n\t\tnum = num / 10;\n\t}\n\treturn rev_num;\n}\nstatic int divSum(int num)\n{\n\tint result = 0;\n\tfor(int i = 2; i <= Math.Sqrt(num); i++)\n\t{\n\t\tif (num % i == 0)\n\t\t{\n\t\t\tif (i == (num / i))\n\t\t\t\tresult += rev(i);\n\t\t\telse\n\t\t\t\tresult += (rev(i) +\n\t\t\t\t\t\trev(num / i));\n\t\t}\n\t}\n\treturn (result + 1);\n}\nstatic Boolean isAntiPerfect(int n)\n{\n\treturn divSum(n) == n;\n}", "10445": "static void printSeries(int n, int a, int b, int c)\n{\n\tint d;\n\tif (n == 1)\n\t{\n\t\tConsole.Write(a + \" \");\n\t\treturn;\n\t}\n\tif (n == 2)\n\t{\n\t\tConsole.Write(a + \" \" + b + \" \");\n\t\treturn;\n\t}\n\tConsole.Write(a + \" \" + b + \" \" + c + \" \");\n\tfor(int i = 4; i <= n; i++)\n\t{\n\td = a + b + c;\n\tConsole.Write(d + \" \");\n\ta = b;\n\tb = c;\n\tc = d;\n\t}\n}", "10452": "static bool checkArray(int n, int k, int []arr)\n{\n\tint cnt = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif ((arr[i] & 1) != 0)\n\t\t\tcnt += 1;\n\t}\n\tif (cnt >= k && cnt % 2 == k % 2)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "10462": "static long func(int []arr, int n)\n{\n\tdouble ans = 0;\n\tint maxx = 0;\n\tdouble []freq = new double[100005];\n\tint temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\ttemp = arr[i];\n\tfreq[temp]++;\n\tmaxx = Math.Max(maxx, temp);\n\t}\n\tfor(int i = 1; i <= maxx; i++)\n\t{\n\tfreq[i] += freq[i - 1];\n\t}\n\tfor(int i = 1; i <= maxx; i++)\n\t{\n\tif (freq[i] != 0)\n\t{\n\t\tdouble j;\n\t\tdouble cur = Math.Ceiling(0.5 * i) - 1.0;\n\t\tfor(j = 1.5;; j++)\n\t\t{\n\t\t\tint val = Math.Min(maxx,\n\t\t\t\t(int)(Math.Ceiling(i * j) - 1.0));\n\t\t\tint times = (int)(freq[i] - freq[i - 1]),\n\t\t\t\t\tcon = (int)(j - 0.5);\n\t\t\tans += times * con * (freq[(int)val] -\n\t\t\t\t\t\t\t\t\tfreq[(int)cur]);\n\t\t\tcur = val;\n\t\t\tif (val == maxx)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t}\n\treturn (long)ans;\n}", "10474": "static int enneacontahexagonNum(int n)\n{\n\treturn (94 * n * n - 92 * n) / 2;\n}", "10475": "static int MegagonNum(int n)\n{\n\treturn (999998 * n * n - 999996 * n) / 2;\n}", "10492": "static void insert_element(int[] a, int n)\n{\n\tint Xor = 0;\n\tint Sum = 0;\n\tfor(int i = 0; i < n; i++)\n\t{ \n\t\tXor ^= a[i];\n\t\tSum += a[i];\n\t}\n\tif(Sum == 2 * Xor)\n\t{\n\t\tConsole.Write(\"0\");\n\t\treturn;\n\t}\n\tif(Xor == 0)\n\t{\n\t\tConsole.Write(\"1\" + '\\n');\n\t\tConsole.Write(Sum);\n\t\treturn;\n\t}\n\tint num1 = Sum + Xor;\n\tint num2 = Xor;\n\tConsole.Write(\"2\");\n\tConsole.Write(num1 + \" \" + num2);\n}", "10502": "static void checkSolution(int a, int b, int c)\n{\n\tif (a == c)\n\t\tConsole.WriteLine(\"Yes\");\n\telse\n\t\tConsole.WriteLine(\"No\");\n}", "10539": "static int productPairs(int []arr, int n)\n{\n\tint product = 1;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tproduct *= (arr[i] % mod * arr[j] % mod) % mod;\n\t\t\tproduct = product % mod;\n\t\t}\n\t}\n\treturn product % mod;\n}", "10540": "static int power(int x, int y)\n{\n\tint p = 1000000007;\n\tint res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif (y % 2 == 1)\n\t\t\tres = (res * x) % p;\n\t\ty = y >> 1;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nstatic int productPairs(int []arr, int n)\n{\n\tint product = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tproduct = (product % mod *\n\t\t\t\t(int)power(arr[i],\n\t\t\t\t\t\t\t(2 * n)) % mod) % mod;\n\t}\n\treturn product % mod;\n}", "10546": "static void constructArray(int N)\n{\n\tint []arr = new int[N];\n\tfor(int i = 1; i <= N; i++)\n\t{\n\tarr[i - 1] = i;\n\t}\n\tfor(int i = 0; i < N; i++)\n\t{\n\tConsole.Write(arr[i] + \", \");\n\t}\n}", "10568": "static bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (int i = 2; i < n; i++)\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nstatic int countSubsequences(int []arr, int n)\n{\n\tint totalSubsequence = (int)(Math.Pow(2, n) - 1);\n\tint countPrime = 0, countOnes = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] == 1)\n\t\t\tcountOnes++;\n\t\telse if (isPrime(arr[i]))\n\t\t\tcountPrime++;\n\t}\n\tint compositeSubsequence;\n\tint onesSequence = (int)(Math.Pow(2, countOnes) - 1);\n\tcompositeSubsequence = totalSubsequence -\n\t\t\t\t\t\t\t\tcountPrime -\n\t\t\t\t\t\t\tonesSequence -\n\t\t\t\t\t\t\tonesSequence *\n\t\t\t\t\t\t\t\tcountPrime;\n\treturn compositeSubsequence;\n}", "10569": "static int nCr(int n, int r)\n{\n\treturn fact(n) / (fact(r) * fact(n - r));\n}\nstatic int fact(int n)\n{\n\tint res = 1;\n\tfor(int i = 2; i <= n; i++)\n\tres = res * i;\n\treturn res;\n}\nstatic int sumSubsequences(int[] arr, int n, int k)\n{\n\tint sum = 0;\n\tfor(int i = 0; i < n; i++) \n\t{\n\tsum += arr[i];\n\t}\n\tint kLengthSubSequence;\n\tkLengthSubSequence = nCr(n, k);\n\tint ans = sum * ((k * kLengthSubSequence) / n);\n\treturn ans;\n}", "10573": "static List<int> getFactorization(int x)\n{\n int count = 0;\n List<int> v = new List<int>();\n while (x % 2 == 0)\n {\n\tcount++;\n\tx = x / 2;\n }\n if (count != 0)\n\tv.Add(count);\n for (int i = 3;\n\t\ti <= Math.Sqrt(x); i += 2)\n {\n\tcount = 0;\n\twhile (x % i == 0)\n\t{\n\tcount++;\n\tx /= i;\n\t}\n\tif (count != 0)\n\tv.Add(count);\n }\n if (x > 1)\n {\n\tv.Add(1);\n }\n return v;\n}\nstatic int nonPrimeDivisors(int N)\n{\n List<int> v = getFactorization(N);\n int ret = 1;\n for (int i = 0; i < v.Count; i++)\n\tret = ret * (v[i] + 1);\n ret = ret - v.Count;\n return ret;\n}", "10653": "static void checksum(int n, int k)\n{\n\tfloat first_term = (float)(((2 * n) / k +\n\t\t\t\t\t\t\t\t(1 - k)) / 2.0);\n\tif (first_term - (int)(first_term) == 0)\n\t{\n\t\tfor(int i = (int)first_term; i <= first_term + k - 1; i++)\n\t\t{\n\t\t\tConsole.Write(i + \" \");\n\t\t}\n\t}\n\telse\n\t\tConsole.Write(\"-1\");\n}", "10668": "static void sumEvenNumbers(int N, int K)\n{\n\tint check = N - 2 * (K - 1);\n\tif (check > 0 && check % 2 == 0)\n\t{\n\t\tfor(int i = 0; i < K - 1; i++)\n\t\t{\n\t\tConsole.Write(\"2 \");\n\t\t}\n\t\tConsole.WriteLine(check);\n\t}\n\telse\n\t{\n\t\tConsole.WriteLine(\"-1\");\n\t}\n}", "10677": "static bool isPerfectSquare(double x)\n{\n\tdouble sr = Math.Sqrt(x);\n\treturn((sr - Math.Floor(sr)) == 0);\n}\nstatic void checkSunnyNumber(int N)\n{\n\tif (isPerfectSquare(N + 1))\n\t{\n\t\tConsole.WriteLine(\"Yes\");\n\t}\n\telse\n\t{\n\t\tConsole.WriteLine(\"No\");\n\t}\n}", "10694": "public static int[] calculateWays(int N)\n{\n\tint x = 0;\n\tint[]v = new int[N];\n\tfor(int i = 0; i < N; i++)\n\t\tv[i] = 0;\n\tfor(int i = 0; i < N / 2; i++)\n\t{\n\tif(N % 2 == 0 && i == N / 2)\n\t\tbreak;\n\tx = N * (i + 1) - (i + 1) * i;\n\tv[i] = x;\n\tv[N - i - 1] = x;\n\t}\n\treturn v;\n}\npublic static void printArray(int []v)\n{\n\tfor(int i = 0; i < v.Length; i++)\n\t{\n\tConsole.Write(v[i] + \" \");\n\t}\n}", "10703": "static int sumOfDigits(int n)\n{\n\tint sum = 0;\n\twhile(n > 0)\n\t{\n\t\tsum += n % 10;\n\t\tn /= 10;\n\t}\n\treturn sum;\n}\nstatic int smallestNum(int X, int Y)\n{\n\tint res = -1;\n\tfor(int i = X; i < MAXN; i++)\n\t{\n\t\tint sum_of_digit = sumOfDigits(i);\n\t\tif(sum_of_digit % Y == 0)\n\t\t{\n\t\tres = i;\n\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}", "10706": "static int countValues(int n)\n{\n\tint answer = 0;\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tint k = n;\n\t\twhile (k >= i)\n\t\t{\n\t\t\tif (k % i == 0)\n\t\t\t\tk /= i;\n\t\t\telse\n\t\t\t\tk -= i;\n\t\t}\n\t\tif (k == 1)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "10707": "static int countValues(int N)\n{\n\tList<int> div = new List<int>();\n\tfor(int i = 2; i * i <= N; i++)\n\t{\n\t\tif (N % i == 0)\n\t\t{\n\t\t\tdiv.Add(i);\n\t\t\tif (N != i * i)\n\t\t\t{\n\t\t\t\tdiv.Add(N / i);\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tfor(int i = 1; i * i <= N - 1; i++)\n\t{\n\t\tif ((N - 1) % i == 0)\n\t\t{\n\t\t\tif (i * i == N - 1)\n\t\t\t\tanswer++;\n\t\t\telse\n\t\t\t\tanswer += 2;\n\t\t}\n\t}\n\tforeach(int d in div)\n\t{\n\t\tint K = N;\n\t\twhile (K % d == 0)\n\t\t\tK /= d;\n\t\tif ((K - 1) % d == 0)\n\t\t\tanswer++;\n\t}\n\treturn answer;\n}", "10719": "static void findMaxPrimeDivisor(int n)\n{\n\tint max_possible_prime = 0;\n\twhile (n % 2 == 0)\n\t{\n\t\tmax_possible_prime++;\n\t\tn = n / 2;\n\t}\n\tfor(int i = 3; i * i <= n; i = i + 2)\n\t{\n\twhile (n % i == 0)\n\t{\n\t\tmax_possible_prime++;\n\t\tn = n / i;\n\t}\n\t}\n\tif (n > 2)\n\t{\n\t\tmax_possible_prime++;\n\t}\n\tConsole.Write(max_possible_prime + \"\\n\");\n}", "10721": "static void printKNumbers(int N, int K)\n{\n\tfor(int i = 0; i < K - 1; i++)\n\t\tConsole.Write(1 + \" \");\n\tConsole.Write(N - K + 1);\n}", "10751": "static int CountWays(int n)\n{\n\tint ans = (n - 1) / 2;\n\treturn ans;\n}", "10753": "static void Solve(int []arr, int size, int n)\n{\n\tint[] v = new int[n + 1];\n\tfor(int i = 0; i < size; i++)\n\t\tv[arr[i]]++;\n\tint max1 = -1, mx = -1;\n\tfor(int i = 0; i < v.Length; i++)\n\t{\n\t\tif (v[i] > mx)\n\t\t{\n\t\t\tmx = v[i];\n\t\t\tmax1 = i;\n\t\t}\n\t}\n\tint cnt = 0;\n\tforeach(int i in v)\n\t{\n\t\tif (i == 0)\n\t\t\t++cnt;\n\t}\n\tint diff1 = n + 1 - cnt;\n\tint max_size = Math.Max(Math.Min(v[max1] - 1, diff1),\n\t\t\t\t\t\t\tMath.Min(v[max1], diff1 - 1));\n\tConsole.Write(\"Maximum size is :\" + max_size + \"\\n\");\n\tConsole.Write(\"The First Array Is :\\n\");\n\tfor(int i = 0; i < max_size; i++)\n\t{\n\t\tConsole.Write(max1 + \" \");\n\t\tv[max1] -= 1;\n\t}\n\tConsole.Write(\"\\n\");\n\tConsole.Write(\"The Second Array Is :\\n\");\n\tfor(int i = 0; i < (n + 1); i++)\n\t{\n\t\tif (v[i] > 0)\n\t\t{\n\t\t\tConsole.Write(i + \" \");\n\t\t\tmax_size--;\n\t\t}\n\t\tif (max_size < 1)\n\t\t\tbreak;\n\t}\n\tConsole.Write(\"\\n\");\n}", "10768": "static int power(int x, int y, int p)\n{\n\tint res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif ((y & 1) == 1)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nstatic int modInverse(int n, int p)\n{\n\treturn power(n, p - 2, p);\n}\nstatic int nCrModPFermat(int n, int r, int p)\n{\n\tif (r == 0)\n\t\treturn 1;\n\tif (n < r)\n\t\treturn 0;\n\tint []fac = new int[n + 1];\n\tfac[0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tfac[i] = fac[i - 1] * i % p;\n\treturn (fac[n] * modInverse(fac[r], p) % p *\n\t\t\t\t\tmodInverse(fac[n - r], p) % p) % p;\n}\nstatic int SumOfXor(int []a, int n)\n{\n\tint mod = 10037;\n\tint answer = 0;\n\tfor(int k = 0; k < 32; k++)\n\t{\n\t\tint x = 0, y = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif ((a[i] & (1 << k)) != 0)\n\t\t\t\tx++;\n\t\t\telse\n\t\t\t\ty++;\n\t\t}\n\t\tanswer += ((1 << k) % mod *\n\t\t\t\t(nCrModPFermat(x, 3, mod) + x *\n\t\t\t\t\tnCrModPFermat(y, 2, mod)) % mod) % mod;\n\t}\n\treturn answer;\n}", "10801": "static int NthSmallest(int K)\n{\n\tList<int> Q = new List<int>();\n\tint x = 0;\n\tfor (int i = 1; i < 10; i++)\n\t\tQ.Add(i);\n\tfor (int i = 1; i <= K; i++) {\n\t\tx = Q[0];\n\t\tQ.RemoveAt(0);\n\t\tif (x % 10 != 0) {\n\t\t\tQ.Add(x * 10 + x % 10 - 1);\n\t\t}\n\t\tQ.Add(x * 10 + x % 10);\n\t\tif (x % 10 != 9) {\n\t\t\tQ.Add(x * 10 + x % 10 + 1);\n\t\t}\n\t}\n\treturn x;\n}", "10812": "public static float round(float var, int digit)\n{\n\tfloat value = (int)(var *\n\t\t\t\tMath.Pow(10, digit) + .5);\n\treturn (float)value /\n\t\t(float)Math.Pow(10, digit);\n}\npublic static int probability(int N)\n{\n\tint a = 2;\n\tint b = 3;\n\tif (N == 1)\n\t{\n\t\treturn a;\n\t}\n\telse if (N == 2)\n\t{\n\t\treturn b;\n\t}\n\telse\n\t{\n\t\tfor(int i = 3; i <= N; i++)\n\t\t{\n\t\t\tint c = a + b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn b;\n\t}\n}\npublic static float operations(int N)\n{\n\tint x = probability(N);\n\tint y = (int)Math.Pow(2, N);\n\treturn round((float)x /\n\t\t\t\t(float)y, 2);\n}", "10874": "static bool isPerfectCube(int x)\n\t{\n\t\tdouble cr = Math.Round(Math.Cbrt(x));\n\t\treturn (cr * cr * cr == x);\n\t}\nstatic void checkCube(int a, int b)\n\t{\n\t\tstring s1 = Convert.ToString(a);\n\t\tstring s2 = Convert.ToString(b);\n\t\tint c = Convert.ToInt32(s1 + s2);\n\t\tif (isPerfectCube(c)) {\n\t\t\t\tConsole.WriteLine(\"Yes\");\n\t\t}\n\t\telse {\n\t\t\t\tConsole.WriteLine(\"No\");\n\t\t}\n\t}", "10885": "static int largest_sum(int []arr, int n)\n\t{\n\t\tint maximum = -1;\n\t\tDictionary<int, int> m = new Dictionary<int, int>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (m.ContainsKey(arr[i])){\n\t\t\t\tm[arr[i]]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tm.Add(arr[i] , 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif (m[arr[i]] > 1) {\n\t\t\t\tif (m.ContainsKey(2*arr[i]))\n\t\t\t\t{\n\t\t\t\t\tm[2*arr[i]] = m[2 * arr[i]]+ m[arr[i]] / 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm.Add(2*arr[i],m[arr[i]] / 2);\n\t\t\t\t}\n\t\t\t\tif (2 * arr[i] > maximum)\n\t\t\t\t\tmaximum = 2 * arr[i];\n\t\t\t}\n\t\t\t}\n\t\treturn maximum;\n\t}", "10897": "static void canBeReduced(int x, int y)\n\t{\n\t\tint maxi = Math.Max(x, y);\n\t\tint mini = Math.Min(x, y);\n\t\tif (((x + y) % 3) == 0 && maxi <= 2*mini)\n\t\t\tConsole.WriteLine(\"YES\");\n\t\telse\n\t\t\tConsole.WriteLine(\"NO\");\n\t}", "10921": "static void isPrime(int N)\n{\n\tbool isPrime = true;\n\tint []arr = { 7, 11, 13, 17,19, 23, 29, 31 };\n\tif (N < 2) {\n\t\tisPrime = false;\n\t}\n\tif (N % 2 == 0 N % 3 == 0 N % 5 == 0) {\n\t\tisPrime = false;\n\t}\n\tfor (int i = 0; i < (int)Math.Sqrt(N); i += 30) {\n\t\tforeach (int c in arr) {\n\t\t\tif (c > (int)Math.Sqrt(N)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (N % (c + i) == 0) {\n\t\t\t\t\tisPrime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isPrime)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (isPrime)\n\t\tConsole.WriteLine(\"Prime Number\");\n\telse\n\t\tConsole.WriteLine(\"Not a Prime Number\");\n}", "10932": "static void printPairs(int []arr, int n)\n{\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tConsole.Write(\"(\" + arr[i]+ \", \" + arr[j]+ \")\" + \", \");\n\t\t}\n\t}\n}", "10936": "static int nearest(int n)\n\t{\n\t\tint prevSquare = (int)Math.Sqrt(n);\n\t\tint nextSquare = prevSquare + 1;\n\t\tprevSquare = prevSquare * prevSquare;\n\t\tnextSquare = nextSquare * nextSquare;\n\t\tint ans = (n - prevSquare) < (nextSquare - n)? (prevSquare - n): (nextSquare - n);\n\t\treturn ans;\n\t}", "10951": "static void printValueOfPi(int N)\n\t{\n\t\tdouble pi = 2 * Math.Acos(0.0);\n\t\tConsole.WriteLine(pi);\n\t}", "10952": "static int powOfPositive(int n)\n\t{\n\t\tint pos = (int)Math.Floor((Math.Log(n)/Math.Log(2)));\n\t\treturn (int)Math.Pow(2, pos);\n\t}\nstatic int powOfNegative(int n)\n\t{\n\t\tint pos = (int)Math.Ceiling((Math.Log(n)/Math.Log(2)));\n\t\treturn (int)(-1 * Math.Pow(2, pos));\n\t}\nstatic void highestPowerOf2(int n)\n\t{\n\t\tif (n > 0)\n\t\t{\n\t\t\tConsole.WriteLine(powOfPositive(n));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tn = -n;\n\t\t\tConsole.WriteLine(powOfNegative(n));\n\t\t}\n\t}", "10960": "public static int noOfCards(int n)\n\t{\n\t\treturn n * (3 * n + 1) / 2;\n\t}", "10974": "static String smallestPoss(String s, int n)\n{\n\tString ans = \"\";\n\tint []arr = new int[10];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tarr[s[i] - 48]++;\n\t}\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tfor (int j = 0; j < arr[i]; j++)\n\t\t\tans = ans + String.Join(\"\",i);\n\t}\n\treturn ans;\n}", "11014": "static int Count_subarray(int []arr, int n)\n{\n\tint subarray_sum, remaining_sum, count = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i; j < n; j++)\n\t\t{\n\t\t\tsubarray_sum = 0;\n\t\t\tremaining_sum = 0;\n\t\t\tfor (int k = i; k <= j; k++)\n\t\t\t{\n\t\t\t\tsubarray_sum += arr[k];\n\t\t\t}\n\t\t\tfor (int l = 0; l < i; l++)\n\t\t\t{\n\t\t\t\tremaining_sum += arr[l];\n\t\t\t}\n\t\t\tfor (int l = j + 1; l < n; l++)\n\t\t\t{\n\t\t\t\tremaining_sum += arr[l];\n\t\t\t}\n\t\t\tif (subarray_sum > remaining_sum)\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "11015": "static int Count_subarray(int []arr, int n)\n\t{\n\t\tint total_sum = 0, subarray_sum,\n\t\t\tremaining_sum, count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\ttotal_sum += arr[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tsubarray_sum = 0;\n\t\t\tfor (int j = i; j < n; j++)\n\t\t\t{\n\t\t\t\tsubarray_sum += arr[j];\n\t\t\t\tremaining_sum = total_sum - subarray_sum;\n\t\t\t\tif (subarray_sum > remaining_sum)\n\t\t\t\t{\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "11045": "static void decBinary(int []arr, int n)\n\t{\n\t\tint k = (int)(Math.Log(n) /\n\t\t\t\t\tMath.Log(2));\n\t\twhile (n > 0)\n\t\t{\n\t\t\tarr[k--] = n % 2;\n\t\t\tn /= 2;\n\t\t}\n\t}\nstatic int binaryDec(int []arr, int n)\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans += arr[i] << (n - i - 1);\n\t\treturn ans;\n\t}\nstatic int getNum(int n, int k)\n\t{\n\t\tint l = (int)(Math.Log(n) /\n\t\t\t\t\tMath.Log(2)) + 1;\n\t\tint []a = new int[l];\n\t\tdecBinary(a, n);\n\t\tif (k > l)\n\t\t\treturn n;\n\t\ta[k - 1] = (a[k - 1] == 0) ? 1 : 0;\n\t\treturn binaryDec(a, l);\n\t}", "11051": "static void find_composite_nos(int n)\n\t{\n\t\tConsole.WriteLine(9 * n + \" \" + 8 * n);\n\t}", "11052": "static int maxXOR(int []arr, int n)\n\t{\n\t\tint xorArr = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\txorArr ^= arr[i];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans = Math.Max(ans, (xorArr ^ arr[i]));\n\t\treturn ans;\n\t}", "11060": "static bool digitDividesK(int num, int k)\n\t{\n\t\twhile (num != 0)\n\t\t{\n\t\t\tint d = num % 10;\n\t\t\tif (d != 0 && k % d == 0)\n\t\t\t\treturn true;\n\t\t\tnum = num / 10;\n\t\t}\n\t\treturn false;\n\t}\nstatic int findCount(int l, int r, int k)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = l; i <= r; i++)\n\t\t{\n\t\t\tif (digitDividesK(i, k))\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "11088": "static Boolean isFactorial(int n)\n\t{\n\t\tfor (int i = 1;; i++)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (n == 1)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}", "11094": "static int lcm(int a, int b)\n{\n\tint GCD = __gcd(a, b);\n\treturn (a * b) / GCD;\n}\nstatic int MinLCM(int []a, int n)\n{\n\tint []Prefix = new int[n + 2];\n\tint []Suffix = new int[n + 2];\n\tPrefix[1] = a[0];\n\tfor (int i = 2; i <= n; i += 1)\n\t{\n\t\tPrefix[i] = lcm(Prefix[i - 1], a[i - 1]);\n\t}\n\tSuffix[n] = a[n - 1];\n\tfor (int i = n - 1; i >= 1; i -= 1)\n\t{\n\t\tSuffix[i] = lcm(Suffix[i + 1], a[i - 1]);\n\t}\n\tint ans = Math.Min(Suffix[2], Prefix[n - 1]);\n\tfor (int i = 2; i < n; i += 1)\n\t{\n\t\tans = Math.Min(ans, lcm(Prefix[i - 1], Suffix[i + 1]));\n\t}\n\treturn ans;\n}\nstatic int __gcd(int a, int b)\n{\n\treturn b == 0 ? a : __gcd(b, a % b);\t\n}", "11102": "static int diameter(int n)\n{\n\tint L, H;\n\tL = 1;\n\tH = 0;\n\tif (n == 1)\n\t{\n\t\treturn 1;\n\t}\n\tif (n == 2)\n\t{\n\t\treturn 2;\n\t}\n\tif (n == 3)\n\t{\n\t\treturn 3;\n\t}\n\twhile (L * 2 <= n)\n\t{\n\t\tL *= 2;\n\t\tH++;\n\t}\n\tif (n >= L * 2 - 1)\n\t\treturn 2 * H + 1;\n\telse if (n >= L + (L / 2) - 1)\n\t\treturn 2 * H;\n\treturn 2 * H - 1;\n}", "11139": "static int count(int n)\n{\n\treturn n * (3 * n - 1) / 2;\n}", "11180": "static int findMinValue(int []arr, int n)\n\t{\n\t\tlong sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += arr[i];\n\t\treturn ((int)(sum / n) + 1);\n\t}", "11182": "static int modFact(int n, int m)\n\t{\n\t\tint result = 1;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tresult = (result * i) % MOD;\n\t\treturn result;\n\t}", "11194": "static void preCompute()\n{\n\tfact[0] = 1;\n\tresult[0] = 1;\n\tfor (int i = 1; i <= MAX; i++)\n\t{\n\t\tfact[i] = ((fact[i - 1] % MOD) * i) % MOD;\n\t\tresult[i] = ((result[i - 1] % MOD) *\n\t\t\t\t\t(fact[i] % MOD)) % MOD;\n\t}\n}\nstatic void performQueries(int []q, int n)\n{\n\tpreCompute();\n\tfor (int i = 0; i < n; i++)\n\t\tConsole.WriteLine(result[q[i]]);\n}", "11196": "static long gcd(long a, long b)\n\t{\n\t\tif (a == 0)\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t\treturn gcd(b % a, a);\n\t}\nstatic long divTermCount(long a, long b, long c, long num)\n\t{\n\t\treturn ((num / a) + (num / b) + (num / c) -\n\t\t\t\t(num / ((a * b) / gcd(a, b))) -\n\t\t\t\t(num / ((c * b) / gcd(c, b))) -\n\t\t\t\t(num / ((a * c) / gcd(a, c))) +\n\t\t\t\t(num / ((a * b * c) / gcd(gcd(a, b), c))));\n\t}\nstatic long findNthTerm(int a, int b, int c, long n)\n\t{\n\t\tlong low = 1, high = long.MaxValue, mid;\n\t\twhile (low < high)\n\t\t{\n\t\t\tmid = low + (high - low) / 2;\n\t\t\tif (divTermCount(a, b, c, mid) < n)\n\t\t\t{\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn low;\n\t}", "11199": "static double calculate_angle(int n, int i, int j, int k)\n{\n\tint x, y;\n\tif (i < j)\n\t\tx = j - i;\n\telse\n\t\tx = j + n - i;\n\tif (j < k)\n\t\ty = k - j;\n\telse\n\t\ty = k + n - j;\n\tdouble ang1 = (180 * x) / n;\n\tdouble ang2 = (180 * y) / n;\n\tdouble ans = 180 - ang1 - ang2;\n\treturn ans;\n}", "11204": "static long power(int p)\n\t{\n\t\tlong res = 1;\n\t\tfor (int i = 1; i <= p; ++i)\n\t\t{\n\t\t\tres *= 2;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res % mod;\n\t}\nstatic long subset_square_sum(int []A)\n\t{\n\t\tint n = A.Length;\n\t\tlong ans = 0;\n\t\tforeach (int i in A)\n\t\t{\n\t\t\tans += (1 * i * i) % mod;\n\t\t\tans %= mod;\n\t\t}\n\t\treturn (1 * ans * power(n - 1)) % mod;\n\t}", "11217": "static void least_prime_factor()\n{\n\tfor (int i = 2; i < N; i++)\n\t\tif (lpf[i] == 0)\n\t\t\tfor (int j = i; j < N; j += i)\n\t\t\t\tif (lpf[j] == 0)\n\t\t\t\t\tlpf[j] = i;\n}\nstatic void Mobius()\n{\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (i == 1)\n\t\t\tmobius[i] = 1;\n\t\telse\n\t\t{\n\t\t\tif (lpf[i / lpf[i]] == lpf[i])\n\t\t\t\tmobius[i] = 0;\n\t\t\telse\n\t\t\t\tmobius[i] = -1 * mobius[i / lpf[i]];\n\t\t}\n\t}\n}\nstatic int gcd_pairs(int []a, int n)\n{\n\tint maxi = 0;\n\tint []fre = new int[N];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfre[a[i]]++;\n\t\tmaxi = Math.Max(a[i], maxi);\n\t}\n\tleast_prime_factor();\n\tMobius();\n\tint ans = 0;\n\tfor (int i = 1; i <= maxi; i++)\n\t{\n\t\tif (mobius[i] == 0)\n\t\t\tcontinue;\n\t\tint temp = 0;\n\t\tfor (int j = i; j <= maxi; j += i)\n\t\t\ttemp += fre[j];\n\t\tans += temp * (temp - 1) / 2 * mobius[i];\n\t}\n\treturn ans;\n}", "11253": "static void compareVal(double x, double y)\n{\n\tdouble a = y * Math.Log(x);\n\tdouble b = x * Math.Log(y);\n\tif (a > b)\n\t\tConsole.Write (x + \"^\" + y + \" > \" + y + \"^\" + x);\n\telse if (a < b)\n\t\t\tConsole.Write (x + \"^\" + y + \" < \"+ y + \"^\" + x);\n\telse if (a == b)\n\t\tConsole.Write (x + \"^\" + y + \" = \" + y + \"^\" + x );\n}", "11283": "static void compareValues(int a, int b, int c, int d)\n\t{\n\t\tdouble log1 = Math.Log10(a);\n\t\tdouble num1 = log1 * b;\n\t\tdouble log2 = Math.Log10(c);\n\t\tdouble num2 = log2 * d;\n\t\tif (num1 > num2)\n\t\t\tConsole.WriteLine(a + \"^\" + b);\n\t\telse\n\t\t\tConsole.WriteLine(c + \"^\" + d);\n\t}", "11294": "static void ZigZag(int n)\n{\n\tlong[] fact= new long[n + 1];\n\tlong[] zig = new long[n + 1];\n\tfor (int i = 0; i < n + 1; i++)\n\t\tzig[i] = 0;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfact[i] = fact[i - 1] * i;\n\tzig[0] = 1;\n\tzig[1] = 1;\n\tConsole.Write(\"zig zag numbers: \");\n\tConsole.Write(zig[0] + \" \" + zig[1] + \" \");\n\tfor (int i = 2; i < n; i++)\n\t{\n\t\tlong sum = 0;\n\t\tfor (int k = 0; k <= i - 1; k++)\n\t\t{\n\t\t\tsum += (fact[i - 1] / (fact[i - 1 - k] * fact[k])) * zig[k] * zig[i - 1 - k];\n\t\t}\n\t\tzig[i] = sum / 2;\n\t\tConsole.Write(sum / 2 + \" \" );\n\t}\n}", "11302": "static int find_count(List<int> ele)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 0; i < ele.Count; i++)\n\t\t{\n\t\t\tList<int> p = new List<int>();\n\t\t\tint c = 0, j;\n\t\t\tfor (j = ele.Count - 1;\n\t\t\t\tj >= (ele.Count - 1 - i) && j >= 0; j--)\n\t\t\t{\n\t\t\t\tp.Add(ele[j]);\n\t\t\t}\n\t\t\tj = ele.Count - 1;\n\t\t\tint k = 0;\n\t\t\twhile (j >= 0)\n\t\t\t{\n\t\t\t\tif (ele[j] != p[k])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj--;\n\t\t\t\tk++;\n\t\t\t\tif (k == p.Count)\n\t\t\t\t{\n\t\t\t\t\tc++;\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = Math.Max(count, c);\n\t\t}\n\t\treturn count;\n\t}\nstatic void solve(int n)\n\t{\n\t\tint count = 1;\n\t\tList<int> ele = new List<int>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tConsole.Write(count + \", \");\n\t\t\tele.Add(count);\n\t\t\tcount = find_count(ele);\n\t\t}\n\t}", "11306": "static List<int> addPrimes()\n{\n\tint n = MAX;\n\tBoolean []prime = new Boolean[n + 1];\n\tfor(int i = 0; i < n + 1; i++)\n\t\tprime[i]=true;\n\tfor (int p = 2; p * p <= n; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tList<int> ans = new List<int>();\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tans.Add(p);\n\treturn ans;\n}\nstatic Boolean is_prime(int n)\n{\n\treturn (n == 3 n == 5 n == 7);\n}\nstatic int find_Sum(int n)\n{\n\tint sum = 0;\n\tList<int> v = addPrimes();\n\tfor (int i = 0; i < v.Count && n > 0; i++)\n\t{\n\t\tint flag = 1;\n\t\tint a = v[i];\n\t\twhile (a != 0)\n\t\t{\n\t\t\tint d = a % 10;\n\t\t\ta = a / 10;\n\t\t\tif (is_prime(d))\n\t\t\t{\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == 1)\n\t\t{\n\t\t\tn--;\n\t\t\tsum = sum + v[i];\n\t\t}\n\t}\n\treturn sum;\n}", "11315": "static int Wedderburn(int n)\n{\n\tif (n <= 2)\n\t\treturn store[n];\n\telse if (n % 2 == 0)\n\t{\n\t\tint x = n / 2, ans = 0;\n\t\tfor (int i = 1; i < x; i++)\n\t\t{\n\t\t\tans += store[i] * store[n - i];\n\t\t}\n\t\tans += (store[x] * (store[x] + 1)) / 2;\n\t\tif(store.ContainsKey(n))\n\t\t{\n\t\t\tstore.Remove(n);\n\t\t\tstore.Add(n, ans);\n\t\t}\n\t\telse\n\t\t\tstore.Add(n, ans);\n\t\treturn ans;\n\t}\n\telse\n\t{\n\t\tint x = (n + 1) / 2, ans = 0;\n\t\tfor (int i = 1; i < x; i++)\n\t\t{\n\t\t\tans += store[i] * store[n - i];\n\t\t}\n\t\tif(store.ContainsKey(n))\n\t\t{\n\t\t\tstore.Remove(n);\n\t\t\tstore.Add(n, ans);\n\t\t}\n\t\telse\n\t\t\tstore.Add(n, ans);\n\t\treturn ans;\n\t}\n}\nstatic void Wedderburn_Etherington(int n)\n{\n\tstore.Add(0, 0);\n\tstore.Add(1, 1);\n\tstore.Add(2, 1);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tConsole.Write(Wedderburn(i));\n\t\tif(i != n - 1)\n\t\t\tConsole.Write(\" \");\n\t}\n}", "11331": "static int Max_sum(int[] a, int n)\n\t{\n\t\tint pos = 0, neg = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] > 0)\n\t\t\t\tpos = 1;\n\t\t\telse if (a[i] < 0)\n\t\t\t\tneg = 1;\n\t\t\tif ((pos == 1) && (neg == 1))\n\t\t\t\tbreak;\n\t\t}\n\t\tint sum = 0;\n\t\tif ((pos == 1) && (neg == 1))\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tsum += Math.Abs(a[i]);\n\t\t}\n\t\telse if (pos == 1)\n\t\t{\n\t\t\tint mini = a[0];\n\t\t\tsum = a[0];\n\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t{\n\t\t\t\tmini = Math.Min(mini, a[i]);\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\tsum -= 2 * mini;\n\t\t}\n\t\telse if (neg == 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = Math.Abs(a[i]);\n\t\t\tint mini = a[0];\n\t\t\tsum = a[0];\n\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t{\n\t\t\t\tmini = Math.Min(mini, a[i]);\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\tsum -= 2 * mini;\n\t\t}\n\t\treturn sum;\n\t}", "11342": "static void decimalToBinary(int n)\n\t{\n\t\tif (n == 0)\n\t\t{\n\t\t\tConsole.Write(\"0\");\n\t\t\treturn;\n\t\t}\n\t\tdecimalToBinary(n / 2);\n\t\tConsole.Write(n % 2);\n\t}", "11343": "static void MinimumValue(int x, int y)\n{\n\tif (x > y)\n\t{\n\t\tint temp = x;\n\t\t\tx = y;\n\t\t\ty = temp;\n\t}\n\tint a = 1;\n\tint b = x - 1;\n\tint c = y - b;\n\tConsole.WriteLine( a + \" \" + b + \" \" + c);\n}", "11370": "static bool canConvert(int a, int b)\n\t{\n\t\twhile (b > a)\n\t\t{\n\t\t\tif (b % 10 == 1)\n\t\t\t{\n\t\t\t\tb /= 10;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (b % 2 == 0)\n\t\t\t{\n\t\t\t\tb /= 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (b == a)\n\t\t\treturn true;\n\t\treturn false;\n\t}", "11387": "static int count(int N)\n\t{\n\t\tint a = 0;\n\t\ta = (N * (N + 1)) / 2;\n\t\treturn a;\n\t}", "11404": "static int numberOfDays(int a, int b, int n)\n\t{\n\t\tint Days = b * (n + a) / (a + b);\n\t\treturn Days;\n\t}", "11418": "static int getAverage(int x, int y)\n\t{\n\t\tint avg = (x & y) + ((x ^ y) >> 1);\n\t\treturn avg;\n\t}", "11435": "static int max_element(int[] a)\n{\n\tint m = a[0];\n\tfor(int i = 0; i < a.Length; i++)\n\t\tm = Math.Max(a[i], m);\n\treturn m;\n}\nstatic int primeCount(int[] arr, int n)\n{\n\tint max_val = max_element(arr);\n\tbool[] prime = new bool[max_val + 1];\n\tfor (int p = 0; p <= max_val; p++)\n\t\tprime[p] = true;\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (int p = 2; p * p <= max_val; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * 2; i <= max_val; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tint count = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (prime[arr[i]])\n\t\t\tcount++;\n\treturn count;\n}\nstatic int[] getPrefixArray(int[] arr, int n, int[] pre)\n{\n\tpre[0] = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tpre[i] = pre[i - 1] + arr[i];\n\t}\n\treturn pre;\n}", "11510": "static int smallestIndex(int []a, int n)\n{\n\tint right1 = 0, right0 = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] == 1)\n\t\t\tright1 = i;\n\t\telse\n\t\t\tright0 = i;\n\t}\n\treturn Math.Min(right1, right0);\n}", "11523": "static int freqPairs(int []arr, int n)\n\t{\n\t\tint max = arr.Max();\n\t\tint []freq = new int[max + 1];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfreq[arr[i]]++;\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 2 * arr[i]; j <= max; j += arr[i])\n\t\t\t{\n\t\t\t\tif (freq[j] >= 1)\n\t\t\t\t{\n\t\t\t\t\tcount += freq[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (freq[arr[i]] > 1)\n\t\t\t{\n\t\t\t\tcount += freq[arr[i]] - 1;\n\t\t\t\tfreq[arr[i]]--;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "11533": "static int countSquares(int r, int c, int m)\n\t{\n\t\tint squares = 0;\n\t\tfor (int i = 1; i <= 8; i++) {\n\t\t\tfor (int j = 1; j <= 8; j++) {\n\t\t\t\tif (Math.Max(Math.Abs(i - r), Math.Abs(j - c)) <= m)\n\t\t\t\t\tsquares++;\n\t\t\t}\n\t\t}\n\t\treturn squares;\n\t}", "11549": "static void Loss(int SP, int P)\n{\n\tdouble loss = 0;\n\tloss = (double)(2 * P * P * SP) / (100 * 100 - P * P);\n\tSystem.Console.WriteLine(\"Loss = \" +\n\t\t\t\t\t\t\tSystem.Math.Round(loss,3));\n}", "11611": "static void sieve()\n{\n\tspf[1] = 1;\n\tfor (int i = 2; i < MAXN; i++)\n\t\tspf[i] = i;\n\tfor (int i = 4; i < MAXN; i += 2)\n\t\tspf[i] = 2;\n\tfor (int i = 3; i * i < MAXN; i++)\n\t{\n\t\tif (spf[i] == i)\n\t\t{\n\t\t\tfor (int j = i * i; j < MAXN; j += i)\n\t\t\t\tif (spf[j] == j)\n\t\t\t\t\tspf[j] = i;\n\t\t}\n\t}\n}\nstatic void getFactorization(int x)\n{\n\tint temp;\n\twhile (x != 1)\n\t{\n\t\ttemp = spf[x];\n\t\tif (x % temp == 0)\n\t\t{\n\t\t\thash1[spf[x]]++;\n\t\t\tx = x / spf[x];\n\t\t}\n\t\twhile (x % temp == 0)\n\t\t\tx = x / temp;\n\t}\n}\nstatic bool check(int x)\n{\n\tint temp;\n\twhile (x != 1)\n\t{\n\t\ttemp = spf[x];\n\t\tif (x % temp == 0 && hash1[temp] > 1)\n\t\t\treturn false;\n\t\twhile (x % temp == 0)\n\t\t\tx = x / temp;\n\t}\n\treturn true;\n}\nstatic bool hasValidNum(int []arr, int n)\n{\n\tsieve();\n\tfor (int i = 0; i < n; i++)\n\t\tgetFactorization(arr[i]);\n\tfor (int i = 0; i < n; i++)\n\t\tif (check(arr[i]))\n\t\t\treturn true;\n\treturn false;\n}", "11613": "static int countQuadruples(int []a, int n)\n\t{\n\t\tDictionary<int, int> mp = new Dictionary<int, int>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (mp.ContainsKey(a[i]))\n\t\t\t{\n\t\t\t\tmp[a[i]] = mp[a[i]] + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.Add(a[i], 1);\n\t\t\t}\n\t\tint count = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tmp[a[j]] = mp[a[j]] - 1;\n\t\t\t\tmp[a[k]] = mp[a[k]] - 1;\n\t\t\t\tint first = a[j] - (a[k] - a[j]);\n\t\t\t\tint fourth = (a[k] * a[k]) / a[j];\n\t\t\t\tif ((a[k] * a[k]) % a[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (a[j] != a[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mp.ContainsKey(first) && mp.ContainsKey(fourth))\n\t\t\t\t\t\t\tcount += mp[first] * mp[fourth];\n\t\t\t\t\t}\n\t\t\t\t\telse if (mp.ContainsKey(first) && mp.ContainsKey(fourth))\n\t\t\t\t\t\tcount += mp[first] * (mp[fourth] - 1);\n\t\t\t\t}\n\t\t\t\tif (mp.ContainsKey(a[j]))\n\t\t\t\t{\n\t\t\t\t\tmp[a[j]] = mp[a[j]] + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp.Add(a[j], 1);\n\t\t\t\t}\n\t\t\t\tif (mp.ContainsKey(a[k]))\n\t\t\t\t{\n\t\t\t\t\tmp[a[k]] = mp[a[k]] + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp.Add(a[k], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "11626": "static int countNumbers(int L, int R, int K)\n\t{\n\t\tif (K == 9)\n\t\t{\n\t\t\tK = 0;\n\t\t}\n\t\tint totalnumbers = R - L + 1;\n\t\tint factor9 = totalnumbers / 9;\n\t\tint rem = totalnumbers % 9;\n\t\tint ans = factor9;\n\t\tfor (int i = R; i > R - rem; i--)\n\t\t{\n\t\t\tint rem1 = i % 9;\n\t\t\tif (rem1 == K)\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}", "11627": "static int countWays(int N)\n{\n\tint E = (N * (N - 1)) / 2;\n\tif (N == 1)\n\t\treturn 0;\n\treturn (int)Math.Pow(2, E - 1);\n}", "11629": "static void BalanceArray(int [] A, int [, ] Q)\n\t{\n\t\tint [] ANS = new int [A.Length];\n\t\tint i, sum = 0;\n\t\tfor (i = 0; i < A.Length; i++)\n\t\t\tif (A[i] % 2 == 0)\n\t\t\t\tsum = sum + A[i];\n\t\tfor (i = 0; i < Q.GetLength(0); i++)\n\t\t{\n\t\t\tint index = Q[i, 0];\n\t\t\tint value = Q[i, 1];\n\t\t\tif (A[index] % 2 == 0)\n\t\t\t\tsum = sum - A[index];\n\t\t\tA[index] = A[index] + value;\n\t\t\tif (A[index] % 2 == 0)\n\t\t\t\tsum = sum + A[index];\n\t\t\tANS[i]= sum;\n\t\t}\n\t\tfor (i = 0; i < ANS.Length; i++)\n\t\t\tConsole.Write(ANS[i] + \" \");\n\t}", "11658": "static int Cycles(int N)\n{\n\tint fact = 1, result = 0;\n\tresult = N - 1;\n\tint i = result;\n\twhile (i > 0)\n\t{\n\t\tfact = fact * i;\n\t\ti--;\n\t}\n\treturn fact / 2;\n}", "11667": "static int findAndSum(int []arr, int n)\n{\n\tint sum = 0;\n\tint mul = 1;\n\tfor (int i = 0; i < 30; i++)\n\t{\n\t\tbool count_on = false;\n\t\tint l = 0;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif ((arr[j] & (1 << i)) > 0)\n\t\t\t\tif (count_on)\n\t\t\t\t\tl++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount_on = true;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\telse if (count_on)\n\t\t\t{\n\t\t\t\tsum += ((mul * l * (l + 1)) / 2);\n\t\t\t\tcount_on = false;\n\t\t\t\tl = 0;\n\t\t\t}\n\t\t}\n\t\tif (count_on)\n\t\t{\n\t\t\tsum += ((mul * l * (l + 1)) / 2);\n\t\t\tcount_on = false;\n\t\t\tl = 0;\n\t\t}\n\t\tmul *= 2;\n\t}\n\treturn sum;\n}", "11677": "static void initialize()\n\t{\n\t\tl[0, 0] = 1;\n\t\tfor (int i = 1; i < 1001; i++) {\n\t\t\tl[i, 0] = 1;\n\t\t\tfor (int j = 1; j < i + 1; j++) {\n\t\t\t\tl[i, j] = (l[i - 1, j - 1] + l[i - 1, j]);\n\t\t\t}\n\t\t}\n\t}\nstatic int nCr(int n, int r)\n\t{\n\t\treturn l[n, r];\n\t}", "11687": "static int minValue(int n, int x, int y)\n\t{\n\t\tfloat val = (y * n) / 100;\n\t\tif (x >= val)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn (int)(Math.Ceiling(val)-x) ;\n\t}", "11707": "static bool digitWell(int n, int m, int k)\n{\n\tint cnt = 0;\n\twhile (n > 0)\n\t{\n\t\tif (n % 10 == m)\n\t\t\t++cnt;\n\t\tn /= 10;\n\t}\n\treturn cnt == k;\n}\nstatic int findInt(int n, int m, int k)\n{\n\tint i = n + 1;\n\twhile (true)\n\t{\n\t\tif (digitWell(i, m, k))\n\t\t\treturn i;\n\t\ti++;\n\t}\n}", "11709": "static int minAbsDiff(int n)\n\t{\n\t\tint mod = n % 4;\n\t\tif (mod == 0 mod == 3)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}", "11722": "static int countOdd(int [] arr, int n)\n\t{\n\t\tint odd = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] % 2 == 1)\n\t\t\t\todd++;\n\t\t}\n\t\treturn odd;\n\t}\nstatic int countValidPairs(int [] arr, int n)\n\t{\n\t\tint odd = countOdd(arr, n);\n\t\treturn (odd * (odd - 1)) / 2;\n\t}", "11748": "static int gcd(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\nstatic int lcmOfArray(int []arr, int n)\n{\n\tif (n < 1)\n\t\treturn 0;\n\tint lcm = arr[0];\n\tfor (int i = 1; i < n; i++)\n\t\tlcm = (lcm * arr[i]) / gcd(lcm, arr[i]);\n\treturn lcm;\n}\nstatic int minPerfectCube(int []arr, int n)\n{\n\tint minPerfectCube;\n\tint lcm = lcmOfArray(arr, n);\n\tminPerfectCube = lcm;\n\tint cnt = 0;\n\twhile (lcm > 1 && lcm % 2 == 0)\n\t{\n\t\tcnt++;\n\t\tlcm /= 2;\n\t}\n\tif (cnt % 3 == 2)\n\t\tminPerfectCube *= 2;\n\telse if (cnt % 3 == 1)\n\t\tminPerfectCube *= 4;\n\tint i = 3;\n\twhile (lcm > 1)\n\t{\n\t\tcnt = 0;\n\t\twhile (lcm % i == 0)\n\t\t{\n\t\t\tcnt++;\n\t\t\tlcm /= i;\n\t\t}\n\t\tif (cnt % 3 == 1)\n\t\t\tminPerfectCube *= i * i;\n\t\telse if (cnt % 3 == 2)\n\t\t\tminPerfectCube *= i;\n\t\ti += 2;\n\t}\n\treturn minPerfectCube;\n}", "11772": "static bool isPrime(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nstatic bool isStrongPrime(int n)\n\t{\n\t\tif (!isPrime(n) n == 2)\n\t\t\treturn false;\n\t\tint previous_prime = n - 1;\n\t\tint next_prime = n + 1;\n\t\twhile (!isPrime(next_prime))\n\t\t\tnext_prime++;\n\t\twhile (!isPrime(previous_prime))\n\t\t\tprevious_prime--;\n\t\tint mean = (previous_prime + next_prime) / 2;\n\t\tif (n > mean)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "11774": "static bool isPrime(long n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nstatic bool isFactorialPrime(long n)\n\t{\n\t\tif (!isPrime(n))\n\t\t\treturn false;\n\t\tlong fact = 1;\n\t\tint i = 1;\n\t\twhile (fact <= n + 1) {\n\t\t\tfact = fact * i;\n\t\t\tif (n + 1 == fact n - 1 == fact)\n\t\t\t\treturn true;\n\t\t\ti++;\n\t\t}\n\t\treturn false;\n\t}", "11815": "static int countDigitsToBeRemoved(int N, int K)\n\t{\n\t\tstring s = Convert.ToString(N);\n\t\tint res = 0;\n\t\tint f_zero = 0;\n\t\tfor (int i = s.Length - 1; i >= 0; i--) {\n\t\t\tif (K == 0)\n\t\t\t\treturn res;\n\t\t\tif (s[i] == '0') {\n\t\t\t\tf_zero = 1;\n\t\t\t\tK--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tres++;\n\t\t}\n\t\tif (K == 0)\n\t\t\treturn res;\n\t\telse if (f_zero == 1)\n\t\t\treturn s.Length - 1;\n\t\treturn -1;\n\t}", "11906": "public static double getSum(int a, int n)\n{\n\tdouble sum = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tsum += (i / Math.Pow(a, i));\n\t}\n\treturn sum;\n}", "11948": "static bool check(int s)\n{\n\tint[] freq = new int[10];\n\tint r, i;\n\tfor(i = 0; i < 10; i++)\n\t{\n\t\tfreq[i]= 0;\n\t}\n\twhile(s != 0)\n\t{\n\t\tr = s % 10;\n\t\ts = (int)(s / 10);\n\t\tfreq[r] += 1;\n\t}\n\tint xor__ = 0;\n\tfor ( i = 0; i < 10; i++)\n\t{\n\txor__ = xor__ ^ freq[i];\n\tif(xor__ == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n\t}\n\treturn true;\n}", "11998": "static int largestPrimeFactor(int n)\n\t{\n\t\tint max = -1;\n\t\twhile (n % 2 == 0) {\n\t\t\tmax = 2;\n\t\t}\n\t\tfor (int i = 3; i <= Math.Sqrt(n); i += 2) {\n\t\t\twhile (n % i == 0) {\n\t\t\t\tmax = i;\n\t\t\t\tn = n / i;\n\t\t\t}\n\t\t}\n\t\tif (n > 2)\n\t\t\tmax = n;\n\t\treturn max;\n\t}\nstatic bool checkUnusual(int n)\n\t{\n\t\tint factor = largestPrimeFactor(n);\n\t\tif (factor > Math.Sqrt(n)) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}", "12002": "static double Nth_Term(int n)\n{\n\treturn (2 * Math.Pow(n, 3) - 3 *\n\t\t\t\tMath.Pow(n, 2) + n + 6) / 6;\n}", "12035": "static void isHalfReducible(int[] arr, int n, int m)\n\t{\n\t\tint[] frequencyHash = new int[m + 1];\n\t\tint i;\n\t\tfor(i = 0 ; i < frequencyHash.Length ; i++)\n\t\t\tfrequencyHash[i] = 0 ;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfrequencyHash[arr[i] % (m + 1)]++;\n\t\t}\n\t\tfor (i = 0; i <= m; i++) {\n\t\t\tif (frequencyHash[i] >= n / 2)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i <= m)\n\t\t\tConsole.WriteLine(\"Yes\") ;\n\t\telse\n\t\t\tConsole.WriteLine(\"No\") ;\n\t}", "12037": "static void generateDivisors(int n)\n{\n\tfor (int i = 1; i <= Math.Sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (n / i == i)\n\t\t\t\tarr.Add(i);\n\t\t\t{\n\t\t\t\tarr.Add(i);\n\t\t\t\tarr.Add(n / i);\n\t\t\t}\n\t\t}\n\t}\n}\nstatic double harmonicMean(int n)\n{\n\tgenerateDivisors(n);\n\tdouble sum = 0.0;\n\tint len = arr.Count;\n\tfor (int i = 0; i < len; i++)\n\t\tsum = sum + n / (int)arr[i];\n\tsum = sum / n;\n\treturn arr.Count / sum;\n}\nstatic bool isOreNumber(int n)\n{\n\tdouble mean = harmonicMean(n);\n\tif (mean - Math.Floor(mean) == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "12058": "", "12070": "static void printLines(int n, int k)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tConsole.WriteLine ( k * (6 * i + 1) + \" \" +\n\t\t\t\t\t\t\tk * (6 * i + 2) + \" \" +\n\t\t\t\t\t\t\tk * (6 * i + 3) + \" \" +\n\t\t\t\t\t\t\tk * (6 * i + 5) );\n\t}\n}", "12076": "static void SieveOfEratosthenes()\n\t{\n\t\tbool[] prime = new bool[MAX];\n\t\tfor (int i = 0; i < MAX; i++)\n\t\t\tprime[i] = true;\n\t\tfor (int p = 2; p * p < MAX; p++)\n\t\t{\n\t\t\tif (prime[p] == true)\n\t\t\t{\n\t\t\t\tfor (int i = p * 2; i < MAX; i += p)\n\t\t\t\t\tprime[i] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int p = 2; p < MAX; p++)\n\t\t\tif (prime[p])\n\t\t\t\tarr.Add(p);\n\t}\nstatic bool isEuclid(long n)\n\t{\n\t\tlong product = 1;\n\t\tint i = 0;\n\t\twhile (product < n)\n\t\t{\n\t\t\tproduct = product * arr[i];\n\t\t\tif (product + 1 == n)\n\t\t\t\treturn true;\n\t\t\ti++;\n\t\t}\n\t\treturn false;\n\t}", "12077": "static void SieveOfEratosthenes()\n{\n\tBoolean []prime = new Boolean[MAX];\n\tfor (int p = 0; p < MAX; p++)\n\t\tprime[p] = true;\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (int p = 2; p * p < MAX; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * 2; i < MAX; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tint product = 1;\n\tfor (int p = 2; p < MAX; p++)\n\t{\n\t\tif (prime[p])\n\t\t{\n\t\t\tproduct = product * p;\n\t\t\ts.Add(product + 1);\n\t\t}\n\t}\n}\nstatic Boolean isEuclid(int n)\n{\n\tif (s.Contains(n))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "12078": "static bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t{\n\t\tif (n % i == 0 ||\n\t\t\tn % (i + 2) == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nstatic bool isPowerOfTwo(int n)\n{\n\treturn n != 0 && ((n & (n - 1)) == 0);\n}", "12117": "static float area(float a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tfloat area = (float)Math.Pow((a * Math.Sqrt(3)) /\n\t\t\t\t\t\t\t\t(Math.Sqrt(2)), 2);\n\treturn area;\n}", "12147": "static int nthTerm(int n)\n{\n\treturn 3 * (int) Math.Pow(n, 2) -\n\t\t\t\t\t\t4 * n + 2;\n}", "12157": "public void calculateSum(int n)\n\t{\n\t\tdouble r = (n * (n + 1) / 2 +\n\t\t\t\tMath.Pow((n * (n + 1) / 2), 2));\n\t\tConsole.WriteLine(\"Sum = \" + r);\n\t}", "12170": "", "12180": "static int printNthElement(int n)\n{\n\tint [] arr = new int[n + 1];\n\tarr[1] = 3;\n\tarr[2] = 5;\n\tfor (int i = 3; i <= n; i++)\n\t{\n\t\tif (i % 2 != 0)\n\t\t\tarr[i] = arr[i / 2] * 10 + 3;\n\t\telse\n\t\t\tarr[i] = arr[(i / 2) - 1] * 10 + 5;\n\t}\n\treturn arr[n];\n}", "12185": "static bool arePermutations(int[] a, int[] b, int n, int m)\n{\n\tint sum1 = 0, sum2 = 0,\n\t\tmul1 = 1, mul2 = 1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tsum1 += a[i];\n\t\tmul1 *= a[i];\n\t}\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tsum2 += b[i];\n\t\tmul2 *= b[i];\n\t}\n\treturn ((sum1 == sum2) &&\n\t\t\t(mul1 == mul2));\n}", "12191": "static int nextPerfectCube(int N)\n{\n\tint nextN = (int)Math.Floor(Math.Pow(N,\n\t\t\t\t\t\t(double)1/3)) + 1;\n\treturn nextN * nextN * nextN;\n}", "12192": "public int nthTerm(int N)\n{\n\treturn (N * ((N / 2) +\n\t\t((N % 2) * 2) + N));\n}", "12225": "static int Race(int B, int C)\n{\n\tint result = 0;\n\tresult = ((C * 100) / B);\n\treturn 100 - result;\n}", "12228": "static int calculateSum(int n)\n{\n\treturn ((int)Math.Pow(2, n + 1) + n - 2);\n}", "12239": "static float Time(float []arr, int n, float Emptypipe)\n{\n\tfloat fill = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfill += 1 / arr[i];\n\tfill = fill - (1 / (float)Emptypipe);\n\treturn 1 / fill;\n}", "12261": "static bool isPrime(int n)\n{\n\tint i, c = 0;\n\tfor (i = 1; i < n / 2; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tc++;\n\t\t}\n\t}\n\tif (c == 1)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nstatic void findMinNum(int[] arr, int n)\n{\n\tint first = 0, last = 0, num, rev, i;\n\tint[] hash = new int[10];\n\tfor (i = 0; i < n; i++)\n\t{\n\t\thash[arr[i]]++;\n\t}\n\tConsole.Write(\"Minimum number: \");\n\tfor (i = 0; i <= 9; i++)\n\t{\n\t\tfor (int j = 0; j < hash[i]; j++)\n\t\t{\n\t\t\tConsole.Write(i);\n\t\t}\n\t}\n\tConsole.WriteLine();\n\tConsole.WriteLine();\n\tfor (i = 0; i <= 9; i++)\n\t{\n\t\tif (hash[i] != 0)\n\t\t{\n\t\t\tfirst = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 9; i >= 0; i--)\n\t{\n\t\tif (hash[i] != 0)\n\t\t{\n\t\t\tlast = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnum = first * 10 + last;\n\trev = last * 10 + first;\n\tConsole.Write(\"Prime combinations: \");\n\tif (isPrime(num) && isPrime(rev))\n\t{\n\t\tConsole.WriteLine(num + \" \" + rev);\n\t}\n\telse if (isPrime(num))\n\t{\n\t\tConsole.WriteLine(num);\n\t}\n\telse if (isPrime(rev))\n\t{\n\t\tConsole.WriteLine(rev);\n\t}\n\telse\n\t{\n\t\tConsole.WriteLine(\"No combinations exist\");\n\t}\n}", "12264": "static int check(int n)\n\t{\n\t\t\tint sum = 0;\n\t\twhile (n != 0)\n\t\t{\n\t\t\tsum += n % 10;\n\t\t\tn = n / 10;\n\t\t}\n\tif (sum % 7 == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "12314": "static bool isPrime(int n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 ||\n\t\t\tn % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nstatic int SumOfPrimeDivisors(int n)\n{\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (isPrime(i))\n\t\t\t\tsum += i;\n\t\t}\n\t}\n\treturn sum;\n}", "12315": "static int Sum(int N)\n{\n\tint []SumOfPrimeDivisors = new int[N + 1];\n\tfor (int i = 2; i <= N; ++i)\n\t{\n\t\tif (SumOfPrimeDivisors[i] == 0)\n\t\t{\n\t\t\tfor (int j = i; j <= N; j += i)\n\t\t\t{\n\t\t\t\tSumOfPrimeDivisors[j] += i;\n\t\t\t}\n\t\t}\n\t}\n\treturn SumOfPrimeDivisors[N];\n}", "12316": "static bool isPrime(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nstatic int SumOfPrimeDivisors(int n)\n\t{\n\t\tint sum = 0;\n\t\tint root_n = (int)Math.Sqrt(n);\n\t\tfor (int i = 1; i <= root_n; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tif (i == n / i && isPrime(i)) {\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (isPrime(i)) {\n\t\t\t\t\t\tsum += i;\n\t\t\t\t\t}\n\t\t\t\t\tif (isPrime(n / i)) {\n\t\t\t\t\t\tsum += (n / i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}", "12333": "static int findNthNonSquare(int n)\n{\n\tdouble x = (double)n;\n\tdouble ans = x + Math.Floor(0.5 +\n\t\t\t\t\tMath.Sqrt(x));\n\treturn (int)ans;\n}", "12340": "static long power(long x, long y, long p)\n{\n\tlong res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif ((y & 1) > 0)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}", "12422": "static string find_Square_369(string num)\n\t{\n\t\tchar a, b, c, d;\n\t\tif (num[0] == '3')\n\t\t\t{a = '1'; b = '0'; c = '8'; d = '9';}\n\t\telse if (num[0] == '6')\n\t\t\t{a = '4'; b = '3'; c = '5'; d = '6';}\n\t\telse\n\t\t\t{a = '9'; b = '8'; c = '0'; d = '1';}\n\t\tstring result = \"\";\n\t\tint size = num.Length;\n\t\tfor (int i = 1; i < size; i++)\n\t\t\tresult += a;\n\t\tresult += b;\n\t\tfor (int i = 1; i < size; i++)\n\t\t\tresult += c;\n\t\tresult += d;\n\t\treturn result;\n\t}", "12430": "", "12439": "static int findpos(String n)\n{\n\tint pos = 0;\n\tfor (int i = 0; i < n.Length; i++)\n\t{\n\t\tswitch (n[i])\n\t\t{\n\t\tcase '2':\n\t\t\tpos = pos * 4 + 1;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tpos = pos * 4 + 2;\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tpos = pos * 4 + 3;\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tpos = pos * 4 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn pos;\n}", "12462": "static int fact(int n)\n\t{\n\t\tif (n == 0 n == 1)\n\t\t\treturn 1 ;\n\t\tint ans = 1;\n\t\tfor (int i = 1 ; i <= n; i++)\n\t\t\tans = ans * i ;\n\t\treturn ans ;\n\t}\nstatic int nCr(int n, int r)\n\t{\n\t\tint Nr = n , Dr = 1 , ans = 1;\n\t\tfor (int i = 1 ; i <= r ; i++ )\n\t\t{\n\t\t\tans = ( ans * Nr ) / ( Dr ) ;\n\t\t\tNr-- ;\n\t\t\tDr++ ;\n\t\t}\n\t\treturn ans ;\n\t}\nstatic int solve ( int n )\n\t{\n\t\tint N = 2 * n - 2 ;\n\t\tint R = n - 1 ;\n\t\treturn nCr (N, R) * fact(n - 1) ;\n\t}", "12485": "static int gcd(int a, int b)\n\t{\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\nstatic bool coprime(int a, int b)\n\t{\n\t\treturn (gcd(a, b) == 1);\n\t}\nstatic void possibleTripletInRange(int L, int R)\n\t{\n\t\tbool flag = false;\n\t\tint possibleA = 0,\n\t\t\tpossibleB = 0,\n\t\t\tpossibleC = 0;\n\t\tfor (int a = L; a <= R; a++)\n\t\t{\n\t\t\tfor (int b = a + 1; b <= R; b++)\n\t\t\t{\n\t\t\t\tfor (int c = b + 1; c <= R; c++)\n\t\t\t\t{\n\t\t\t\t\tif (coprime(a, b) &&\n\t\t\t\t\t\tcoprime(b, c) &&\n\t\t\t\t\t!coprime(a, c))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tpossibleA = a;\n\t\t\t\t\t\tpossibleB = b;\n\t\t\t\t\t\tpossibleC = c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag == true)\n\t\t{\n\t\t\tConsole.WriteLine(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible triplet \" + \"between \" + L + \" and \" + R);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConsole.WriteLine(\"No Such Triplet exists\" + \"between \" + L + \" and \" + R);\n\t\t}\n\t}", "12486": "static void possibleTripletInRange(int L, int R)\n{\n\tbool flag = false;\n\tint possibleA = 0,\n\t\tpossibleB = 0,\n\t\tpossibleC = 0;\n\tint numbersInRange = (R - L + 1);\n\tif (numbersInRange < 3)\n\t{\n\t\tflag = false;\n\t}\n\telse if (numbersInRange > 3)\n\t{\n\t\tflag = true;\n\t\tif (L % 2 > 0)\n\t\t{\n\t\t\tL++;\n\t\t}\n\t\tpossibleA = L;\n\t\tpossibleB = L + 1;\n\t\tpossibleC = L + 2;\n\t}\n\telse\n\t{\n\t\tif (!(L % 2 > 0))\n\t\t{\n\t\t\tflag = true;\n\t\t\tpossibleA = L;\n\t\t\tpossibleB = L + 1;\n\t\t\tpossibleC = L + 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t}\n\tif (flag == true)\n\t{\n\t\t\tConsole.WriteLine(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible\" + \" triplet between \" + L + \" and \" + R );\n\t}\n\telse {\n\t\tConsole.WriteLine(\"No Such Triplet\" + \" exists between \" + L + \" and \" + R);\n\t}\n}", "12496": "public static bool possibleToReach(int a, int b)\n\t{\n\t\tint c = (int)Math.Pow(a * b, (double) 1 / 3);\n\t\tint re1 = a / c;\n\t\tint re2 = b / c;\n\t\tif ((re1 * re1 * re2 == a) &&\n\t\t\t(re2 * re2 * re1 == b))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "12520": "public static bool isUndulating(string n)\n\t{\n\t\t\tif (n.Length <= 2)\n\t\t\t\treturn false;\n\t\tfor (int i = 2; i < n.Length; i++)\n\t\t\tif (n[i-2] != n[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "12523": "static void pythagoreanTriplet(int n)\n\t{\n\t\tfor (int i = 1; i <= n / 3; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j <= n / 2; j++)\n\t\t\t{\n\t\t\t\tint k = n - i - j;\n\t\t\t\tif (i * i + j * j == k * k)\n\t\t\t\t{\n\t\t\t\t\tConsole.Write(i + \", \"+ j + \", \" + k);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.Write(\"No Triplet\");\n\t}", "12532": "static int factorial(int n)\n\t{\n\t\tint f = 1;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t\tf *= i;\n\t\treturn f;\n\t}\nstatic void series(int A, int X, int n)\n\t{\n\t\tint nFact = factorial(n);\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\tint niFact = factorial(n - i);\n\t\t\tint iFact = factorial(i);\n\t\t\tint aPow = (int)Math.Pow(A, n - i);\n\t\t\tint xPow = (int)Math.Pow(X, i);\n\t\t\tConsole.Write((nFact * aPow * xPow)\n\t\t\t\t\t/ (niFact * iFact) + \" \");\n\t\t}\n\t}", "12533": "static void series(int A, int X, int n)\n\t{\n\t\tint term = (int)Math.Pow(A, n);\n\t\tConsole.Write(term + \" \");\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tterm = term * X * (n - i + 1)\n\t\t\t\t\t\t\t\t/ (i * A);\n\t\tConsole.Write(term + \" \");\n\t\t}\n\t}", "12547": "static int seiresSum(int n, int[] a)\n\t{\n\t\tint res = 0, i;\n\t\tfor (i = 0; i < 2 * n; i++)\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t\tres += a[i] * a[i];\n\t\t\telse\n\t\t\t\tres -= a[i] * a[i];\n\t\t}\n\t\treturn res;\n\t}", "12548": "static int seiresSum(int n, int[] a)\n\t{\n\treturn n * (a[0] * a[0] - a[2 * n - 1] * a[2 * n - 1]) / (2 * n - 1);\n\t}", "12550": "public static bool checkdigit(int n, int k)\n\t{\n\t\twhile (n != 0)\n\t\t{\n\t\t\tint rem = n % 10;\n\t\t\tif (rem == k)\n\t\t\t\treturn true;\n\t\t\tn = n / 10;\n\t\t}\n\t\treturn false;\n\t}\npublic static int findNthNumber(int n, int k)\n\t{\n\t\tfor (int i = k + 1, count = 1; count < n; i++)\n\t\t{\n\t\t\tif (checkdigit(i, k) || (i % k == 0))\n\t\t\t\tcount++;\n\t\t\tif (count == n)\n\t\t\t\treturn i;\n\t\t}\n\treturn -1;\n\t}", "12561": "static int power(int n, int r) {\n\tint count = 0;\n\tfor (int i = r; (n / i) >= 1; i = i * r)\n\tcount += n / i;\n\treturn count;\n}", "12564": "static int digitNumber(long n) {\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\tif (n == 1)\n\t\t\treturn 9;\n\t\tif (n % 2 != 0) {\n\t\t\tint temp = digitNumber((n - 1) / 2) % mod;\n\t\t\treturn (9 * (temp * temp) % mod) % mod;\n\t\t}\n\t\telse {\n\t\t\tint temp = digitNumber(n / 2) % mod;\n\t\t\treturn (temp * temp) % mod;\n\t\t}\n\t}\nstatic int countExcluding(int n, int d) {\n\t\tif (d == 0)\n\t\t\treturn (9 * digitNumber(n - 1)) % mod;\n\t\telse\n\t\t\treturn (8 * digitNumber(n - 1)) % mod;\n\t}", "12587": "static bool Div_by_8(int n)\t\t\n {\t\t\n return (((n >> 3) << 3) == n);\t\t\n }", "12603": "static int avg_of_odd_num(int n)\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsum += (2 * i + 1);\n\t\treturn sum / n;\n\t}", "12604": "static int avg_of_odd_num(int n)\n\t{\n\t\treturn n;\n\t}", "12615": "static void fib(int[] f, int N)\n\t{\n\t\tf[1] = 1;\n\t\tf[2] = 1;\n\t\tfor (int i = 3; i <= N; i++)\n\t\t\tf[i] = f[i - 1] + f[i - 2];\n\t}\nstatic void fiboTriangle(int n)\n\t{\n\t\tint N = n * (n + 1) / 2;\n\t\tint[] f = new int[N + 1];\n\t\tfib(f, N);\n\t\tint fiboNum = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tConsole.Write(f[fiboNum++] + \" \");\n\t\t\tConsole.WriteLine();\n\t\t}\n\t}", "12638": "static int averageEven(int n)\n\t{\n\t\tif (n % 2 != 0) {\n\t\tConsole.Write(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\tint sum = 0, count = 0;\n\t\twhile (n >= 2) {\n\t\tcount++;\n\t\tsum += n;\n\t\tn = n - 2;\n\t\t}\n\t\treturn sum / count;\n\t}", "12639": "static int averageEven(int n)\n\t{\n\t\tif (n % 2 != 0) {\n\t\tConsole.Write(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn (n + 2) / 2;\n\t}", "12645": "static int averageOdd(int n)\n\t{\n\t\tif (n % 2 == 0) {\n\t\t\tConsole.Write(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\tint sum = 0, count = 0;\n\t\twhile (n >= 1) {\n\t\t\tcount++;\n\t\t\tsum += n;\n\t\t\tn = n - 2;\n\t\t}\n\t\treturn sum / count;\n\t}", "12646": "static int averageOdd(int n)\n\t{\n\t\tif (n % 2 == 0)\n\t\t{\n\t\t\tConsole.Write(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn (n + 1) / 2;\n\t}", "12686": "static int lcm(int a, int b)\n{\n\treturn (a * b) / (__gcd(a, b));\n}\nstatic Rational maxRational(Rational first, Rational sec)\n{\n\tint k = lcm(first.deno, sec.deno);\n\tint nume1 = first.nume;\n\tint nume2 = sec.nume;\n\tnume1 *= k / (first.deno);\n\tnume2 *= k / (sec.deno);\n\treturn (nume2 < nume1)? first : sec;\n}\nstatic int __gcd(int a, int b)\n{\n\treturn b == 0 ? a:__gcd(b, a % b);\t\n}", "12714": "public static int TrinomialValue(int n, int k)\n\t{\n\t\tif (n == 0 && k == 0)\n\t\t\treturn 1;\n\t\tif (k < -n k > n)\n\t\t\treturn 0;\n\t\treturn TrinomialValue(n - 1, k - 1)\n\t\t\t+ TrinomialValue(n - 1, k)\n\t\t\t+ TrinomialValue(n - 1, k + 1);\n\t}\npublic static void printTrinomial(int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = -i; j <= 0; j++)\n\t\t\t\tConsole.Write(TrinomialValue(i, j) + \" \");\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tConsole.Write(TrinomialValue(i, j) + \" \");\n\t\t\tConsole.WriteLine();\n\t\t}\n\t}", "12715": "public static int TrinomialValue(int [,]dp, int n, int k)\n\t{\n\t\tif (k < 0)\n\t\t\tk = -k;\n\t\tif (dp[n, k] != 0)\n\t\t\treturn dp[n, k];\n\t\tif (n == 0 && k == 0)\n\t\t\treturn 1;\n\t\tif (k < -n k > n)\n\t\t\treturn 0;\n\t\treturn (dp[n, k] = TrinomialValue(dp, n - 1, k - 1) +\n\t\t\t\t\t\tTrinomialValue(dp, n - 1, k) +\n\t\t\t\t\t\tTrinomialValue(dp, n - 1, k + 1));\n\t}\npublic static void printTrinomial(int n)\n\t{\n\t\tint[,] dp = new int[MAX, MAX];\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = -i; j <= 0; j++)\n\t\t\tConsole.Write(TrinomialValue(dp, i, j) + \" \");\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tConsole.Write(TrinomialValue(dp, i, j) + \" \");\n\t\t\tConsole.WriteLine();\n\t\t}\n\t}", "12716": "static int Series(int n)\n\t{\n\t\tint i;\n\t\tint sums = 0;\n\t\tfor (i = 1; i <= n; i++)\n\t\t\tsums += (i * i);\n\t\treturn sums;\n\t}", "12745": "public static bool isPrime(int n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tfor (int i = 2; i < n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\npublic static bool isEmirp(int n)\n\t{\n\t\tif (isPrime(n) == false)\n\t\t\treturn false;\n\t\tint rev = 0;\n\t\twhile (n != 0) {\n\t\t\tint d = n % 10;\n\t\t\trev = rev * 10 + d;\n\t\t\tn /= 10;\n\t\t}\n\t\treturn isPrime(rev);\n\t}", "12747": "static int sumOfLargePrimeFactor(int n)\n\t{\n\t\tint[] prime = new int[n + 1];\n\t\tint sum = 0;\n\t\tfor (int i = 1; i < n + 1; i++)\n\t\t\tprime[i] = 0;\n\t\tint max = n / 2;\n\t\tfor (int p = 2; p <= max; p++)\n\t\t{\n\t\t\tif (prime[p] == 0)\n\t\t\t{\n\t\t\t\tfor (int i = p * 2; i <= n; i += p)\n\t\t\t\t\tprime[i] = p;\n\t\t\t}\n\t\t}\n\t\tfor (int p = 2; p <= n; p++)\n\t\t{\n\t\t\tif (prime[p] != 0)\n\t\t\t\tsum += prime[p];\n\t\t\telse\n\t\t\t\tsum += p;\n\t\t}\n\t\treturn sum;\n\t}", "12750": "static int gcd(int a, int b)\n\t{\n\t\tif (a == 0 b == 0)\n\t\t\treturn 0;\n\t\tif (a == b)\n\t\t\treturn a;\n\t\tif (a > b)\n\t\t\treturn gcd(a - b, b);\n\t\treturn gcd(a, b - a);\n\t}\nstatic int cpFact(int x, int y)\n\t{\n\t\twhile (gcd(x, y) != 1) {\n\t\t\tx = x / gcd(x, y);\n\t\t}\n\t\treturn x;\n\t}", "12764": "public static int counLastDigitK(int low, int high, int k)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = low; i <= high; i++)\n\t\t\tif (i % 10 == k)\n\t\t\t\tcount++;\n\t\treturn count;\n\t}", "12765": "public static int counLastDigitK(int low, int high, int k)\n\t{\n\t\tint mlow = 10 * Convert.ToInt32(\n\t\t\t\tMath.Ceiling(low/10.0));\n\t\tint mhigh = 10 * Convert.ToInt32(\n\t\t\t\tMath.Floor(high/10.0));\n\t\tint count = (mhigh - mlow) / 10;\n\t\tif (high % 10 >= k)\n\t\t\tcount++;\n\t\tif (low % 10 <= k && (low%10) > 0)\n\t\t\tcount++;\n\t\treturn count;\n\t}", "12794": "static double Convert(double radian){\n\t\tdouble pi = 3.14159;\n\t\treturn(radian * (180 / pi));\n\t}", "12799": "static int sn(int n, int an)\n\t{\n\t\treturn (n * (1 + an)) / 2;\n\t}\nstatic int trace(int n, int m)\n\t{\n\t\tint an = 1 + (n - 1) * (m + 1);\n\t\tint rowmajorSum = sn(n, an);\n\t\tan = 1 + (n - 1) * (n + 1);\n\t\tint colmajorSum = sn(n, an);\n\t\treturn rowmajorSum + colmajorSum;\n\t}", "12810": "static float avgOfFirstN(int n)\n\t{\n\t\treturn (float)(1 + n) / 2;\n\t}", "12842": "static int sum(int L, int R)\n\t{\n\t\tint p = R / 6;\n\t\tint q = (L - 1) / 6;\n\t\tint sumR = 3 * (p * (p + 1));\n\t\tint sumL = (q * (q + 1)) * 3;\n\t\treturn sumR - sumL;\n\t}", "12844": "static void max_area(int n, int m, int k)\n\t{\n\t\tif (k > (n + m - 2))\n\t\t\tConsole.WriteLine(\"Not possible\");\n\t\telse {\n\t\t\tint result;\n\t\t\tif (k < Math.Max(m, n) - 1)\n\t\t\t{\n\t\t\t\tresult = Math.Max(m * (n / (k + 1)),\n\t\t\t\t\t\tn * (m / (k + 1)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = Math.Max(m / (k - n + 2),\n\t\t\t\t\t\tn / (k - m + 2));\n\t\t\t}\n\t\t\tConsole.WriteLine(result);\n\t\t}\n\t}", "12855": "static String prevNum(String str)\n\t{\n\t\tint len = str.Length;\n\t\tint index = -1;\n\t\tfor (int i = len - 2; i >= 0; i--)\n\t\t{\n\t\t\tif (str[i] > str[i + 1])\n\t\t\t{\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint smallGreatDgt = -1;\n\t\tfor (int i = len - 1; i > index; i--)\n\t\t{\n\t\t\tif (str[i] < str[index])\n\t\t\t{\n\t\t\t\tif (smallGreatDgt == -1)\n\t\t\t\t{\n\t\t\t\t\tsmallGreatDgt = i;\n\t\t\t\t}\n\t\t\t\telse if (str[i] >= str[smallGreatDgt])\n\t\t\t\t{\n\t\t\t\t\tsmallGreatDgt = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (index == -1)\n\t\t{\n\t\t\treturn \"-1\";\n\t\t}\n\t\tif (smallGreatDgt != -1)\n\t\t{\n\t\t\tstr = swap(str, index, smallGreatDgt);\n\t\t\treturn str;\n\t\t}\n\t\treturn \"-1\";\n\t}\nstatic String swap(String str, int i, int j)\n\t{\n\t\tchar[] ch = str.ToCharArray();\n\t\tchar temp = ch[i];\n\t\tch[i] = ch[j];\n\t\tch[j] = temp;\n\t\treturn String.Join(\"\",ch);\n\t}", "12891": "static int calculate_sum(int a, int N)\n\t{\n\t\tint m = N / a;\n\t\tint sum = m * (m + 1) / 2;\n\t\tint ans = a * sum;\n\t\treturn ans;\n\t}", "12895": "static int horner(int []poly, int n, int x)\n\t{\n\t\tint result = poly[0];\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tresult = result * x + poly[i];\n\t\treturn result;\n\t}\nstatic int findSign(int []poly, int n, int x)\n\t{\n\t\tint result = horner(poly, n, x);\n\t\tif (result > 0)\n\t\t\treturn 1;\n\t\telse if (result < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}", "12905": "static int isPowerOf2(string s)\n{\n\tchar []str = s.ToCharArray();\n\tint len_str = str.Length;\n\tint num = 0;\n\tif (len_str == 1 && str[len_str - 1] == '1')\n\t\treturn 0;\n\twhile (len_str != 1 str[len_str - 1] != '1')\n\t{\n\t\tif ((str[len_str - 1] - '0') % 2 == 1)\n\t\t\treturn 0;\n\t\tint j = 0;\n\t\tfor (int i = 0; i < len_str; i++)\n\t\t{\n\t\t\tnum = num * 10 + (int)str[i] - (int)'0';\n\t\t\tif (num < 2)\n\t\t\t{\n\t\t\t\tif (i != 0)\n\t\t\t\t\tstr[j++] = '0';\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstr[j++] = (char)((int)(num / 2) + (int)'0');\n\t\t\tnum = (num) - (num / 2) * 2;\n\t\t}\n\t\tstr[j] = '\\0';\n\t\tlen_str = j;\n\t}\n\treturn 1;\n}", "12906": "static long ispowerof2 ( long num )\n{\n\tif ((num&(num-1)) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "12970": "static int counDivisors(int X)\n\t{\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= X; ++i)\n\t\t{\n\t\t\tif (X % i == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\nstatic int countDivisorsMult( int []arr, int n)\n\t{\n\t\tint mul = 1;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tmul *= arr[i];\n\t\treturn counDivisors(mul);\n\t}", "12971": "static void SieveOfEratosthenes(int largest, List<int> prime)\n{\n\tbool[] isPrime = new bool[largest + 1];\n\tArray.Fill(isPrime, true);\n\tfor(int p = 2; p * p <= largest; p++)\n\t{\n\t\tif (isPrime[p] == true)\n\t\t{\n\t\t\tfor (int i = p * 2; i <= largest; i += p)\n\t\t\t\tisPrime[i] = false;\n\t\t}\n\t}\n\tfor(int p = 2; p <= largest; p++)\n\t\tif (isPrime[p])\n\t\t\tprime.Add(p);\n}\nstatic long countDivisorsMult(int[] arr, int n)\n{\n\tint largest = 0;\n\tforeach(int a in arr )\n\t{\n\t\tlargest = Math.Max(largest, a);\n\t}\n\tList<int> prime = new List<int>();\n\tSieveOfEratosthenes(largest, prime);\n\tDictionary<int,\n\t\t\tint> mp = new Dictionary<int,\n\t\t\t\t\t\t\t\t\t\tint>();\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < prime.Count; j++)\n\t\t{\n\t\t\twhile(arr[i] > 1 && arr[i] % prime[j] == 0)\n\t\t\t{\n\t\t\t\tarr[i] /= prime[j];\n\t\t\t\tif (mp.ContainsKey(prime[j]))\n\t\t\t\t{\n\t\t\t\t\tmp[prime[j]]++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp.Add(prime[j], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (arr[i] != 1)\n\t\t{\n\t\t\tif(mp.ContainsKey(arr[i]))\n\t\t\t{\n\t\t\t\tmp[arr[i]]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.Add(arr[i], 1);\n\t\t\t}\n\t\t}\n\t}\n\tlong res = 1;\n\tforeach(KeyValuePair<int, int> it in mp)\n\t\tres *= (it.Value + 1L);\n\treturn res;\n}", "12983": "public static void printTaxicab2(int N)\n\t{\n\t\tint i = 1, count = 0;\n\t\twhile (count < N)\n\t\t{\n\t\t\tint int_count = 0;\n\t\t\tfor (int j = 1; j <= Math.Pow(i, 1.0/3); j++)\n\t\t\t\tfor (int k = j + 1; k <= Math.Pow(i, 1.0/3); k++)\n\t\t\t\t\tif (j * j * j + k * k * k == i)\n\t\t\t\t\t\tint_count++;\n\t\t\tif (int_count == 2)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tConsole.WriteLine(count + \" \" + i);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}", "12991": "public static bool isComposite(int n)\n\t{\n\tif (n <= 1) return false;\n\tif (n <= 3) return false;\n\tif (n % 2 == 0 n % 3 == 0) return true;\n\tfor (int i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\treturn true;\n\treturn false;\n\t}", "13022": "static int area_fun(int side)\n\t{\n\t\tint area = side * side;\n\t\treturn area;\n\t}", "13040": "static int countConsecutive(int N)\n\t{\n\t\tint count = 0;\n\t\tfor (int L = 1; L * (L + 1) < 2 * N; L++) {\n\t\t\tdouble a = (double)((1.0\n\t\t\t\t\t\t\t\t* N\n\t\t\t\t\t\t\t- (L * (L + 1)) / 2)\n\t\t\t\t\t\t\t/ (L + 1));\n\t\t\tif (a - (int)a == 0.0)\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "13048": "static bool isPrime(int n)\n\t\t{\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tfor (int i = 2; i < n; i++)\n\t\t\t\tif (n % i == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\nstatic int findPrime(int n)\n\t\t{\n\t\t\tint num = n + 1;\n\t\t\twhile (num > 0)\n\t\t\t\t{\n\t\t\t\t\tif (isPrime(num))\n\t\t\t\t\t\treturn num;\n\t\t\t\t\tnum = num + 1;\n\t\t\t\t}\n\t\t\treturn 0;\n\t\t}\nstatic int minNumber(int []arr, int n)\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tsum += arr[i];\n\t\t\tif (isPrime(sum))\n\t\t\t\treturn 0;\n\t\t\tint num = findPrime(sum);\n\t\t\treturn num - sum;\n\t\t}", "13049": "static void sieveOfEratostheneses()\n{\n\tisPrime[1] = true;\n\tfor (int i = 2; i * i < MAX; i++)\n\t{\n\t\tif (!isPrime[i])\n\t\t{\n\t\t\tfor (int j = 2 * i; j < MAX; j += i)\n\t\t\t\tisPrime[j] = true;\n\t\t}\n\t}\n}\nstatic int findPrime(int n)\n{\n\tint num = n + 1;\n\twhile (num > 0)\n\t{\n\t\tif (!isPrime[num])\n\t\t\treturn num;\n\t\tnum = num + 1;\n\t}\n\treturn 0;\n}\nstatic int minNumber(int[] arr, int n)\n{\n\tsieveOfEratostheneses();\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += arr[i];\n\tif (!isPrime[sum])\n\t\treturn 0;\n\tint num = findPrime(sum);\n\treturn num - sum;\n}", "13140": "static int fac(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\treturn n * fac(n - 1);\n\t}\nstatic int div(int x)\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= x; i++)\n\t\t\tif (x % i == 0)\n\t\t\t\tans += i;\n\t\treturn ans;\n\t}\nstatic int sumFactDiv(int n)\n\t{\n\t\treturn div(fac(n));\n\t}", "13141": "static void sieve(int n)\n{\n\tbool[] prime=new bool[n+1];\n\tfor (int p = 2; p*p <= n; p++)\n\t{\n\t\tif (prime[p] == false)\n\t\t{\n\t\t\tfor (int i = p*2; i <= n; i += p)\n\t\t\t\tprime[i] = true;\n\t\t}\n\t}\n\tfor (int p = 2; p <= n; p++)\n\t\tif (prime[p]==false)\n\t\t\tallPrimes.Add(p);\n}\nstatic int factorialDivisors(int n)\n{\n\tint result = 1;\n\tfor (int i = 0; i < allPrimes.Count; i++)\n\t{\n\t\tint p = (int)allPrimes[i];\n\t\tint exp = 0;\n\t\twhile (p <= n)\n\t\t{\n\t\t\texp = exp + (n/p);\n\t\t\tp = p*(int)allPrimes[i];\n\t\t}\n\t\tresult = result*((int)Math.Pow((int)allPrimes[i], exp+1)-1)/\n\t\t\t\t\t\t\t\t\t((int)allPrimes[i]-1);\n\t}\n\treturn result;\n}", "13144": "static bool isAutomorphic(int N)\n\t{\n\t\tint sq = N * N;\n\t\twhile (N > 0) {\n\t\t\tif (N % 10 != sq % 10)\n\t\t\t\treturn false;\n\t\t\tN /= 10;\n\t\t\tsq /= 10;\n\t\t}\n\t\treturn true;\n\t}", "13179": "static bool checkPandigital(int b, string n) {\n\tif (n.Length < b)\n\treturn false;\n\tbool []hash = new bool[b];\n\tfor(int i = 0; i < b; i++)\n\thash[i] = false;\n\tfor (int i = 0; i < n.Length; i++) {\n\tif (n[i] >= '0' && n[i] <= '9')\n\t\thash[n[i] - '0'] = true;\n\telse if (n[i] - 'A' <= b - 11)\n\t\thash[n[i] - 'A' + 10] = true;\n\t}\n\tfor (int i = 0; i < b; i++)\n\tif (hash[i] == false)\n\t\treturn false;\n\treturn true;\n}", "13180": "static int convert(int m, int n)\n\t{\n\t\tif (m == n)\n\t\t\treturn 0;\n\t\tif (m > n)\n\t\t\treturn m - n;\n\t\tif (m <= 0 && n > 0)\n\t\t\treturn -1;\n\t\tif (n % 2 == 1)\n\t\t\treturn 1 + convert(m, n + 1);\n\t\telse\n\t\t\treturn 1 + convert(m, n / 2);\n\t}", "13236": "static int getDigitProduct(int x)\n{\n\tif (x < 10)\n\treturn x;\n\tif (prodDig[x] != 0)\n\treturn prodDig[x];\n\tint prod = (x % 10) * getDigitProduct(x/10);\n\treturn (prodDig[x] = prod);\n}\nstatic void findSeed(int n)\n{\n\tArrayList res = new ArrayList();\n\tfor (int i=1; i<=n/2; i++)\n\t\tif (i*getDigitProduct(i) == n)\n\t\t\tres.Add(i);\n\tif (res.Count == 0)\n\t{\n\t\tConsole.WriteLine(\"NO seed exists\");\n\t\treturn;\n\t}\n\tfor (int i=0; i<res.Count; i++)\n\t\tConsole.WriteLine(res[i]+\" \");\n}", "13240": "static int maxPrimefactorNum(int N)\n{\n\tint []arr = new int[N + 5];\n\tfor (int i = 2; i * i <= N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t{\n\t\t\tfor (int j = 2 * i; j <= N; j += i)\n\t\t\t{\n\t\t\t\tarr[j]++;\n\t\t\t}\n\t\t}\n\t\tarr[i] = 1;\n\t}\n\tint maxval = 0, maxint = 1;\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tif (arr[i] > maxval)\n\t\t{\n\t\t\tmaxval = arr[i];\n\t\t\tmaxint = i;\n\t\t}\n\t}\n\treturn maxint;\n}", "13241": "static int maxPrimefactorNum(int N)\n\t{\n\t\tbool []arr = new bool[N + 5];\n\t\tint i ;\n\t\tfor (i = 3; i * i <= N; i += 2)\n\t\t{\n\t\t\tif (!arr[i])\n\t\t\t{\n\t\t\t\tfor (int j = i * i; j <= N; j += i)\n\t\t\t\t{\n\t\t\t\t\tarr[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList prime = new ArrayList();\n\t\tprime.Add(2);\n\t\tfor (i = 3; i <= N; i += 2)\n\t\t{\n\t\t\tif (!arr[i])\n\t\t\t{\n\t\t\t\tprime.Add(i);\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\ti = 0;\n\t\twhile (ans * (int)prime[i] <= N && i < prime.Count)\n\t\t{\n\t\t\tans *= (int)prime[i];\n\t\t\ti++;\n\t\t}\n\t\treturn ans;\n\t}", "13250": "public static long SubArraySum(int []arr, int n)\n\t{\n\t\tlong result = 0,temp=0;\n\t\tfor (int i = 0; i < n; i ++)\n\t\t{\n\t\t\ttemp=0;\n\t\t\tfor (int j = i; j < n; j ++)\n\t\t\t{\n\t\t\t\ttemp+=arr[j];\n\t\t\t\tresult += temp ;\n\t\t\t}\n\t\t}\n\t\treturn result ;\n\t}", "13251": "public static long SubArraySum(int []arr , int n )\n\t{\n\t\tlong result = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tresult += (arr[i] *\n\t\t\t\t\t(i + 1) * (n - i));\n\t\treturn result ;\n\t}", "13288": "public static int highestPowerof2(int n)\n{\n\tint res = 0;\n\tfor (int i = n; i >= 1; i--)\n\t\t{\n\t\tif ((i & (i - 1)) == 0)\n\t\t\t{\n\t\t\t\tres = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn res;\n}", "13290": "static int highestPowerof2(int n)\n{\n\tint p = (int)(Math.Log(n) /\n\t\t\t\tMath.Log(2));\n\treturn (int)Math.Pow(2, p);\n}", "13291": "static int highestPowerof2(int x)\n {\n\tx |= x >> 1;\n\tx |= x >> 2;\n\tx |= x >> 4;\n\tx |= x >> 8;\n\tx |= x >> 16;\n\treturn x ^ (x >> 1); \n }", "13307": "static int aModM(string s, int mod)\n{\n\tint number = 0;\n\tfor (int i = 0; i < s.Length; i++)\n\t{\n\t\tnumber = (number * 10 );\n\t\tint x = (int)(s[i] - '0');\n\t\tnumber = number + x;\n\t\tnumber %= mod;\n\t}\n\treturn number;\n}\nstatic int ApowBmodM(string a, int b, int m)\n{\n\tint ans = aModM(a, m);\n\tint mul = ans;\n\tfor (int i = 1; i < b; i++)\n\t\tans = (ans * mul) % m;\n\treturn ans;\n}", "13352": "static int divSum(int num)\n\t{\n\t\tint result = 0;\n\t\tfor (int i = 2; i <= Math.Sqrt(num); i++)\n\t\t{\n\t\t\tif (num % i == 0)\n\t\t\t{\n\t\t\t\tif (i == (num / i))\n\t\t\t\t\tresult += i;\n\t\t\t\telse\n\t\t\t\t\tresult += (i + num / i);\n\t\t\t}\n\t\t}\n\t\treturn (result + 1);\n\t}", "13400": "static void findPairs(int n)\n{\n\tint cubeRoot = (int)Math.Pow(n, 1.0 / 3.0);\n\tint []cube = new int[cubeRoot + 1];\n\tfor (int i = 1; i <= cubeRoot; i++)\n\t\tcube[i] = i * i * i;\n\tint l = 1;\n\tint r = cubeRoot;\n\twhile (l < r)\n\t{\n\t\tif (cube[l] + cube[r] < n)\n\t\t\tl++;\n\t\telse if(cube[l] + cube[r] > n)\n\t\t\tr--;\n\t\telse {\n\t\t\tConsole.WriteLine(\"(\" + l + \", \" + r + \")\" );\n\t\t\tl++; r--;\n\t\t}\n\t}\n}", "13401": "static void findPairs(int n)\n{\n\tint cubeRoot = (int) Math.Pow(n, 1.0/3.0);\n\tDictionary<int, pair> s = new Dictionary<int, pair>();\n\tfor (int x = 1; x < cubeRoot; x++)\n\t{\n\t\tfor (int y = x + 1; y <= cubeRoot; y++)\n\t\t{\n\t\t\tint sum = x*x*x + y*y*y;\n\t\t\tif (sum != n)\n\t\t\t\tcontinue;\n\t\t\tif (s.ContainsKey(sum))\n\t\t\t{\n\t\t\t\tConsole.Write(\"(\" + s[sum].first+ \", \" + s[sum].second+ \") and (\" + x+ \", \" + y+ \")\" +\"\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t\ts.Add(sum, new pair(x, y));\n\t\t}\n\t}\n}", "13409": "static int gcd(int a, int b)\n{\n\twhile (b != 0)\n\t{\n\t\tint t = b;\n\t\tb = a % b;\n\t\ta = t;\n\t}\n\treturn a;\n}\nstatic int findMinDiff(int a, int b, int x, int y)\n{\n\tint g = gcd(a, b);\n\tint diff = Math.Abs(x - y) % g;\n\treturn Math.Min(diff, g - diff);\n}", "13429": "static void printDivisors(int n)\n\t{\n\t\tint[] v = new int[n];\n\t\tint t = 0;\n\t\tfor (int i = 1;\n\t\t\ti <= Math.Sqrt(n); i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tif (n / i == i)\n\t\t\t\t\tConsole.Write(i + \" \");\n\t\t\t\telse {\n\t\t\t\t\tConsole.Write(i + \" \");\n\t\t\t\t\tv[t++] = n / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = t - 1; i >= 0; i--)\n\t\t\tConsole.Write(v[i] + \" \");\n\t}", "13430": "static void printDivisors(int n)\n{\n\tfor(int i = 1; i * i < n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t\tConsole.Write(i + \" \");\n\t}\n\tfor(int i = (int)Math.Sqrt(n); i >= 1; i--)\n\t{\n\t\tif (n % i == 0)\n\t\t\tConsole.Write(n / i + \" \");\n\t}\n}", "13431": "static void printDivisors(int n)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t\tConsole.Write( i + \" \");\n\t}", "13432": "static void printDivisors(int n)\n\t{\n\t\tfor (int i = 1; i <= Math.Sqrt(n); i++)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tif (n / i == i)\n\t\t\t\t\tConsole.Write(i + \" \");\n\t\t\t\telse\n\t\t\t\t\tConsole.Write(i + \" \" + n / i + \" \");\n\t\t\t}\n\t\t}\n\t}", "13448": "static double interpolate(Data []f, int xi, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble term = f[i].y;\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (j != i)\n\t\t\t\tterm = term * (xi - f[j].x) /\n\t\t\t\t\t\t(f[i].x - f[j].x);\n\t\t}\n\t\tresult += term;\n\t}\n\treturn result;\n}", "13453": "static int SieveOfAtkin(int limit)\n\t{\n\t\tif (limit > 2)\n\t\t\tConsole.Write(2 + \" \");\n\t\tif (limit > 3)\n\t\t\tConsole.Write(3 + \" \");\n\t\tbool[] sieve = new bool[limit];\n\t\tfor (int i = 0; i < limit; i++)\n\t\t\tsieve[i] = false;\n\t\tfor (int x = 1; x * x < limit; x++) {\n\t\t\tfor (int y = 1; y * y < limit; y++) {\n\t\t\t\tint n = (4 * x * x) + (y * y);\n\t\t\t\tif (n <= limit && (n % 12 == 1 n % 12 == 5))\n\t\t\t\t\tsieve[n] ^= true;\n\t\t\t\tn = (3 * x * x) + (y * y);\n\t\t\t\tif (n <= limit && n % 12 == 7)\n\t\t\t\t\tsieve[n] ^= true;\n\t\t\t\tn = (3 * x * x) - (y * y);\n\t\t\t\tif (x > y && n <= limit && n % 12 == 11)\n\t\t\t\t\tsieve[n] ^= true;\n\t\t\t}\n\t\t}\n\t\tfor (int r = 5; r * r < limit; r++) {\n\t\t\tif (sieve[r]) {\n\t\t\t\tfor (int i = r * r; i < limit; i += r * r)\n\t\t\t\t\tsieve[i] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int a = 5; a < limit; a++)\n\t\t\tif (sieve[a])\n\t\t\t\tConsole.Write(a + \" \");\n\t\treturn 0;\n\t}", "13454": "static int SieveOfSundaram(int n)\n{\n\tint nNew = (n - 1) / 2;\n\tbool []marked = new bool[nNew + 1];\n\tfor (int i=0;i<nNew+1;i++)\n\tmarked[i]=false;\n\tfor (int i = 1; i <= nNew; i++)\n\tfor (int j = i; (i + j + 2 * i * j) <= nNew; j++)\n\t\tmarked[i + j + 2 * i * j] = true;\n\tif (n > 2)\n\tConsole.Write(2 + \" \");\n\tfor (int i = 1; i <= nNew; i++)\n\tif (marked[i] == false)\n\t\tConsole.Write(2 * i + 1 + \" \");\n\treturn -1;\n}", "13460": "static int power(int x, int y, int p)\n{\n\twhile (y > 0) {\n\t\tif (y %2 == 1)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nstatic void squareRoot(int n, int p)\n{\n\tif (p % 4 != 3) {\n\t\tConsole.Write(\"Invalid Input\");\n\t\treturn;\n\t}\n\tn = n % p;\n\tint x = power(n, (p + 1) / 4, p);\n\tif ((x * x) % p == n) {\n\t\tConsole.Write(\"Square root is \" + x);\n\t\treturn;\n\t}\n\tx = p - x;\n\tif ((x * x) % p == n) {\n\t\tConsole.Write(\"Square root is \" + x);\n\t\treturn;\n\t}\n\tConsole.Write(\"Square root doesn't exist \");\n}", "13468": "static int power(int x, int y, int p)\n\t{\n\t\tint res = 1;\n\t\tx = x % p;\n\t\twhile (y > 0)\n\t\t{\n\t\t\tif ((y & 1) == 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\nstatic bool miillerTest(int d, int n)\n\t{\n\t\tRandom r = new Random();\n\t\tint a = 2 + (int)(r.Next() % (n - 4));\n\t\tint x = power(a, d, n);\n\t\tif (x == 1 x == n - 1)\n\t\t\treturn true;\n\t\twhile (d != n - 1)\n\t\t{\n\t\t\tx = (x * x) % n;\n\t\t\td *= 2;\n\t\t\tif (x == 1)\n\t\t\t\treturn false;\n\t\t\tif (x == n - 1)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\nstatic bool isPrime(int n, int k)\n\t{\n\t\tif (n <= 1 n == 4)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tint d = n - 1;\n\t\twhile (d % 2 == 0)\n\t\t\td /= 2;\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tif (miillerTest(d, n) == false)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "13489": "static bool isInside(int circle_x, int circle_y, int rad, int x, int y)\n\t{\n\t\tif ((x - circle_x) * (x - circle_x) +\n\t\t\t(y - circle_y) * (y - circle_y) <= rad * rad)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "13501": "static int eval(int a, char op, int b)\n\t{\n\t\tif (op == '+')\n\t\t{\n\t\t\treturn a + b;\n\t\t}\n\t\tif (op == '-')\n\t\t{\n\t\t\treturn a - b;\n\t\t}\n\t\tif (op == '*')\n\t\t{\n\t\t\treturn a * b;\n\t\t}\n\t\treturn int.MaxValue;\n\t}\nstatic List<int> evaluateAll(String expr, int low, int high)\n\t{\n\t\tList<int> res = new List<int> ();\n\t\tif (low == high)\n\t\t{\n\t\t\tres.Add(expr[low] - '0');\n\t\t\treturn res;\n\t\t}\n\t\tif (low == (high - 2))\n\t\t{\n\t\t\tint num = eval(expr[low] - '0', expr[low + 1], expr[low + 2] - '0');\n\t\t\tres.Add(num);\n\t\t\treturn res;\n\t\t}\n\t\tfor (int i = low + 1; i <= high; i += 2)\n\t\t{\n\t\t\tList<int> l = evaluateAll(expr, low, i - 1);\n\t\t\tList<int> r = evaluateAll(expr, i + 1, high);\n\t\t\tfor (int s1 = 0; s1 < l.Count; s1++)\n\t\t\t{\n\t\t\t\tfor (int s2 = 0; s2 < r.Count; s2++)\n\t\t\t\t{\n\t\t\t\t\tint val = eval(l[s1], expr[i], r[s2]);\n\t\t\t\t\tres.Add(val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}", "13504": "static bool isLucky(int n)\n\t{\n\t\tbool []arr = new bool[10];\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tarr[i] = false;\n\t\twhile (n > 0)\n\t\t{\n\t\t\tint digit = n % 10;\n\t\t\tif (arr[digit])\n\t\t\t\treturn false;\n\t\t\tarr[digit] = true;\n\t\t\tn = n / 10;\n\t\t}\n\t\treturn true;\n\t}", "13535": "static void printSquares(int n)\n{\n\tint square = 0, odd = 1;\n\tfor (int x = 0; x < n; x++)\n\t{\n\t\tConsole.Write(square + \" \" );\n\t\tsquare = square + odd;\n\t\todd = odd + 2;\n\t}\n}", "13575": "static int reversDigits(int num)\n\t{\n\t\tif (num > 0) {\n\t\t\treversDigits(num / 10);\n\t\t\trev_num += (num % 10) * base_pos;\n\t\t\tbase_pos *= 10;\n\t\t}\n\t\treturn rev_num;\n\t}", "13606": "static void constructArray(int[] A, int N, int K)\n\t{\n\t\tint[] B = new int[N];\n\t\tint totalXOR = A[0] ^ K;\n\t\tfor(int i = 0; i < N; i++)\n\t\t\tB[i] = totalXOR ^ A[i];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tConsole.Write(B[i] + \" \");\n\t\t}\n\t}", "13633": "static int RecursiveFunction(List<int> re, int bit)\n{\n\tif (re.Count == 0 bit < 0)\n\t\treturn 0;\n\tList<int> curr_on = new List<int>();\n\tList<int> curr_off = new List<int>();\n\tfor(int i = 0; i < re.Count; i++)\n\t{\n\t\tif (((re[i] >> bit) & 1) == 0)\n\t\t\tcurr_off.Add(re[i]);\n\t\telse\n\t\t\tcurr_on.Add(re[i]);\n\t}\n\tif (curr_off.Count == 0)\n\t\treturn RecursiveFunction(curr_on, bit - 1);\n\tif (curr_on.Count == 0)\n\t\treturn RecursiveFunction(curr_off, bit - 1);\n\treturn Math.Min(RecursiveFunction(curr_off, bit - 1),\n\t\t\t\t\tRecursiveFunction(curr_on, bit - 1)) +\n\t\t\t\t\t\t\t\t\t(1 << bit);\n}\nstatic void PrintMinimum(int []a, int n)\n{\n\tList<int> v = new List<int>();\n\tfor(int i = 0; i < n; i++)\n\t\tv.Add(a[i]);\n\tConsole.WriteLine(RecursiveFunction(v, 30));\n}", "13660": "static int extraElement(int []A, int []B, int n)\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans ^= A[i];\n\t\tfor (int i = 0; i < n + 1; i++)\n\t\t\tans ^= B[i];\n\t\treturn ans;\n\t}", "13671": "static int cntElements(int []arr, int n)\n{\n\tint cnt = 0;\n\tfor (int i = 0; i < n - 2; i++)\n\t{\n\t\tif (arr[i] == (arr[i + 1] ^ arr[i + 2]))\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}", "13672": "static int xor_triplet(int []arr, int n)\n{\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tfor (int k = j; k < n; k++)\n\t\t\t{\n\t\t\t\tint xor1 = 0, xor2 = 0;\n\t\t\t\tfor (int x = i; x < j; x++)\n\t\t\t\t{\n\t\t\t\t\txor1 ^= arr[x];\n\t\t\t\t}\n\t\t\t\tfor (int x = j; x <= k; x++)\n\t\t\t\t{\n\t\t\t\t\txor2 ^= arr[x];\n\t\t\t\t}\n\t\t\t\tif (xor1 == xor2)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}", "13684": "static long bit_q(int i, int j)\n{\n long sum = 0;\n while (j > 0)\n {\n\tsum += bit[j];\n\tj -= (j & (j * -1));\n }\n i--;\n while (i > 0)\n {\n\tsum -= bit[i];\n\ti -= (i & (i * -1));\n }\n return sum;\n}\nstatic void bit_up(int i, long diff)\n{\n while (i <= n)\n {\n\tbit[i] += diff;\n\ti += i & -i;\n }\n}\nstatic void dfs(int node)\n{\n Ideal_pair += bit_q(Math.Max(1, node - k),\n\t\t\t\t\tMath.Min(n, node + k));\n bit_up(node, 1);\n for(int i = 0; i < al[node].Count; i++)\n\tdfs(al[node][i]);\n bit_up(node, -1);\n}\nstatic void initialise()\n{\n Ideal_pair = 0;\n for (int i = 0; i <= n; i++)\n {\n\troot_node[i] = true;\n\tbit[i] = 0;\n }\n}\nstatic void Add_Edge(int x, int y)\n{\n al[x].Add(y);\n root_node[y] = false;\n}\nstatic long Idealpairs()\n{\t\n int r = -1;\n for(int i = 1; i <= n; i++)\n\tif (root_node[i])\n\t{\n\tr = i;\n\tbreak;\n\t}\n dfs(r);\n return Ideal_pair;\n}", "13757": "static int hammingDistance(int n1, int n2)\n{\n\tint x = n1 ^ n2;\n\tint setBits = 0;\n\twhile (x > 0)\n\t{\n\t\tsetBits += x & 1;\n\t\tx >>= 1;\n\t}\n\treturn setBits;\n}", "13829": "static void printSubsets(int n)\n\t{\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tif ((n & i) == i)\n\t\t\t\tConsole.Write(i + \" \");\n\t}", "13830": "static void printSubsets(int n) {\n\tfor (int i = n; i > 0; i = (i - 1) & n)\n\t\tConsole.Write(i +\" \");\n\t\tConsole.WriteLine(\"0\");\n\t}", "13875": "static bool isDivisibleby17(int n)\n\t{\n\t\tif (n == 0 n == 17)\n\t\t\treturn true;\n\t\tif (n < 17)\n\t\t\treturn false;\n\t\treturn isDivisibleby17((int)(n >> 4)\n\t\t\t\t\t\t\t- (int)(n & 15));\n\t}", "13876": "static long answer(long n)\n{\n\tlong m = 2;\n\tlong ans = 1;\n\tlong r = 1;\n\twhile (r < n) {\n\t\tr = ((long)Math.Pow(2, m) - 1) *\n\t\t\t((long)Math.Pow(2, m - 1));\n\t\tif (r < n)\n\t\t\tans = r;\n\t\tm++;\n\t}\n\treturn ans;\n}", "13897": "static int setBitNumber(int n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn 0;\n\t\tint msb = 0;\n\t\tn = n / 2;\n\t\twhile (n != 0) {\n\t\t\tn = n / 2;\n\t\t\tmsb++;\n\t\t}\n\t\treturn (1 << msb);\n\t}", "13898": "static int setBitNumber(int n)\n\t{\n\t\tn |= n >> 1;\n\t\tn |= n >> 2;\n\t\tn |= n >> 4;\n\t\tn |= n >> 8;\n\t\tn |= n >> 16;\n\t\tn = n + 1;\n\t\treturn (n >> 1);\n\t}", "13899": "static int setBitNumber(int n)\n\t{\n\t\tint k = (int)(Math.Log(n) / Math.Log(2));\n\t\treturn 1 << k;\n\t}", "13966": "public static int countTrailingZero(int x)\n\t{\n\t\tint count = 0;\n\t\twhile ((x & 1) == 0)\n\t\t{\n\t\t\tx = x >> 1;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "13967": "static int countTrailingZero(int x)\n{\n\tint []lookup = {32, 0, 1, 26, 2, 23,\n\t\t\t\t\t27, 0, 3, 16, 24, 30,\n\t\t\t\t\t28, 11, 0, 13, 4, 7,\n\t\t\t\t\t17, 0, 25, 22, 31, 15,\n\t\t\t\t\t29, 10, 12, 6, 0, 21,\n\t\t\t\t\t14, 9, 5, 20, 8, 19, 18};\n\treturn lookup[(-x & x) % 37];\n}", "13987": "private static int maxConsecutiveOnes(int x)\n\t{\n\t\tint count = 0;\n\t\twhile (x != 0)\n\t\t{\n\t\t\tx = (x & (x << 1));\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "14020": "static int multiplyBySevenByEight(int n)\n\t{\n\t\treturn (n - (n >> 3));\n\t}", "14021": "static int multiplyBySevenByEight(int n)\n\t{\n\t\treturn ((n << 3) -n) >> 3;\n\t}", "14022": "static int subtract(int x, int y)\n\t{\n\t\twhile (y != 0)\n\t\t{\n\t\t\tint borrow = (~x) & y;\n\t\t\tx = x ^ y;\n\t\t\ty = borrow << 1;\n\t\t}\n\t\treturn x;\n\t}", "14023": "static int subtract(int x, int y)\n\t{\n\t\tif (y == 0)\n\t\t\treturn x;\n\t\treturn subtract(x ^ y, (~x & y) << 1);\n\t}"}, "Javascript": {"451": "function minCost(cost)\n\t{\n\t\tlet dist = new Array(N);\n\t\tdist.fill(0);\n\t\tfor (let i = 0; i < N; i++)\n\t\t\tdist[i] = INF;\n\t\tdist[0] = 0;\n\t\tfor (let i = 0; i < N; i++)\n\t\t\tfor (let j = i + 1; j < N; j++)\n\t\t\t\tif (dist[j] > dist[i] + cost[i][j])\n\t\t\t\t\tdist[j] = dist[i] + cost[i][j];\n\t\treturn dist[N-1];\n\t}", "455": "function numOfways(n, k)\n\t{\n\t\tlet p = 1;\n\t\tif (k % 2 != 0)\n\t\t\tp = -1;\n\t\treturn (Math.pow(n - 1, k)\n\t\t\t\t\t+ p * (n - 1)) / n;\n\t}", "496": "function fib(n)\n{\n\tif (n <= 1)\n\t\treturn n;\n\treturn fib(n - 1) + fib(n - 2);\n}\nfunction findVertices (n)\n{\n\treturn fib(n + 2);\n}", "617": "function reverse(head_ref) {\nvar temp = null;\nvar current = head_ref;\n\t\twhile (current != null) {\n\t\t\ttemp = current.prev;\n\t\t\tcurrent.prev = current.next;\n\t\t\tcurrent.next = temp;\n\t\t\tcurrent = current.prev;\n\t\t}\n\t\tif (temp != null)\n\t\t\thead_ref = temp.prev;\n\t\treturn head_ref;\n\t}\nfunction merge(first, second) {\n\t\tif (first == null)\n\t\t\treturn second;\n\t\tif (second == null)\n\t\t\treturn first;\n\t\tif (first.data < second.data) {\n\t\t\tfirst.next = merge(first.next, second);\n\t\t\tfirst.next.prev = first;\n\t\t\tfirst.prev = null;\n\t\t\treturn first;\n\t\t} else {\n\t\t\tsecond.next = merge(first, second.next);\n\t\t\tsecond.next.prev = second;\n\t\t\tsecond.prev = null;\n\t\t\treturn second;\n\t\t}\n\t}\nfunction sort(head) {\n\t\tif (head == null head.next == null)\n\t\t\treturn head;\nvar current = head.next;\n\t\twhile (current != null) {\n\t\t\tif (current.data < current.prev.data)\n\t\t\t\tbreak;\n\t\t\tcurrent = current.next;\n\t\t}\n\t\tif (current == null)\n\t\t\treturn head;\n\t\tcurrent.prev.next = null;\n\t\tcurrent.prev = null;\n\t\tcurrent = reverse(current);\n\t\treturn merge(head, current);\n\t}\nfunction push(head_ref , new_data) {\nvar new_node = new Node();\n\t\tnew_node.data = new_data;\n\t\tnew_node.prev = null;\n\t\tnew_node.next = (head_ref);\n\t\tif ((head_ref) != null)\n\t\t\t(head_ref).prev = new_node;\n\t\t(head_ref) = new_node;\n\t\treturn head_ref;\n\t}\nfunction printList(head) {\n\t\tif (head == null)\n\t\t\tdocument.write(\"Doubly Linked list empty\");\n\t\twhile (head != null) {\n\t\t\tdocument.write(head.data + \" \");\n\t\t\thead = head.next;\n\t\t}\n\t}", "647": "function printlist(head)\n{\n\tif (head == null)\n\t{\n\t\tdocument.write(\"Empty List<br>\");\n\t\treturn;\n\t}\n\twhile (head != null)\n\t{\n\t\tdocument.write(head.data +\" \");\n\t\tif (head.next != null)\n\t\t\tdocument.write(\"-> \");\n\t\thead = head.next;\n\t}\n\tdocument.write(\"<br>\");\n}\nfunction isVowel(x)\n{\n\treturn (x == 'a' x == 'e' x == 'i' x == 'o' x == 'u');\n}\nfunction arrange(head)\n{\n\tlet newHead = head;\n\tlet latestVowel;\n\tlet curr = head;\n\tif (head == null)\n\t\treturn null;\n\tif (isVowel(head.data) == true)\n\t\tlatestVowel = head;\n\telse\n\t{\n\t\twhile (curr.next != null &&\n\t\t\t!isVowel(curr.next.data))\n\t\t\tcurr = curr.next;\n\t\tif (curr.next == null)\n\t\t\treturn head;\n\t\tlatestVowel = newHead = curr.next;\n\t\tcurr.next = curr.next.next;\n\t\tlatestVowel.next = head;\n\t}\n\twhile (curr != null && curr.next != null)\n\t{\n\t\tif (isVowel(curr.next.data) == true)\n\t\t{\n\t\t\tif (curr == latestVowel)\n\t\t\t{\n\t\t\t\tlatestVowel = curr = curr.next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlet temp = latestVowel.next;\n\t\t\t\tlatestVowel.next = curr.next;\n\t\t\t\tlatestVowel = latestVowel.next;\n\t\t\t\tcurr.next = curr.next.next;\n\t\t\t\tlatestVowel.next = temp;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurr = curr.next;\n\t\t}\n\t}\n\treturn newHead;\n}", "694": "function newNode(data)\n{\n\tvar temp = new Node();\n\ttemp.data = data;\n\ttemp.right = null;\n\ttemp.left = null;\n\treturn temp;\n}\nfunction KthLargestUsingMorrisTraversal(root , k)\n{\n\tvar curr = root;\n\tvar Klargest = null;\n\tvar count = 0;\n\twhile (curr != null)\n\t{\n\t\tif (curr.right == null)\n\t\t{\n\t\t\tif (++count == k)\n\t\t\t\tKlargest = curr;\n\t\t\tcurr = curr.left;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar succ = curr.right;\n\t\t\twhile (succ.left != null && succ.left != curr)\n\t\t\t\tsucc = succ.left;\n\t\t\tif (succ.left == null)\n\t\t\t{\n\t\t\t\tsucc.left = curr;\n\t\t\t\tcurr = curr.right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsucc.left = null;\n\t\t\t\tif (++count == k)\n\t\t\t\t\tKlargest = curr;\n\t\t\t\tcurr = curr.left;\n\t\t\t}\n\t\t}\n\t}\n\treturn Klargest;\n}", "803": "function sortByRow(mat,n,ascending)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tif (ascending)\n\t\t\t\tmat[i].sort(function(a,b){return a-b;});\n\t\t\telse\n\t\t\t\tmat[i].sort(function(a,b){return b-a;});\n\t\t}\t\n\t}\nfunction transpose(mat,n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tfor (let j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tlet temp = mat[i][j];\n\t\t\t\tmat[i][j] = mat[j][i];\n\t\t\t\tmat[j][i] = temp;\n\t\t\t}\n\t}\nfunction sortMatRowAndColWise(mat,n)\n\t{\n\t\tsortByRow(mat, n, true);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n, false);\n\t\ttranspose(mat, n);\n\t}\nfunction printMat(mat,n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (let j = 0; j < n; j++)\n\t\t\t\tdocument.write(mat[i][j] + \" \");\n\t\t\tdocument.write(\"<br>\");\n\t\t}\n\t}", "815": "function sortByRow(mat,n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tmat[i].sort(function(a,b){return a-b;});\n\t}\nfunction transpose(mat,n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tfor (let j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\tlet temp=mat[i][j];\n\t\t\t\tmat[i][j]=mat[j][i];\n\t\t\t\tmat[j][i]=temp;\n\t\t\t\t}\n\t}\nfunction sortMatRowAndColWise(mat,n)\n\t{\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t\tsortByRow(mat, n);\n\t\ttranspose(mat, n);\n\t}\nfunction printMat(mat,n)\n\t{\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < n; j++)\n\t\t\t\tdocument.write(mat[i][j] + \" \");\n\t\t\tdocument.write(\"<br>\");\n\t\t}\n\t}", "818": "function doublyEven(n)\n\t{\n\t\tvar arr = Array(n).fill(0).map(x => Array(n).fill(0));\n\t\tvar i, j;\n\tfor ( i = 0; i < n; i++)\n\t\tfor ( j = 0; j < n; j++)\n\t\t\tarr[i][j] = (n*i) + j + 1;\n\tfor ( i = 0; i < parseInt(n/4); i++)\n\t\tfor ( j = 0; j < parseInt(n/4); j++)\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor ( i = 0; i < parseInt(n/4); i++)\n\t\tfor ( j = 3 * (parseInt(n/4)); j < n; j++)\n\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor ( i = 3 * parseInt(n/4); i < n; i++)\n\t\tfor ( j = 0; j < parseInt(n/4); j++)\n\t\t\tarr[i][j] = (n*n+1) - arr[i][j];\n\t\tfor ( i = 3 * parseInt(n/4); i < n; i++)\n\t\t\tfor ( j = 3 * parseInt(n/4); j < n; j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\t\tfor ( i = parseInt(n/4); i < 3 * parseInt(n/4); i++)\n\t\t\tfor ( j = parseInt(n/4); j < 3 * parseInt(n/4); j++)\n\t\t\t\tarr[i][j] = (n*n + 1) - arr[i][j];\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor ( j = 0; j < n; j++)\n\t\t\tdocument.write(arr[i][j]+\" \");\n\t\tdocument.write('<br>');\n\t}\n}", "821": "function Kroneckerproduct(A, B)\n\t{\n\t\tlet C= new Array(rowa * rowb)\n\t\tfor(let i = 0; i < (rowa * rowb); i++)\n\t\t{\n\t\t\tC[i] = new Array(cola * colb);\n\t\t\tfor(let j = 0; j < (cola * colb); j++)\n\t\t\t{\n\t\t\t\tC[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < rowa; i++)\n\t\t{\n\t\t\tfor (let k = 0; k < rowb; k++)\n\t\t\t{\n\t\t\t\tfor (let j = 0; j < cola; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (let l = 0; l < colb; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tC[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n\t\t\t\t\t\tdocument.write( C[i + l + 1][j + k + 1]+\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdocument.write(\"</br>\");\n\t\t\t}\n\t\t}\n\t}", "832": "function isLowerTriangularMatrix(mat)\n\t{\n\t\tfor (let i = 0; i < N; i++)\n\t\t\tfor (let j = i + 1; j < N; j++)\n\t\t\t\tif (mat[i][j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "833": "function isUpperTriangularMatrix(mat)\n\t{\n\t\tfor (let i = 1; i < N ; i++)\n\t\t\tfor (let j = 0; j < i; j++)\n\t\t\t\tif (mat[i][j] != 0)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "846": "function countSets(a) {\n\t\tvar res = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tvar u = 0, v = 0;\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tif (a[i][j] == 1)\n\t\t\t\t\tu++;\n\t\t\t\telse\n\t\t\t\t\tv++;\n\t\t\t}\n\t\t\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tvar u = 0, v = 0;\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (a[j][i] == 1)\n\t\t\t\t\tu++;\n\t\t\t\telse\n\t\t\t\t\tv++;\n\t\t\t}\n\t\t\tres += Math.pow(2, u) - 1 + Math.pow(2, v) - 1;\n\t\t}\n\t\treturn res - (n * m);\n\t}", "861": "function transpose(mat, tr, N)\n{\n\tfor(let i = 0; i < N; i++)\n\t\tfor(let j = 0; j < N; j++)\n\t\t\ttr[i][j] = mat[j][i];\n}\nfunction isSymmetric(mat, N)\n{\n\tlet tr = new Array(N);\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\ttr[i] = new Array(MAX);\n\t}\n\ttranspose(mat, tr, N);\n\tfor(let i = 0; i < N; i++)\n\t\tfor(let j = 0; j < N; j++)\n\t\t\tif (mat[i][j] != tr[i][j])\n\t\t\t\treturn false;\n\treturn true;\n}", "862": "function isSymmetric(mat, N)\n\t{\n\t\tfor (let i = 0; i < N; i++)\n\t\t\tfor (let j = 0; j < N; j++)\n\t\t\t\tif (mat[i][j] != mat[j][i])\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}", "883": "function findNormal(mat, n)\n{\n\tvar sum = 0;\n\tfor(var i = 0; i < n; i++)\n\t\tfor(var j = 0; j < n; j++)\n\t\t\tsum += mat[i][j] * mat[i][j];\n\treturn parseInt(Math.sqrt(sum));\n}\nfunction findTrace(mat, n)\n{\n\tvar sum = 0;\n\tfor(var i = 0; i < n; i++)\n\t\tsum += mat[i][i];\n\treturn sum;\n}", "895": "function maxDet(n)\n{\n\treturn (2 * n * n * n);\n}\nfunction resMatrix(n)\n{\n\tfor(let i = 0; i < 3; i++)\n\t{\n\t\tfor(let j = 0; j < 3; j++)\n\t\t{\n\t\t\tif (i == 0 && j == 2)\n\t\t\t\tdocument.write(\"0 \");\n\t\t\telse if (i == 1 && j == 0)\n\t\t\t\tdocument.write(\"0 \");\n\t\t\telse if (i == 2 && j == 1)\n\t\t\t\tdocument.write(\"0 \");\n\t\t\telse\n\t\t\t\tdocument.write(n +\" \");\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t}\n}", "918": "function countNegative(M,n,m)\n\t{\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < m; j++) {\n\t\t\t\tif (M[i][j] < 0)\n\t\t\t\t\tcount += 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "919": "function countNegative(M, n, m)\n\t{\n\t\tlet count = 0;\n\t\tlet i = 0;\n\t\tlet j = m - 1;\n\t\twhile (j >= 0 && i < n)\n\t\t{\n\t\t\tif (M[i][j] < 0)\n\t\t\t{\n\t\t\t\tcount += j + 1;\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tj -= 1;\n\t\t}\n\t\treturn count;\n\t}", "926": "function findMaxValue(N,mat)\n\t{\n\t\tlet maxValue = Number.MIN_VALUE;\n\t\tfor (let a = 0; a < N - 1; a++)\n\t\tfor (let b = 0; b < N - 1; b++)\n\t\t\tfor (let d = a + 1; d < N; d++)\n\t\t\tfor (let e = b + 1; e < N; e++)\n\t\t\t\tif (maxValue < (mat[d][e] - mat[a][b]))\n\t\t\t\t\tmaxValue = mat[d][e] - mat[a][b];\n\t\treturn maxValue;\n\t}", "927": "function findMaxValue(N,mat)\n\t{\n\t\tlet maxValue = Number.MIN_VALUE;\n\t\tlet maxArr=new Array(N);\n\t\tfor(let i = 0; i < N; i++)\n\t\t{\n\t\t\tmaxArr[i]=new Array(N);\n\t\t}\n\t\tmaxArr[N - 1][N - 1] = mat[N - 1][N - 1];\nlet maxv = mat[N-1][N-1]; \n\t\tfor (let j = N - 2; j >= 0; j--)\n\t\t{\n\t\t\tif (mat[N - 1][j] > maxv)\n\t\t\t\tmaxv = mat[N - 1][j];\n\t\t\tmaxArr[N - 1][j] = maxv;\n\t\t}\nmaxv = mat[N - 1][N - 1]; \n\t\tfor (let i = N - 2; i >= 0; i--)\n\t\t{\n\t\t\tif (mat[i][N - 1] > maxv)\n\t\t\t\tmaxv = mat[i][N - 1];\n\t\t\tmaxArr[i][N - 1] = maxv;\n\t\t}\n\t\tfor (let i = N-2; i >= 0; i--)\n\t\t{\n\t\t\tfor (let j = N-2; j >= 0; j--)\n\t\t\t{\n\t\t\t\tif (maxArr[i+1][j+1] - mat[i][j] > maxValue)\n\t\t\t\t\tmaxValue = maxArr[i + 1][j + 1] - mat[i][j];\n\t\t\t\tmaxArr[i][j] = Math.max(mat[i][j],\n\t\t\t\t\t\t\t\tMath.max(maxArr[i][j + 1], maxArr[i + 1][j]) );\n\t\t\t}\n\t\t}\n\t\treturn maxValue;\n\t}", "953": "function youngify(mat,i,j)\n\t{\n\t\tlet downVal = (i + 1 < N) ?\n\t\t\t\t\tmat[i + 1][j] : INF;\n\t\tlet rightVal = (j + 1 < N) ?\n\t\t\t\t\tmat[i][j + 1] : INF;\n\t\tif (downVal == INF && rightVal == INF)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (downVal < rightVal)\n\t\t{\n\t\t\tmat[i][j] = downVal;\n\t\t\tmat[i + 1][j] = INF;\n\t\t\tyoungify(mat, i + 1, j);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmat[i][j] = rightVal;\n\t\t\tmat[i][j + 1] = INF;\n\t\t\tyoungify(mat, i, j + 1);\n\t\t}\n\t}\nfunction extractMin(mat)\n\t{\n\t\tlet ret = mat[0][0];\n\t\tmat[0][0] = INF;\n\t\tyoungify(mat, 0, 0);\n\t\treturn ret;\n\t}\nfunction printSorted(mat)\n\t{\n\t\tdocument.write(\"Elements of matrix in sorted order n<br>\");\n\t\tfor (let i = 0; i < N * N; i++)\n\t\t{\n\t\t\tdocument.write(extractMin(mat) + \" \");\n\t\t}\n\t}", "955": "function printSumSimple(mat,k)\n\t{\n\t\tif (k > n) return;\n\t\tfor (let i = 0; i < n-k+1; i++)\n\t\t{\n\t\t\tfor (let j = 0; j < n-k+1; j++)\n\t\t\t{\n\t\t\t\tlet sum = 0;\n\t\t\t\tfor (let p = i; p < k+i; p++)\n\t\t\t\t\tfor (let q = j; q < k+j; q++)\n\t\t\t\t\t\tsum += mat[p][q];\n\t\t\t\tdocument.write(sum+ \" \");\n\t\t\t}\n\t\t\tdocument.write(\"<br>\");\n\t\t}\n\t}", "956": "function printSumTricky(mat, k)\n{\n\tif (k > n)\n\t\treturn;\n\tlet stripSum = new Array(n);\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tstripSum[i] = new Array(n);\n\t}\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tfor(let j = 0; j < n; j++)\n\t\t{\n\t\t\tstripSum[i][j] = 0;\n\t\t}\n\t}\n\tfor(let j = 0; j < n; j++)\n\t{\n\t\tlet sum = 0;\n\t\tfor(let i = 0; i < k; i++)\n\t\t\tsum += mat[i][j];\n\t\tstripSum[0][j] = sum;\n\t\tfor(let i = 1; i < n - k + 1; i++)\n\t\t{\n\t\t\tsum += (mat[i + k - 1][j] - mat[i - 1][j]);\n\t\t\tstripSum[i][j] = sum;\n\t\t}\n\t}\n\tfor(let i = 0; i < n - k + 1; i++)\n\t{\n\t\tlet sum = 0;\n\t\tfor (let j = 0; j < k; j++)\n\t\t\tsum += stripSum[i][j];\n\t\tdocument.write(sum + \" \");\n\t\tfor(let j = 1; j < n - k + 1; j++)\n\t\t{\n\t\t\tsum += (stripSum[i][j + k - 1] - stripSum[i][j - 1]);\n\t\t\tdocument.write(sum + \" \");\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t}\n}", "958": "function transpose(A , B) {\n\t\tvar i, j;\n\t\tfor (i = 0; i < N; i++)\n\t\t\tfor (j = 0; j < M; j++)\n\t\t\t\tB[i][j] = A[j][i];\n\t}", "959": "function transpose(A) {\n\t\tfor (i = 0; i < N; i++)\n\t\t\tfor (j = i + 1; j < N; j++) {\n\t\t\t\tvar temp = A[i][j];\n\t\t\t\tA[i][j] = A[j][i];\n\t\t\t\tA[j][i] = temp;\n\t\t\t}\n\t}", "965": "function pathCountRec(mat, m, n, k)\n{\n\tif (m < 0 n < 0)\n\t\treturn 0;\n\tif (m == 0 && n == 0)\n\t\treturn (k == mat[m][n]);\n\treturn pathCountRec(mat, m - 1, n, k - mat[m][n]) +\n\t\tpathCountRec(mat, m, n - 1, k - mat[m][n]);\n}\nfunction pathCount(mat, k)\n{\n\treturn pathCountRec(mat, R - 1, C - 1, k);\n}", "966": "function pathCountDPRecDP(mat , m , n , k) {\n\t\tif (m < 0 n < 0)\n\t\t\treturn 0;\n\t\tif (m == 0 && n == 0)\n\t\t\treturn (k == mat[m][n] ? 1 : 0);\n\t\tif (dp[m][n][k] != -1)\n\t\t\treturn dp[m][n][k];\n\t\tdp[m][n][k] = pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) + pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]);\n\t\treturn dp[m][n][k];\n\t}\nfunction pathCountDP(mat , k) {\n\t\tfor (i = 0; i < R; i++)\n\t\t\tfor (j = 0; j < C; j++)\n\t\t\t\tfor (l = 0; l < MAX_K; l++)\n\t\t\t\t\tdp[i][j][l] = -1;\n\t\treturn pathCountDPRecDP(mat, R - 1, C - 1, k);\n\t}", "1073": "function printLeast(arr)\n\t{\n\t\tlet min_avail = 1, pos_of_I = 0;\n\t\tlet al = [];\n\t\tif (arr[0] == 'I')\n\t\t{\n\t\t\tal.push(1);\n\t\t\tal.push(2);\n\t\t\tmin_avail = 3;\n\t\t\tpos_of_I = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tal.push(2);\n\t\t\tal.push(1);\n\t\t\tmin_avail = 3;\n\t\t\tpos_of_I = 0;\n\t\t}\n\t\tfor (let i = 1; i < arr.length; i++)\n\t\t{\n\t\t\tif (arr[i] == 'I')\n\t\t\t{\n\t\t\t\tal.push(min_avail);\n\t\t\t\tmin_avail++;\n\t\t\t\tpos_of_I = i + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tal.push(al[i]);\n\t\t\t\tfor (let j = pos_of_I; j <= i; j++)\n\t\t\t\t\tal[j] = al[j] + 1;\n\t\t\t\tmin_avail++;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < al.length; i++)\n\t\t\tdocument.write(al[i] + \" \");\n\t\tdocument.write(\"</br>\");\n\t}", "1074": "function PrintMinNumberForPattern(seq)\n\t{\n\t\tlet result = \"\";\n\t\tlet stk = [];\n\t\tfor (let i = 0; i <= seq.length; i++)\n\t\t{\n\t\t\tstk.push(i + 1);\n\t\t\tif (i == seq.length seq[i] == 'I')\n\t\t\t{\n\t\t\t\twhile (stk.length!=0) {\n\t\t\t\tresult +=\n\t\t\t\t(stk[stk.length - 1]).toString();\n\t\t\t\tresult += \" \";\n\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdocument.write(result + \"</br>\");\n\t}", "1075": "function getMinNumberForPattern(seq)\n\t{\n\t\tlet n = seq.length;\n\t\tif (n >= 9)\n\t\t\treturn \"-1\";\n\t\tlet result = new Array(n + 1);\n\t\tlet count = 1;\n\t\tfor (let i = 0; i <= n; i++)\n\t\t{\n\t\t\tif (i == n seq[i] == 'I')\n\t\t\t{\n\t\t\t\tfor (let j = i - 1; j >= -1; j--)\n\t\t\t\t{\n\t\t\t\t\tresult[j + 1] =\n\t\t\t\t\tString.fromCharCode('0'.charCodeAt() + count++);\n\t\t\t\t\tif (j >= 0 && seq[j] == 'I')\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result.join(\"\");\n\t}", "1252": "function subset(ar, n)\n\t{\n\t\tlet res = 0;\n\t\tar.sort();\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tlet count = 1;\n\t\t\tfor (; i < n - 1; i++)\n\t\t\t{\n\t\t\t\tif (ar[i] == ar[i + 1])\n\t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = Math.max(res, count);\n\t\t}\n\t\treturn res;\n\t}", "1344": "function areElementsContiguous(arr, n)\n\t{\n\tarr.sort(function(a, b){return a - b});\n\tfor (let i = 1; i < n; i++)\n\t\tif (arr[i] - arr[i - 1] > 1)\n\t\t\treturn false;\n\treturn true;\n\t}", "1345": "function areElementsContiguous(arr, n)\n\t{\n\t\tlet max = Number.MIN_VALUE;\n\t\tlet min = Number.MAX_VALUE;\n\t\tfor(let i = 0; i < n; i++)\n\t\t{\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t\tmin = Math.min(min, arr[i]);\n\t\t}\n\t\tlet m = max - min + 1;\n\t\tif (m > n)\n\t\t\treturn false;\n\t\tlet visited = new Array(n);\n\t\tvisited.fill(false);\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tvisited[arr[i] - min] = true;\n\t\tfor (let i = 0; i < m; i++)\n\t\t\tif (visited[i] == false)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "1346": "function areElementsContiguous(arr, n)\n{\n\tvar us = new Set();\n\tfor (var i = 0; i < n; i++)\n\t\tus.add(arr[i]);\n\tvar count = 1;\n\tvar curr_ele = arr[0] - 1;\n\twhile (us.has(curr_ele)) {\n\t\tcount++;\n\t\tcurr_ele--;\n\t}\n\tcurr_ele = arr[0] + 1;\n\twhile (us.has(curr_ele)) {\n\t\tcount++;\n\t\tcurr_ele++;\n\t}\n\treturn (count == (us.size));\n}", "1366": "function longest(a, n, k)\n{\n\tvar freq = Array(7).fill(0);\n\tvar start = 0, end = 0, now = 0, l = 0;\n\tfor (var i = 0; i < n; i++)\n\t{\n\t\tfreq[a[i]]++;\n\t\tif (freq[a[i]] == 1)\n\t\t\tnow++;\n\t\twhile (now > k)\n\t\t{\n\t\t\tfreq[a[l]]--;\n\t\t\tif (freq[a[l]] == 0)\n\t\t\t\tnow--;\n\t\t\tl++;\n\t\t}\n\t\tif (i - l + 1 >= end - start + 1)\n\t\t{\n\t\t\tend = i;\n\t\t\tstart = l;\n\t\t}\n\t}\n\tfor (var i = start; i <= end; i++)\n\t\tdocument.write(a[i]+\" \");\n}", "1390": "function findSmallestRange(arr,n,k)\n{\n\tlet i, minval, maxval, minrange, minel = 0, maxel = 0, flag, minind;\n\t\tfor (i = 0; i <= k; i++) {\n\t\t\tptr[i] = 0;\n\t\t}\n\t\tminrange = Number.MAX_VALUE;\n\t\twhile (true) {\n\t\t\tminind = -1;\n\t\t\tminval = Number.MAX_VALUE;\n\t\t\tmaxval = Number.MIN_VALUE;\n\t\t\tflag = 0;\n\t\t\tfor (i = 0; i < k; i++) {\n\t\t\t\tif (ptr[i] == n) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i][ptr[i]] < minval) {\nminind = i; \n\t\t\t\t\tminval = arr[i][ptr[i]];\n\t\t\t\t}\n\t\t\t\tif (ptr[i] < n && arr[i][ptr[i]] > maxval) {\n\t\t\t\t\tmaxval = arr[i][ptr[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr[minind]++;\n\t\t\tif ((maxval - minval) < minrange) {\n\t\t\t\tminel = minval;\n\t\t\t\tmaxel = maxval;\n\t\t\t\tminrange = maxel - minel;\n\t\t\t}\n\t\t}\n\t\tdocument.write(\"The smallest range is [\"+minel+\", \"+maxel+\"]<br>\");\n}", "1405": "function findLargestd(S, n)\n\t{\n\t\tlet found = false;\n\t\tS.sort();\n\t\tfor (let i = n - 1; i >= 0; i--)\n\t\t{\n\t\t\tfor (let j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (let k = j + 1; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (i == k)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (let l = k + 1; l < n; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i == l)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (S[i] == S[j] + S[k] + S[l])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\treturn S[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found == false)\n\t\t\treturn Number.MAX_VALUE;\n\t\treturn -1;\n\t}", "1406": "function findFourElements(arr,n)\n{\n\tlet map = new Map();\n\t\tfor (let i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (let j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tmap.set(arr[i] + arr[j], new Indexes(i, j));\n\t\t\t}\n\t\t}\n\t\tlet d = Number.MIN_VALUE;\n\t\tfor (let i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tfor (let j = i + 1; j < n; j++)\n\t\t\t{\n\t\t\t\tlet abs_diff = Math.abs(arr[i] - arr[j]);\n\t\t\t\tif (map.has(abs_diff))\n\t\t\t\t{\n\t\t\t\t\tlet indexes = map.get(abs_diff);\n\t\t\t\t\tif (indexes.getI() != i && indexes.getI() != j &&\n\t\t\t\t\tindexes.getJ() != i && indexes.getJ() != j)\n\t\t\t\t\t{\n\t\t\t\t\t\td = Math.max(d, Math.max(arr[i], arr[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n}", "1428": "function leftRotatebyOne(arr , n) {\n\t\tvar i, temp;\n\t\ttemp = arr[0];\n\t\tfor (i = 0; i < n - 1; i++)\n\t\t\tarr[i] = arr[i + 1];\n\t\tarr[n - 1] = temp;\n\t}\nfunction leftRotate(arr , d , n) {\n\t\tfor (i = 0; i < d; i++)\n\t\t\tleftRotatebyOne(arr, n);\n\t}\nfunction printArray(arr , n) {\n\t\tfor (i = 0; i < n; i++)\n\t\t\tdocument.write(arr[i] + \" \");\n\t}", "1468": "function pushZerosToEnd(arr, n)\n{\nlet count = 0; \n\tfor (let i = 0; i < n; i++)\n\t\tif (arr[i] != 0)\narr[count++] = arr[i]; \n\twhile (count < n)\n\t\tarr[count++] = 0;\n}", "1469": "function moveZerosToEnd(arr, n)\n{\n\tlet count = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tif (arr[i] != 0)\n\t\t{\n\t\t\t\ttemp = arr[count];\n\t\t\t\tarr[count] = arr[i];\n\t\t\t\tarr[i] = temp;\n\t\t\t\tcount = count + 1;\n\t\t}\n}\nfunction printArray(arr, n)\n{\n\tfor (let i = 0; i < n; i++)\n\t\tdocument.write(arr[i] + \" \");\n}", "1473": "function pushZerosToEnd(arr, n)\n\t{\n\t\tvar count = 0;\n\t\tfor (var i = 0; i < n; i++)\n\t\tif (arr[i] != 0)\n\t\t\tarr[count++] = arr[i];\n\t\twhile (count < n) arr[count++] = 0;\n\t}\nfunction modifyAndRearrangeArr(arr, n)\n\t{\n\t\tif (n == 1) return;\n\t\tfor (var i = 0; i < n - 1; i++)\n\t\t{\n\t\tif (arr[i] != 0 && arr[i] == arr[i + 1]) {\n\t\t\tarr[i] = 2 * arr[i];\n\t\t\tarr[i + 1] = 0;\n\t\t\ti++;\n\t\t}\n\t\t}\n\t\tpushZerosToEnd(arr, n);\n\t}\nfunction printArray(arr, n)\n\t{\n\t\tfor (var i = 0; i < n; i++) document.write(arr[i] + \" \");\n\t}", "1474": "function swap(A,i,j)\n\t{\n\t\tlet temp = A[i];\n\t\tA[i] = A[j];\n\t\tA[j] = temp;\n\t}\nfunction shiftAllZeroToLeft(array,n)\n\t{\n\t\tlet lastSeenNonZero = 0;\n\t\tfor (let index = 0; index < n; index++) {\n\t\t\tif (array[index] != 0) {\n\t\t\t\tswap(array, array[index], array[lastSeenNonZero]);\n\t\t\t\tlastSeenNonZero++;\n\t\t\t}\n\t\t}\n\t}", "1478": "function printArray(arr, n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tdocument.write(arr[i] + \" \");\n\t\tdocument.write(\"<br />\");\n\t}\nfunction RearrangePosNeg(arr, n)\n\t{\n\t\tlet key, j;\n\t\tfor (let i = 1; i < n; i++) {\n\t\t\tkey = arr[i];\n\t\t\tif (key > 0)\n\t\t\t\tcontinue;\n\t\t\tj = i - 1;\n\t\t\twhile (j >= 0 && arr[j] > 0) {\n\t\t\t\tarr[j + 1] = arr[j];\n\t\t\t\tj = j - 1;\n\t\t\t}\n\t\t\tarr[j + 1] = key;\n\t\t}\n\t}", "1480": "function printArray(A,size)\n\t{\n\t\tfor (let i = 0; i < size; i++)\n\t\t\tdocument.write(A[i] + \" \");\n\t\tdocument.write(\"<br>\");\n\t}\nfunction reverse(arr,l,r)\n\t{\n\t\tif (l < r) {\n\t\t\tarr = swap(arr, l, r);\n\t\t\treverse(arr, ++l, --r);\n\t\t}\n\t}\nfunction merge(arr,l,m,r)\n\t{\nlet i = l; \nlet j = m + 1; \n\t\twhile (i <= m && arr[i] < 0)\n\t\t\ti++;\n\t\twhile (j <= r && arr[j] < 0)\n\t\t\tj++;\n\t\treverse(arr, i, m);\n\t\treverse(arr, m + 1, j - 1);\n\t\treverse(arr, i, j - 1);\n\t}\nfunction RearrangePosNeg(arr,l,r)\n\t{\n\t\tif (l < r) {\n\t\t\tlet m = l + Math.floor((r - l) / 2);\n\t\t\tRearrangePosNeg(arr, l, m);\n\t\t\tRearrangePosNeg(arr, m + 1, r);\n\t\t\tmerge(arr, l, m, r);\n\t\t}\n\t}\nfunction swap(arr,i,j)\n\t{\n\t\tlet temp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t\treturn arr;\n\t}", "1481": "function RearrangePosNeg(arr)\n{\n\tvar i = 0;\n\tvar j = arr.length - 1;\n\twhile(true)\n\t{\n\t\twhile(arr[i] < 0 && i < arr.length)\n\t\ti++;\n\t\twhile(arr[j] > 0 && j >= 0)\n\t\tj--;\n\t\t\tif(i < j)\n\t\t\t{\n\t\t\t\tvar temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t}\n\t\t\telse\n\t\t\tbreak;\n\t\t}\n\t}", "1515": "function findElements(arr, n)\n{\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tlet count = 0;\n\t\tfor (let j = 0; j < n; j++)\n\t\t\tif (arr[j] > arr[i])\n\t\t\t\tcount++;\n\t\tif (count >= 2)\n\t\t\tdocument.write(arr[i] + \" \");\n\t}\n}", "1516": "function findElements(arr, n)\n{\n\tarr.sort();\n\tfor(let i = 0; i < n - 2; i++)\n\t\tdocument.write(arr[i] + \" \");\n}", "1517": "function findElements(arr, n)\n{\n\tlet first = Number.MIN_VALUE;\n\tlet second = Number.MAX_VALUE;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > first)\n\t\t{\n\t\t\tsecond = first;\n\t\t\tfirst = arr[i];\n\t\t}\n\t\telse if (arr[i] > second)\n\t\t\tsecond = arr[i];\n\t}\n\tfor(let i = 0; i < n; i++)\n\t\tif (arr[i] < second)\n\t\t\tdocument.write(arr[i] + \" \") ;\n}", "1535": "function findFirstMissing(array, start, end)\n\t{\n\t\tif (start > end)\n\t\t\treturn end + 1;\n\t\tif (start != array[start])\n\t\t\treturn start;\n\t\tlet mid = parseInt((start + end) / 2, 10);\n\t\tif (array[mid] == mid)\n\t\t\treturn findFirstMissing(array, mid+1, end);\n\t\treturn findFirstMissing(array, start, mid);\n\t}", "1536": "function findFirstMissing(arr, start, end, first)\n{\n\tif (start < end)\n\t{\n\t\tlet mid = (start + end) / 2;\n\t\tif (arr[mid] != mid + first)\n\t\t\treturn findFirstMissing(arr, start, mid, first);\n\t\telse\n\t\t\treturn findFirstMissing(arr, mid + 1, end, first);\n\t}\n\treturn start + first;\n}\nfunction findSmallestMissinginSortedArray(arr)\n{\n\tif (arr[0] != 0)\n\t\treturn 0;\n\tif (arr[arr.length - 1] == arr.length - 1)\n\t\treturn arr.length;\n\tlet first = arr[0];\n\treturn findFirstMissing( arr, 0, arr.length - 1, first);\n}", "1537": "function FindMaxSum(arr, n)\n{\n\tlet incl = arr[0];\n\tlet excl = 0;\n\tlet excl_new;\n\tlet i;\n\tfor(i = 1; i < n; i++)\n\t{\n\t\texcl_new = (incl > excl) ? incl : excl;\n\t\tincl = excl + arr[i];\n\t\texcl = excl_new;\n\t}\n\treturn ((incl > excl) ? incl : excl);\n}", "1545": "function buildSparseTable(arr, n)\n{\n\tfor (var i = 0; i < n; i++)\n\t\tlookup[i][0] = arr[i];\n\tfor (var j = 1; (1 << j) <= n; j++) {\n\t\tfor (var i = 0; (i + (1 << j) - 1) < n; i++) {\n\t\t\tif (lookup[i][j - 1] <\n\t\t\t\t\t\tlookup[i + (1 << (j - 1))][j - 1])\n\t\t\t\tlookup[i][j] = lookup[i][j - 1];\n\t\t\telse\n\t\t\t\tlookup[i][j] =\n\t\t\t\t\t\tlookup[i + (1 << (j - 1))][j - 1];\n\t\t}\n\t}\n}\nfunction query(L, R)\n{\n\tvar j = parseInt(Math.log2(R - L + 1));\n\tif (lookup[L][j] <= lookup[R - (1 << j) + 1][j])\n\t\treturn lookup[L][j];\n\telse\n\t\treturn lookup[R - (1 << j) + 1][j];\n}", "1590": "function findMaxAverage(arr, n, k)\n{\n\tif (k > n)\n\t\treturn -1;\n\tlet csum = new Array(n);\n\tcsum[0] = arr[0];\n\tfor(let i = 1; i < n; i++)\n\t\tcsum[i] = csum[i - 1] + arr[i];\n\tlet max_sum = csum[k - 1],\n\t\tmax_end = k - 1;\n\tfor(let i = k; i < n; i++)\n\t{\n\t\tlet curr_sum = csum[i] - csum[i - k];\n\t\tif (curr_sum > max_sum)\n\t\t{\n\t\t\tmax_sum = curr_sum;\n\t\t\tmax_end = i;\n\t\t}\n\t}\n\treturn max_end - k + 1;\n}", "1591": "function findMaxAverage(arr, n, k)\n\t{\n\t\tif (k > n)\n\t\t\treturn -1;\n\t\tlet sum = arr[0];\n\t\tfor (let i = 1; i < k; i++)\n\t\t\tsum += arr[i];\n\t\tlet max_sum = sum;\n\t\tlet max_end = k-1;\n\t\tfor (let i = k; i < n; i++)\n\t\t{\n\t\t\tsum = sum + arr[i] - arr[i-k];\n\t\t\tif (sum > max_sum)\n\t\t\t{\n\t\t\t\tmax_sum = sum;\n\t\t\t\tmax_end = i;\n\t\t\t}\n\t\t}\n\t\treturn max_end - k + 1;\n\t}", "1694": "function isMajority(arr, n, x)\n\t{\n\t\tlet i, last_index = 0;\n\t\tlast_index = (n % 2 == 0) ?\n\t\tparseInt(n / 2, 10) : parseInt(n / 2, 10) + 1;\n\t\tfor (i = 0; i < last_index; i++) {\n\t\t\tif (arr[i] == x && arr[i + parseInt(n / 2, 10)] == x)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "1695": "function _binarySearch(arr, low, high, x)\n\t{\n\t\tif (high >= low) {\n\t\t\tlet mid = parseInt((low + high) / 2, 10);\n\t\t\tif ((mid == 0 x > arr[mid - 1]) && (arr[mid] == x))\n\t\t\t\treturn mid;\n\t\t\telse if (x > arr[mid])\n\t\t\t\treturn _binarySearch(arr, (mid + 1), high, x);\n\t\t\telse\n\t\t\t\treturn _binarySearch(arr, low, (mid - 1), x);\n\t\t}\n\t\treturn -1;\n\t}\nfunction isMajority(arr, n, x)\n\t{\n\t\tlet i = _binarySearch(arr, 0, n - 1, x);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\tif (((i + parseInt(n / 2, 10)) <= (n - 1)) && arr[i + parseInt(n / 2, 10)] == x)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "1696": "function isMajorityElement(arr, n, key)\n\t{\n\t\tif (arr[parseInt(n / 2, 10)] == key)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "1730": "function sortMat(mat, n)\n{\n\tlet temp = new Array(n * n);\n\tlet k = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tfor (let j = 0; j < n; j++)\n\t\t\ttemp[k++] = mat[i][j];\n\ttemp.sort();\n\tk = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tfor (let j = 0; j < n; j++)\n\t\t\tmat[i][j] = temp[k++];\n}\nfunction printMat(mat, n)\n{\n\tfor (let i = 0; i < n; i++) {\n\t\tfor (let j = 0; j < n; j++)\n\t\t\tdocument.write( mat[i][j] + \" \");\n\t\tdocument.write( \"<br>\");\n\t}\n}", "1813": "function findCrossOver(arr, low, high, x)\n{\nif (arr[high] <= x) \n\t\treturn high\nif (arr[low] > x) \n\t\treturn low\nvar mid = (low + high) /2\n\tif (arr[mid] <= x && arr[mid + 1] > x)\n\t\treturn mid\n\tif (arr[mid] < x)\n\t\treturn findCrossOver(arr, mid + 1, high, x)\n\treturn findCrossOver(arr, low, mid - 1, x)\n}\nfunction printKclosest(arr, x, k, n)\n{\n\tvar l = findCrossOver(arr, 0, n - 1, x)\nvar r = l + 1 \nvar count = 0 \n\tif (arr[l] == x)\n\t\tl -= 1\n\twhile (l >= 0 && r < n && count < k)\n\t{\n\t\tif (x - arr[l] < arr[r] - x)\n\t\t{\n\t\t\tdocument.write(arr[l] + \" \")\n\t\t\tl -= 1\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.write(arr[r] + \" \")\n\t\t\tr += 1\n\t\t}\n\t\tcount += 1\n\t}\n\twhile (count < k && l >= 0)\n\t{\n\t\tprint(arr[l])\n\t\tl -= 1\n\t\tcount += 1\n\t}\n\twhile (count < k && r < n)\n\t{\n\t\tprint(arr[r])\n\t\tr += 1\n\t\tcount += 1\n\t}\n}", "1822": "function push(val) {\n\t\tvar newnode = new node(val);\n\t\tnewnode.next = head;\n\t\thead = newnode;\n\t}\nfunction insertionSort( headref) {\n\t\tvar sorted = null;\n\t\tvar current = headref;\n\t\twhile (current != null) {\n\t\t\tvar next = current.next;\n\t\t\tsortedInsert(current);\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = sorted;\n\t}\nfunction sortedInsert( newnode) {\n\t\tif (sorted == null sorted.val >= newnode.val) {\n\t\t\tnewnode.next = sorted;\n\t\t\tsorted = newnode;\n\t\t} else {\n\t\t\tvar current = sorted;\n\t\t\twhile (current.next != null && current.next.val < newnode.val) {\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\tnewnode.next = current.next;\n\t\t\tcurrent.next = newnode;\n\t\t}\n\t}\nfunction printlist( head) {\n\t\twhile (head != null) {\n\t\t\tdocument.write(head.val + \" \");\n\t\t\thead = head.next;\n\t\t}\n\t}", "1847": "function count(S , m , n )\n{\n\tif (n == 0)\n\t\treturn 1;\n\tif (n < 0)\n\t\treturn 0;\n\tif (m <=0 && n >= 1)\n\t\treturn 0;\n\treturn count( S, m - 1, n ) +\n\t\tcount( S, m, n - S[m - 1] );\n}", "1849": "function count(S, m, n)\n\t{\n\t\tlet table = new Array(n + 1);\n\t\ttable.fill(0);\n\t\ttable[0] = 1;\n\t\tfor(let i = 0; i < m; i++)\n\t\t\tfor(let j = S[i]; j <= n; j++)\n\t\t\t\ttable[j] += table[j - S[i]];\n\t\treturn table[n];\n\t}", "1852": "function matrixChainMemoised(p, i, j)\n{\n\tif (i == j) \n\t{\n\t\treturn 0;\n\t}\n\tif (dp[i][j] != -1) \n\t{\n\t\treturn dp[i][j];\n\t}\n\tdp[i][j] = Number.MAX_VALUE;\n\tfor(let k = i; k < j; k++) \n\t{\n\t\tdp[i][j] = Math.min(\n\t\t\tdp[i][j], matrixChainMemoised(p, i, k) +\n\t\t\t\t\tmatrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n\t}\n\treturn dp[i][j];\n}\nfunction MatrixChainOrder(p, n)\n{\n\tlet i = 1, j = n - 1;\n\treturn matrixChainMemoised(p, i, j);\n}", "1853": "function MatrixChainOrder(p , n)\n{\n\tvar m = Array(n).fill(0).map(x => Array(n).fill(0));\n\tvar i, j, k, L, q;\n\tfor (i = 1; i < n; i++)\n\t\tm[i][i] = 0;\n\tfor (L = 2; L < n; L++)\n\t{\n\t\tfor (i = 1; i < n - L + 1; i++)\n\t\t{\n\t\t\tj = i + L - 1;\n\t\t\tif (j == n)\n\t\t\t\tcontinue;\n\t\t\tm[i][j] = Number.MAX_VALUE;\n\t\t\tfor (k = i; k <= j - 1; k++)\n\t\t\t{\n\t\t\t\tq = m[i][k] + m[k + 1][j]\n\t\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\t\t\tif (q < m[i][j])\n\t\t\t\t\tm[i][j] = q;\n\t\t\t}\n\t\t}\n\t}\n\treturn m[1][n - 1];\n}", "1869": "function cutRod(price, n)\n\t{\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tlet max_val = Number.MIN_VALUE;\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tmax_val = Math.max(max_val, price[i] +\n\t\t\t\t\t\tcutRod(price, n - i - 1));\n\t\treturn max_val;\n\t}", "1870": "function cutRod(price, n)\n\t{\n\t\tlet val = new Array(n + 1);\n\t\tval[0] = 0;\n\t\tfor (let i = 1; i<=n; i++)\n\t\t{\n\t\t\tlet max_val = Number.MIN_VALUE;\n\t\t\tfor (let j = 0; j < i; j++)\n\t\t\t\tmax_val = Math.max(max_val, price[j] + val[i - j - 1]);\n\t\t\tval[i] = max_val;\n\t\t}\n\t\treturn val[n];\n\t}", "1871": "function un_kp(price, length, Max_len, n)\n{\n\tif (n == 0 Max_len == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (length[n - 1] <= Max_len)\n\t{\n\t\tt[n][Max_len]\n\t\t\t= Math.max(price[n - 1]\n\t\t\t\t\t+ un_kp(price, length, Max_len - length[n - 1], n),\n\t\t\t\tun_kp(price, length, Max_len, n - 1));\n\t}\n\telse\n\t{\n\t\tt[n][Max_len]\n\t\t\t= un_kp(price, length, Max_len, n - 1);\n\t}\n\treturn t[n][Max_len];\n}", "1998": "function multiply( x, y)\n{\n\tif(y == 0)\n\treturn 0;\n\tif(y > 0 )\n\treturn (x + multiply(x, y-1));\n\tif(y < 0 )\n\treturn -multiply(x, -y);\n}", "2013": "function sieveOfEratosthenes(n)\n{\n\tprime = Array.from({length: n+1}, (_, i) => true);\n\tfor (p = 2; p * p <= n; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor (i = 2; i <= n; i++)\n\t{\n\t\tif (prime[i] == true)\n\t\t\tdocument.write(i + \" \");\n\t}\n}", "2024": "function binomialCoeff(n, k)\n\t{\n\t\tlet res = 1;\n\t\tif (k > n - k)\n\t\tk = n - k;\n\t\tfor (let i = 0; i < k; ++i)\n\t\t{\n\t\t\tres *= (n - i);\n\t\t\tres /= (i + 1);\n\t\t}\n\t\treturn res;\n\t}\nfunction printPascal(n)\n\t{\n\tfor (let line = 0; line < n; line++)\n\t{\n\t\tfor (let i = 0; i <= line; i++)\n\t\tdocument.write(binomialCoeff\n\t\t\t\t\t\t(line, i)+\" \");\n\t\tdocument.write(\"<br />\");\n\t}\n\t}", "2025": "function printPascal(n)\n{\narr = a = Array(n).fill(0).map(x => Array(n).fill(0));\nfor (line = 0; line < n; line++)\n{\n\tfor (i = 0; i <= line; i++)\n\t{\n\tif (line == i i == 0)\n\t\tarr[line][i] = 1;\n\telse\n\t\tarr[line][i] = arr[line-1][i-1] + arr[line-1][i];\n\tdocument.write(arr[line][i]);\n\t}\n\tdocument.write(\"<br>\");\n}\n}", "2026": "function printPascal(n)\n{\n\tfor(line = 1; line <= n; line++)\n\t{\nvar C=1;\n\tfor(i = 1; i <= line; i++)\n\t{\n\t\tdocument.write(C+\" \");\n\t\tC = C * (line - i) / i;\n\t}\n\tdocument.write(\"<br>\");\n\t}\n}", "2079": "function Add(x, y) {\n\t\twhile (y != 0)\n\t\t{\n\t\t\tlet carry = x & y; \n\t\t\tx = x ^ y; \n\t\t\ty = carry << 1;\n\t\t}\n\t\treturn x;\n\t}", "2080": "function Add(x, y)\n{\n\tif (y == 0)\n\t\treturn x;\n\telse\n\t\treturn Add(x ^ y, (x & y) << 1);\n}", "2101": "function getModulo(n,d)\n{\n\treturn ( n & (d - 1) );\n}", "2114": "function countSetBits(n)\n {\n\tvar count = 0;\n\twhile (n)\n\t{\n\tcount += n & 1;\n\tn >>= 1;\n\t}\n\treturn count;\n }", "2117": "function countSetBits(n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\telse\n\t\treturn 1 + countSetBits(n & (n - 1));\n}", "2118": "function initialize()\n{\n\tBitsSetTable256[0] = 0;\n\tfor (var i = 0; i < 256; i++) {\n\t\tBitsSetTable256[i] = (i & 1) +\n\t\tBitsSetTable256[parseInt(i / 2)];\n\t}\n}\nfunction countSetBits(n)\n{\n\treturn (BitsSetTable256[n & 0xff]\n\t\t\t+ BitsSetTable256[(n >> 8) & 0xff]\n\t\t\t+ BitsSetTable256[(n >> 16) & 0xff] + BitsSetTable256[n >> 24]);\n}", "2119": "", "2120": "function countSetBitsRec(num)\n{\n\tvar nibble = 0;\n\tif (0 == num)\n\t\treturn num_to_bits[0];\n\tnibble = num & 0xf;\n\treturn num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}", "2121": "function countSetBits(N)\n {\n\tvar count = 0;\n\tfor (i = 0; i < 4 * 8; i++)\n\t{\n\t\tif ((N & (1 << i)) != 0)\n\t\tcount++;\n\t}\n\treturn count;\n }", "2127": "function getParity(n)\n{\n\tvar parity = false;\n\twhile(n != 0)\n\t{\n\t\tparity = !parity;\n\t\tn = n & (n - 1);\n\t}\n\treturn parity;\n}", "2129": "function isPowerOfTwo(n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn false;\n\t\treturn parseInt( (Math.ceil((Math.log(n) / Math.log(2))))) == parseInt( (Math.floor(((Math.log(n) / Math.log(2))))));\n\t}", "2130": "function isPowerOfTwo(n)\n\t{\n\t\tif (n == 0)\n\t\t\treturn 0;\n\t\twhile (n != 1)\n\t\t{\n\t\t\tif (n%2 != 0)\n\t\t\t\treturn 0;\n\t\t\tn = n/2;\n\t\t}\n\t\treturn 1;\n\t}", "2131": "function powerOf2(n)\n{\n if (n == 1)\n\treturn true;\n else if (n % 2 != 0 n ==0)\n\treturn false;\n return powerOf2(n / 2);\n}", "2132": "function isPowerOfTwo (x)\n\t{\n\t\treturn x!=0 && ((x&(x-1)) == 0);\n\t}", "2210": "function maxRepeating(arr, n, k)\n{\n\tfor (let i = 0; i< n; i++)\n\t\tarr[arr[i]%k] += k;\n\tlet max = arr[0], result = 0;\n\tfor (let i = 1; i < n; i++)\n\t{\n\t\tif (arr[i] > max)\n\t\t{\n\t\t\tmax = arr[i];\n\t\t\tresult = i;\n\t\t}\n\t}\n\treturn result;\n}", "2226": "function fun(x)\n{\n\tlet y = parseInt(x / 4) * 4;\n\tlet ans = 0;\n\tfor (let i = y; i <= x; i++)\n\t\tans ^= i;\n\treturn ans;\n}\nfunction query(x)\n{\n\tif (x == 0)\n\t\treturn 0;\n\tlet k = parseInt((x + 1) / 2);\n\treturn (x %= 2) ? 2 * fun(k) : ((fun(k - 1) * 2) ^ (k & 1));\n}\nfunction allQueries(q, l, r)\n{\n\tfor (let i = 0; i < q; i++)\n\t\tdocument.write((query(r[i]) ^ query(l[i] - 1)) + \"<br>\");\n}", "2243": "function prefixXOR(arr, preXOR, n)\n{\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\twhile (arr[i] % 2 != 1)\n\t\t\tarr[i] = parseInt(arr[i] / 2);\n\t\tpreXOR[i] = arr[i];\n\t}\n\tfor(let i = 1; i < n; i++)\n\t\tpreXOR[i] = preXOR[i - 1] ^ preXOR[i];\n}\nfunction query(preXOR, l, r)\n{\n\tif (l == 0)\n\t\treturn preXOR[r];\n\telse\n\t\treturn preXOR[r] ^ preXOR[l - 1];\n}", "2258": "function findMinSwaps(arr, n)\n\t{\n\t\tlet noOfZeroes = [];\n\t\tlet i, count = 0;\n\t\tnoOfZeroes[n - 1] = 1 - arr[n - 1];\n\t\tfor (i = n - 2; i >= 0; i--)\n\t\t{\n\t\t\tnoOfZeroes[i] = noOfZeroes[i + 1];\n\t\t\tif (arr[i] == 0)\n\t\t\t\tnoOfZeroes[i]++;\n\t\t}\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] == 1)\n\t\t\t\tcount += noOfZeroes[i];\n\t\t}\n\t\treturn count;\n\t}", "2259": "function minswaps(arr, n)\n{\n\tvar count = 0;\n\tvar num_unplaced_zeros = 0;\n\tfor(var index = n - 1; index >= 0; index--)\n\t{\n\t\tif(arr[index] == 0)\n\t\t\tnum_unplaced_zeros += 1;\n\t\telse\n\t\t\tcount += num_unplaced_zeros;\n\t}\n\treturn count;\n}", "2281": "function arraySortedOrNot(arr, n)\n\t{\n\t\tif (n == 0 n == 1)\n\t\t\treturn true;\n\t\tfor (let i = 1; i < n; i++)\n\t\t\tif (arr[i - 1] > arr[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "2308": "function printTwoOdd(arr, size)\n{\n\tlet xor2 = arr[0];\n\tlet set_bit_no; \n\tlet i;\n\tint n = size - 2;\n\tlet x = 0, y = 0;\n\tfor(i = 1; i < size; i++)\n\t\txor2 = xor2 ^ arr[i];\n\tset_bit_no = xor2 & ~(xor2-1);\n\tfor(i = 0; i < size; i++)\n\t{\n\t\tif ((arr[i] & set_bit_no)>0)\n\t\t\tx = x ^ arr[i];\n\t\telse\n\t\t\ty = y ^ arr[i];\n\t}\n\tdocument.write(\"The two ODD elements are \"+ x + \" & \" + y + \"</br>\");\n}", "2309": "function printTwoOdd(arr, size)\n{\n\tlet m = new Map();\n\tfor (let i = 0; i < size; i++) {\n\t\tif(m.has(arr[i])){\n\t\t\tm.set(arr[i], m.get(arr[i]) + 1)\n\t\t}else{\n\t\t\tm.set(arr[i], 1)\n\t\t}\n\t}\n\tdocument.write(\"The two ODD elements are \");\n\tlet ar = []\n\tfor (let x of m) {\n\t\tif (x[1] % 2 != 0)\n\t\t\tar.push(x[0])\n\t}\n\tdocument.write(`${ar.reverse()},`)\n}", "2310": "function findPair(arr, size, n) {\n\t\tlet i = 0;\n\t\tlet j = 1;\n\t\twhile (i < size && j < size) {\n\t\t\tif (i != j && arr[j] - arr[i] == n) {\n\t\t\t\tdocument.write(\"Pair Found: (\" + arr[i] + \", \" + arr[j] + \")\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (arr[j] - arr[i] < n)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\ti++;\n\t\t}\n\t\tdocument.write(\"No such pair\");\n\t\treturn false;\n\t}", "2360": "function printMax(arr, k, n)\n{\n\tvar brr = arr.slice();\n\tbrr.sort((a, b) => b - a);\n\tfor (var i = 0; i < n; ++i)\n\t\tif (brr.indexOf(arr[i]) < k)\n\t\t\tdocument.write(arr[i] +\" \");\n}", "2372": "function printSmall(arr, asize, n)\n{\n\tlet copy_arr = [...arr];\n\tcopy_arr.sort((a, b) => a - b);\n\tfor (let i = 0; i < asize; ++i) {\n\t\tif (arr[i] < copy_arr[n])\n\t\t\tdocument.write(arr[i] + \" \");\n\t}\n}", "2379": "function checkIsAP(arr, n)\n{\n if (n == 1)\n\treturn true;\n arr.sort((a, b) => a - b);\n let d = arr[1] - arr[0];\n for (let i=2; i<n; i++)\n\tif (arr[i] - arr[i-1] != d)\n\treturn false;\n return true;\n}", "2380": "function checkIsAP(arr, n)\n{\n\tvar hm = new Map();\n\tvar smallest = 1000000000, second_smallest = 1000000000;\n\tfor (var i = 0; i < n; i++) {\n\t\tif (arr[i] < smallest) {\n\t\t\tsecond_smallest = smallest;\n\t\t\tsmallest = arr[i];\n\t\t}\n\t\telse if (arr[i] != smallest && arr[i] < second_smallest)\n\t\t\tsecond_smallest = arr[i];\n\t\tif (!hm.has(arr[i]))\n\t\t{\n\t\t\thm.set(arr[i], 1);\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\tvar diff = second_smallest - smallest;\n\tfor (var i = 0; i < n - 1; i++) {\n\t\tif (!hm.has(second_smallest))\n\t\t\treturn false;\n\t\tsecond_smallest += diff;\n\t}\n\treturn true;\n}", "2382": "function countPairs(a, n)\n\t{\n\t\tlet mn = Number.MAX_VALUE;\n\t\tlet mx = Number.MIN_VALUE;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tmn = Math.min(mn, a[i]);\n\t\t\tmx = Math.max(mx, a[i]);\n\t\t}\n\t\tlet c1 = 0;\nlet c2 = 0; \n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tif (a[i] == mn)\n\t\t\t\tc1++;\n\t\t\tif (a[i] == mx)\n\t\t\t\tc2++;\n\t\t}\n\t\tif (mn == mx)\n\t\t\treturn n * (n - 1) / 2;\n\t\telse\n\t\t\treturn c1 * c2;\n\t}", "2437": "function rearrange(head)\n\t{\nif (head == null) \n\t\t\treturn null;\n\t\tlet prev = head, curr = head.next;\n\t\twhile (curr != null)\n\t\t{\n\t\t\tif (prev.data > curr.data) {\n\t\t\t\tlet t = prev.data;\n\t\t\t\tprev.data = curr.data;\n\t\t\t\tcurr.data = t;\n\t\t\t}\n\t\t\tif (curr.next != null && curr.next.data > curr.data) {\n\t\t\t\tlet t = curr.next.data;\n\t\t\t\tcurr.next.data = curr.data;\n\t\t\t\tcurr.data = t;\n\t\t\t}\n\t\t\tprev = curr.next;\n\t\t\tif (curr.next == null)\n\t\t\t\tbreak;\n\t\t\tcurr = curr.next.next;\n\t\t}\n\t\treturn head;\n\t}\nfunction push(head,k)\n\t{\n\t\tlet tem = new Node();\n\t\ttem.data = k;\n\t\ttem.next = head;\n\t\thead = tem;\n\t\treturn head;\n\t}\nfunction display(head)\n\t{\n\t\tlet curr = head;\n\t\twhile (curr != null) {\n\t\t\tdocument.write(curr.data+\" \");\n\t\t\tcurr = curr.next;\n\t\t}\n\t}", "2438": "function printlist(head) {\n\t\twhile (head != null) {\n\t\t\tdocument.write(head.data + \" \");\n\t\t\tif (head.next != null) {\n\t\t\t\tdocument.write(\"->\");\n\t\t\t}\n\t\t\thead = head.next;\n\t\t}\n\t\tdocument.write(\"<br/>\");\n\t}\nfunction rearrange(head) {\n\t\tif (head != null) {\n\t\t\tleft = head;\n\t\t\treorderListUtil(left);\n\t\t}\n\t}\nfunction reorderListUtil(right) {\n\t\tif (right == null) {\n\t\t\treturn;\n\t\t}\n\t\treorderListUtil(right.next);\n\t\tif (left == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (left != right && left.next != right) {\n\tvar temp = left.next;\n\t\t\tleft.next = right;\n\t\t\tright.next = temp;\n\t\t\tleft = temp;\n} else { \n\t\t\tif (left.next == right) {\nleft.next.next = null; \n\t\t\t\tleft = null;\n\t\t\t} else {\nleft.next = null; \n\t\t\t\tleft = null;\n\t\t\t}\n\t\t}\n\t}", "2464": "function getLength(node) {\n\t\tvar size = 0;\n\t\twhile (node != null) {\n\t\t\tnode = node.next;\n\t\t\tsize++;\n\t\t}\n\t\treturn size;\n\t}\nfunction paddZeros(sNode , diff) {\n\t\tif (sNode == null)\n\t\t\treturn null;\nvar zHead = new Node(0);\n\t\tdiff--;\nvar temp = zHead;\n\t\twhile ((diff--) != 0) {\n\t\t\ttemp.next = new Node(0);\n\t\t\ttemp = temp.next;\n\t\t}\n\t\ttemp.next = sNode;\n\t\treturn zHead;\n\t}\nfunction subtractLinkedListHelper(l1, l2) {\n\t\tif (l1 == null && l2 == null && borrow == false)\n\t\t\treturn null;\n\tvar previous = subtractLinkedListHelper((l1 != null) ?\n\tl1.next : null, (l2 != null) ? l2.next : null);\n\t\tvar d1 = l1.data;\n\t\tvar d2 = l2.data;\n\t\tvar sub = 0;\n\t\tif (borrow) {\n\t\t\td1--;\n\t\t\tborrow = false;\n\t\t}\n\t\tif (d1 < d2) {\n\t\t\tborrow = true;\n\t\t\td1 = d1 + 10;\n\t\t}\n\t\tsub = d1 - d2;\nvar current = new Node(sub);\n\t\tcurrent.next = previous;\n\t\treturn current;\n\t}\nfunction subtractLinkedList(l1, l2) {\n\t\tif (l1 == null && l2 == null)\n\t\t\treturn null;\n\t\tvar len1 = getLength(l1);\n\t\tvar len2 = getLength(l2);\nvar lNode = null, sNode = null;\nvar temp1 = l1;\nvar temp2 = l2;\n\t\tif (len1 != len2) {\n\t\t\tlNode = len1 > len2 ? l1 : l2;\n\t\t\tsNode = len1 > len2 ? l2 : l1;\n\t\t\tsNode = paddZeros(sNode, Math.abs(len1 - len2));\n\t\t}\n\t\telse {\n\t\t\twhile (l1 != null && l2 != null) {\n\t\t\t\tif (l1.data != l2.data) {\n\t\t\t\t\tlNode = l1.data > l2.data ? temp1 : temp2;\n\t\t\t\t\tsNode = l1.data > l2.data ? temp2 : temp1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tl1 = l1.next;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t}\n\t\tborrow = false;\n\t\treturn subtractLinkedListHelper(lNode, sNode);\n\t}\nfunction printList(head) {\nvar temp = head;\n\t\twhile (temp != null) {\n\t\t\tdocument.write(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2501": "function insertAtMid(x) {\n\t\tif (head == null)\n\t\t\thead = new Node(x);\n\t\telse {\n\t\t\tvar newNode = new Node(x);\n\t\t\tvar ptr = head;\n\t\t\tvar len = 0;\n\t\t\twhile (ptr != null) {\n\t\t\t\tlen++;\n\t\t\t\tptr = ptr.next;\n\t\t\t}\n\t\t\tvar count = ((len % 2) == 0) ? (len / 2) :\n\t\t\t(len + 1) / 2;\n\t\t\tptr = head;\n\t\t\twhile (count-- > 1)\n\t\t\t\tptr = ptr.next;\n\t\t\tnewNode.next = ptr.next;\n\t\t\tptr.next = newNode;\n\t\t}\n\t}\nfunction display() {\n\t\tvar temp = head;\n\t\twhile (temp != null) {\n\t\t\tdocument.write(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2502": "function insertAtMid(x) {\n\t\tif (head == null)\n\t\t\thead = new Node(x);\n\t\telse {\n\tvar newNode = new Node(x);\n\tvar slow = head;\n\tvar fast = head.next;\n\t\t\twhile (fast != null && fast.next != null)\n\t\t\t{\n\t\t\t\tslow = slow.next;\n\t\t\t\tfast = fast.next.next;\n\t\t\t}\n\t\t\tnewNode.next = slow.next;\n\t\t\tslow.next = newNode;\n\t\t}\n\t}\nfunction display() {\n\tvar temp = head;\n\t\twhile (temp != null) {\n\t\t\tdocument.write(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t}", "2518": "function getNode(data) {\n\t\tvar newNode = new Node();\n\t\tnewNode.data = data;\n\t\tnewNode.prev = newNode.next = null;\n\t\treturn newNode;\n\t}\nfunction sortedInsert(head_ref, newNode) {\n\t\tvar current;\n\t\tif (head_ref == null)\n\t\t\thead_ref = newNode;\n\t\telse if ((head_ref).data >= newNode.data) {\n\t\t\tnewNode.next = head_ref;\n\t\t\tnewNode.next.prev = newNode;\n\t\t\thead_ref = newNode;\n\t\t}\n\t\telse {\n\t\t\tcurrent = head_ref;\n\t\t\twhile (current.next != null && current.next.data < newNode.data)\n\t\t\t\tcurrent = current.next;\n\t\t\tnewNode.next = current.next;\n\t\t\tif (current.next != null)\n\t\t\t\tnewNode.next.prev = newNode;\n\t\t\tcurrent.next = newNode;\n\t\t\tnewNode.prev = current;\n\t\t}\n\t\treturn head_ref;\n\t}\nfunction insertionSort(head_ref) {\n\t\tvar sorted = null;\n\t\tvar current = head_ref;\n\t\twhile (current != null) {\n\t\t\tvar next = current.next;\n\t\t\tcurrent.prev = current.next = null;\n\t\t\tsorted = sortedInsert(sorted, current);\n\t\t\tcurrent = next;\n\t\t}\n\t\thead_ref = sorted;\n\t\treturn head_ref;\n\t}\nfunction printList(head) {\n\t\twhile (head != null) {\n\t\t\tdocument.write(head.data + \" \");\n\t\t\thead = head.next;\n\t\t}\n\t}\nfunction push(head_ref , new_data) {\n\t\tvar new_node = new Node();\n\t\tnew_node.data = new_data;\n\t\tnew_node.next = (head_ref);\n\t\tnew_node.prev = null;\n\t\tif ((head_ref) != null)\n\t\t\t(head_ref).prev = new_node;\n\t\t(head_ref) = new_node;\n\t\treturn head_ref;\n\t}", "2575": "function reverse(arr, s , e)\n{\n\twhile(s < e)\n\t{\n\t\tvar tem = arr[s];\n\t\tarr[s] = arr[e];\n\t\tarr[e] = tem;\n\t\ts = s + 1;\n\t\te = e - 1;\n\t}\n}\nfunction fun(arr , k)\n{\n\tvar n = 4 - 1;\n\tvar v = n - k;\n\tif (v >= 0)\n\t{\n\t\treverse(arr, 0, v);\n\t\treverse(arr, v + 1, n);\n\t\treverse(arr, 0, n);\n\t}\n}", "2578": "function build(node , l , r , a) {\n\t\tif (l == r)\n\t\t\tseg[node] = a[l];\n\t\telse {\n\t\t\tvar mid = parseInt((l + r) / 2);\n\t\t\tbuild(2 * node, l, mid, a);\n\t\t\tbuild(2 * node + 1, mid + 1, r, a);\n\t\t\tseg[node] = (seg[2 * node] seg[2 * node + 1]);\n\t\t}\n\t}\nfunction query(node , l , r , start , end , a) {\n\t\tif (l > end r < start)\n\t\t\treturn 0;\n\t\tif (start <= l && r <= end)\n\t\t\treturn seg[node];\n\t\tvar mid = parseInt((l + r) / 2);\n\t\treturn ((query(2 * node, l, mid, start, end, a)) | (query(2 * node + 1, mid + 1, r, start, end, a)));\n\t}\nfunction orsum(a , n , q , k) {\n\t\tbuild(1, 0, n - 1, a);\n\t\tfor (j = 0; j < q; j++) {\n\t\t\tvar i = k[j] % (n / 2);\n\t\t\tvar sec = query(1, 0, n - 1, n / 2 - i, n - i - 1, a);\n\t\t\tvar first = (query(1, 0, n - 1, 0, n / 2 - 1 - i, a) | query(1, 0, n - 1, n - i, n - 1, a));\n\t\t\tvar temp = sec + first;\n\t\t\tdocument.write(temp + \"<br/>\");\n\t\t}\n\t}", "2579": "function maximumEqual(a, b, n)\n{\n\tlet store = Array.from({length: 1e5}, (_, i) => 0); \n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tstore[b[i]] = i + 1;\n\t}\n\tlet ans = Array.from({length: 1e5}, (_, i) => 0); \n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tlet d = Math.abs(store[a[i]] - (i + 1));\n\t\tif (store[a[i]] < i + 1)\n\t\t{\n\t\t\td = n - d;\n\t\t}\n\t\tans[d]++;\n\t}\n\tlet finalans = 0;\n\tfor (let i = 0; i < 1e5; i++)\n\t\tfinalans = Math.max(finalans, ans[i]);\n\tdocument.write(finalans + \"\\n\");\n}", "2583": "function RightRotate(a, n, k)\n{\n\tk = k % n;\n\tfor (let i = 0; i < n; i++) {\n\t\tif (i < k) {\n\t\t\tdocument.write(a[n + i - k] + \" \");\n\t\t}\n\t\telse {\n\t\t\tdocument.write((a[i - k]) + \" \");\n\t\t}\n\t}\n\tdocument.write(\"<br>\");\n}", "2615": "function restoreSortedArray(arr, n)\n{\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] > arr[i + 1])\n\t\t{\n\t\t\treverse(arr,0,i);\n\t\t\treverse(arr , i + 1, n);\n\t\t\treverse(arr,0, n);\n\t\t}\n\t}\n}\nfunction reverse(arr, i, j)\n{\n\tlet temp;\n\twhile(i < j)\n\t{\n\t\ttemp = arr[i];\n\t\tarr[i] = arr[j];\n\t\tarr[j] = temp;\n\t\ti++;\n\t\tj--;\n\t}\n}\nfunction printArray(arr, size)\n{\n\tfor (let i = 0; i < size; i++)\n\t\tdocument.write(arr[i] + \" \");\n}", "2616": "function findStartIndexOfArray(arr, low, high)\n{\n\tif (low > high)\n\t{\n\t\treturn -1;\n\t}\n\tif (low == high)\n\t{\n\t\treturn low;\n\t}\n\tlet mid = low + parseInt((high - low) / 2, 10);\n\tif (arr[mid] > arr[mid + 1])\n\t{\n\t\treturn mid + 1;\n\t}\n\tif (arr[mid - 1] > arr[mid])\n\t{\n\t\treturn mid;\n\t}\n\tif (arr[low] > arr[mid])\n\t{\n\t\treturn findStartIndexOfArray(arr, low, mid - 1);\n\t}\n\telse\n\t{\n\t\treturn findStartIndexOfArray(arr, mid + 1, high);\n\t}\n}\nfunction restoreSortedArray(arr, n)\n{\n\tif (arr[0] < arr[n - 1])\n\t{\n\t\treturn;\n\t}\n\tlet start = findStartIndexOfArray(arr, 0, n - 1);\n\tarr.sort();\n}\nfunction printArray(arr, size)\n{\n\tfor(let i = 0; i < size; i++)\n\t{\n\t\tdocument.write(arr[i] + \" \");\n\t}\n}", "2623": "function leftrotate(str, d)\n{\n\tvar ans = str.substring(d, str.length) +\n\t\t\tstr.substring(0, d);\n\treturn ans;\n}\nfunction rightrotate(str, d)\n{\n\treturn leftrotate(str, str.length - d);\n}", "2673": "function insertNode(start,value)\n{\n\tif (start == null)\n\t{\n\t\tlet new_node = new Node();\n\t\tnew_node.data = value;\n\t\tnew_node.next = new_node.prev = new_node;\n\t\tstart = new_node;\n\t\treturn new_node;\n\t}\n\tlet last = (start).prev;\n\tlet new_node = new Node();\n\tnew_node.data = value;\n\tnew_node.next = start;\n\t(start).prev = new_node;\n\tnew_node.prev = last;\n\tlast.next = new_node;\n\treturn start;\n}\nfunction displayList(start)\n{\n\tlet temp = start;\n\twhile (temp.next != start)\n\t{\n\t\tdocument.write(temp.data+\" \");\n\t\ttemp = temp.next;\n\t}\n\tdocument.write(temp.data+\" \");\n}\nfunction searchList(start,search)\n{\n\tlet temp = start;\n\tlet count = 0, flag = 0, value;\n\tif(temp == null)\n\t\treturn -1;\n\telse\n\t{\n\t\twhile(temp.next != start)\n\t\t{\n\t\t\tcount++;\n\t\t\tif(temp.data == search)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tif(temp.data == search)\n\t\t{\n\t\t\tcount++;\n\t\t\tflag = 1;\n\t\t}\n\t\tif(flag == 1)\n\t\t\tdocument.write(\"<br>\"+search +\" found at location \"+ count);\n\t\telse\n\t\t\tdocument.write(\"<br>\"+search +\" not found\");\n\t}\n\treturn -1;\n}", "2675": "function getNode(data) {\n\t\tvar newNode = new Node();\n\t\tnewNode.data = data;\n\t\treturn newNode;\n\t}\nfunction insertEnd(head, new_node) {\n\t\tif (head == null) {\n\t\tnew_node.next = new_node.prev = new_node;\n\t\thead = new_node;\n\t\treturn head;\n\t\t}\n\t\tvar last = head.prev;\n\t\tnew_node.next = head;\n\t\thead.prev = new_node;\n\t\tnew_node.prev = last;\n\t\tlast.next = new_node;\n\t\treturn head;\n\t}\nfunction reverse(head) {\n\t\tif (head == null) return null;\n\t\tvar new_head = null;\n\t\tvar last = head.prev;\n\t\tvar curr = last,\n\t\tprev;\n\t\twhile (curr.prev != last) {\n\t\tprev = curr.prev;\n\t\tnew_head = insertEnd(new_head, curr);\n\t\tcurr = prev;\n\t\t}\n\t\tnew_head = insertEnd(new_head, curr);\n\t\treturn new_head;\n\t}\nfunction display(head) {\n\t\tif (head == null) return;\n\t\tvar temp = head;\n\t\tdocument.write(\"Forward direction: \");\n\t\twhile (temp.next != head) {\n\t\tdocument.write(temp.data + \" \");\n\t\ttemp = temp.next;\n\t\t}\n\t\tdocument.write(temp.data + \" \");\n\t\tvar last = head.prev;\n\t\ttemp = last;\n\t\tdocument.write(\"<br>Backward direction: \");\n\t\twhile (temp.prev != last) {\n\t\tdocument.write(temp.data + \" \");\n\t\ttemp = temp.prev;\n\t\t}\n\t\tdocument.write(temp.data + \" \");\n\t}", "2696": "function addEdge(u, v)\n{\n\tadj[u].push(v);\n\tadj[v].push(u);\n}\nfunction dfs(cur, prev)\n{\n\tparent[cur] = prev;\n\tdepth[cur] = depth[prev] + 1;\n\tfor(var i = 0; i < adj[cur].length; i++)\n\t\tif (adj[cur][i] != prev)\n\t\t\tdfs(adj[cur][i], cur);\n}\nfunction preprocess()\n{\n\tdepth[0] = -1;\n\tdfs(1, 0);\n}\nfunction LCANaive(u, v)\n{\n\tif (u == v)\n\t\treturn u;\n\tif (depth[u] > depth[v])\n\t{\n\t\tvar temp = u;\n\t\tu = v;\n\t\tv = temp;\n\t}\n\tv = parent[v];\n\treturn LCANaive(u, v);\n}", "2697": "function addEdge(u, v)\n{\n\tadj[u].push(v);\n\tadj[v].push(u);\n}\nfunction LCANaive(u, v)\n{\n\tif (u == v) \n\t\treturn u;\n\tif (depth[u] > depth[v])\n\t{\n\t\tlet t = u;\n\t\tu = v;\n\t\tv = t;\n\t} \n\tv = parent[v];\n\treturn LCANaive(u, v);\n}\nfunction dfs(cur, prev)\n{\n\tdepth[cur] = depth[prev] + 1;\n\tparent[cur] = prev;\n\tif (depth[cur] % block_sz == 0)\n\t\tjump_parent[cur] = parent[cur];\n\telse\n\t\tjump_parent[cur] = jump_parent[prev];\n\tfor(let i = 0; i < adj[cur].length; ++i)\n\t\tif (adj[cur][i] != prev)\n\t\t\tdfs(adj[cur][i], cur);\n}\nfunction LCASQRT(u, v)\n{\n\twhile (jump_parent[u] != jump_parent[v])\n\t{\n\t\tif (depth[u] > depth[v])\n\t\t{\n\t\t\tlet t = u;\n\t\t\tu = v;\n\t\t\tv = t;\n\t\t}\n\t\tv = jump_parent[v];\n\t}\n\treturn LCANaive(u, v);\n}\nfunction preprocess(height)\n{\n\tblock_sz = parseInt(Math.sqrt(height), 10);\n\tdepth[0] = -1;\n\tdfs(1, 0);\n}", "2740": "function find_permutations(arr)\n{\n\tvar cnt = 0;\n\tvar max_ind = -1, min_ind = 10000000;\n\tvar n = arr.length;\n\tvar index_of = new Map();\n\tfor (var i = 0; i < n; i++) {\n\t\tindex_of.set(arr[i], i + 1);\n\t}\n\tfor (var i = 1; i <= n; i++) {\n\t\tmax_ind = Math.max(max_ind, index_of.get(i));\n\t\tmin_ind = Math.min(min_ind, index_of.get(i));\n\t\tif (max_ind - min_ind + 1 == i)\n\t\t\tcnt++;\n\t}\n\treturn cnt;\n}", "2753": "", "2773": "function countOfNum(n,a,b)\n\t{\n\t\tlet cnt_of_a, cnt_of_b, cnt_of_ab, sum;\n\t\tcnt_of_a = Math.floor(n / a);\n\t\tcnt_of_b = Math.floor(n / b);\n\t\tsum = cnt_of_b + cnt_of_a;\n\t\tcnt_of_ab = Math.floor(n / (a * b));\n\t\tsum = sum - cnt_of_ab;\n\t\treturn sum;\n\t}\nfunction sumOfNum(n,a,b)\n\t{\n\t\tlet i;\n\t\tlet sum = 0;\n\t\tlet ans = new Set();\n\t\tfor (i = a; i <= n; i = i + a) {\n\t\t\tans.add(i);\n\t\t}\n\t\tfor (i = b; i <= n; i = i + b) {\n\t\t\tans.add(i);\n\t\t}\n\t\tfor (let it of ans.values()) {\n\t\t\tsum = sum + it;\n\t\t}\n\t\treturn sum;\n\t}", "2783": "function maximumArea(l, b, x, y) {\n\t\tvar left = x * b;\n\t\tvar right = (l - x - 1) * b;\n\t\tvar above = l * y;\n\t\tvar below = (b - y - 1) * l;\n\t\tdocument.write(Math.max(Math.max(left, right), Math.max(above, below)));\n\t}", "2802": "function precompute()\n{\n\tF[1] = 2;\n\tF[2] = 3;\n\tF[3] = 4;\n\tfor (var i = 4; i < N; i++)\n\t\tF[i] = (F[i - 1] + F[i - 2]) % MOD;\n}", "2804": "function get(L, R)\n{\n\tlet x = 1.0 / L;\n\tlet y = 1.0 / (R + 1.0);\n\treturn (x - y);\n}", "2809": "function upper_bound(ar, k)\n{\n\tlet s = 0;\n\tlet e = ar.length;\n\twhile (s != e)\n\t{\n\t\tlet mid = s + e >> 1;\n\t\tif (ar[mid] <= k)\n\t\t{\n\t\t\ts = mid + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te = mid;\n\t\t}\n\t}\n\tif (s == ar.length)\n\t{\n\t\treturn -1;\n\t}\n\treturn s;\n}\nfunction consecutiveOnes(x)\n{\n\tlet p = 0;\n\twhile (x > 0) {\n\t\tif (x % 2 == 1 && p == 1)\n\t\t\treturn true;\n\t\tp = x % 2;\n\t\tx = parseInt(x / 2);\n\t}\n\treturn false;\n}\nfunction preCompute()\n{\n\tfor (let i = 0; i <= MAX; i++) {\n\t\tif (!consecutiveOnes(i))\n\t\t\tv.push(i);\n\t}\n}\nfunction nextValid(n)\n{\n\tlet it = upper_bound(v, n);\n\tlet val = v[it];\n\treturn val;\n}\nfunction performQueries(queries, q)\n{\n\tfor (let i = 0; i < q; i++)\n\t\tdocument.write(nextValid(queries[i]) + \"<br>\");\n}", "2816": "function changeToOnes(str)\n{\n\tvar i, l, ctr = 0;\n\tl = str.length;\n\tfor (i = l - 1; i >= 0; i--) {\n\t\tif (str[i] == '1')\n\t\t\tctr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn l - ctr;\n}\nfunction removeZeroesFromFront(str)\n{\n\tvar s;\n\tvar i = 0;\n\twhile (i < str.length && str[i] == '0')\n\t\ti++;\n\tif (i == str.length)\n\t\ts = \"0\";\n\telse\n\t\ts = str.substring(i, str.length - i);\n\treturn s;\n}", "2818": "function calgcd(a, b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn calgcd(b, a % b);\n}\nfunction getCount(a, n)\n{\n\tlet gcd = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tgcd = calgcd(gcd, a[i]);\n\tlet cnt = 0;\n\tfor (let i = 1; i * i <= gcd; i++) {\n\t\tif (gcd % i == 0) {\n\t\t\tif (i * i == gcd)\n\t\t\t\tcnt++;\n\t\t\telse\n\t\t\t\tcnt += 2;\n\t\t}\n\t}\n\treturn cnt;\n}", "2827": "function MinDeletion( a, n){\n\tlet map = new Map();\n\tfor (let i = 0; i < n; i++){\n\t\tif(map[a[i]])\n\t\t\tmap[a[i]]++;\n\t\telse\n\t\t\tmap[a[i]] = 1\n\t}\n\tlet ans = 0;\n\tfor(var m in map){\n\t\tlet x = m;\n\t\tlet frequency = map[m];\n\t\tif (x <= frequency) {\n\t\t\tans += (frequency - x);\n\t\t}\n\t\telse\n\t\t\tans += frequency;\n\t};\n\treturn ans;\n}", "2831": "function maxCountAB(s, n)\n{\n\tvar A = 0, B = 0, BA = 0, ans = 0;\n\tfor (var i = 0; i < n; i++) {\n\t\tvar S = s[i];\n\t\tvar L = S.length;\n\t\tfor (var j = 0; j < L - 1; j++) {\n\t\t\tif (S[j] == 'A' && S[j + 1] == 'B') {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tif (S[0] == 'B' && S[L - 1] == 'A')\n\t\t\tBA++;\n\t\telse if (S[0] == 'B')\n\t\t\tB++;\n\t\telse if (S[L - 1] == 'A')\n\t\t\tA++;\n\t}\n\tif (BA == 0)\n\t\tans += Math.min(B, A);\n\telse if (A + B == 0)\n\t\tans += BA - 1;\n\telse\n\t\tans += BA + Math.min(B, A);\n\treturn ans;\n}", "2832": "function MinOperations(n, x, arr)\n{\n\tlet total = 0;\n\tfor (let i = 0; i < n; ++i)\n\t{\n\t\tif (arr[i] > x)\n\t\t{\n\t\t\tlet difference = arr[i] - x;\n\t\t\ttotal = total + difference;\n\t\t\tarr[i] = x;\n\t\t}\n\t}\n\tfor (let i = 1; i < n; ++i)\n\t{\n\t\tlet LeftNeigbouringSum = arr[i] + arr[i - 1];\n\t\tif (LeftNeigbouringSum > x)\n\t\t{\n\t\t\tlet current_diff = LeftNeigbouringSum - x;\n\t\t\tarr[i] = Math.max(0, arr[i] - current_diff);\n\t\t\ttotal = total + current_diff;\n\t\t}\n\t}\n\treturn total;\n}", "2847": "function findNumbers(arr, n)\n{\n\tsumN = (n * (n + 1)) / 2;\n\tsumSqN = (n * (n + 1) *\n\t\t\t\t(2 * n + 1)) / 6;\n\tlet sum = 0 ;\n\tlet sumSq = 0 ;\n\tfor (let i = 0;i < n; i++)\n\t{\n\t\tsum += arr[i];\n\t\tsumSq += Math.pow(arr[i], 2);\n\t}\n\tB = (((sumSq - sumSqN) / (sum - sumN)) + sumN - sum) / 2;\n\tA = sum - sumN + B;\n\tdocument.write( \"A = \"+ A, \"<br>B = \", B);\n}", "2883": "function is_prefix(temp, str)\n\t\t{\n\t\t\tif (temp.length < str.length)\n\t\t\t\treturn 0;\n\t\t\telse {\n\t\t\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\t\t\tif (str[i] != temp[i])\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\nfunction lexicographicallyString( input, n, str)\n\t{\n\t\t\tinput = Array.from(input).sort();\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tlet temp = input[i];\n\t\t\t\tif (is_prefix(temp, str)) {\n\t\t\t\t\treturn temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"-1\";\n\t\t}", "2892": "function Rearrange(arr, K, N)\n\t\t{\n\t\t\tlet ans = new Array(N + 1);\n\t\t\tlet f = -1;\n\t\t\tfor (let i = 0; i < N; i++) {\n\t\t\t\tans[i] = -1;\n\t\t\t}\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tif (arr[i] == K) {\n\t\t\t\t\tK = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet smaller = [];\n\t\t\tlet greater = [];\n\t\t\tfor (let i = 0; i < N; i++) {\n\t\t\t\tif (arr[i] < arr[K])\n\t\t\t\t\tsmaller.push(arr[i]);\n\t\t\t\telse if (arr[i] > arr[K])\n\t\t\t\t\tgreater.push(arr[i]);\n\t\t\t}\n\t\t\tlet low = 0, high = N - 1;\n\t\t\twhile (low <= high) {\n\t\t\t\tlet mid = Math.floor((low + high) / 2);\n\t\t\t\tif (mid == K) {\n\t\t\t\t\tans[mid] = arr[K];\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (mid < K) {\n\t\t\t\t\tif (smaller.length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tans[mid] = smaller[smaller.length - 1];\n\t\t\t\t\tsmaller.pop();\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (greater.length == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tans[mid] = greater[greater.length - 1];\n\t\t\t\t\tgreater.pop();\n\t\t\t\t\thigh = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f == -1) {\n\t\t\t\tdocument.write(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = 0; i < N; i++) {\n\t\t\t\tif (ans[i] == -1) {\n\t\t\t\t\tif (smaller.length != 0) {\n\t\t\t\t\t\tans[i] = smaller[smaller.length - 1];\n\t\t\t\t\t\tsmaller.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse if (greater.length != 0) {\n\t\t\t\t\t\tans[i] = greater[greater.length - 1];\n\t\t\t\t\t\tgreater.pop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < N; i++)\n\t\t\t\tdocument.write(ans[i] + \" \");\n\t\t\tdocument.write(\"<br>\")\n\t\t}", "2923": "function minimumK(arr, M, N)\n{\n\tlet good = Math.floor((N * 1.0) / ((M + 1) * 1.0))+1;\n\tfor (let i = 1; i <= N; i++) {\n\t\tlet K = i;\n\t\tlet candies = N;\n\t\tlet taken = 0;\n\t\twhile (candies > 0) {\n\t\t\ttaken += Math.min(K, candies);\n\t\t\tcandies -= Math.min(K, candies);\n\t\t\tfor (let j = 0; j < M; j++) {\n\t\t\t\tlet consume = (arr[j] * candies) / 100;\n\t\t\t\tcandies -= consume;\n\t\t\t}\n\t\t}\n\t\tif (taken >= good) {\n\t\t\tdocument.write(i);\n\t\t\treturn;\n\t\t}\n\t}\n}", "2940": "function calcTotalTime(path)\n{\n\tvar time = 0;\n\tvar x = 0, y = 0;\n\tvar s = new Set();\n\tfor(var i = 0; i < path.length; i++)\n\t{\n\t\tvar p = x;\n\t\tvar q = y;\n\t\tif (path[i] == 'N')\n\t\t\ty++;\n\t\telse if (path[i] == 'S')\n\t\t\ty--;\n\t\telse if (path[i] == 'E')\n\t\t\tx++;\n\t\telse if (path[i] == 'W')\n\t\t\tx--;\n\t\tif (!s.has([p + x, q + y].toString()))\n\t\t{\n\t\t\ttime += 2;\n\t\t\ts.add([p + x, q + y].toString());\n\t\t}\n\t\telse\n\t\t\ttime += 1;\n\t}\n\tdocument.write(time)\n}", "2950": "function calcPsquare(N)\n{\n\tvar i;\n\tfor (i = 1; i * i <= N; i++)\n\t\tpsquare.push(i * i);\n}\nfunction countWays(index, target)\n{\n\tif (target == 0)\n\t\treturn 1;\n\tif (index < 0 target < 0)\n\t\treturn 0;\n\tvar inc = countWays( index, target - psquare[index]);\n\tvar exc = countWays(index - 1, target);\n\treturn inc + exc;\n}", "2983": "function findCost(A, N)\n{\n\tvar totalCost = 0;\n\tvar i;\n\tfor (i = 0; i < N; i++) {\n\t\tif (A[i] == 0) {\n\t\t\tA[i] = 1;\n\t\t\ttotalCost += i;\n\t\t}\n\t}\n\treturn totalCost;\n}", "3003": "function search(list, num)\n{\n\tvar low = 0, high = list.length - 1;\n\tvar ans = -1;\n\twhile (low <= high)\n\t{\n\t\tvar mid = low + (high - low) / 2;\n\t\tif (list[mid] <= num)\n\t\t{\n\t\t\tans = mid;\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn ans;\n}\nfunction isPalindrome(n)\n{\n\tvar rev = 0;\n\tvar temp = n;\n\twhile (n > 0)\n\t{\n\t\trev = rev * 10 + n % 10;\n\t\tn = parseInt(n/10);\n\t}\n\treturn rev == temp;\n}\nfunction countNumbers(L, R, K)\n{\n\tvar list = [];\n\tfor(var i = L; i <= R; i++)\n\t{\n\t\tif (isPalindrome(i))\n\t\t{\n\t\t\tlist.push(i);\n\t\t}\n\t}\n\tvar count = 0;\n\tfor(var i = 0; i < list.length; i++)\n\t{\n\t\tvar right_index = search(list, list[i] + K - 1);\n\t\tif (right_index != -1)\n\t\t\tcount = Math.max(count, right_index - i + 1);\n\t}\n\treturn count;\n}", "3010": "function peakIndex(arr)\n\t{\n\t\tvar N = arr.length;\n\t\tif (arr.length < 3)\n\t\t\treturn -1;\n\t\tvar i = 0;\n\t\twhile (i + 1 < N) {\n\t\t\tif (arr[i + 1] < arr[i] arr[i] == arr[i + 1])\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == 0 i == N - 1)\n\t\t\treturn -1;\n\t\tvar ans = i;\n\t\twhile (i < N - 1) {\n\t\t\tif (arr[i] < arr[i + 1] arr[i] == arr[i + 1])\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\t\tif (i == N - 1)\n\t\t\treturn ans;\n\t\treturn -1;\n\t}", "3053": "function hasArrayTwoPairs(nums, n, target)\n{\n\tnums.sort();\n\tvar i;\n\tfor (i = 0; i < n; i++) {\n\t\tvar x = target - nums[i];\n\t\tvar low = 0, high = n - 1;\n\t\twhile (low <= high) {\n\t\t\tvar mid = low\n\t\t\t\t\t+ (Math.floor((high - low) / 2));\n\t\t\tif (nums[mid] > x) {\n\t\t\t\thigh = mid - 1;\n\t\t\t}\n\t\t\telse if (nums[mid] < x) {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mid == i) {\n\t\t\t\t\tif ((mid - 1 >= 0) && nums[mid - 1] == x) {\n\t\t\t\t\t\tdocument.write(nums[i] + \", \");\n\t\t\t\t\t\tdocument.write(nums[mid - 1]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mid + 1 < n) && nums[mid + 1] == x) {\n\t\t\t\t\t\tdocument.write(nums[i] + \", \");\n\t\t\t\t\t\tdocument.write(nums[mid + 1]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdocument.write(nums[i] +\", \");\n\t\t\t\t\tdocument.write(nums[mid]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdocument.write(-1);\n}", "3096": "function sumofsubtree(root)\n{\n\tlet p = new pair(1, 0);\n\tif (root.left != null)\n\t{\n\t\tlet ptemp\n\t\t\t= sumofsubtree(root.left);\n\t\tp.second += ptemp.first\n\t\t\t\t\t+ ptemp.second;\n\t\tp.first += ptemp.first;\n\t}\n\tif (root.right != null)\n\t{\n\t\tlet ptemp\n\t\t\t= sumofsubtree(root.right);\n\t\tp.second += ptemp.first\n\t\t\t\t\t+ ptemp.second;\n\t\tp.first += ptemp.first;\n\t}\n\troot.size = p.first;\n\treturn p;\n}\nfunction distance(root,target,distancesum,n)\n{\n\tif (root.data == target)\n\t{\n\t\tsum = distancesum;\n\t}\n\tif (root.left != null)\n\t{\n\t\tlet tempsum = distancesum\n\t\t\t\t\t- root.left.size\n\t\t\t\t\t+ (n - root.left.size);\n\t\tdistance(root.left, target, tempsum, n);\n\t}\n\tif (root.right != null)\n\t{\n\t\tlet tempsum = distancesum\n\t\t\t\t\t- root.right.size\n\t\t\t\t\t+ (n - root.right.size);\n\t\tdistance(root.right, target, tempsum, n);\n\t}\n}", "3120": "function delCost( s, cost) {\n\t\tvar visited =Array(s.length).fill(false);\n\t\tvar ans = 0;\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tif (visited[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar maxDel = 0;\n\t\t\tvar totalCost = 0;\n\t\t\tvisited[i] = true;\n\t\t\tfor (j = i; j < s.length; j++) {\n\t\t\t\tif (s.charAt(i) == s.charAt(j)) {\n\t\t\t\t\tmaxDel = Math.max(maxDel, cost[j]);\n\t\t\t\t\ttotalCost += cost[j];\n\t\t\t\t\tvisited[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += totalCost - maxDel;\n\t\t}\n\t\treturn ans;\n\t}", "3121": "function delCost(s, cost)\n{\n\tvar ans = 0;\n\tvar forMax = new Map();\n\tvar forTot = new Map();\n\tfor (var i = 0; i < s.length; i++) {\n\t\tif (!forMax.has(s[i])) {\n\t\t\tforMax.set(s[i], cost[i]);\n\t\t}\n\t\telse {\n\t\t\tforMax.set(s[i], Math.max(forMax.get(s[i]),cost[i]))\n\t\t}\n\t\tif (!forTot.has(s[i])) {\n\t\t\tforTot.set(s[i], cost[i]);\n\t\t}\n\t\telse {\n\t\t\tforTot.set(s[i], forTot.get(s[i]) + cost[i])\n\t\t}\n\t}\n\tforMax.forEach((value, key) => {\n\t\tans += forTot.get(key) - value; });\n\treturn ans;\n}", "3128": "function findClosest(N, target)\n{\n\tlet closest = -1;\n\tlet diff = Number.MAX_VALUE;\n\tfor (let i = 1; i <= Math.sqrt(N); i++) {\n\tif (N % i == 0) {\n\t\tif (N / i == i) {\n\t\tif (Math.abs(target - i) < diff)\n\t\t{\n\t\t\tdiff = Math.abs(target - i);\n\t\t\tclosest = i;\n\t\t}\n\t\t}\n\t\telse {\n\t\tif (Math.abs(target - i) < diff)\n\t\t{\n\t\t\tdiff = Math.abs(target - i);\n\t\t\tclosest = i;\n\t\t}\n\t\tif (Math.abs(target - N / i) < diff)\n\t\t{\n\t\t\tdiff = Math.abs(target - N / i);\n\t\t\tclosest = N / i;\n\t\t}\n\t\t}\n\t}\n\t}\n\tdocument.write(closest);\n}", "3129": "function computeDivisors()\n{\n\tfor(let i = 1; i <= MAX; i++)\n\t{\n\t\tfor(let j = i; j <= MAX; j += i)\n\t\t{\n\t\t\tdivisors[j].push(i);\n\t\t}\n\t}\n}\nfunction getClosest(val1, val2, target)\n{\n\tif (target - val1 >= val2 - target)\n\t\treturn val2;\n\telse\n\t\treturn val1;\n}\nfunction findClosest(arr, n, target)\n{\n\tif (target <= arr[0])\n\t\treturn arr[0];\n\tif (target >= arr[n - 1])\n\t\treturn arr[n - 1];\n\tlet i = 0, j = n, mid = 0;\n\twhile (i < j)\n\t{\n\t\tmid = Math.floor((i + j) / 2);\n\t\tif (arr[mid] == target)\n\t\t\treturn arr[mid];\n\t\tif (target < arr[mid])\n\t\t{\n\t\t\tif (mid > 0 && target > arr[mid - 1])\n\t\t\t\treturn getClosest(arr[mid - 1], arr[mid], target);\n\t\t\tj = mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mid < n - 1 && target < arr[mid + 1])\n\t\t\t\treturn getClosest(arr[mid], arr[mid + 1], target);\n\t\t\ti = mid + 1;\n\t\t}\n\t}\n\treturn arr[mid];\n}\nfunction printClosest(N, X)\n{\n\tcomputeDivisors();\n\tlet ans = findClosest(divisors[N], divisors[N].length, X);\n\tdocument.write(ans);\n}", "3135": "function countTriplets(arr, N)\n{\n\tvar zero_i = [];\n\tvar one_i = [];\n\tvar mp = new Map();\n\tfor (var i = 0; i < N; i++) {\n\t\tif (arr[i] == 0)\n\t\t\tzero_i.push(i + 1);\n\t\telse if (arr[i] == 1)\n\t\t\tone_i.push(i + 1);\n\t\telse\n\t\t\tmp.set(i + 1, 1);\n\t}\n\tvar total = zero_i.length\n\t\t\t\t* one_i.length * mp.size;\n\tfor (var i = 0; i < zero_i.length; i++) {\n\t\tfor (var j = 0; j < one_i.length; j++) {\n\t\t\tvar p = zero_i[i];\n\t\t\tvar q = one_i[j];\n\t\t\tvar r = 2 * p - q;\n\t\t\tif (mp.has(r))\n\t\t\t\ttotal--;\n\t\t\tr = 2 * q - p;\n\t\t\tif (mp.has(r))\n\t\t\t\ttotal--;\n\t\t\tr = (p + q) / 2;\n\t\t\tif (mp.has(r) && Math.abs(r - p) == Math.abs(r - q))\n\t\t\t\ttotal--;\n\t\t}\n\t}\n\tdocument.write( total);\n}", "3138": "function power(A, N)\n{\n\tlet count = 0;\n\tif (A == 1)\n\t\treturn 0;\n\twhile (N > 0)\n\t{\n\t\tcount++;\n\t\tN /= A;\n\t}\n\treturn count;\n}\nfunction Pairs(N, A, B)\n{\n\tlet powerA, powerB;\n\tpowerA = power(A, N);\n\tpowerB = power(B, N);\n\tlet letialB = B, letialA = A;\n\tA = 1;\n\tfor(let i = 0; i <= powerA; i++)\n\t{\n\t\tB = 1;\n\t\tfor(let j = 0; j <= powerB; j++)\n\t\t{\n\t\t\tif (B == N - A)\n\t\t\t{\n\t\t\t\tdocument.write(i + \" \" + j);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tB *= letialB;\n\t\t}\n\t\tA *= letialA;\n\t}\n\tdocument.write(\"-1\");\n\treturn;\n}", "3142": "function findNonMultiples(arr, n, k)\n{\n\tlet multiples = new Set();\n\tfor (let i = 0; i < n; ++i) {\n\t\tif (!multiples.has(arr[i])) {\n\t\t\tfor (let j = 1; j <= k / arr[i]; j++) {\n\t\t\t\tmultiples.add(arr[i] * j);\n\t\t\t}\n\t\t}\n\t}\n\treturn k - multiples.size;\n}\nfunction countValues(arr, N, L, R)\n{\n\treturn findNonMultiples(arr, N, R)\n\t\t- findNonMultiples(arr, N, L - 1);\n}", "3163": "function maxMatch(A, B) {\n\t\tvar Aindex = {};\n\t\tvar diff = {};\n\t\tfor (var i = 0; i < A.length; i++) {\n\t\tAindex[A[i]] = i;\n\t\t}\n\t\tfor (var i = 0; i < B.length; i++) {\n\t\tif (i - Aindex[B[i]] < 0) {\n\t\t\tif (!diff.hasOwnProperty(A.length + i - Aindex[B[i]])) {\n\t\t\tdiff[A.length + i - Aindex[B[i]]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\tdiff[A.length + i - Aindex[B[i]]] += 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!diff.hasOwnProperty(i - Aindex[B[i]])) {\n\t\t\tdiff[i - Aindex[B[i]]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\tdiff[i - Aindex[B[i]]] += 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tvar max = 0;\n\t\tfor (const [key, value] of Object.entries(diff)) {\n\t\tif (value > max) {\n\t\t\tmax = value;\n\t\t}\n\t\t}\n\t\treturn max;\n\t}", "3176": "function checkXOR(arr, N)\n{\n\tif (N % 2 == 0) {\n\t\tlet xro = 0;\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\txro ^= arr[i];\n\t\t}\n\t\tif (xro != 0) {\n\t\t\tdocument.write(-1 + \"<br>\");\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < N - 3; i += 2) {\n\t\t\tdocument.write(i + \" \" + (i + 1)\n\t\t\t\t+ \" \" + (i + 2) + \"<br>\");\n\t\t}\n\t\tfor (let i = 0; i < N - 3; i += 2) {\n\t\t\tdocument.write(i + \" \" + (i + 1)\n\t\t\t\t+ \" \" + (N - 1) + \"<br>\");\n\t\t}\n\t}\n\telse {\n\t\tfor (let i = 0; i < N - 2; i += 2) {\n\t\t\tdocument.write(i + \" \" + (i + 1) + \" \"\n\t\t\t\t+ (i + 2) + \"<br>\");\n\t\t}\n\t\tfor (let i = 0; i < N - 2; i += 2) {\n\t\t\tdocument.write(i + \" \" + (i + 1)\n\t\t\t\t+ \" \" + (N - 1) + \"<br>\");\n\t\t}\n\t}\n}", "3179": "function make_array_element_even(arr, N)\n{\n\tlet res = 0;\n\tlet odd_cont_seg = 0;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] % 2 == 1)\n\t\t{\n\t\t\todd_cont_seg++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (odd_cont_seg > 0)\n\t\t\t{\n\t\t\t\tif (odd_cont_seg % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tres += odd_cont_seg / 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tres += (odd_cont_seg / 2) + 2;\n\t\t\t\t}\n\t\t\t\todd_cont_seg = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (odd_cont_seg > 0)\n\t{\n\t\tif (odd_cont_seg % 2 == 0)\n\t\t{\n\t\t\tres += odd_cont_seg / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += odd_cont_seg / 2 + 2;\n\t\t}\n\t}\n\treturn res;\n}", "3183": "function minCollectingSpeed(piles, H)\n{\n\tvar ans = -1;\n\tvar low = 1, high;\n\thigh = piles.reduce((a,b)=> Math.max(a,b));\n\twhile (low <= high)\n\t{\n\t\tvar K = low + parseInt((high - low) / 2);\n\t\tvar time = 0;\n\t\tpiles.forEach(ai => {\n\t\t\ttime += parseInt((ai + K - 1) / K); });\n\t\tif (time <= H) {\n\t\t\tans = K;\n\t\t\thigh = K - 1;\n\t\t}\n\t\telse {\n\t\t\tlow = K + 1;\n\t\t}\n\t}\n\tdocument.write( ans);\n}", "3198": "function cntDisPairs(arr,N , K)\n{\n\tvar cntPairs = 0;\n\tarr.sort();\n\tvar i = 0;\n\tvar j = N - 1;\n\twhile (i < j) {\n\t\tif (arr[i] + arr[j] == K) {\n\t\t\twhile (i < j && arr[i] == arr[i + 1]) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (i < j && arr[j] == arr[j - 1]) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tcntPairs += 1;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse if (arr[i] + arr[j] < K) {\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\tj--;\n\t\t}\n\t}\n\treturn cntPairs;\n}", "3229": "function push(head_ref, new_data)\n{\n\tvar new_node\n\t\t= new Node();\n\tnew_node.data = new_data;\n\tnew_node.prev = null;\n\tnew_node.next = (head_ref);\n\tif ((head_ref) != null) {\n\t\t(head_ref).prev = new_node;\n\t}\n\t(head_ref) = new_node;\n\treturn head_ref;\n}\nfunction search( head_ref, x)\n{\n\tvar temp = head_ref;\n\tvar pos = 0;\n\twhile (temp.data != x && temp.next != null) {\n\t\tpos++;\n\t\ttemp = temp.next;\n\t}\n\tif (temp.data != x)\n\t\treturn -1;\n\treturn (pos + 1);\n}", "3234": "function longestSubsequence(N, Q, arr, Queries)\n{\n\tfor (let i = 0; i < Q; i++)\n\t{\n\t\tlet x = Queries[i][0];\n\t\tlet y = Queries[i][1];\n\t\tarr[x - 1] = y;\n\t\tlet count = 1;\n\t\tfor (let j = 1; j < N; j++)\n\t\t{\n\t\t\tif (arr[j] != arr[j - 1])\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tdocument.write(count +\" \");\n\t}\n}", "3235": "function longestSubsequence( N , Q , arr , Queries) {\n\t\tvar count = 1;\n\t\tfor (var i = 1; i < N; i++) {\n\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0; i < Q; i++) {\n\t\t\tvar x = Queries[i][0];\n\t\t\tvar y = Queries[i][1];\n\t\t\tif (x > 1) {\n\t\t\t\tif (arr[x - 1] != arr[x - 2]) {\n\t\t\t\t\tcount -= 1;\n\t\t\t\t}\n\t\t\t\tif (arr[x - 2] != y) {\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < N) {\n\t\t\t\tif (arr[x] != arr[x - 1]) {\n\t\t\t\t\tcount -= 1;\n\t\t\t\t}\n\t\t\t\tif (y != arr[x]) {\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdocument.write(count + \" \");\n\t\t\tarr[x - 1] = y;\n\t\t}\n\t}", "3253": "function sum(arr, n)\n{\n\tvar mp = new Map();\n\tfor (var i = 0; i < n; i++) {\n\t\tif(mp.has(arr[i]))\n\t\t{\n\t\t\tvar tmp = mp.get(arr[i]);\n\t\t\ttmp.push(i);\n\t\t\tmp.set(arr[i], tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.set(arr[i], [i]);\n\t\t}\n\t}\n\tvar ans = Array(n);\n\tfor (var i = 0; i < n; i++) {\n\t\tvar sum = 0;\n\t\tmp.get(arr[i]).forEach(it => {\n\t\t\tsum += Math.abs(it - i); });\n\t\tans[i] = sum;\n\t}\n\tfor (var i = 0; i < n; i++) {\n\t\tdocument.write( ans[i] + \" \");\n\t}\n\treturn;\n}", "3270": "function reverse(a)\n{\n\tlet i, n = a.length, t;\n\tfor(i = 0; i < n / 2; i++)\n\t{\n\t\tt = a[i];\n\t\ta[i] = a[n - i - 1];\n\t\ta[n - i - 1] = t;\n\t}\n\treturn a;\n}\nfunction rearrangeArray(A, B, N, K)\n{\n\tB.sort();\n\tB = reverse(B);\n\tlet flag = true;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tif (A[i] + B[i] > K)\n\t\t{\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!flag)\n\t{\n\t\tdocument.write(\"-1\" + \"<br/>\");\n\t}\n\telse\n\t{\n\t\tfor(let i = 0; i < N; i++)\n\t\t{\n\t\t\tdocument.write(B[i] + \" \");\n\t\t}\n\t}\n}", "3311": "function isinRange(board)\n{\n\tfor(var i = 0; i < N; i++)\n\t{\n\t\tfor(var j = 0; j < N; j++)\n\t\t{\n\t\t\tif (board[i][j] <= 0 board[i][j] > 9)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nfunction isValidSudoku(board)\n{\n\tif (isinRange(board) == false)\n\t{\n\t\treturn false;\n\t}\n\tvar unique = Array(N+1).fill(false);\n\tfor(var i = 0; i < N; i++)\n\t{\n\t\tunique = Array(N+1).fill(false);\n\t\tunique = Array(N+1).fill(false);\n\t\tfor(var j = 0; j < N; j++)\n\t\t{\n\t\t\tvar Z = board[i][j];\n\t\t\tif (unique[Z])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tunique[Z] = true;\n\t\t}\n\t}\n\tfor(var i = 0; i < N; i++)\n\t{\n\t\tfor(var j = 0; j < N; j++)\n\t\t{\n\t\t\tvar Z = board[j][i];\n\t\t\tif (unique[Z])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tunique[Z] = true;\n\t\t}\n\t}\n\tfor(var i = 0; i < N - 2; i += 3)\n\t{\n\t\tfor(var j = 0; j < N - 2; j += 3)\n\t\t{\n\t\t\tunique = Array(N+1).fill(false);\n\t\t\tfor(var k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tfor(var l = 0; l < 3; l++)\n\t\t\t\t{\n\t\t\t\t\tvar X = i + k;\n\t\t\t\t\tvar Y = j + l;\n\t\t\t\t\tvar Z = board[X][Y];\n\t\t\t\t\tif (unique[Z])\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tunique[Z] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "3332": "function conVowUpp(str) {\n\t\tvar N = str.length;\n\t\tfor (var i = 0; i < N; i++) {\n\t\tif ( str[i] === \"a\" str[i] === \"e\" str[i] === \"i\" str[i] === \"o\" str[i] === \"u\" ) {\n\t\t\tdocument.write(str[i].toUpperCase());\n\t\t} else {\n\t\t\tdocument.write(str[i]);\n\t\t}\n\t\t}\n\t}", "3337": "function zvalue(nums)\n{\n\tvar m = max_element(nums);\n\tvar cnt = 0;\n\tfor(i = 0; i <= m; i++)\n\t{\n\t\tcnt = 0;\n\t\tfor(j = 0; j < nums.length; j++)\n\t\t{\n\t\t\tif (nums[j] >= i)\n\t\t\t\tcnt++;\n\t\t}\n\t\tif (cnt == i)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\nfunction max_element(nums)\n{\n\tvar max = nums[0];\n\tfor(i = 1; i < nums.length; i++)\n\t\tmax = Math.max(max, nums[i]);\n\treturn max;\n}", "3345": "function palindrome(a, i, j)\n\t{\n\t\twhile(i<j)\n\t\t{\n\t\t\tif(a[i] != a[j])\n\t\t\t\treturn false;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\nfunction findSubArray(arr, k)\n\t{\n\t\tlet n= arr.length;\n\t\tfor(let i=0; i<=n-k; i++){\n\t\t\tif(palindrome(arr, i, i+k-1))\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}", "3346": "function helper(mid)\n{\n\tvar cnt = 0;\n\tmp.forEach((value,) => {\n\t\tvar temp = value;\n\t\twhile (temp >= mid) { temp -= mid; cnt++; } });\n\treturn cnt >= N;\n}\nfunction findMaximumDays(arr)\n{\n\tfor (var i = 0; i < P; i++) {\n\t\tif(mp.has(arr[i]))\n\t\t\tmp.set(arr[i], mp.get(arr[i])+1)\n\t\telse\n\t\t\tmp.set(arr[i], 1);\n\t}\n\tvar start = 0, end = P, ans = 0;\n\twhile (start <= end) {\n\t\tvar mid = start\n\t\t\t\t+ parseInt((end - start) / 2);\n\t\tif (mid != 0 && helper(mid)) {\n\t\t\tans = mid;\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse if (mid == 0) {\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse {\n\t\t\tend = mid - 1;\n\t\t}\n\t}\n\treturn ans;\n}", "3374": "function countSubarrays( a, n, k)\n{\n\tvar ans = 0;\n\tvar pref = [];\n\tpref.push(0);\n\tfor (var i = 0; i < n; i++)\n\t\tpref.push((a[i] + pref[i]) % k);\n\tfor (var i = 1; i <= n; i++) {\n\t\tfor (var j = i; j <= n; j++) {\n\t\t\tif ((pref[j] - pref[i - 1] + k) % k == j - i + 1) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tdocument.write( ans + ' ');\n}", "3398": "function countRows( mat)\n{\n var count = 0;\n var totalSum = 0;\n for (var i = 0; i < N; i++)\n {\n\tfor (var j = 0; j < M; j++)\n\t{\n\ttotalSum += mat[i][j];\n\t}\n }\n for (var i = 0; i < N; i++)\n {\n\tvar currSum = 0;\n\tfor (var j = 0; j < M; j++)\n\t{\n\tcurrSum += mat[i][j];\n\t}\n\tif (currSum > totalSum - currSum)\n\tcount++;\n }\n document.write( count);\n}", "3417": "function isCrossed(path)\n\t{\n\t\tif (path.length == 0)\n\t\t\treturn;\n\t\tlet ans = false;\n\t\tlet mySet = new Set();\n\t\tlet x = 0, y = 0;\n\t\tmySet.add([x, y]);\n\t\tfor(let i = 0; i < path.length; i++)\n\t\t{\n\t\t\tif (path[i] == 'N')\n\t\t\t\tmySet.add([x, y++]);\n\t\t\tif (path[i] == 'S')\n\t\t\t\tmySet.add([x, y--]);\n\t\t\tif (path[i] == 'E')\n\t\t\t\tmySet.add([x++, y]);\n\t\t\tif (path[i] == 'W')\n\t\t\t\tmySet.add([x--, y]);\n\t\t\tif (!mySet.has([x, y]))\n\t\t\t{\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ans)\n\t\t\tdocument.write(\"Crossed\");\n\t\telse\n\t\t\tdocument.write(\"Not Crossed\");\n\t}", "3427": "function maxWidth(N, M, cost, s)\n\t{\n\t\tlet adj = [];\n\t\tfor(let i = 0; i < N; i++)\n\t\t{\n\t\t\tadj.push([]);\n\t\t}\n\t\tfor(let i = 0; i < M; i++)\n\t\t{\n\t\t\tadj[s[i][0]].push(s[i][1]);\n\t\t}\n\t\tlet result = 0;\n\t\tlet q = [];\n\t\tq.push(0);\n\t\twhile(q.length != 0)\n\t\t{\n\t\t\tlet count = q.length;\n\t\t\tresult = Math.max(count, result);\n\t\t\twhile(count-->0)\n\t\t\t{\n\t\t\t\tlet temp = q.shift();\n\t\t\t\tfor(let i = 0; i < adj[temp].length; i++)\n\t\t\t\t{\n\t\t\t\t\tq.push(adj[temp][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "3463": "function SieveOfEratosthenes()\n{\n isPrime.fill(true);\n\tfor (let p = 2; p * p <= MAX; p++) {\n\t\tif (isPrime[p] == true) {\n\t\t\tfor (let i = p * p; i <= MAX; i += p)\n\t\t\t\tisPrime[i] = false;\n\t\t}\n\t}\n\tfor (let p = 2; p <= MAX; p++)\n\t\tif (isPrime[p])\n\t\t\tprimes.push(p);\n}\nfunction prime_search(primes, diff)\n{\n\tlet low = 0;\n\tlet high = primes.length - 1;\n\tlet res = 0;\n\twhile (low <= high) {\n\t\tlet mid = Math.floor((low + high) / 2);\n\t\tif (primes[mid] == diff) {\n\t\t\treturn primes[mid];\n\t\t}\n\t\telse if (primes[mid] < diff) {\n\t\t\tlow = mid + 1;\n\t\t}\n\t\telse {\n\t\t\tres = primes[mid];\n\t\t\thigh = mid - 1;\n\t\t}\n\t}\n\treturn res;\n}\nfunction minCost(arr, n)\n{\n\tSieveOfEratosthenes();\n\tlet res = 0;\n\tfor (let i = 1; i < n; i++) {\n\t\tif (arr[i] < arr[i - 1]) {\n\t\t\tlet diff = arr[i - 1] - arr[i];\n\t\t\tlet closest_prime\n\t\t\t\t= prime_search(primes, diff);\n\t\t\tres += closest_prime;\n\t\t\tarr[i] += closest_prime;\n\t\t}\n\t}\n\treturn res;\n}", "3464": "function lexico_smallest(s1, s2)\n\t{\n\t\tlet M = new Map();\n\t\tlet S = new Set();\n\t\tlet pr;\n\t\tfor (let i = 0; i <= s1.length - 1; ++i) {\n\t\t\tif(M.has(s1[i]))\n\t\t\t{\n\t\t\t\tM[s1[i]]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tM[s1[i]] = 1;\n\t\t\t}\n\t\t\tS.add(s1[i]);\n\t\t}\n\t\tfor (let i = 0; i <= s2.length - 1; ++i) {\n\t\t\tif(M.has(s2[i]))\n\t\t\t{\n\t\t\t\tM[s2[i]]--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tM[s2[i]] = -1;\n\t\t\t}\n\t\t}\n\t\tlet c = s2[0];\n\t\tlet index = 0;\n\t\tlet res = \"\";\n\t\tS.forEach (function(x) {\n\t\t\tif (x != c) {\n\t\t\t\tfor (let i = 1; i <= M[x]; ++i) {\n\t\t\t\t\tres += x;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet j = 0;\n\t\t\t\tindex = res.length;\n\t\t\t\twhile (s2[j] == x) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif (s2[j] < c) {\n\t\t\t\t\tres += s2;\n\t\t\t\t\tfor (let i = 1; i <= M[x]; ++i) {\n\t\t\t\t\t\tres += x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (let i = 1; i <= M[x]; ++i) { res += x; } index += M[x]; res += s2; } } })\n\t\tres = \"aageeksgghmnpt\";\n\t\tpr = [res, index];\n\t\treturn pr;\n\t}\nfunction lexico_largest(s1, s2)\n\t{\n\t\tlet pr = lexico_smallest(s1, s2);\n\t\tlet d1 = \"\";\n\t\tfor (let i = pr[1] - 1; i >= 0; i--) {\n\t\t\td1 += pr[0][i];\n\t\t}\n\t\tlet d2 = \"\";\n\t\tfor (let i = pr[0].length - 1; i >= pr[1] + s2.length; --i) {\n\t\t\td2 += pr[0][i];\n\t\t}\n\t\tlet res = d2 + s2 + d1;\n\t\treturn res;\n\t}", "3468": "function addEdge(v, x, y)\n\t{\n\t\tv[x].push(y);\n\t\tv[y].push(x);\n\t}\nfunction dfs(tree, temp, ancestor, u, parent, k)\n\t{\n\t\ttemp.push(u);\n\t\tfor(let i = 0; i < tree[u].length; i++)\n\t\t{\n\t\t\tif (tree[u][i] == parent)\n\t\t\t\tcontinue;\n\t\t\tdfs(tree, temp, ancestor, tree[u][i], u, k);\n\t\t}\n\t\ttemp.pop();\n\t\tif (temp.length < k)\n\t\t{\n\t\t\tancestor[u] = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tancestor[u] = temp[temp.length - k];\n\t\t}\n\t}\nfunction KthAncestor(N, K, E, edges)\n\t{\n\t\tlet tree = new Array(N + 1);\n\t\tfor(let i = 0; i < tree.length; i++)\n\t\t\ttree[i] = [];\n\t\tfor(let i = 0; i < E; i++)\n\t\t{\n\t\t\taddEdge(tree, edges[i][0], edges[i][1]);\n\t\t}\n\t\tlet temp = [];\n\t\tlet ancestor = new Array(N + 1);\n\t\tdfs(tree, temp, ancestor, 1, 0, K);\n\t\tfor(let i = 1; i <= N; i++)\n\t\t{\n\t\t\tdocument.write(ancestor[i] + \" \");\n\t\t}\n\t}", "3471": "function build(sum, a, l, r, rt)\n{\n\t\tif(l == r)\n\t\t{\n\t\t\tsum[rt] = a[l - 1];\n\t\t\treturn;\n\t\t}\n\t\tlet m = (l + r) >> 1;\n\t\tbuild(sum, a, l, m, rt << 1);\n\t\tbuild(sum, a, m + 1, r, rt << 1 1);\n}\nfunction pushDown(sum,add,rt,ln,rn)\n{\n\tif(add[rt] != 0)\n\t\t{\n\t\t\tadd[rt << 1] = add[rt];\n\t\t\tadd[rt << 1 1] = add[rt];\n\t\t\tsum[rt << 1] = sum[rt << 1] + add[rt] * ln;\n\t\t\tsum[rt << 1 1] = sum[rt << 1 1] + add[rt] * rn;\n\t\t\tadd[rt]= 0;\n\t\t}\n}\nfunction update(sum,add,L,R,C,l,r,rt)\n{\n\t\tif(L <= l && r <= R)\n\t\t{\n\t\t\tsum[rt] = sum[rt] + C * (r - l + 1);\n\t\t\tadd[rt] = add[rt] + C;\n\t\t\treturn;\n\t\t}\n\t\tlet m = (l + r) >> 1;\n\t\tpushDown(sum, add, rt, m - l + 1, r - m);\n\t\tif(L <= m)\n\t\t{\n\t\t\tupdate(sum, add, L, R, C, l, m, rt << 1);\n\t\t}\n\t\tif(R > m)\n\t\t{\n\t\t\tupdate(sum, add, L, R, C, m + 1, r, rt << 1 1);\n\t\t}\n}\nfunction query(sum,add,L,R,l,r,rt)\n{\n\t\tif (L <= l && r <= R)\n\t\t{\n\t\t\treturn sum[rt];\n\t\t}\n\t\tlet m = (l + r) >> 1;\n\t\tpushDown(sum, add, rt, m - l + 1, r - m);\n\t\tlet ans = 0;\n\t\tif(L <= m)\n\t\t{\n\t\t\tans += query(sum, add, L, R, l, m, rt << 1);\n\t\t}\n\t\tif(R > m)\n\t\t{\n\t\t\tans += query(sum, add, L, R, m + 1, r,rt << 1 1);\n\t\t}\n\t\treturn ans;\n}\nfunction sequenceMaintenance(n,q,a,b,m)\n{\n\t\ta.sort(function(a,b){return a-b;});\n\t\tlet sum = [];\n\t\tlet ad = [];\n\t\tlet ans = [];\n\t\tfor(let i = 0; i < (n << 2); i++)\n\t\t{\n\t\t\tsum.push(0);\n\t\t\tad.push(0);\n\t\t}\n\t\tbuild(sum, a, 1, n, 1);\n\t\tfor(let i = 0; i < q; i++)\n\t\t{\n\t\t\tlet l = 1, r = n, pos = -1;\n\t\t\twhile(l <= r)\n\t\t\t{\n\t\t\t\tm = (l + r) >> 1;\n\t\t\t\tif(query(sum, ad, m, m, 1, n, 1) >= b[i])\n\t\t\t\t{\n\t\t\t\t\tr = m - 1;\n\t\t\t\t\tpos = m;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tl = m + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos == -1)\n\t\t\t{\n\t\t\t\tans.push(0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans.push(n - pos + 1);\n\t\t\t\tupdate(sum, ad, pos, n, -m, 1, n, 1);\n\t\t\t}\n\t\t}\n\t\tfor(let i = 0; i < ans.length; i++)\n\t\t{\n\t\t\tdocument.write(ans[i] + \" \");\n\t\t}\n}", "3487": "function count(s)\n{\n\tvar cnt = 0;\n\ts.split('').forEach(c => {\n\t\tcnt += (c == '0') ? 1 : 0; });\n\tif (cnt % 3 != 0)\n\t\treturn 0;\n\tvar res = 0, k = parseInt(cnt / 3), sum = 0;\n\tvar mp = new Map();\n\tfor(var i = 0; i < s.length; i++)\n\t{\n\t\tsum += (s[i] == '0') ? 1 : 0;\n\t\tif (sum == 2 * k && mp.has(k) && i < s.length - 1 && i > 0)\n\t\t{\n\t\t\tres += mp.get(k);\n\t\t}\n\t\tif(mp.has(sum))\n\t\t\tmp.set(sum, mp.get(sum)+1)\n\t\telse\n\t\t\tmp.set(sum, 1);\n\t}\n\treturn res;\n}", "3488": "function splitstring(s)\n\t{\n\t\tlet n = s.length;\n\t\tlet zeros = 0;\n\t\tfor(let i = 0; i < n; i++)\n\t\t\tif (s[i] == '0')\n\t\t\t\tzeros++;\n\t\tif (zeros % 3 != 0)\n\t\t\treturn 0;\n\t\tif (zeros == 0)\n\t\t\treturn parseInt(((n - 1) * (n - 2)) / 2, 10);\n\t\tlet zerosInEachSubstring = parseInt(zeros / 3, 10);\n\t\tlet waysOfFirstCut = 0;\n\t\tlet waysOfSecondCut = 0;\n\t\tlet count = 0;\n\t\tfor(let i = 0; i < n; i++)\n\t\t{\n\t\t\tif (s[i] == '0')\n\t\t\t\tcount++;\n\t\t\tif (count == zerosInEachSubstring)\n\t\t\t\twaysOfFirstCut++;\n\t\t\telse if (count == 2 * zerosInEachSubstring)\n\t\t\t\twaysOfSecondCut++;\n\t\t}\n\t\treturn waysOfFirstCut * waysOfSecondCut;\n\t}", "3495": "function check(s, k)\n{\n let n = s.length;\n for (let i = 0; i < k; i++)\n {\n\tfor (let j = i; j < n; j += k)\n\t{\n\tif (s[i] != s[j])\n\t\treturn false;\n\t}\n }\n let c = 0;\n for (let i = 0; i < k; i++)\n {\n\tif (s[i]== '0')\n\tc++;\n\telse\n\tc--;\n }\n if (c == 0)\n\treturn true;\n else\n\treturn false;\n}", "3503": "function addEdge(a, b)\n{\n\ttree[a].push(b);\n\ttree[b].push(a);\n}\nfunction dfs(x)\n{\n\tvis[x] = true;\n\tsubtreeSize[x] = 1;\n\ttree[x].forEach(i => {\n\t\tif (!vis[i]) {\n\t\t\tdfs(i); subtreeSize[x] += subtreeSize[i]; } });\n}\nfunction countPairs(a, b)\n{\n\tvar sub = Math.min(subtreeSize[a], subtreeSize[b]);\n\tdocument.write( sub * (n - sub) + \"<br>\");\n}", "3516": "function revNum(N) {\n\t\tvar x = 0;\n\t\twhile (N) {\n\t\tx = x * 10 + (N % 10);\n\t\tN = N / 10;\n\t\t}\n\t\treturn x;\n\t}\nfunction ctNonPalin(arr, N) {\n\t\tvar Res = 0;\n\t\tfor (var i = 0; i < N; i++) {\n\t\tvar x = revNum(arr[i]);\n\t\tif (x == arr[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tRes += arr[i] % 10 == N % 10;\n\t\t}\n\t\t}\n\t\treturn Res;\n\t}", "3520": "function isSame(str, n)\n{\n\tvar mp = {};\n\tfor(var i = 0; i < str.length; i++)\n\t{\n\t\tif (mp.hasOwnProperty(str[i].charCodeAt(0) -\n\t\t\t\t\t\t\t\t\"a\".charCodeAt(0)))\n\t\t{\n\t\t\tmp[str[i].charCodeAt(0) - \"a\".charCodeAt(0)] =\n\t\t\tmp[str[i].charCodeAt(0) - \"a\".charCodeAt(0)] + 1;\n\t\t} else\n\t\t{\n\t\t\tmp[str[i].charCodeAt(0) - \"a\".charCodeAt(0)] = 1;\n\t\t}\n\t}\n\tfor(const [key, value] of Object.entries(mp))\n\t{\n\t\tif (value >= n)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "3531": "function canTransform(str1, str2) {\n\t\tvar s1 = \"\";\n\t\tvar s2 = \"\";\n\t\tfor (const c of str1) {\n\t\tif (c !== \"C\") {\n\t\t\ts1 += c;\n\t\t}\n\t\t}\n\t\tfor (const c of str2) {\n\t\tif (c !== \"C\") {\n\t\t\ts2 += c;\n\t\t}\n\t\t}\n\t\tif (s1 !== s2) return false;\n\t\tvar i = 0;\n\t\tvar j = 0;\n\t\tvar n = str1.length;\n\t\twhile (i < n && j < n) {\n\t\tif (str1[i] === \"C\") {\n\t\t\ti++;\n\t\t} else if (str2[j] === \"C\") {\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tif ((str1[i] === \"A\" && i < j) || (str1[i] === \"B\" && i > j)) {\n\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\t}\n\t\treturn true;\n\t}", "3540": "function func(a, b, c, x)\n{\n\treturn a * x * x + b * x + c;\n}\nfunction findRoot(a, b, c, low, high)\n{\n\tlet x = -1;\n\twhile (Math.abs(high - low) > eps)\n\t{\n\t\tx = (low + high) / 2;\n\t\tif (func(a, b, c, low) *\n\t\t\tfunc(a, b, c, x) <= 0)\n\t\t{\n\t\t\thigh = x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlow = x;\n\t\t}\n\t}\n\treturn x;\n}\nfunction solve(a, b, c, A, B)\n{\n\tif (func(a, b, c, A) * func(a, b, c, B) > 0)\n\t{\n\t\tdocument.write(\"No solution\");\n\t}\n\telse\n\t{\n\t\tdocument.write(findRoot( a, b, c, A, B));\n\t}\n}", "3550": "function __gcd(a , b) {\n\t\treturn b == 0 ? a : __gcd(b, a % b);\n\t}\nfunction hasCoprimePair(arr , n) {\n\t\tfor (i = 0; i < n - 1; i++) {\n\t\t\tfor (j = i + 1; j < n; j++) {\n\t\t\t\tif ((__gcd(arr[i], arr[j])) == 1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "3555": "function findPermutation(arr, N)\n{\n\tvar pos = arr.size + 1;\n\tif (pos > N)\n\t\treturn 1;\n\tvar res = 0;\n\tfor(var i = 1; i <= N; i++)\n\t{\n\t\tif (!arr.has(i))\n\t\t{\n\t\t\tif (i % pos == 0 pos % i == 0)\n\t\t\t{\n\t\t\t\tarr.add(i);\n\t\t\t\tres += findPermutation(arr, N);\n\t\t\t\tarr.delete(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "3562": "function solve(arr, n, X, Y)\n{\n\tvar diff = Y - X;\n\tfor(var i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] != 1)\n\t\t{\n\t\t\tdiff = diff % (arr[i] - 1);\n\t\t}\n\t}\n\tif (diff == 0)\n\t\tdocument.write(\"Yes\");\n\telse\n\t\tdocument.write(\"No\");\n}", "3564": "function Numberofways(n)\n{\n\tvar count = 0;\n\tfor (var a = 1; a < n; a++)\n\t{\n\t\tfor (var b = 1; b < n; b++)\n\t\t{\n\t\t\tvar c = n - (a + b);\n\t\t\tif (a + b > c && a + c > b && b + c > a)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "3567": "function maxsubStringLength(S, N)\n{\n\tlet arr = Array.from({length: N}, (_, i) => 0);\n\tfor(let i = 0; i < N; i++)\n\tif (S[i] == 'a' S[i] == 'e' S[i] == 'i' S[i] == 'o' S[i] == 'u')\n\t\tarr[i] = 1;\n\telse\n\t\tarr[i] = -1;\n\tlet maxLen = 0;\n\tlet curr_sum = 0;\n\tlet hash = new Map();\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tcurr_sum += arr[i];\n\t\tif (curr_sum == 0)\n\t\t\tmaxLen = Math.max(maxLen, i + 1);\n\t\tif (hash.has(curr_sum))\n\t\t\tmaxLen = Math.max(maxLen,\n\t\t\t\t\t\t\ti - hash.get(curr_sum));\n\t\telse\n\t\t\thash.set(curr_sum, i);\n\t}\n\treturn maxLen;\n}", "3584": "function findMaximumSum(a ,n)\n\t{\n\t\tvar prev_smaller = findPrevious(a, n);\n\t\tvar next_smaller = findNext(a, n);\n\t\tvar max_value = 0;\n\t\tfor (var i = 0; i < n; i++)\n\t\t{\n\t\t\tmax_value = Math.max(max_value, a[i] * (next_smaller[i] - prev_smaller[i] - 1));\n\t\t}\n\t\treturn max_value;\n\t}\nfunction findPrevious(a , n) {\n\t\tvar ps = Array(n).fill(0);\n\t\tps[0] = -1;\n\t\tlet stack = Array();\n\t\tstack.push(0);\n\t\tfor (var i = 1; i < a.length; i++) {\n\t\t\twhile (stack.length > 0 && a[stack[stack.length-1]] >= a[i])\n\t\t\t\tstack.pop();\n\t\t\tps[i] = stack.length > 0 ?stack[stack.length-1] : -1;\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn ps;\n\t}\nfunction findNext(a , n) {\n\t\tvar ns = Array(n).fill(0);\n\t\tns[n - 1] = n;\n\t\tvar stack = Array();\n\t\tstack.push(n - 1);\n\t\tfor (var i = n - 2; i >= 0; i--) {\n\t\t\twhile (stack.length > 0 && a[stack[stack.length-1]] >= a[i])\n\t\t\t\tstack.pop();\n\t\t\tns[i] = stack.length > 0 ? stack[stack.length-1] : a.length;\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn ns;\n\t}", "3601": "function possible(mid, a)\n{\n\tlet n = a.length;\n\tlet total = parseInt((n * (n - 1)) / 2);\n\tlet need = parseInt((total + 1) / 2);\n\tlet count = 0;\n\tlet start = 0, end = 1;\n\twhile (end < n) {\n\t\tif (a[end] - a[start] <= mid) {\n\t\t\tend++;\n\t\t}\n\t\telse {\n\t\t\tcount += (end - start - 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\tif (end == n && start < end && a[end - 1] - a[start] <= mid) {\n\t\tlet t = end - start - 1;\n\t\tcount += parseInt(t * (t + 1) / 2);\n\t}\n\tif (count >= need)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nfunction findMedian(a)\n{\n\tlet n = a.length;\n\tlet low = 0, high = a[n - 1] - a[0];\n\twhile (low <= high) {\n\t\tlet mid = (low + high) / 2;\n\t\tif (possible(mid, a))\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\treturn high + 1;\n}", "3605": "function FindMinimumDistance()\n\t{\n\t\tlet q = [];\n\t\tq.push([ x, y ]);\n\t\tmat[x][y] = 0;\n\t\twhile (q.length > 0) {\n\t\t\tx = q[0][0];\n\t\t\ty = q[0][1];\n\t\t\tq.shift();\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tlet a = x + dx[i];\n\t\t\t\tlet b = y + dy[i];\n\t\t\t\tif (a < 0 a >= r b >= c b < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (mat[a][b] == 0) {\n\t\t\t\t\tmat[a][b] = mat[x][y] + 1;\n\t\t\t\t\tq.push([ a, b ]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "3629": "function addEdge(u, v)\n\t{\n\t\tadj[u].push(v);\n\t\tadj[v].push(u);\n\t}\nfunction dfs1(cur, par)\n\t{\n\t\tfor(let u = 0; u < adj[cur].length; u++)\n\t\t{\n\t\t\tif (adj[cur][u] != par)\n\t\t\t{\n\t\t\t\tdfs1(adj[cur][u], cur);\n\t\t\t\theight[cur] = Math.max(height[cur], height[adj[cur][u]]);\n\t\t\t}\n\t\t}\n\t\theight[cur] += 1;\n\t}\nfunction dfs2(cur, par)\n\t{\n\t\tlet max1 = 0;\n\t\tlet max2 = 0;\n\t\tfor(let u = 0; u < adj[cur].length; u++)\n\t\t{\n\t\t\tif (adj[cur][u] != par)\n\t\t\t{\n\t\t\t\tif (height[adj[cur][u]] >= max1)\n\t\t\t\t{\n\t\t\t\t\tmax2 = max1;\n\t\t\t\t\tmax1 = height[adj[cur][u]];\n\t\t\t\t}\n\t\t\t\telse if (height[adj[cur][u]] > max2)\n\t\t\t\t{\n\t\t\t\t\tmax2 = height[adj[cur][u]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet sum = 0;\n\t\tfor(let u = 0; u < adj[cur].length; u++)\n\t\t{\n\t\t\tif (adj[cur][u] != par)\n\t\t\t{\n\t\t\t\tsum = ((max1 == height[adj[cur][u]]) ? max2 : max1);\n\t\t\t\tif (max1 == height[adj[cur][u]])\n\t\t\t\t\tdist[adj[cur][u]] = 1 + Math.max(1 + max2, dist[cur]);\n\t\t\t\telse\n\t\t\t\t\tdist[adj[cur][u]] = 1 + Math.max(1 + max1, dist[cur]);\n\t\t\t\tdfs2(adj[cur][u], cur);\n\t\t\t}\n\t\t}\n\t}", "3644": "function countPairs(N, arr)\n\t{\n\t\tlet count = 0;\n\t\tfor(let i = 0; i < N; i++)\n\t\t{\n\t\t\tif (i == arr[arr[i] - 1] - 1)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tdocument.write(count / 2);\n\t}", "3664": "function minOperations(S, K) {\n\t\tvar ans = 0;\n\t\tfor (var i = 0; i < K; i++) {\n\t\tvar zero = 0,\n\t\t\tone = 0;\n\t\tfor (var j = i; j < S.length; j += K) {\n\t\t\tif (S[j] === \"0\")\n\t\t\t\tzero++;\n\t\t\telse\n\t\t\t\tone++;\n\t\t}\n\t\tans += Math.min(zero, one);\n\t\t}\n\t\treturn ans;\n\t}", "3678": "function UniversalSubset(A, B)\n{\n\tvar n1 = A.length;\n\tvar n2 = B.length;\n\tvar res = [];\n\tvar A_fre = Array.from( Array(n1), ()=> Array(26));\n\tfor (var i = 0; i < n1; i++) {\n\t\tfor (var j = 0; j < 26; j++)\n\t\t\tA_fre[i][j] = 0;\n\t}\n\tfor (var i = 0; i < n1; i++) {\n\t\tfor (var j = 0; j < A[i].length; j++) {\n\t\t\tA_fre[i][A[i].charCodeAt(j) - 'a'.charCodeAt(0)]++;\n\t\t}\n\t}\n\tvar B_fre = Array(26).fill(0);\n\tfor (var i = 0; i < n2; i++) {\n\t\tvar arr = Array(26).fill(0);\n\t\tfor (var j = 0; j < B[i].length; j++) {\n\t\t\tarr[B[i].charCodeAt(j) - 'a'.charCodeAt(0)]++;\n\t\t\tB_fre[B[i].charCodeAt(j) - 'a'.charCodeAt(0)]\n\t\t\t\t= Math.max(B_fre[B[i].charCodeAt(j) - 'a'.charCodeAt(0)],\n\t\t\t\t\tarr[B[i].charCodeAt(j)- 'a'.charCodeAt(0)]);\n\t\t}\n\t}\n\tfor (var i = 0; i < n1; i++) {\n\t\tvar flag = 0;\n\t\tfor (var j = 0; j < 26; j++) {\n\t\t\tif (A_fre[i][j] < B_fre[j]) {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == 0)\n\t\t\tres.push(A[i]);\n\t}\n\tif (res.length>0) {\n\t\tfor (var i = 0; i < res.length; i++) {\n\t\t\tfor (var j = 0; j < res[i].length; j++)\n\t\t\t\tdocument.write( res[i][j]);\n\t\t}\n\t\tdocument.write( \" \");\n\t}\n\telse\n\t\tdocument.write( \"-1\");\n}", "3692": "function findPair(a, n)\n{\n\tlet min_dist = Number.MAX_VALUE;\n\tlet index_a = -1, index_b = -1;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tfor(let j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (j - i < min_dist)\n\t\t\t{\n\t\t\t\tif (a[i] % a[j] == 0 a[j] % a[i] == 0)\n\t\t\t\t{\n\t\t\t\tmin_dist = j - i;\n\t\t\t\tindex_a = i;\n\t\t\t\tindex_b = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (index_a == -1)\n\t{\n\t\tdocument.write(\"-1\");\n\t}\n\telse\n\t{\n\t\tdocument.write(\"(\" + a[index_a] + \", \" + a[index_b] + \")\");\n\t}\n}", "3704": "function printNum(L, R)\n{\n\tfor(let i = L; i <= R; i++)\n\t{\n\t\tlet temp = i;\n\t\tlet c = 10;\n\t\tlet flag = 0;\n\t\twhile (temp > 0)\n\t\t{\n\t\t\tif (temp % 10 >= c)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = temp % 10;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tif (flag == 0)\n\t\t\tdocument.write(i + \" \");\n\t}\n}", "3742": "function findMissing(arr, left, right, diff)\n{\n\tif (right <= left)\n\t\treturn 0;\n\tlet mid = left + parseInt((right - left) / 2, 10);\n\tif (arr[mid + 1] - arr[mid] != diff)\n\t\treturn (arr[mid] + diff);\n\tif (mid > 0 && arr[mid] - arr[mid - 1] != diff)\n\t\treturn (arr[mid - 1] + diff);\n\tif (arr[mid] == arr[0] + mid * diff)\n\t\treturn findMissing(arr, mid + 1, right, diff);\n\treturn findMissing(arr, left, mid - 1, diff);\n}\nfunction missingElement(arr, n)\n{\n\tarr.sort(function(a, b){return a - b});\n\tlet diff = parseInt((arr[n - 1] - arr[0]) / n, 10);\n\treturn findMissing(arr, 0, n - 1, diff);\n}", "3743": "function missingElement(arr, n)\n\t{\n\t\tlet max_ele = arr[0];\n\t\tlet min_ele = arr[0];\n\t\tlet x = 0;\n\t\tlet d;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tif (arr[i] > max_ele)\n\t\t\t\tmax_ele = arr[i];\n\t\t\tif (arr[i] < min_ele)\n\t\t\t\tmin_ele = arr[i];\n\t\t}\n\t\td = parseInt((max_ele - min_ele) / n, 10);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tx = x ^ arr[i];\n\t\t}\n\t\tfor (let i = 0; i <= n; i++) {\n\t\t\tx = x ^ (min_ele + (i * d));\n\t\t}\n\t\treturn x;\n\t}", "3752": "function power(x, y)\n{\n\tlet temp;\n\tif (y == 0)\n\t\treturn 1;\n\ttemp = power(x, Math.floor(y / 2));\n\tif (y % 2 == 0)\n\t\treturn temp * temp;\n\telse\n\t\treturn x * temp * temp;\n}\nfunction nthRootSearch(low, high, N, K)\n{\n\tif (low <= high)\n\t{\n\t\tlet mid = Math.floor((low + high) / 2);\n\t\tif ((power(mid, K) <= N) &&\n\t\t\t(power(mid + 1, K) > N))\n\t\t{\n\t\t\treturn mid;\n\t\t}\n\t\telse if (power(mid, K) < N)\n\t\t{\n\t\t\treturn nthRootSearch(mid + 1, high, N, K);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn nthRootSearch(low, mid - 1, N, K);\n\t\t}\n\t}\n\treturn low;\n}", "3755": "function get_subset_count(arr,K,N)\n{\n\t(arr).sort(function(a,b){return a-b;});\n\tlet left, right;\n\tleft = 0;\n\tright = N - 1;\n\tlet ans = 0;\n\twhile (left <= right)\n\t{\n\t\tif (arr[left] + arr[right] < K)\n\t\t{\n\t\t\tans += 1 << (right - left);\n\t\t\tleft++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tright--;\n\t\t}\n\t}\n\treturn ans;\n}", "3765": "function minMaxDiff(arr, n, k)\n{\n\tvar max_adj_dif = -1000000000;\n\tfor (var i = 0; i < n - 1; i++)\n\t\tmax_adj_dif\n\t\t\t= Math.max(max_adj_dif,\n\t\t\t\tMath.abs(arr[i] - arr[i + 1]));\n\tif (max_adj_dif == 0)\n\t\treturn 0;\n\tvar best = 1;\n\tvar worst = max_adj_dif;\n\tvar mid, required;\n\twhile (best < worst) {\n\t\tmid = (best + worst) / 2;\n\t\trequired = 0;\n\t\tfor (var i = 0; i < n - 1; i++) {\n\t\t\trequired += parseInt((Math.abs(arr[i] - arr[i + 1]) - 1) / mid);\n\t\t}\n\t\tif (required > k)\n\t\t\tbest = mid + 1;\n\t\telse\n\t\t\tworst = mid;\n\t}\n\treturn worst;\n}", "3773": "function checkMin(arr, len)\n{\n\tvar smallest = Number.INFINITY,\n\t\tsecondSmallest = Number.INFINITY;\n\tfor(var i = 0; i < len; i++)\n\t{\n\t\tif (arr[i] < smallest)\n\t\t{\n\t\t\tsecondSmallest = smallest;\n\t\t\tsmallest = arr[i];\n\t\t}\n\t\telse if (arr[i] < secondSmallest)\n\t\t{\n\t\t\tsecondSmallest = arr[i];\n\t\t}\n\t}\n\tif (2 * smallest <= secondSmallest)\n\t\tdocument.write(\"Yes\");\n\telse\n\t\tdocument.write(\"No\");\n}", "3798": "function createHash(hash, maxElement)\n{\n\tlet prev = 0, curr = 1;\n\thash.add(prev);\n\thash.add(curr);\n\twhile (curr <= maxElement) {\n\t\tlet temp = curr + prev;\n\t\thash.add(temp);\n\t\tprev = curr;\n\t\tcurr = temp;\n\t}\n}\nfunction fibonacci(arr, n)\n{\n\tlet max_val= Math.max(...arr);\n\tlet hash = new Set();\n\tcreateHash(hash, max_val);\n\tlet minimum = Number.MAX_VALUE;\n\tlet maximum = Number.MIN_VALUE;\n\tfor (let i = 0; i < n; i++) {\n\t\tif (hash.has(arr[i])) {\n\t\t\tminimum = Math.min(minimum, arr[i]);\n\t\t\tmaximum = Math.max(maximum, arr[i]);\n\t\t}\n\t}\n\tdocument.write(minimum+ \", \" + maximum +\"<br/>\");\n}", "3814": "function isValidLen(s, len, k)\n{\n\tvar n = s.length;\n\tvar mp = new Map();\n\tvar right = 0;\n\twhile (right < len) {\n\t\tif(mp.has(s[right]))\n\t\t\tmp.set(s[right],mp.get(s[right])+1)\n\t\telse\n\t\t\tmp.set(s[right], 1)\n\t\tright++;\n\t}\n\tif (mp.size <= k)\n\t\treturn true;\n\twhile (right < n) {\n\t\tif(mp.has(s[right]))\n\t\t\tmp.set(s[right],mp.get(s[right])+1)\n\t\telse\n\t\t\tmp.set(s[right], 1)\n\t\tif(mp.has(s[right - len]))\n\t\t\tmp.set(s[right - len], mp.get(s[right - len])-1)\n\t\tif(mp.has(s[right - len]) && mp.get(s[right - len])==0)\n\t\t\tmp.delete(s[right - len]);\n\t\tif (mp.size <= k)\n\t\t\treturn true;\n\t\tright++;\n\t}\n\treturn mp.size <= k;\n}\nfunction maxLenSubStr(s, k)\n{\n\tvar uni = new Set();\n\ts.split('').forEach(x => {\n\t\tuni.add(x); });\n\tif (uni.size < k)\n\t\treturn -1;\n\tvar n = s.length;\n\tvar lo = -1, hi = n + 1;\n\twhile (hi - lo > 1) {\n\t\tvar mid = lo + hi >> 1;\n\t\tif (isValidLen(s, mid, k))\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid;\n\t}\n\treturn lo;\n}", "3822": "function isSquarePossible(arr, n, l) {\n\tlet cnt = 0;\n\tfor (let i = 0; i < n; i++) {\n\t\tif (arr[i] >= l)\n\t\t\tcnt++;\n\t\tif (cnt >= l)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nfunction maxArea(arr, n) {\n\tlet l = 0, r = n;\n\tlet len = 0;\n\twhile (l <= r) {\n\t\tlet m = l + Math.floor((r - l) / 2);\n\t\tif (isSquarePossible(arr, n, m)) {\n\t\t\tlen = m;\n\t\t\tl = m + 1;\n\t\t}\n\t\telse\n\t\t\tr = m - 1;\n\t}\n\treturn (len * len);\n}", "3825": "function kOverlap(pairs, k)\n{\n\tvar vec = [];\n\tfor (var i = 0; i < pairs.length; i++) {\n\t\tvec.push([pairs[i][0], -1 ]);\n\t\tvec.push([pairs[i][1], +1 ]);\n\t}\n\tvec.sort((a,b)=>{\n\t\tif(a[0]!=b[0]) return a[0]-b[0] return a[1]-b[1] });\n\tvar st = [];\n\tfor (var i = 0; i < vec.length; i++) {\n\t\tvar cur = vec[i];\n\t\tif (cur[1] == -1) {\n\t\t\tst.push(cur);\n\t\t}\n\t\telse {\n\t\t\tst.pop();\n\t\t}\n\t\tif (st.length >= k) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "3829": "function insertNames(arr, n)\n{\n\tlet set = new Set();\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tif (!set.has(arr[i]))\n\t\t{\n\t\t\tdocument.write(\"No\" + \"<br/>\");\n\t\t\tset.add(arr[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.write(\"Yes\" + \"<br/>\");\n\t\t}\n\t}\n}", "3871": "function countLessThan(arr,n,key)\n{\n\tlet l = 0, r = n - 1;\n\t\tlet index = -1;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tlet m = Math.floor((l + r) / 2);\n\t\t\tif (arr[m] < key)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t\tindex = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t}\n\t\t}\n\t\treturn (index + 1);\n}\nfunction countGreaterThan(arr,n,key)\n{\n\tlet l = 0, r = n - 1;\n\t\tlet index = -1;\n\t\twhile (l <= r)\n\t\t{\n\t\tlet m = Math.floor((l + r) / 2);\n\t\t\tif (arr[m] <= key)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m - 1;\n\t\t\t\tindex = m;\n\t\t\t}\n\t\t}\n\t\tif (index == -1)\n\t\t\treturn 0;\n\t\treturn (n - index);\n}\nfunction countTriplets(n,a,b,c)\n{\n\t\ta.sort(function(e,f){return e-f;}) ;\n\t\tb.sort(function(e,f){return e-f;}) ;\n\t\tc.sort(function(e,f){return e-f;}) ;\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < n; ++i)\n\t\t{\n\t\t\tlet current = b[i];\n\t\t\tlet low = countLessThan(a, n, current);\n\t\t\tlet high = countGreaterThan(c, n, current);\n\t\t\tcount += (low * high);\n\t\t}\n\t\treturn count;\n}", "3885": "function Printksubstring(str, n, k)\n\t{\n\t\tlet total = parseInt((n * (n + 1)) / 2, 10);\n\t\tif (k > total)\n\t\t{\n\t\t\tdocument.write(\"-1\" + \"</br>\");\n\t\t\treturn;\n\t\t}\n\t\tlet substring = new Array(n + 1);\n\t\tsubstring[0] = 0;\n\t\tlet temp = n;\n\t\tfor (let i = 1; i <= n; i++)\n\t\t{\n\t\t\tsubstring[i] = substring[i - 1] + temp;\n\t\t\ttemp--;\n\t\t}\n\t\tlet l = 1;\n\t\tlet h = n;\n\t\tlet start = 0;\n\t\twhile (l <= h)\n\t\t{\n\t\t\tlet m = parseInt((l + h) / 2, 10);\n\t\t\tif (substring[m] > k)\n\t\t\t{\n\t\t\t\tstart = m;\n\t\t\t\th = m - 1;\n\t\t\t}\n\t\t\telse if (substring[m] < k)\n\t\t\t{\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlet end = n - (substring[start] - k);\n\t\tfor (let i = start - 1; i < end; i++)\n\t\t{\n\t\t\tdocument.write(str[i]);\n\t\t}\n\t}", "3932": "function LowerInsertionPoint(arr, n, X)\n\t{\n\t\tif (X < arr[0])\n\t\t\treturn 0;\n\t\telse if (X > arr[n - 1])\n\t\t\treturn n;\n\t\tlet lowerPnt = 0;\n\t\tlet i = 1;\n\t\twhile (i < n && arr[i] < X) {\n\t\t\tlowerPnt = i;\n\t\t\ti = i * 2;\n\t\t}\n\t\twhile (lowerPnt < n && arr[lowerPnt] < X)\n\t\t\tlowerPnt++;\n\t\treturn lowerPnt;\n\t}", "3967": "function LongestFibSubseq(A, n)\n{\n\tvar S = new Set(A);\n\tvar maxLen = 0, x, y;\n\tfor (var i = 0; i < n; ++i) {\n\t\tfor (var j = i + 1; j < n; ++j) {\n\t\t\tx = A[j];\n\t\t\ty = A[i] + A[j];\n\t\t\tvar length = 2;\n\t\t\twhile (S.has(y)) {\n\t\t\t\tvar z = x + y;\n\t\t\t\tx = y;\n\t\t\t\ty = z;\n\t\t\t\tmaxLen = Math.max(maxLen, ++length);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxLen >= 3 ? maxLen : 0;\n}", "4039": "function getCount(M, N)\n\t{\n\t\tlet count = 0;\n\t\tif (M == 1)\n\t\t\treturn N;\n\t\tif (N == 1)\n\t\t\treturn M;\n\t\tif (N > M) {\n\t\t\tfor (let i = 1; i <= M; i++) {\n\t\t\t\tlet numerator = N * i - N + M - i;\n\t\t\t\tlet denominator = M - 1;\n\t\t\t\tif (numerator % denominator == 0) {\n\t\t\t\t\tlet j =\n\t\t\t\t\tparseInt(numerator / denominator, 10);\n\t\t\t\t\tif (j >= 1 && j <= N)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (let j = 1; j <= N; j++) {\n\t\t\t\tlet numerator = M * j - M + N - j;\n\t\t\t\tlet denominator = N - 1;\n\t\t\t\tif (numerator % denominator == 0) {\n\t\t\t\t\tlet i =\n\t\t\t\t\tparseInt(numerator / denominator, 10);\n\t\t\t\t\tif (i >= 1 && i <= M)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "4048": "function swapElement(arr1, arr2, n)\n\t{\n\t\tlet wrongIdx = 0;\n\t\tfor (let i = 1; i < n; i++)\n\t\t{\n\t\t\tif (arr1[i] < arr1[i - 1])\n\t\t\t{\n\t\t\t\twrongIdx = i;\n\t\t\t}\n\t\t}\n\t\tlet maximum = Number.MIN_VALUE;\n\t\tlet maxIdx = -1;\n\t\tlet res = false;\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr2[i] > maximum && arr2[i] >= arr1[wrongIdx - 1])\n\t\t\t{\n\t\t\t\tif (wrongIdx + 1 <= n - 1 && arr2[i] <= arr1[wrongIdx + 1])\n\t\t\t\t{\n\t\t\t\t\tmaximum = arr2[i];\n\t\t\t\t\tmaxIdx = i;\n\t\t\t\t\tres = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (res)\n\t\t{\n\t\t\tswap(arr1, wrongIdx, arr2, maxIdx);\n\t\t}\n\t\treturn res;\n\t}\nfunction swap(a, wrongIdx, b, maxIdx)\n\t{\n\t\tlet c = a[wrongIdx];\n\t\ta[wrongIdx] = b[maxIdx];\n\t\tb[maxIdx] = c;\n\t}\nfunction getSortedArray(arr1, arr2, n)\n\t{\n\t\tif (swapElement(arr1, arr2, n))\n\t\t{\n\t\t\tfor (let i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tdocument.write(arr1[i] + \" \");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.write(\"Not Possible\");\n\t\t}\n\t}", "4052": "function costToBalance( s)\n\t{\n\t\tif (s.length == 0)\n\t\t\tdocument.write(0);\n\t\tvar ans = 0;\n\t\tvar o = 0, c = 0;\n\t\tfor (var i = 0; i < s.length; i++)\n\t\t{\n\t\t\tif (s[i] == '(')\n\t\t\t\to++;\n\t\t\tif (s[i] == ')')\n\t\t\t\tc++;\n\t\t}\n\t\tif (o != c)\n\t\t\treturn -1;\n\t\tvar a = new Array(s.Length);\n\t\tif (s[0] == '(')\n\t\t\ta[0] = 1;\n\t\telse\n\t\t\ta[0] = -1;\n\t\tif (a[0] < 0)\n\t\t\tans += Math.abs(a[0]);\n\t\tfor (var i = 1; i < s.length; i++)\n\t\t{\n\t\t\tif (s[i] == '(')\n\t\t\t\ta[i] = a[i - 1] + 1;\n\t\t\telse\n\t\t\t\ta[i] = a[i - 1] - 1;\n\t\t\tif (a[i] < 0)\n\t\t\t\tans += Math.abs(a[i]);\n\t\t}\n\t\treturn ans;\n\t}", "4079": "function middleOfThree($a, $b, $c)\n{\n\tif ((a < b && b < c) || (c < b && b < a))\n\treturn b;\n\telse if ((b < a && a < c) || (c < a && a < b))\n\treturn a;\n\telse\n\treturn c;\n}", "4080": "function middleOfThree(a, b, c)\n\t{\n\t\tif (a > b)\n\t\t{\n\t\t\tif (b > c)\n\t\t\t\treturn b;\n\t\t\telse if (a > c)\n\t\t\t\treturn c;\n\t\t\telse\n\t\t\t\treturn a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a > c)\n\t\t\t\treturn a;\n\t\t\telse if (b > c)\n\t\t\t\treturn c;\n\t\t\telse\n\t\t\t\treturn b;\n\t\t}\n\t}", "4081": "function middleOfThree(a, b, c)\n\t{\n\t\tlet x = a - b;\nlet y = b - c; \nlet z = a - c; \n\t\tif (x * y > 0)\n\t\t\treturn b;\n\t\telse if (x * z > 0)\n\t\t\treturn c;\n\t\telse\n\t\t\treturn a;\n\t}", "4099": "function missing4(arr)\n{\n\tlet helper =[];\n\tfor(let i = 0; i < 4; i++)\n\t{\n\t\thelper[i] = 0;\n\t}\n\tfor(let i = 0; i < arr.length; i++)\n\t{\n\t\tlet temp = Math.abs(arr[i]);\n\t\tif (temp <= arr.length)\n\t\t\tarr[temp - 1] = Math.floor(arr[temp - 1] * (-1));\n\t\telse if (temp > arr.length)\n\t\t{\n\t\t\tif (temp % arr.length != 0)\n\t\t\t\thelper[temp % arr.length - 1] = -1;\n\t\t\telse\n\t\t\t\thelper[(temp % arr.length) + arr.length - 1] = -1;\n\t\t}\n\t}\n\tfor(let i = 0; i < arr.length; i++)\n\t\tif (arr[i] > 0)\n\t\t\tdocument.write(i + 1 + \" \");\t\n\tfor(let i = 0; i < helper.length; i++)\n\t\tif (helper[i] >= 0)\n\t\t\tdocument.write(arr.length + i + 1 + \" \");\t\t\n\treturn;\n}", "4129": "function lexiMiddleSmallest(K, N)\n\t{\n\t\tif (K % 2 == 0) {\n\t\t\tdocument.write(K / 2 + \" \");\n\t\t\tfor (let i = 0; i < N - 1; ++i) {\n\t\t\t\tdocument.write(K + \" \");\n\t\t\t}\n\t\t\tdocument.write(\"<br/>\");\n\t\t\treturn;\n\t\t}\n\t\tlet a = [];\n\t\tfor (let i = 0; i < N / 2; ++i) {\n\t\t\tif (a[a.length - 1] == 1) {\n\t\t\t\ta.pop(a.length - 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[a.length - 1] -= 1;\n\t\t\t\twhile (a.length < N) {\n\t\t\t\t\ta.push(K);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(let i in a) { document.write(i + \" \"); }\n\t\tdocument.write(\"<br/>\");\n\t}", "4155": "function transpose(mat,row,col)\n{\n\tlet tr = new Array(col);\n\tfor(let i=0;i<col;i++)\n\t{\n\t\ttr[i]=new Array(row);\n\t}\n\tfor(let i = 0; i < row; i++)\n\t{\n\t\tfor(let j = 0; j < col; j++)\n\t\t{\n\t\t\ttr[j][i] = mat[i][j];\n\t\t}\n\t}\n\treturn tr;\n}\nfunction RowWiseSort(B)\n{\n\tfor(let i = 0; i < B.length; i++)\n\t{\n\t\t(B[i]).sort(function(a,b){return a-b;});\n\t}\n}\nfunction sortCol(mat,n,M)\n{\n\tlet B = transpose(mat, N, M);\n\tRowWiseSort(B);\n\tmat = transpose(B, M, N);\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tfor(let j = 0; j < M; j++)\n\t\t{\n\t\t\tdocument.write(mat[i][j] + \" \");\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t}\n}", "4169": "function largestArea(N, M, H, V, h, v)\n{\n var s1 = new Set();\n var s2 = new Set();\n for (var i = 1; i <= N + 1; i++)\n\ts1.add(i);\n for (var i = 1; i <= M + 1; i++)\n\ts2.add(i);\n for (var i = 0; i < h; i++) {\n\ts1.delete(H[i]);\n }\n for (var i = 0; i < v; i++) {\n\ts2.delete(V[i]);\n }\n var list1 = Array(s1.size);\n var list2 = Array(s2.size);\n var i = 0;\n s1.forEach(element => { list1[i++] = element; });\n i = 0;\n s2.forEach(element => { list2[i++] = element; });\n list1.sort((a,b)=> a-b)\n list2.sort((a,b)=> a-b)\n var maxH = 0, p1 = 0, maxV = 0, p2 = 0;\n for (var j = 0; j < s1.size; j++) {\n\tmaxH = Math.max(maxH, list1[j] - p1);\n\tp1 = list1[j];\n }\n for (var j = 0; j < s2.size; j++) {\n\tmaxV = Math.max(maxV, list2[j] - p2);\n\tp2 = list2[j];\n }\n document.write(maxV * maxH);\n}", "4179": "function findLastElement(arr, N)\n{\n\tarr.sort();\n\tlet i = 0;\n\tfor (i = 1; i < N; i++)\n\t{\n\t\tif (arr[i] - arr[i - 1] != 0 && arr[i] - arr[i - 1] != 2)\n\t\t{\n\t\t\tdocument.write(\"-1\" + \"<br>\");\n\t\t\treturn;\n\t\t}\n\t}\n\tdocument.write(arr[N - 1] + \"<br>\");\n}", "4185": "function checkifSorted(A , B , N) {\n\t\tvar flag = false;\n\t\tfor (i = 0; i < N - 1; i++) {\n\t\t\tif (A[i] > A[i + 1]) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!flag) {\n\t\t\treturn true;\n\t\t}\n\t\tvar count = 0;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tif (B[i] == 0) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tif (B[i] == 1) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (count == 2) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "4186": "function maxDivisions(arr, N, X)\n{\n\tarr.sort();\n\tlet maxSub = 0;\n\tlet size = 0;\n\tfor (let i = 0; i < N; i++)\n\t{\n\t\tsize++;\n\t\tif (arr[i] * size >= X)\n\t\t{\n\t\t\tmaxSub++;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\tdocument.write(maxSub + \"<br/>\");\n}", "4194": "function maxPossibleSum(arr, N)\n\t{\n\t\tarr.sort();\n\t\tlet sum = 0;\n\t\tlet j = N - 3;\n\t\twhile (j >= 0) {\n\t\t\tsum += arr[j];\n\t\t\tj -= 3;\n\t\t}\n\t\tdocument.write(sum);\n\t}", "4197": "function minSteps( A, B,M, N)\n{\n\tif (A[0] > B[0])\n\treturn 0;\n\tif (B[0] > A[0])\n\t{\n\t\treturn 1;\n\t}\n\tif (M <= N && A[0] == B[0] && count(A, A[0]) == M\n\t\t&& count(B, B[0]) == N)\n\t\treturn -1;\n\tfor (var i = 1; i < N; i++)\n\t{\n\t\tif (B[i] > B[0])\n\t\t\treturn 1;\n\t}\n\tfor (var i = 1; i < M; i++)\n\t{\n\t\tif (A[i] < A[0])\n\t\t\treturn 1;\n\t}\n\tfor (var i = 1; i < M; i++)\n\t{\n\t\tif (A[i] > A[0])\n\t\t{\n\t\t\tswap(A, i, B, 0);\n\t\t\tswap(A, 0, B, 0);\n\t\t\treturn 2;\n\t\t}\n\t}\n\tfor (var i = 1; i < N; i++)\n\t{\n\t\tif (B[i] < B[0])\n\t\t{\n\t\t\tswap(A, 0, B, i);\n\t\t\tswap(A, 0, B, 0);\n\t\t\treturn 2;\n\t\t}\n\t}\n\treturn 0;\n}\nfunction count(a, c)\n{\n\tcount = 0;\n\tfor(var i = 0; i < a.length; i++)\n\t\tif(a[i] == c)\n\t\t\tcount++; \n\treturn count; \n}\nfunction swap(s1, index1, s2, index2)\n{\n\tvar c = s1[index1];\n\ts1[index1] = s2[index2];\n\ts2[index2] = c;\n}", "4209": "function CountMaximum(arr, n, k)\n\t{\n\t\tarr.sort();\n\t\tlet sum = 0, count = 0;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tsum += arr[i];\n\t\t\tif (sum > k)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "4210": "function CountMaximum(arr, n, k)\n\t{\n\t\tarr.sort(function(a, b){return a - b});\n\t\tlet sum = 0, count = 0;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tsum += arr[i];\n\t\t\tif (sum > k)\n\t\t\t\tbreak;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "4219": "function insertionSort(arr,n)\n{\n\tlet i, key, j;\n\tfor (i = 1; i < n; i++)\n\t{\n\t\tkey = arr[i];\n\t\tj = i - 1;\n\t\twhile (j >= 0 && arr[j] > key)\n\t\t{\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\tarr[j + 1] = key;\n\t}\n}\nfunction printArray(arr,n)\n{\n\tlet i;\n\tfor (i = 0; i < n; i++) {\n\t\tdocument.write(arr[i] + \" \");\n\t}\n\tdocument.write(\"<br>\");\n}", "4220": "function selectionSort(arr, n)\n{\n\tlet i, j, min_idx;\n\tfor(i = 0; i < n - 1; i++)\n\t{\n\t\tmin_idx = i;\n\t\tfor(j = i + 1; j < n; j++)\n\t\t\tif (arr[j] < arr[min_idx])\n\t\t\t\tmin_idx = j;\n\t\tlet temp = arr[min_idx];\n\t\tarr[min_idx]= arr[i];\n\t\tarr[i] = temp;\n\t}\n}\nfunction printArray(arr, size)\n{\n\tlet i;\n\tfor(i = 0; i < size; i++)\n\t{\n\t\tdocument.write(arr[i] + \" \");\n\t}\n\tdocument.write(\"<br>\");\n}", "4237": "function getPairs(arr, N, K)\n{\n\tlet count = 0;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tfor(let j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (arr[i] > K * arr[i + 1])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tdocument.write(count);\n}", "4238": "function merge(arr, temp, l, m, r, K)\n{\n\tlet i = l;\n\tlet j = m + 1;\n\tlet cnt = 0;\n\tfor(i = l; i <= m; i++)\n\t{\n\t\tlet found = false;\n\t\twhile (j <= r)\n\t\t{\n\t\t\tif (arr[i] >= K * arr[j])\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\t\tj++;\n\t\t}\n\t\tif (found == true)\n\t\t{\n\t\t\tcnt += j - (m + 1);\n\t\t\tj--;\n\t\t}\n\t}\n\tlet k = l;\n\ti = l;\n\tj = m + 1;\n\twhile (i <= m && j <= r)\n\t{\n\t\tif (arr[i] <= arr[j])\n\t\t\ttemp[k++] = arr[i++];\n\t\telse\n\t\t\ttemp[k++] = arr[j++];\n\t}\n\twhile (i <= m)\n\t\ttemp[k++] = arr[i++];\n\twhile (j <= r)\n\t\ttemp[k++] = arr[j++];\n\tfor(i = l; i <= r; i++)\n\t\tarr[i] = temp[i];\n\treturn cnt;\n}\nfunction mergeSortUtil(arr, temp, l, r, K)\n{\n\tlet cnt = 0;\n\tif (l < r)\n\t{\n\t\tlet m = parseInt((l + r) / 2, 10);\n\t\tcnt += mergeSortUtil(arr, temp, l, m, K);\n\t\tcnt += mergeSortUtil(arr, temp, m + 1, r, K);\n\t\tcnt += merge(arr, temp, l, m, r, K);\n\t}\n\treturn cnt;\n}\nfunction mergeSort(arr, N, K)\n{\n\tlet temp = new Array(N);\n\tdocument.write(mergeSortUtil( arr, temp, 0, N - 1, K));\n}", "4249": "function minRemovals(A, N)\n\t{\n\t\tA.sort();\n\t\tlet mx = A[N - 1];\n\t\tlet sum = 1;\n\t\tfor (let i = 0; i < N; i++)\n\t\t{\n\t\t\tsum += A[i];\n\t\t}\n\t\tif (sum - mx >= mx) {\n\t\t\tdocument.write(0);\n\t\t}\n\t\telse {\n\t\t\tdocument.write(2 * mx - sum);\n\t\t}\n\t}", "4250": "function rearrangeArray(a, n)\n{\n\ta.sort();\n\tfor(let i = 0; i < n - 1; i++)\n\t{\n\t\tif (a[i] == i + 1)\n\t\t{\n\t\t\tlet temp = a[i];\n\t\t\ta[i] = a[i + 1];\n\t\t\ta[i + 1] = temp;\n\t\t}\n\t}\n\tif (a[n - 1] == n)\n\t{\n\t\tlet temp = a[n - 1];\n\t\ta[n - 1] = a[n - 2];\n\t\ta[n - 2] = temp;\n\t}\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tdocument.write(a[i] + \" \");\n\t}\n}", "4256": "function checkStr1CanConStr2(str1, str2)\n{\n\tvar N = str1.length;\n\tvar M = str2.length;\n\tvar st1 = new Set();\n\tvar st2 = new Set();\n\tvar hash1 = Array(256).fill(0);\n\tfor (var i = 0; i < N; i++) {\n\t\thash1[str1[i].charCodeAt(0)]++;\n\t}\n\tfor (var i = 0; i < N; i++) {\n\t\tst1.add(str1[i]);\n\t}\n\tfor (var i = 0; i < M; i++) {\n\t\tst2.add(str2[i]);\n\t}\n\tif (st1.size != st2.size) {\n\t\treturn false;\n\t}\n\tvar hash2 = Array(256).fill(0);\n\tfor (var i = 0; i < M; i++) {\n\t\thash2[str2[i].charCodeAt(0)]++;\n\t}\n\thash1.sort((a,b)=>a-b);\n\t\thash2.sort((a,b)=>a-b);\n\tfor (var i = 0; i < 256; i++) {\n\t\tif (hash1[i] != hash2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "4305": "function minOperations(arr1, arr2, i, j, n)\n{\n\tlet f = 0;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tif (arr1[i] != arr2[i])\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif (f == 0)\n\t\treturn 0;\n\tif (i >= n j >= n)\n\t\treturn 0;\n\tif (arr1[i] < arr2[j])\n\t\treturn 1 + minOperations(arr1, arr2, i + 1, j + 1, n);\n\treturn Math.max(minOperations(arr1, arr2, i, j + 1, n),\n\t\t\t\t\tminOperations(arr1, arr2, i + 1, j, n));\n}\nfunction minOperationsUtil(arr, n)\n{\n\tlet brr = new Array(n);\n\tfor(let i = 0; i < n; i++)\n\t\tbrr[i] = arr[i];\n\tbrr.sort();\n\tlet f = 0;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] != brr[i])\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif (f == 1)\n\t\tdocument.write(minOperations(arr, brr, 0, 0, n));\n\telse\n\t\tcout << \"0\";\n}", "4310": "function canTransform(s, t)\n{\n\tvar n = s.length;\n\tvar occur = Array.from(Array(26), ()=>new Array());\n\tfor (var x = 0; x < n; x++) {\n\t\tvar ch = s[x].charCodeAt(0) - 'a'.charCodeAt(0);\n\t\toccur[ch].push(x);\n\t}\n\tvar idx = Array(26).fill(0);\n\tvar poss = true;\n\tfor (var x = 0; x < n; x++) {\n\t\tvar ch = t[x].charCodeAt(0) - 'a'.charCodeAt(0);\n\t\tif (idx[ch] >= occur[ch].length) {\n\t\t\tposs = false;\n\t\t\tbreak;\n\t\t}\n\t\tfor (var small = 0; small < ch; small++) {\n\t\t\tif (idx[small] < occur[small].length && occur[small][idx[small]] < occur[ch][idx[ch]]) {\n\t\t\t\tposs = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tidx[ch]++;\n\t}\n\tif (poss) {\n\t\tdocument.write( \"Yes\" );\n\t}\n\telse {\n\t\tdocument.write( \"No\" );\n\t}\n}", "4326": "function getMaxSum(i, j, k, arr1, arr2, arr3)\n{\n\tvar cnt = 0;\n\tif (i >= n1)\n\t\tcnt++;\n\tif (j >= n2)\n\t\tcnt++;\n\tif (k >= n3)\n\t\tcnt++;\n\tif (cnt >= 2)\n\t\treturn 0;\n\tif (dp[i][j][k] != -1)\n\t\treturn dp[i][j][k];\n\tvar ans = 0;\n\tif (i < n1 && j < n2)\n\t\tans = Math.max(ans,\n\t\t\t\tgetMaxSum(i + 1, j + 1, k, arr1, arr2, arr3) + arr1[i] * arr2[j]);\n\tif (i < n1 && k < n3)\n\t\tans = Math.max(ans,\n\t\t\t\tgetMaxSum(i + 1, j, k + 1, arr1, arr2, arr3) + arr1[i] * arr3[k]);\n\tif (j < n2 && k < n3)\n\t\tans = Math.max(ans,\n\t\t\t\tgetMaxSum(i, j + 1, k + 1, arr1, arr2, arr3) + arr2[j] * arr3[k]);\n\tdp[i][j][k] = ans;\n\treturn dp[i][j][k];\n}\nfunction maxProductSum(arr1, arr2, arr3)\n{\n\tarr1.sort();\n\tarr1.reverse();\n\tarr2.sort();\n\tarr2.reverse();\n\tarr3.sort();\n\tarr3.reverse();\n\treturn getMaxSum(0, 0, 0, arr1, arr2, arr3);\n}", "4347": "function findTriplet(arr, N) {\n\t\tarr.sort((a, b) => a - b);\n\t\tvar flag = 0,\n\t\ti;\n\t\tfor (i = N - 1; i - 2 >= 0; i--) {\n\t\tif (arr[i - 2] + arr[i - 1] > arr[i]) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tif (flag) {\n\t\tdocument.write( arr[i - 2] + \" \" + arr[i - 1] + \" \" + arr[i] + \"<br>\" );\n\t\t}\n\t\telse {\n\t\tdocument.write(-1 + \"<br>\");\n\t\t}\n\t}", "4354": "function inversionCount(s)\n{\n\tvar freq = Array(26).fill(0);\n\tvar inv = 0;\n\tfor(var i = 0; i < s.length; i++)\n\t{\n\t\tvar temp = 0;\n\t\tfor(var j = 0;\n\t\t\t\tj < String.fromCharCode(\n\t\t\t\t\ts[i].charCodeAt(0) -\n\t\t\t\t\t'a'.charCodeAt(0)); j++)\n\t\t\ttemp += freq[j];\n\t\tinv += (i - temp);\n\t\tfreq[s[i] - 'a']++;\n\t}\n\treturn inv;\n}\nfunction haveRepeated(S1, S2)\n{\n\tvar freq = Array(26).fill(0);\n\tS1.forEach(i => {\n\t\tif (freq[i - 'a'] > 0) return true; freq[i - 'a']++; });\n\tfor(var i = 0; i < 26; i++)\n\t\tfreq[i] = 0;\n\tS2.split('').forEach(i => {\n\t\tif (freq[i - 'a'] > 0) return true; freq[i - 'a']++; });\n\treturn false;\n}\nfunction checkToMakeEqual(S1, S2)\n{\n\tvar freq = Array(26).fill(0);\n\tfor(var i = 0; i < S1.length; i++)\n\t{\n\t\tfreq[S1[i] - 'a']++;\n\t}\n\tvar flag = 0;\n\tfor(var i = 0; i < S2.length; i++)\n\t{\n\t\tif (freq[S2[i] - 'a'] == 0)\n\t\t{\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t\tfreq[S2[i] - 'a']--;\n\t}\n\tif (flag == true)\n\t{\n\t\tdocument.write(\"No<br>\");\n\t\treturn;\n\t}\n\tvar invCount1 = inversionCount(S1);\n\tvar invCount2 = inversionCount(S2);\n\tif (invCount1 == invCount2 ||\n\t(invCount1 & 1) == (invCount2 & 1) ||\n\thaveRepeated(S1, S2))\n\t{\n\t\tdocument.write(\"Yes<br>\");\n\t}\n\telse\n\t\tdocument.write(\"No<br>\");\n}", "4357": "function numberofpairs(arr, N)\n\t{\n\t\tlet answer = 0;\n\t\tarr.sort();\n\t\tlet minDiff = Number.MAX_VALUE;\n\t\tfor (let i = 0; i < N - 1; i++)\n\t\t\tminDiff = Math.min(minDiff, arr[i + 1] - arr[i]);\n\t\tfor (let i = 0; i < N - 1; i++) {\n\t\t\tif (arr[i + 1] - arr[i] == minDiff)\n\t\t\t\tanswer++;\n\t\t}\n\t\treturn answer;\n\t}", "4360": "function sortArr(a,n)\n{\n\tlet i, k;\n\tk = parseInt(Math.log(n) / Math.log(2));\n\tk = parseInt( Math.pow(2, k));\n\twhile (k > 0)\n\t{\n\t\tfor(i = 0; i + k < n; i++)\n\t\t\tif (a[i] > a[i + k])\n\t\t\t{\n\t\t\t\tlet tmp = a[i];\n\t\t\t\ta[i] = a[i + k];\n\t\t\t\ta[i + k] = tmp;\n\t\t\t}\n\t\tk = k / 2;\n\t}\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tdocument.write(a[i] + \" \");\n\t}\n}", "4362": "function maximumSum(arr, n, k)\n{\n\tlet elt = (n / k);\n\tlet sum = 0;\n\tarr.sort((a, b) => a - b);\n\tlet count = 0;\n\tlet i = n - 1;\n\twhile (count < k)\n\t{\n\t\tsum += arr[i];\n\t\ti--;\n\t\tcount++;\n\t}\n\tcount = 0;\n\ti = 0;\n\twhile (count < k)\n\t{\n\t\tsum += arr[i];\n\t\ti += elt - 1;\n\t\tcount++;\n\t}\n\tdocument.write(sum);\n}", "4369": "function findMinSum(arr, K, L, size)\n{\n\tif (K * L > size)\n\t\treturn -1;\n\tlet minsum = 0;\n\tarr.sort((a, b) => a - b);\n\tfor(let i = 0; i < K; i++)\n\t\tminsum += arr[i];\n\treturn minsum;\n}", "4371": "function find_max_length(arr,index,sum,k)\n{\n\tsum = sum + arr[index];\n\tstore.push(arr[index]);\n\tif (sum == k)\n\t{\n\t\tif (max_length < store.length)\n\t\t{\n\t\t\tmax_length = store.length;\n\t\t\tans = store;\n\t\t}\n\t}\n\tfor (let i = index + 1; i < arr.length; i++)\n\t{\n\t\tif (sum + arr[i] <= k)\n\t\t{\n\t\t\tfind_max_length(arr, i, sum, k);\n\t\t\tstore.pop();\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\treturn;\n}\nfunction longestSubsequence(arr, n, k)\n{\n\tarr.sort(function(a,b){return a-b;});\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tif (max_length >= n - i)\n\t\t\tbreak;\n\t\tstore=[];\n\t\tfind_max_length(arr, i, 0, k);\n\t}\n\treturn max_length;\n}", "4378": "function findKthSmallest(arr, n, k)\n\t{\n\t\tlet max = 0;\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tif (arr[i] > max)\n\t\t\t\tmax = arr[i];\n\t\t}\n\t\tlet counter = Array.from({length: max + 1}, (_, i) => 0);\n\t\tlet smallest = 0;\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tcounter[arr[i]]++;\n\t\t}\n\t\tfor (let num = 1; num <= max; num++)\n\t\t{\n\t\t\tif (counter[num] > 0)\n\t\t\t{\n\t\t\t\tsmallest += counter[num];\n\t\t\t}\n\t\t\tif (smallest >= k)\n\t\t\t{\n\t\t\t\treturn num;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "4385": "function lexNumbers(n)\n{\n\tlet s = [];\n\tfor (let i = 1; i <= n; i++)\n\t{\n\t\ts.push(i.toString());\n\t}\n\ts.sort();\n\tlet ans = [];\n\tfor (let i = 0; i < n; i++)\n\t\tans.push(parseInt(s[i]));\n\tfor (let i = 0; i < n; i++)\n\t\tdocument.write(ans[i] + \" \");\n}", "4386": "function lexNumbers(n)\n{\n\tvar sol = [];\n\tdfs(1, n, sol);\n\tdocument.write(\"[\"+ sol[0]);\n\tfor (var i = 1; i < sol.length; i++)\n\tdocument.write(\", \"+ sol[i]); document.write(\"]\");\n}\nfunction dfs(temp, n, sol)\n{\n\tif (temp > n)\n\t\treturn;\n\tsol.push(temp);\n\tdfs(temp * 10, n, sol);\n\tif (temp % 10 != 9)\n\t\tdfs(temp + 1, n, sol);\n}", "4392": "function func(a)\n{\n\tfor (let i = 0; i < N; i++) {\n\t\tif (i % 2 == 0) {\n\t\t\tfor (let j = 0; j < N; j++) {\n\t\t\t\tfor (let k = j + 1; k < N; ++k) {\n\t\t\t\t\tif (a[i][j] > a[i][k]) {\n\t\t\t\t\t\tlet temp = a[i][j];\n\t\t\t\t\t\ta[i][j] = a[i][k];\n\t\t\t\t\t\ta[i][k] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (let j = 0; j < N; j++) {\n\t\t\t\tfor (let k = j + 1; k < N; ++k) {\n\t\t\t\t\tif (a[i][j] < a[i][k]) {\n\t\t\t\t\t\tlet temp = a[i][j];\n\t\t\t\t\t\ta[i][j] = a[i][k];\n\t\t\t\t\t\ta[i][k] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (let i = 0; i < N; i++) {\n\t\tfor (let j = 0; j < N; j++) {\n\t\t\tdocument.write(\" \" + a[i][j]);\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t}\n}", "4400": "function partition(arr, l, h)\n{\n\tlet pivot = arr[l];\n\tlet i = l + 1;\n\tlet j = h;\n\twhile (i <= j)\n\t{\n\t\twhile (i <= h && arr[i] < pivot)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\twhile (j > l && arr[j] > pivot)\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\tif (i < j)\n\t\t{\n\t\t\tlet temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[l] = arr[j];\n\tarr[j] = pivot;\n\treturn j;\n}\nfunction sortArray(arr, l, h)\n{\n\tif (l >= h)\n\t\treturn;\n\tlet pivot = partition(arr, l, h);\n\tsortArray(arr, l, pivot - 1);\n\tsortArray(arr, pivot + 1, h);\n}\nfunction findMaxIntervals(start, end, n, R)\n{\n\tlet ans = 0;\n\tlet prev = 0;\n\tlet currActive = 0;\n\tlet i = 0;\n\tlet j = 0;\n\tif (start[0] > 0)\n\t\tans++;\n\twhile (i < n && j < n)\n\t{\n\t\tif (start[i] < end[j])\n\t\t{\n\t\t\ti++;\n\t\t\tcurrActive++;\n\t\t}\n\t\telse if (start[i] > end[j])\n\t\t{\n\t\t\tj++;\n\t\t\tcurrActive--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tif (currActive == 0)\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\tif (end[n - 1] < R)\n\t\tans++;\n\treturn ans;\n}", "4401": "function sortArray(A, N)\n{\n\tlet x = 0, y = 0, z = 0;\n\tif (N % 4 == 0 N % 4 == 1)\n\t{\n\t\tfor(let i = 0; i < N / 2; i++)\n\t\t{\n\t\tx = i;\n\t\tif (i % 2 == 0)\n\t\t{\n\t\t\ty = N - i - 2;\n\t\t\tz = N - i - 1;\n\t\t}\n\t\tA[z] = A[y];\n\t\tA[y] = A[x];\n\t\tA[x] = x + 1;\n\t\t}\n\t\tdocument.write(\"Sorted Array: \");\n\t\tfor(let i = 0; i < N; i++)\n\t\tdocument.write(A[i] + \" \");\n\t}\n\telse\n\t{\n\t\tdocument.write(\"-1\");\n\t}\n}", "4412": "function dfs(x)\n{\n\tlet v = [];\n\tfor(let it of s.values())\n\t{\n\t\tif (g[x].get(it) != null)\n\t\t{\n\t\t\tv.push(it);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tns.add(it);\n\t\t}\n\t}\n\ts = ns;\n\tfor(let i of v.values())\n\t{\n\t\tdfs(i);\n\t}\n}\nfunction weightOfMST(N)\n{\n\tlet cnt = 0;\n\tfor(let i = 1; i <= N; ++i)\n\t{\n\t\ts.add(i);\n\t}\n\tlet qt = []\n\tfor(let t of s.values())\n\t\tqt.push(t);\n\twhile (qt.length != 0)\n\t{\n\t\t++cnt;\n\t\tlet t = qt[0];\n\t\tqt.shift();\n\t\tdfs(t);\n\t}\n\tdocument.write(cnt - 4);\n}", "4420": "function countPairs(A, B)\n{\n\tlet n = A.length;\n\tlet ans = 0;\n\tA.sort();\n\tB.sort();\n\tfor(let i = 0; i < n; i++)\n\t{\n\tif (A[i] > B[ans])\n\t{\n\t\tans++;\n\t}\n\t}\n\treturn ans;\n}", "4455": "function compare(arr1,arr2)\n{\n\tfor(let i = 0; i < 256; i++)\n\t\tif (arr1[i] != arr2[i])\n\t\t\treturn false;\n\treturn true;\n}\nfunction search(pat,txt)\n{\n\tlet M = pat.length;\n\tlet N = txt.length;\n\tlet countP = new Array(256);\n\tlet countTW = new Array(256);\n\tfor(let i = 0; i < 256; i++)\n\t{\n\t\tcountP[i] = 0;\n\t\tcountTW[i] = 0;\n\t}\n\tfor(let i = 0; i < 256; i++)\n\t{\n\t\tcountP[i] = 0;\n\t\tcountTW[i] = 0;\n\t}\n\tfor(let i = 0; i < M; i++)\n\t{\n\t\t(countP[pat[i].charCodeAt(0)])++;\n\t\t(countTW[txt[i].charCodeAt(0)])++;\n\t}\n\tfor(let i = M; i < N; i++)\n\t{\n\t\tif (compare(countP, countTW))\n\t\t\treturn true;\n\t\t(countTW[txt[i].charCodeAt(0)])++;\n\t\tcountTW[txt[i - M].charCodeAt(0)]--;\n\t}\n\tif (compare(countP, countTW))\n\t\treturn true;\n\t\treturn false;\n}", "4459": "function findK(arr, size, N)\n\t{\n\t\tarr.sort(function(a, b){return a - b});\n\t\tlet temp_sum = 0;\n\t\tfor (let i = 0; i < size; i++)\n\t\t{\n\t\t\ttemp_sum += arr[i];\n\t\t\tif (N - temp_sum == arr[i] * (size - i - 1))\n\t\t\t{\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "4460": "function minimumSwaps(arr)\n{\n\tlet count = 0;\n\tlet i = 0;\n\twhile (i < arr.length)\n\t{\n\t\tif (arr[i] != i + 1)\n\t\t{\n\t\t\twhile (arr[i] != i + 1)\n\t\t\t{\n\t\t\t\tlet temp = 0;\n\t\t\t\ttemp = arr[arr[i] - 1];\n\t\t\t\tarr[arr[i] - 1] = arr[i];\n\t\t\t\tarr[i] = temp;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn count;\n}", "4482": "function maxMod(arr, n) {\n\tlet maxVal = arr.sort((a, b) => b - a)[0]\n\tlet secondMax = 0;\n\tfor (let i = 0; i < n; i++) {\n\t\tif (arr[i] < maxVal && arr[i] > secondMax) {\n\t\t\tsecondMax = arr[i];\n\t\t}\n\t}\n\treturn secondMax;\n}", "4493": "function isPossible(A , B , n, m , x , y)\n{\n\tif (x > n y > m)\n\t\treturn false;\n\tA.sort();\n\tB.sort();\n\tif (A[x - 1] < B[m - y])\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "4507": "function Min_Replace(arr, n, k)\n{\n\tarr.sort((a,b)=>a-b)\n\tvar freq = Array(MAX).fill(0);\n\tvar p = 0;\n\tfreq[p] = 1;\n\tfor (var i = 1; i < n; i++) {\n\t\tif (arr[i] == arr[i - 1])\n\t\t\t++freq[p];\n\t\telse\n\t\t\t++freq[++p];\n\t}\n\tfreq.sort((a,b)=>b-a);\n\tvar ans = 0;\n\tfor (var i = k; i <= p; i++)\n\t\tans += freq[i];\n\treturn ans;\n}", "4508": "function append( head_ref , new_data)\n\t{\n\t\tnew_node = new Node();\n\t\tlast = head_ref;\n\t\tnew_node.data = new_data;\n\t\tnew_node.next = null;\n\t\tif (head_ref == null) {\n\t\t\tnew_node.prev = null;\n\t\t\thead_ref = new_node;\n\t\t\treturn head_ref;\n\t\t}\n\t\twhile (last.next != null)\n\t\t\tlast = last.next;\n\t\tlast.next = new_node;\n\t\tnew_node.prev = last;\n\t\treturn head_ref;\n\t}\nfunction printList( node) {\n\t\tlast;\n\t\twhile (node != null) {\n\t\t\tdocument.write(node.data + \" \");\n\t\t\tlast = node;\n\t\t\tnode = node.next;\n\t\t}\n\t}\nfunction mergeList( p, q) {\n\t\ts = null;\n\t\tif (p == null q == null) {\n\t\t\treturn (p == null ? q : p);\n\t\t}\n\t\tif (p.data < q.data) {\n\t\t\tp.prev = s;\n\t\t\ts = p;\n\t\t\tp = p.next;\n\t\t} else {\n\t\t\tq.prev = s;\n\t\t\ts = q;\n\t\t\tq = q.next;\n\t\t}\n\t\thead = s;\n\t\twhile (p != null && q != null) {\n\t\t\tif (p.data < q.data) {\n\t\t\t\ts.next = p;\n\t\t\t\tp.prev = s;\n\t\t\t\ts = s.next;\n\t\t\t\tp = p.next;\n\t\t\t} else {\n\t\t\t\ts.next = q;\n\t\t\t\tq.prev = s;\n\t\t\t\ts = s.next;\n\t\t\t\tq = q.next;\n\t\t\t}\n\t\t}\n\t\tif (p == null) {\n\t\t\ts.next = q;\n\t\t\tq.prev = s;\n\t\t}\n\t\tif (q == null) {\n\t\t\ts.next = p;\n\t\t\tp.prev = s;\n\t\t}\n\t\treturn head;\n\t}\nfunction mergeAllList( head , k) {\n\t\tfinalList = null;\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tfinalList = mergeList(finalList, head[i]);\n\t\t}\n\t\treturn finalList;\n\t}", "4510": "function Segment(x, l, n) {\n\tif (n == 1)\n\t\treturn 1;\n\tlet ans = 2;\n\tfor (let i = 1; i < n - 1; i++) {\n\t\tif (x[i] - l[i] > x[i - 1])\n\t\t\tans++;\n\t\telse if (x[i] + l[i] < x[i + 1]) {\n\t\t\tx[i] = x[i] + l[i];\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "4529": "function existsTriplet(a, b, c, x, l1, l2, l3)\n{\n\tif (l2 <= l1 && l2 <= l3)\n\t{\n\t\ttemp = l1; l1 = l2; l2 = temp;\n\t\ttemp = a; a = b; b = temp;\n\t}\n\telse if (l3 <= l1 && l3 <= l2)\n\t{\n\t\ttemp = l1; l1 = l3; l3 = temp;\n\t\ttemp = a; a = c; c = temp;\n\t}\n\tfor (var i = 0; i < l1; i++) {\n\t\tvar j = 0, k = l3 - 1;\n\t\twhile (j < l2 && k >= 0) {\n\t\t\tif (a[i] + b[j] + c[k] == x)\n\t\t\t\treturn true;\n\t\t\tif (a[i] + b[j] + c[k] < x)\n\t\t\t\tj++;\n\t\t\telse\n\t\t\t\tk--;\n\t\t}\n\t}\n\treturn false;\n}", "4570": "function MinimizeleftOverSum(a , n)\n{\n var v1 = [], v2 =[];\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (a[i] % 2 == 1)\n\t\t\tv1.push(a[i]);\n\t\telse\n\t\t\tv2.push(a[i]);\n\t}\n\tif (v1.length > v2.length)\n\t{\n\t\tv1.sort();\n\t\tv2.sort();\n\t\tvar x = v1.length - v2.length - 1;\n\t\tvar sum = 0;\n\t\tvar i = 0;\n\t\twhile (i < x)\n\t\t{\n\t\t\tsum += v1[i++];\n\t\t}\n\t\treturn sum;\n\t}\n\telse if (v2.length > v1.length)\n\t{\n\t\tv1.sort();\n\t\tv2.sort();\n\t\tvar x = v2.length - v1.length - 1;\n\t\tvar sum = 0;\n\t\tvar i = 0;\n\t\twhile (i < x)\n\t\t{\n\t\t\tsum += v2[i++];\n\t\t}\n\t\treturn sum;\n\t}\n\telse\n\t\treturn 0;\n}", "4578": "function printArr(arr,n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tdocument.write(arr[i]);\n\t}\nfunction compare(num1,num2)\n\t{\n\t\tlet A = num1.toString();\n\t\tlet B = num2.toString();\n\t\treturn (A + B).localeCompare(B + A);\n\t}\nfunction printSmallest(N,arr)\n\t{\n\t\tfor (let i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (let j = i + 1; j < N; j++)\n\t\t\t{\n\t\t\t\tif (compare(arr[i], arr[j]) > 0)\n\t\t\t\t{\n\t\t\t\t\tlet temp = arr[i];\n\t\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\tarr[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintArr(arr,N);\n\t}", "4585": "function getMaxMedian(arr, n, k) {\n\tlet size = n + k;\n\tarr.sort((a, b) => a - b);\n\tif (size % 2 == 0) {\n\t\tlet median = (arr[Math.floor(size / 2) - 1] +\n\t\tarr[Math.floor(size / 2)]) / 2;\n\t\treturn median;\n\t}\n\tlet median = arr[Math.floor(size / 2)];\n\treturn median;\n}", "4591": "function minOperation(S, N, K)\n{\n\tif (N % K) {\n\t\tdocument.write( \"Not Possible\" );\n\t\treturn;\n\t}\n\tvar count = Array(26).fill(0);\n\tfor (var i = 0; i < N; i++) {\n\t\tcount[S[i].charCodeAt(0) - 97]++;\n\t}\n\tvar E = N / K;\n\tvar greaterE = [];\n\tvar lessE = [];\n\tfor (var i = 0; i < 26; i++) {\n\t\tif (count[i] < E)\n\t\t\tlessE.push(E - count[i]);\n\t\telse\n\t\t\tgreaterE.push(count[i] - E);\n\t}\n\tgreaterE.sort();\n\tlessE.sort();\n\tvar mi = 1000000000;\n\tfor (var i = 0; i <= K; i++) {\n\t\tvar set1 = i;\n\t\tvar set2 = K - i;\n\t\tif (greaterE.length >= set1 && lessE.length >= set2) {\n\t\t\tvar step1 = 0;\n\t\t\tvar step2 = 0;\n\t\t\tfor (var j = 0; j < set1; j++)\n\t\t\t\tstep1 += greaterE[j];\n\t\t\tfor (var j = 0; j < set2; j++)\n\t\t\t\tstep2 += lessE[j];\n\t\t\tmi = Math.min(mi, Math.max(step1, step2));\n\t\t}\n\t}\n\tdocument.write( mi );\n}", "4620": "function partSort(arr, N, a, b)\n\t{\n\t\tlet l = Math.min(a, b);\n\t\tlet r = Math.max(a, b);\n\t\tlet temp = new Array(r - l + 1);\n\t\ttemp.fill(0);\n\t\tlet j = 0;\n\t\tfor (let i = l; i <= r; i++) {\n\t\t\ttemp[j] = arr[i];\n\t\t\tj++;\n\t\t}\n\t\ttemp.sort(function(a, b){return a - b});\n\t\tj = 0;\n\t\tfor (let i = l; i <= r; i++) {\n\t\t\tarr[i] = temp[j];\n\t\t\tj++;\n\t\t}\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tdocument.write(arr[i] + \" \");\n\t\t}\n\t}", "4621": "function swap(arr, xp, yp)\n{\n\tvar temp = arr[xp];\n\tarr[xp] = arr[yp];\n\tarr[yp] = temp;\n}\nfunction partSort(arr , N , a , b)\n\t{\n\t\tvar l = Math.min(a, b);\n\t\tvar r = Math.max(a, b);\n\t\tvar i, j;\n\t\tfor (i = l; i < r + 1 + 1; i++)\n\t\t{\n\t\t\tfor (j = l; j < r - i + 1; j++)\n\t\t\t{\n\t\tif (arr[j] > arr[j + 1])\n\t\t{\n\t\tswap(arr, j, j + 1);\n\t\t}\n\t}\n}\n\t\tfor (i = 0; i < N; i++)\n\t\t\tdocument.write(arr[i] + \" \");\n\t}", "4622": "function minMovesToSort(arr, n)\n{\n\tvar moves = 0;\n\tvar i, mn = arr[n - 1];\n\tfor(i = n - 2; i >= 0; i--)\n\t{\n\t\tif (arr[i] > mn)\n\t\t\tmoves += arr[i] - mn;\n\t\tmn = arr[i];\n\t}\n\treturn moves;\n}", "4624": "function sortByRow(mat,n,descending)\n\t{\n\t\tlet temp = 0;\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tif (descending == true)\n\t\t{\n\t\t\tlet t = i;\n\t\t\tfor (let p = 0; p < n; p++)\n\t\t\t{\n\t\t\t\tfor (let j = p + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (mat[t][p] < mat[t][j])\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp = mat[t][p];\n\t\t\t\t\t\tmat[t][p] = mat[t][j];\n\t\t\t\t\t\tmat[t][j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tmat[i].sort(function(a,b){return a-b;});\n\t}\n\t}\nfunction transpose(mat,n)\n\t{\n\t\tlet temp = 0;\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tfor (let j = i + 1; j < n; j++)\n\t\t{\n\t\t\ttemp = mat[i][j];\n\t\t\tmat[i][j] = mat[j][i];\n\t\t\tmat[j][i] = temp;\n\t\t}\n\t}\n\t}\nfunction sortMatRowAndColWise(mat,n)\n\t{\n\tsortByRow(mat, n, true);\n\ttranspose(mat, n);\n\tsortByRow(mat, n, false);\n\ttranspose(mat, n);\n\t}\nfunction printMat(mat,n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t{\n\t\tfor (let j = 0; j < n; j++)\n\t\t\tdocument.write(mat[i][j] + \" \");\n\t\tdocument.write(\"<br>\");\n\t}\n\t}", "4648": "function SieveOfEratosthenes( n)\n{\n\tprime[1] = false;\n\tfor (var p = 2; p * p <= n; p++) {\n\t\tif (prime[p]) {\n\t\t\tfor (var i = p * 2; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n}\nfunction sortPrimes(arr, n)\n{\n\tSieveOfEratosthenes(100005);\n\tvar v = [];\n\tfor (var i = 0; i < n; i++) {\n\t\tif (prime[arr[i]])\n\t\t\tv.push(arr[i]);\n\t}\n\tv.sort((a,b)=>b-a)\n\tvar j = 0;\n\tfor (var i = 0; i < n; i++) {\n\t\tif (prime[arr[i]])\n\t\t\tarr[i] = v[j++];\n\t}\n}", "4701": "function findOptimalPairs(arr, N)\n{\n\tarr.sort(function(a,b){ return a-b;});\n\tfor (var i = 0, j = N - 1; i <= j; i++, j--)\n\t\tdocument.write(\"(\" + arr[i] + \", \" + arr[j] + \")\" + \" \");\n}", "4740": "function stableSelectionSort(a, n)\n\t{\n\t\tfor (let i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tlet min = i;\n\t\t\tfor (let j = i + 1; j < n; j++)\n\t\t\t\tif (a[min] > a[j])\n\t\t\t\t\tmin = j;\n\t\t\tlet key = a[min];\n\t\t\twhile (min > i)\n\t\t\t{\n\t\t\t\ta[min] = a[min - 1];\n\t\t\t\tmin--;\n\t\t\t}\n\t\t\ta[i] = key;\n\t\t}\n\t}\nfunction prletArray(a, n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\tdocument.write(a[i]+ \" \");\n\t\tdocument.write(\"<br/>\");\n\t}", "4783": "function printSorted(a, b, c)\n\t{\n\t\tlet get_max = Math.max(a, Math.max(b, c));\n\t\tlet get_min = -Math.max(-a, Math.max(-b, -c));\n\t\tlet get_mid = (a + b + c) \n\t\t\t\t\t- (get_max + get_min);\n\t\tdocument.write(get_min + \" \" + get_mid + \" \" + get_max);\n\t}", "4786": "function insertionSortRecursive(arr,n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn;\n\t\tinsertionSortRecursive( arr, n-1 );\n\t\tlet last = arr[n-1];\n\t\tlet j = n-2;\n\t\twhile (j >= 0 && arr[j] > last)\n\t\t{\n\t\t\tarr[j+1] = arr[j];\n\t\t\tj--;\n\t\t}\n\t\tarr[j+1] = last;\n\t}", "4793": "function bubbleSort(arr, n)\n{\n\tif (n == 1)\n\t\treturn;\n\tfor (var i = 0; i < n - 1; i++)\n\t\tif (arr[i] > arr[i + 1])\n\t\t{\n\t\t\tvar temp = arr[i];\n\t\t\tarr[i] = arr[i + 1];\n\t\t\tarr[i + 1] = temp;\n\t\t}\n\tbubbleSort(arr, n - 1);\n}", "4804": "function isPossible(a, b, n, k)\n\t{\n\t\ta.sort(function(a, b){return a - b});\n\t\tb.reverse();\n\t\tfor (let i = 0; i < n; i++)\n\t\tif (a[i] + b[i] < k)\n\t\t\treturn false;\n\t\treturn true;\n\t}", "4817": "function countBits(a)\n\t{\n\t\tlet count = 0;\n\twhile (a > 0)\n\t{\n\t\tif ((a & 1) > 0)\n\t\t\tcount+= 1;\n\t\ta = a >> 1;\n\t}\n\treturn count;\n\t}\nfunction insertionSort(arr,aux,n)\n{\n\tfor (let i = 1; i < n; i++)\n\t{\n\t\tlet key1 = aux[i];\n\t\tlet key2 = arr[i];\n\t\tlet j = i - 1;\n\t\twhile (j >= 0 && aux[j] < key1)\n\t\t{\n\t\t\taux[j + 1] = aux[j];\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\taux[j + 1] = key1;\n\t\tarr[j + 1] = key2;\n\t}\n}\nfunction sortBySetBitCount(arr,n)\n{\n\tlet aux = new Array(n);\n\tfor (let i = 0; i < n; i++)\n\t\taux[i] = countBits(arr[i]);\n\tinsertionSort(arr, aux, n);\n}\nfunction printArr(arr,n)\n{\n\tfor (let i = 0; i < n; i++)\n\t\tdocument.write(arr[i] + \" \");\n}", "4819": "function countBits(a)\n{\n\tlet count = 0;\n while (a > 0)\n {\n\tif ((a & 1) > 0 )\n\tcount += 1;\n\ta = a >> 1;\n }\n return count;\n}\nfunction sortBySetBitCount(arr,n)\n{\nlet count = new Array(32);\n for (let i = 0; i < count.length; i++)\n\tcount[i] = [];\n let setbitcount = 0;\n for (let i = 0; i < n; i++)\n {\n\tsetbitcount = countBits(arr[i]);\n\tcount[setbitcount].push(arr[i]);\n }\n let j = 0;\n for (let i = 31; i >= 0; i--)\n {\n\tlet v1 = count[i];\n\tfor (let p = 0; p < v1.length; p++)\n\tarr[j++] = v1[p];\n }\n}\nfunction printArr(arr,n)\n{\n\tfor (let i = 0; i < n; i++)\n\t\tdocument.write(arr[i] + \" \");\n}", "4847": "function binarySearch( a, item, low, high)\n{\n\twhile (low <= high) {\n\t\tvar mid = low + (high - low) / 2;\n\t\tif (item == a[mid])\n\t\t\treturn mid + 1;\n\t\telse if (item > a[mid])\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn low;\n}\nfunction insertionSort(a, n)\n{\n\tvar i, loc, j, k, selected;\n\tfor (i = 1; i < n; ++i) {\n\t\tj = i - 1;\n\t\tselected = a[i];\n\t\tloc = binarySearch(a, selected, 0, j);\n\t\twhile (j >= loc) {\n\t\t\ta[j + 1] = a[j];\n\t\t\tj--;\n\t\t}\n\t\ta[j + 1] = selected;\n\t}\n}", "4855": "function insertionSort(arr, n) \n{ \n\tlet i, key, j; \n\tfor (i = 1; i < n; i++)\n\t{ \n\t\tkey = arr[i]; \n\t\tj = i - 1; \n\t\twhile (j >= 0 && arr[j] > key)\n\t\t{ \n\t\t\tarr[j + 1] = arr[j]; \n\t\t\tj = j - 1; \n\t\t} \n\t\tarr[j + 1] = key; \n\t} \n}\nfunction printArray(arr, n) \n{ \n\tlet i; \n\tfor (i = 0; i < n; i++) \n\t\tdocument.write(arr[i] + \" \"); \n\tdocument.write(\"<br>\");\n}", "4859": "", "4889": "function generateString(k1, k2, s)\n\t\t{\n\t\t\tlet C1s = 0, C0s = 0;\n\t\t\tlet flag = 0;\n\t\t\tlet pos = [];\n\t\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\t\tif (s[i] == '0') {\n\t\t\t\t\tC0s++;\n\t\t\t\t\tif ((i + 1) % k1 != 0\n\t\t\t\t\t\t&& (i + 1) % k2 != 0) {\n\t\t\t\t\t\tpos.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tC1s++;\n\t\t\t\t}\n\t\t\t\tif (C0s >= C1s) {\n\t\t\t\t\tif (pos.length == 0) {\n\t\t\t\t\t\tcout << -1;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet k = pos[pos.length - 1];\n\t\t\t\t\t\tvar ns = s.replace(s[k], '1');\n\t\t\t\t\t\tC0s--;\n\t\t\t\t\t\tC1s++;\n\t\t\t\t\t\tpos.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag == 0) {\n\t\t\t\tdocument.write(ns);\n\t\t\t}\n\t\t}", "4893": "function maximizeProduct(N)\n\t\t{\n\t\t\tlet MSB = Math.log2(N);\n\t\t\tlet X = 1 << MSB;\n\t\t\tlet Y = N - (1 << MSB);\n\t\t\tfor (let i = 0; i < MSB; i++) {\n\t\t\t\tif (!(N & (1 << i))) {\n\t\t\t\t\tX += 1 << i;\n\t\t\t\t\tY += 1 << i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdocument.write(X + \" \" + Y);\n\t\t}", "4899": "function check(num)\n{\n let sm = 0;\n let num2 = num * num;\n while (num) {\n\tsm += num % 10;\n\tnum = Math.floor(num / 10);\n }\n let sm2 = 0;\n while (num2) {\n\tsm2 += num2 % 10;\n\tnum2 = Math.floor(num2 / 10);\n }\n return sm * sm == sm2;\n}\nfunction convert(s) {\n let val = 0;\n s = s.split(\"\").reverse().join(\"\");\n let cur = 1;\n for (let i = 0; i < s.length; i++) {\n\tval += (s[i].charCodeAt(0) - \"0\".charCodeAt(0)) * cur;\n\tcur *= 10;\n }\n return val;\n}\nfunction generate(s, len, uniq) {\n if (s.length == len) {\n\tif (check(convert(s))) {\n\tuniq.add(convert(s));\n\t}\n\treturn;\n }\n for (let i = 0; i <= 3; i++) {\n\tgenerate(s + String.fromCharCode(i + \"0\".charCodeAt(0)), len, uniq);\n }\n}\nfunction totalNumbers(L, R) {\n let ans = 0;\n let max_len = Math.log10(R) + 1;\n let uniq = new Set();\n for (let i = 1; i <= max_len; i++) {\n\tgenerate(\"\", i, uniq);\n }\n for (let x of uniq) {\n\tif (x >= L && x <= R) {\n\tans++;\n\t}\n }\n return ans;\n}", "4906": "function maxSumAfterPartition(arr, n) {\n\t\t\tlet pos = [];\n\t\t\tlet neg = [];\n\t\t\tlet zero = 0;\n\t\t\tlet pos_sum = 0;\n\t\t\tlet neg_sum = 0;\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tif (arr[i] > 0) {\n\t\t\t\t\tpos.push(arr[i]);\n\t\t\t\t\tpos_sum += arr[i];\n\t\t\t\t}\n\t\t\t\telse if (arr[i] < 0) {\n\t\t\t\t\tneg.push(arr[i]);\n\t\t\t\t\tneg_sum += arr[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tzero++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet ans = 0;\n\t\t\tpos.sort(function (a, b) { return a - b })\n\t\t\tneg.sort(function (a, b) { return b - a })\n\t\t\tif (pos.length > 0 && neg.length > 0) {\n\t\t\t\tans = (pos_sum - neg_sum);\n\t\t\t}\n\t\t\telse if (pos.length > 0) {\n\t\t\t\tif (zero > 0) {\n\t\t\t\t\tans = (pos_sum);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans = (pos_sum - 2 * pos[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (zero > 0) {\n\t\t\t\t\tans = (-1 * neg_sum);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans = (neg[0] - (neg_sum - neg[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}", "4916": "function validPermutations(str) {\n let m = new Map();\n let count = str.length,\n\tans = 0;\n for (let i = 0; i < str.length; i++) {\n\tif (m.has(str[i])) {\n\tm.set(str[i], m.get(str[i]) + 1);\n\t} else {\n\tm.set(str[i], 1);\n\t}\n }\n for (let i = 0; i < str.length; i++)\n {\n\tans += count - m.get(str[i]);\n\tm.set(str[i], m.get(str[i]) - 1);\n\tcount--;\n }\n return ans + 1;\n}", "4961": "function num_candyTypes(candies) {\n\tlet s = new Set();\n\tfor (let i = 0; i < candies.length; i++) {\n\t\ts.add(candies[i]);\n\t}\n\treturn s.size;\n}\nfunction distribute_candies(candies)\n{\n\tlet allowed = candies.length / 2;\n\tlet types = num_candyTypes(candies);\n\tif (types < allowed)\n\t\tdocument.write(types);\n\telse\n\t\tdocument.write(allowed);\n}", "4962": "function convertXintoY(X, Y)\n\t\t{\n\t\t\twhile (Y > X) {\n\t\t\t\tif (Y % 2 == 0)\n\t\t\t\t\tY = parseInt(Y / 2);\n\t\t\t\telse if (Y % 10 == 1)\n\t\t\t\t\tY = parseInt(Y /= 10);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (X == Y)\n\t\t\t\tdocument.write(\"Yes\");\n\t\t\telse\n\t\t\t\tdocument.write(\"No\");\n\t\t}", "4964": "function maxXORUtil(arr,N,xrr,orr)\n{\n\t\tif (N == 0)\n\t\t\treturn xrr ^ orr;\n\t\tlet x\n\t\t\t= maxXORUtil(arr, N - 1, xrr ^ orr, arr[N - 1]);\n\t\tlet y\n\t\t\t= maxXORUtil(arr, N - 1, xrr, orr arr[N - 1]);\n\t\treturn Math.max(x, y);\n}\nfunction maximumXOR(arr,N)\n{\n\treturn maxXORUtil(arr, N, 0, 0);\n}", "4965": "function MaxXOR(arr, N)\n{\n\tvar res = 0;\n\tfor(var i = 0; i < N; i++)\n\t{\n\t\tres |= arr[i];\n\t}\n\treturn res;\n}", "4989": "function generateString(K)\n{\n\tvar s = \"\";\n\tfor(var i = 97; i < 97 + K; i++)\n\t{\n\t\ts = s + String.fromCharCode(i);\n\t\tfor(var j = i + 1; j < 97 + K; j++)\n\t\t{\n\t\t\ts += String.fromCharCode(i);\n\t\t\ts += String.fromCharCode(j);\n\t\t}\n\t}\n\ts += String.fromCharCode(97);\n\tdocument.write(s);\n}", "4990": "function countEqual(A, B, N)\n{\n\tlet first = 0;\n\tlet second = N - 1;\n\tlet count = 0;\n\twhile (first < N && second >= 0) {\n\t\tif (A[first] < B[second]) {\n\t\t\tfirst++;\n\t\t}\n\t\telse if (B[second] < A[first]) {\n\t\t\tsecond--;\n\t\t}\n\t\telse {\n\t\t\tcount++;\n\t\t\tfirst++;\n\t\t\tsecond--;\n\t\t}\n\t}\n\treturn count;\n}", "5016": "function findEquation(S, M)\n{\n\tdocument.write(\"1 \" + ((-1) * S) + \" \" + M); \n}", "5030": "function isPalindrome(N)\n{\n\tint temp = N;\n\tlet res = 0;\n\twhile (temp != 0)\n\t{\n\t\tlet rem = temp % 10;\n\t\tres = res * 10 + rem;\n\t\ttemp = Math.floor( temp / 10);\n\t}\n\tif (res == N)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\nfunction sumOfDigits(N)\n{\n\tlet sum = 0;\n\twhile (N != 0)\n\t{\n\t\tsum += N % 10;\n\t\tN = Math.floor( N / 10);\n\t}\n\treturn sum;\n}\nfunction isPrime(n)\n{\n\tif (n <= 1)\n\t{\n\t\treturn false;\n\t}\n\tfor(let i = 2; i <= Math.floor(n / 2); ++i)\n\t{\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nfunction precompute()\n{\n\tfor(let i = 1; i <= 100000; i++)\n\t{\n\t\tif (isPalindrome(i))\n\t\t{\n\t\t\tlet sum = sumOfDigits(i);\n\t\t\tif (isPrime(sum))\n\t\t\t\tarr[i] = 1;\n\t\t\telse\n\t\t\t\tarr[i] = 0;\n\t\t}\n\t\telse\n\t\t\tarr[i] = 0;\n\t}\n\tfor(let i = 1; i <= 100000; i++)\n\t{\n\t\tarr[i] = arr[i] + arr[i - 1];\n\t}\n}\nfunction countNumbers( Q, N)\n{\n\tprecompute();\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tdocument.write((arr[Q[i][1]] - arr[Q[i][0] - 1]) + \"<br/>\");\n\t}\n}", "5038": "function minSteps(a, n)\n{\n\tvar prefix_sum = Array(n).fill(0);\n\tprefix_sum[0] = a[0];\n\tfor (var i = 1; i < n; i++)\n\t\tprefix_sum[i] += prefix_sum[i - 1] + a[i];\n\tvar mx = -1;\n\tfor (var subgroupsum =0; subgroupsum<prefix_sum.length; subgroupsum++)\n\t{\n\t\tvar sum = 0;\n\t\tvar i = 0;\n\t\tvar grp_count = 0;\n\t\twhile (i < n)\n\t\t{\n\t\t\tsum += a[i];\n\t\t\tif (sum == prefix_sum[subgroupsum])\n\t\t\t{\n\t\t\t\tgrp_count += 1;\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\telse if(sum > prefix_sum[subgroupsum])\n\t\t\t{\n\t\t\t\tgrp_count = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t\tif (grp_count > mx)\n\t\t\tmx = grp_count;\n\t}\n\treturn n - mx;\n}", "5056": "function maxOccuringCharacter(s)\n{\n\tvar count0 = 0, count1 = 0;\n\tfor (var i = 0; i < s.length; i++) {\n\t\tif (s.charAt(i) == '1') {\n\t\t\tcount1++;\n\t\t}\n\t\telse if (s.charAt(i) == '0') {\n\t\t\tcount0++;\n\t\t}\n\t}\n\tvar prev = -1;\n\tfor (var i = 0; i < s.length; i++) {\n\t\tif (s.charAt(i) == '1') {\n\t\t\tprev = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (var i = prev + 1; i < s.length; i++) {\n\t\tif (s.charAt(i) != 'X') {\n\t\t\tif (s.charAt(i) == '1') {\n\t\t\t\tcount1 += i - prev - 1;\n\t\t\t\tprev = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag = true;\n\t\t\t\tfor (var j = i + 1; j < s.length; j++) {\n\t\t\t\t\tif (s.charAt(j) == '1') {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tprev = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) {\n\t\t\t\t\ti = prev;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti = s.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprev = -1;\n\tfor (var i = 0; i < s.length; i++) {\n\t\tif (s.charAt(i) == '0') {\n\t\t\tprev = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (var i = prev + 1; i < s.length; i++) {\n\t\tif (s.charAt(i) != 'X') {\n\t\t\tif (s.charAt(i) == '0') {\n\t\t\t\tcount0 += i - prev - 1;\n\t\t\t\tprev = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag = true;\n\t\t\t\tfor (var j = i + 1; j < s.length; j++) {\n\t\t\t\t\tif (s.charAt(j) == '0') {\n\t\t\t\t\t\tprev = j;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flag) {\n\t\t\t\t\ti = prev;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti = s.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (s.charAt(0) == 'X') {\n\t\tvar count = 0;\n\t\tvar i = 0;\n\t\twhile (s.charAt(i) == 'X') {\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}\n\t\tif (s.charAt(i) == '1') {\n\t\t\tcount1 += count;\n\t\t}\n\t}\n\tif (s.charAt(s.length - 1) == 'X') {\n\t\tvar count = 0;\n\t\tvar i = s.length - 1;\n\t\twhile (s.charAt(i) == 'X') {\n\t\t\tcount++;\n\t\t\ti--;\n\t\t}\n\t\tif (s.charAt(i) == '0') {\n\t\t\tcount0 += count;\n\t\t}\n\t}\n\tif (count0 == count1) {\n\t\tdocument.write(\"X\");\n\t}\n\telse if (count0 > count1) {\n\t\tdocument.write(0);\n\t}\n\telse\n\t\tdocument.write(1);\n}", "5062": "function winner(arr, N) {\n\t\tif (N % 2 === 1) {\n\t\tdocument.write(\"A\");\n\t\t}\n\t\telse {\n\t\tdocument.write(\"B\");\n\t\t}\n\t}", "5090": "function maxSheets(A, B)\n\t{\n\t\tlet area = A * B;\n\t\tlet count = 1;\n\t\twhile (area % 2 == 0) {\n\t\t\tarea /= 2;\n\t\t\tcount *= 2;\n\t\t}\n\t\treturn count;\n\t}", "5093": "function findMinMoves(a, b)\n{\n\tlet ans = 0;\n\tif (a == b || Math.abs(a - b) == 1) {\n\t\tans = a + b;\n\t}\n\telse {\n\t\tlet k = Math.min(a, b);\n\t\tlet j = Math.max(a, b);\n\t\tans = 2 * k + 2 * (j - k) - 1;\n\t}\n\tdocument.write(ans);\n}", "5102": "function cntEvenSumPairs(X , Y) {\n\t\tvar cntXEvenNums = parseInt(X / 2);\n\t\tvar cntXOddNums = parseInt((X + 1) / 2);\n\t\tvar cntYEvenNums = parseInt(Y / 2);\n\t\tvar cntYOddNums =parseInt( (Y + 1) / 2);\n\t\tvar cntPairs = (cntXEvenNums * cntYEvenNums) +\n\t\t(cntXOddNums * cntYOddNums);\n\t\treturn cntPairs;\n\t}", "5118": "function minMoves(arr)\n{\n\tlet N = arr.length;\n\tif (N <= 2)\n\t\treturn 0;\n\tlet ans = Number.MAX_VALUE;\n\tfor (let i = -1; i <= 1; i++)\n\t{\n\t\tfor (let j = -1; j <= 1; j++)\n\t\t{\n\t\t\tlet num1 = arr[0] + i;\n\t\t\tlet num2 = arr[1] + j;\n\t\t\tlet flag = 1;\n\t\t\tlet moves = Math.abs(i) + Math.abs(j);\n\t\t\tfor (let idx = 2; idx < N; idx++)\n\t\t\t{\n\t\t\t\tlet num = num1 + num2;\n\t\t\t\tif (Math.abs(arr[idx] - num) > 1)\n\t\t\t\t\tflag = 0;\n\t\t\t\telse\n\t\t\t\t\tmoves += Math.abs(arr[idx] - num);\n\t\t\t\tnum1 = num2;\n\t\t\t\tnum2 = num;\n\t\t\t}\n\t\t\tif (flag > 0)\n\t\t\t\tans = Math.min(ans, moves);\n\t\t}\n\t}\n\tif (ans == Number.MAX_VALUE)\n\t\treturn -1;\n\treturn ans;\n}", "5119": "function querySum(arr, N, Q, M)\n{\n\tfor (let i = 0; i < M; i++) {\n\t\tlet x = Q[i][0];\n\t\tlet y = Q[i][1];\n\t\tlet sum = 0;\n\t\twhile (x < N) {\n\t\t\tsum += arr[x];\n\t\t\tx += y;\n\t\t}\n\t\tdocument.write(sum + \" \");\n\t}\n}", "5167": "function construct_tree(weights, n)\n{\n\tlet minimum = Number.MAX_VALUE;\n\tlet maximum = Number.MIN_VALUE;\n\tfor(let i = 0; i < weights.length; i++)\n\t{\n\t\tminimum = Math.min(minimum, weights[i]);\n\t\tmaximum = Math.max(maximum, weights[i]);\n\t}\n\tif (minimum == maximum)\n\t{\n\t\tdocument.write(\"No\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tdocument.write(\"Yes\" + \"</br>\");\n\t}\n\tlet root = weights[0];\n\tvisited[1] = 1;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] != root && visited[i + 1] == 0)\n\t\t{\n\t\t\tdocument.write(1 + \" \" +\n\t\t\t\t\t\t(i + 1) + \"</br>\");\n\t\t\tvisited[i + 1] = 1;\n\t\t}\n\t}\n\tlet notroot = 0;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] != root)\n\t\t{\n\t\t\tnotroot = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tif (weights[i] == root && visited[i + 1] == 0)\n\t\t{\n\t\t\tdocument.write(notroot + \" \" +\n\t\t\t\t\t\t\t\t(i + 1) + \"</br>\");\n\t\t\tvisited[i + 1] = 1;\n\t\t}\n\t}\n}", "5170": "function findBitwiseORGivenXORAND(X, Y)\n{\n\treturn X + Y;\n}", "5198": "function GCD(a, b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn GCD(b, a % b);\n}\nfunction canReach(N, A, B, K)\n{\n\tvar gcd = GCD(N, K);\n\tif (Math.abs(A - B) % gcd == 0) {\n\t\tdocument.write( \"Yes\");\n\t}\n\telse {\n\t\tdocument.write( \"No\");\n\t}\n}", "5199": "function sum(n)\n{\n\tvar res = 0;\n\twhile (n > 0)\n\t{\n\t\tres += n % 10;\n\t\tn /= 10;\n\t}\n\treturn res;\n}\nfunction smallestNumber(n , s)\n{\n\tif (sum(n) <= s)\n\t{\n\t\treturn n;\n\t}\n\tvar ans = n, k = 1;\n\tfor(i = 0; i < 9; ++i)\n\t{\n\t\tvar digit = (ans / k) % 10;\n\t\tvar add = k * ((10 - digit) % 10);\n\t\tans += add;\n\t\tif (sum(ans) <= s)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tk *= 10;\n\t}\n\treturn ans;\n}", "5218": "function countOfSubarray(arr, N)\n{\n\tvar mp = new Map();\n\tvar answer = 0;\n\tvar sum = 0;\n\tif(!mp.has(1))\n\t\tmp.set(1, 1)\n\telse\n\t\tmp.set(1, mp.get(1)+1)\n\tfor (var i = 0; i < N; i++) {\n\t\tsum += arr[i];\n\t\tanswer += mp.has(sum - i)?mp.get(sum - i):0;\n\t\tif(mp.has(sum - i))\n\t\t\tmp.set(sum - i, mp.get(sum - i)+1)\n\t\telse\n\t\t\tmp.set(sum - i, 1)\n\t}\n\tdocument.write( answer);\n}", "5227": "function minCost(s, k)\n{\n\tvar n = s.length;\n\tvar ans = 0;\n\tfor(var i = 0; i < k; i++)\n\t{\n\t\tvar a = new Array(26).fill(0);\n\t\tfor(var j = i; j < n; j += k)\n\t\t{\n\t\t\ta[s[j].charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\t\t}\n\t\tvar min_cost = 1000000000;\n\t\tfor(var ch = 0; ch < 26; ch++)\n\t\t{\n\t\t\tvar cost = 0;\n\t\t\tfor(var tr = 0; tr < 26; tr++)\n\t\t\t\tcost += Math.abs(ch - tr) * a[tr];\n\t\t\tmin_cost = Math.min(min_cost, cost);\n\t\t}\n\t\tans += min_cost;\n\t}\n\tdocument.write(ans);\n}", "5233": "function minAbsDiff(N)\n{\n\tvar sumSet1 = 0;\n\tvar sumSet2 = 0;\n\tfor(i = N; i > 0; i--)\n\t{\n\t\tif (sumSet1 <= sumSet2)\n\t\t{\n\t\t\tsumSet1 += i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsumSet2 += i;\n\t\t}\n\t}\n\treturn Math.abs(sumSet1 - sumSet2);\n}", "5234": "function minAbsDiff(N) {\n\t\tif (N % 4 == 0 N % 4 == 3) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}", "5250": "function checkDigits(n)\n{\n\tdo {\n\t\tvar r = n % 10;\n\t\tif (r == 3 r == 4 r == 6 r == 7 r == 9)\n\t\t\treturn false;\n\t\tn = parseInt(n/10);\n\t} while (n != 0);\n\treturn true;\n}\nfunction isPrime(n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (var i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nfunction isAllPrime(n)\n{\n\treturn isPrime(n)\n\t\t&& checkDigits(n);\n}", "5262": "function maximumSubarrays(arr, N, target)\n{\n\tvar ans = 0;\n\tvar availIdx = -1;\n\tvar cur_sum = 0;\n\tvar mp = new Map();\n\tmp.set(0, 1);\n\tfor (var i = 0; i < N; i++) {\n\t\tcur_sum += arr[i];\n\t\tif (mp.has(cur_sum - target)\n\t\t\t&& mp.get(cur_sum - target) >= availIdx) {\n\t\t\tans++;\n\t\t\tavailIdx = i;\n\t\t}\n\t\tmp.set(cur_sum , i);\n\t}\n\treturn ans;\n}", "5291": "function getMinOps(arr) {\n\t\tvar res = 0;\n\t\tfor (i = 0; i < arr.length - 1; i++) {\n\t\t\tres += Math.max(arr[i + 1] - arr[i], 0);\n\t\t}\n\t\treturn res;\n\t}", "5310": "function minCost(str, a, b)\n{\n\tlet openUnbalanced = 0;\n\tlet closedUnbalanced = 0;\n\tlet openCount = 0;\n\tlet closedCount = 0;\n\tfor(let i = 0; i < str.length; i++)\n\t{\n\t\tif (str[i] == '(')\n\t\t{\n\t\t\topenUnbalanced++;\n\t\t\topenCount++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (openUnbalanced == 0)\n\t\t\t\tclosedUnbalanced++;\n\t\t\telse\n\t\t\t\topenUnbalanced--;\n\t\t\tclosedCount++;\n\t\t}\n\t}\n\tlet result = a * (Math.abs(openCount - closedCount));\n\tif (closedCount > openCount)\n\t\tclosedUnbalanced -= (closedCount - openCount);\n\tif (openCount > closedCount)\n\t\topenUnbalanced -= (openCount - closedCount);\n\tresult += Math.min(a * (openUnbalanced + closedUnbalanced), b * closedUnbalanced);\n\tdocument.write(result + \"\\n\");\n}", "5322": "function\n\tcountEvenSum(low, high, k)\n\t{\n\t\tlet even_count = high / 2 - (low - 1) / 2;\n\t\tlet odd_count = (high + 1) / 2 - low / 2;\n\t\tlet even_sum = 1;\n\t\tlet odd_sum = 0;\n\t\tfor (let i = 0; i < k; i++) {\n\t\t\tlet prev_even = even_sum;\n\t\t\tlet prev_odd = odd_sum;\n\t\t\teven_sum = (prev_even * even_count)\n\t\t\t\t\t+ (prev_odd * odd_count);\n\t\t\todd_sum = (prev_even * odd_count)\n\t\t\t\t\t+ (prev_odd * even_count);\n\t\t}\n\t\tdocument.write(even_sum);\n\t}", "5329": "function Length_Diagonals(a, theta)\n{\n\tlet p = a * Math.sqrt(2 + (2 *\n\t\t\t\tMath.cos(theta * (Math.PI / 180))));\n\tlet q = a * Math.sqrt(2 - (2 *\n\t\t\t\tMath.cos(theta * (Math.PI / 180))));\n\treturn [ p, q ];\n}", "5333": "function AddEdge(u, v)\n\t{\n\t\tadj[u].push(v);\n\t\tadj[v].push(u);\n\t}\nfunction Matching_dfs(u, p)\n\t{\n\t\tfor(let i = 0; i < adj[u].length; i++)\n\t\t{\n\t\t\tif (adj[u][i] != p)\n\t\t\t{\n\t\t\t\tMatching_dfs(adj[u][i], u);\n\t\t\t}\n\t\t}\n\t\tif (used[u] == 0 && used[p] == 0 && p != 0)\n\t\t{\n\t\t\tmax_matching++;\n\t\t\tused[u] = used[p] = 1;\n\t\t}\n\t}\nfunction maxMatching()\n\t{\n\t\tMatching_dfs(1, 0);\n\t\tdocument.write(max_matching + \"</br>\");\n\t}", "5353": "function balancedMatrix(mat)\n\t{\n\t\tlet is_balanced = true;\n\t\tfor (let i = 0; i < N && is_balanced; i++)\n\t\t{\n\t\t\tfor (let j = 0; j < M && is_balanced; j++)\n\t\t\t{\n\t\t\t\tif ((i == 0 i == N - 1) &&\n\t\t\t\t\t(j == 0 j == M - 1))\n\t\t\t\t{\n\t\t\t\t\tif (mat[i][j] >= 2)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t\telse if (i == 0 i == N - 1 j == 0 j == M - 1)\n\t\t\t\t{\n\t\t\t\t\tif (mat[i][j] >= 3)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (mat[i][j] >= 4)\n\t\t\t\t\t\tis_balanced = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (is_balanced)\n\t\t\treturn \"Balanced\";\n\t\telse\n\t\t\treturn \"Unbalanced\";\n\t}", "5361": "function getMinCost(A,B,N)\n{\n\tlet mini = Number.MAX_VALUE;\n\tfor (let i = 0; i < N; i++)\n\t{\n\t\tmini = Math.min(mini,\n\t\t\tMath.min(A[i], B[i]));\n\t}\n\treturn mini * (2 * N - 1);\n}", "5370": "function maxSubsequences(arr, n)\n{\n\tlet map = new Map();\n\tlet maxCount = 0;\n\tlet count;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tif (map.has(arr[i]))\n\t\t{\n\t\t\tcount = map[arr[i]];\n\t\t\tif (count > 1)\n\t\t\t{\n\t\t\t\tmap.add(arr[i], count - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tmap.delete(arr[i]);\n\t\t\tif (arr[i] - 1 > 0)\n\t\t\t\tif (map.has(arr[i] - 1))\n\t\t\t\t\tmap[arr[i] - 1]++;\n\t\t\t\telse\n\t\t\t\t\tmap.set(arr[i] - 1, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmaxCount++;\n\t\t\tif (arr[i] - 1 > 0)\n\t\t\t\tif (map.has(arr[i] - 1))\n\t\t\t\t\tmap[arr[i] - 1]++;\n\t\t\t\telse\n\t\t\t\t\tmap.set(arr[i] - 1, 1);\n\t\t}\n\t}\n\treturn maxCount;\n}", "5373": "function count(n, k)\n{\n\tlet count = Math.pow(10, k) - Math.pow(10, k - 1);\n\tdocument.write(count);\n}", "5380": "function func(N, P)\n{\n\tlet sumUptoN = (N * (N + 1) / 2);\n\tlet sumOfMultiplesOfP;\n\tif (N < P)\n\t{\n\t\treturn sumUptoN;\n\t}\n\telse if ((N / P) == 1)\n\t{\n\t\treturn sumUptoN - P + 1;\n\t}\n\tsumOfMultiplesOfP = ((N / P) * (2 * P +\n\t\t\t\t\t\t(N / P - 1) * P)) / 2;\n\treturn (sumUptoN + func(N / P, P) - sumOfMultiplesOfP);\n}", "5383": "", "5388": "function findShifts(A, N)\n{\n\tlet shift = Array.from({length: N}, (_, i) => 0);\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tif (i == A[i] - 1)\n\t\t\tshift[i] = 0;\n\t\telse\n\t\t\tshift[i] = (A[i] - 1 - i + N) % N;\n\t}\n\tfor(let i = 0; i < N; i++)\n\t\tdocument.write(shift[i] + \" \");\n}", "5398": "function printVector(arr)\n{\n\tif (arr.length != 1) {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tdocument.write( arr[i] + \" \");\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t}\n}\nfunction findWays(arr, i, n)\n{\n\tif (n == 0)\n\t\tprintVector(arr);\n\tfor (var j = i; j <= n; j++) {\n\t\tarr.push(j);\n\t\tfindWays(arr, j, n - j);\n\t\tarr.pop();\n\t}\n}", "5405": "function Maximum_subsequence(A, N)\n{\n\tvar frequency = new Map();\n\tvar max_freq = 0;\n\tfor (var i = 0; i < N; i++) {\n\t\tif(frequency.has(A[i]))\n\t\t\tfrequency.set(A[i], frequency.get(A[i])+1)\n\t\telse\n\t\t\tfrequency.set(A[i], 1);\n\t}\n\tfrequency.forEach((value, key) => {\n\t\tif (value > max_freq) { max_freq = value; } });\n\tdocument.write( max_freq );\n}", "5407": "function minSteps(N, increasing, decreasing, m1, m2)\n{\n\tvar mini = 2147483647;\n\tvar i;\n\tfor(i = 0; i < m1; i++)\n\t{\n\t\tif (mini > increasing[i])\n\t\t\tmini = increasing[i];\n\t}\n\tvar maxi = -2147483648;\n\tfor(i = 0; i < m2; i++)\n\t{\n\t\tif (maxi < decreasing[i])\n\t\t\tmaxi = decreasing[i];\n\t}\n\tvar minSteps = Math.max(maxi,N - mini);\n\tdocument.write(minSteps);\n}", "5416": "function constructmatrix(N)\n\t{\n\t\tlet check = true;\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tfor (let j = 0; j < N; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdocument.write(\"1 \");\n\t\t\t\t}\n\t\t\t\telse if (check) {\n\t\t\t\t\tdocument.write(\"2 \");\n\t\t\t\t\tcheck = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdocument.write(\"-2 \");\n\t\t\t\t\tcheck = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdocument.write(\"<br/>\");\n\t\t}\n\t}", "5418": "function countChanges(matrix, n, m)\n{\n\tvar dist = n + m - 1;\n\tvar freq = Array.from(Array(dist), ()=>Array(10));\n\tfor (var i = 0; i < dist; i++) {\n\t\tfor (var j = 0; j < 10; j++)\n\t\t\tfreq[i][j] = 0;\n\t}\n\tfor (var i = 0; i < n; i++) {\n\t\tfor (var j = 0; j < m; j++) {\n\t\t\tfreq[i + j][matrix[i][j]]++;\n\t\t}\n\t}\n\tvar min_changes_sum = 0;\n\tfor (var i = 0; i < parseInt(dist / 2); i++) {\n\t\tvar maximum = 0;\n\t\tvar total_values = 0;\n\t\tfor (var j = 0; j < 10; j++) {\n\t\t\tmaximum = Math.max(maximum, freq[i][j] + freq[n + m - 2 - i][j]);\n\t\t\ttotal_values += (freq[i][j] + freq[n + m - 2 - i][j]);\n\t\t}\n\t\tmin_changes_sum += (total_values - maximum);\n\t}\n\treturn min_changes_sum;\n}", "5440": "function DivideString(s, n, k) {\n\t\tvar i,\n\t\tc = 0,\n\t\tno = 1;\n\t\tvar c1 = 0,\n\t\tc2 = 0;\n\t\tvar fr = new Array(26).fill(0);\n\t\tvar ans = [];\n\t\tfor (i = 0; i < n; i++) {\n\t\tfr[s[i].charCodeAt(0) - \"a\".charCodeAt(0)]++;\n\t\t}\n\t\tvar ch = \"a\",\n\t\tch1 = \"a\";\n\t\tfor (i = 0; i < 26; i++) {\n\t\tif (fr[i] === k) {\n\t\t\tc++;\n\t\t}\n\t\tif (fr[i] > k && fr[i] !== 2 * k) {\n\t\t\tc1++;\n\t\t\tch = String.fromCharCode(i + \"a\".charCodeAt(0));\n\t\t}\n\t\tif (fr[i] === 2 * k) {\n\t\t\tc2++;\n\t\t\tch1 = String.fromCharCode(i + \"a\".charCodeAt(0));\n\t\t}\n\t\t}\n\t\tfor (i = 0; i < n; i++) ans.push(\"1\");\n\t\tvar mp = {};\n\t\tif (c % 2 === 0 c1 > 0 c2 > 0) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (fr[s[i].charCodeAt(0) - \"a\".charCodeAt(0)] === k) {\n\t\t\tif (mp.hasOwnProperty(s[i])) {\n\t\t\t\tans[i] = \"2\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (no <= parseInt(c / 2)) {\n\t\t\t\tans[i] = \"2\";\n\t\t\t\tno++;\n\t\t\t\tmp[s[i]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c % 2 === 1 && c1 > 0) {\n\t\t\tno = 1;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (s[i] === ch && no <= k) {\n\t\t\t\tans[i] = \"2\";\n\t\t\t\tno++;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c % 2 === 1 && c1 === 0) {\n\t\t\tno = 1;\n\t\t\tvar flag = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (s[i] === ch1 && no <= k) {\n\t\t\t\tans[i] = \"2\";\n\t\t\t\tno++;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tfr[s[i].charCodeAt(0) - \"a\".charCodeAt(0)] === k && flag === 0 && ans[i] === \"1\" ) {\n\t\t\t\tans[i] = \"2\";\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdocument.write(ans.join(\"\"));\n\t\t}\n\t\telse {\n\t\tdocument.write(\"NO\");\n\t\t}\n\t}", "5447": "function check(unit_digit, X)\n{\n\tlet times, digit;\n\tfor (times = 1; times <= 10; times++)\n\t{\n\t\tdigit = (X * times) % 10;\n\t\tif (digit == unit_digit)\n\t\t\treturn times;\n\t}\n\treturn -1;\n}\nfunction getNum(N, X)\n{\n\tlet unit_digit;\n\tunit_digit = N % 10;\n\tlet times = check(unit_digit, X);\n\tif (times == -1)\n\t\treturn times;\n\telse\n\t{\n\t\tif (N >= (times * X))\n\t\t\treturn times;\n\t\telse\n\t\t\treturn -1;\n\t}\n}", "5455": "function minPolets(n, m)\n{\n\tlet ans = 0;\n\tif ((n % 2 != 0) && (m % 2 != 0))\n\t{\n\t\tans = Math.floor((n * m) / 2) + 1;\n\t}\n\telse\n\t{\n\t\tans = Math.floor((n * m) / 2);\n\t}\n\treturn ans;\n}", "5468": "function solve(P, n)\n{\n\tlet arr = Array.from({length: n+1}, (_, i) => 0);\n\tarr[0] = 0;\n\tfor(let i = 0; i < n; i++)\n\tarr[i + 1] = P[i];\n\tlet cnt = 0;\n\tfor(let i = 1; i < n; i++)\n\t{\n\tif (arr[i] == i)\n\t{\n\t\tlet t = arr[i + 1];\n\t\tarr[i + 1] = arr[i];\n\t\tarr[i] = t;\n\t\tcnt++;\n\t}\n\t}\n\tif (arr[n] == n)\n\t{\n\t\tlet t = arr[n - 1];\n\t\tarr[n - 1] = arr[n];\n\t\tarr[n] = t;\n\t\tcnt++;\n\t}\n\tdocument.write(cnt);\n}", "5482": "function __builtin_popcount(n) {\n\tlet count = 0;\n\twhile (n > 0) {\n\t\tcount += n & 1;\n\t\tn >>= 1;\n\t}\n\treturn count;\n}\nfunction countEvenOdd(arr, n, K) {\n\tlet even = 0, odd = 0;\n\tfor (let i = 0; i < n; i++) {\n\t\tlet x = __builtin_popcount(arr[i]);\n\t\tif (x % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\t\todd++;\n\t}\n\tlet y;\n\ty = __builtin_popcount(K);\n\tif ((y & 1) != 0) {\n\t\tdocument.write(\"Even = \" + odd + \", Odd = \" + even);\n\t}\n\telse {\n\t\tdocument.write(\"Even = \" + even + \", Odd = \" + odd);\n\t}\n}", "5495": "function check(S, prices, type, n)\n{\n\tfor(let j = 0; j < n; j++)\n\t{\n\tfor(let k = j + 1; k < n; k++)\n\t{ \n\t\tif ((type[j] == 0 && type[k] == 1) ||\n\t\t\t(type[j] == 1 && type[k] == 0))\n\t\t{\n\t\t\tif (prices[j] + prices[k] <= S)\n\t\t\t{\n\t\t\t\treturn \"Yes\";\n\t\t\t}\n\t\t}\n\t}\n\t}\n\treturn \"No\";\n}", "5501": "function getLargestString(s,k)\n{\n let frequency_array = new Array(26);\n for(let i=0;i<26;i++)\n {\n\tfrequency_array[i]=0;\n }\n for (let i = 0; i < s.length; i++)\n {\n\tfrequency_array[s[i].charCodeAt(0) - 'a'.charCodeAt(0)]++;\n }\n let ans = \"\";\n for (let i = 25; i >= 0;)\n {\n\tif (frequency_array[i] > k)\n\t{\n\tlet temp = k;\n\tlet st = String.fromCharCode(i + 'a'.charCodeAt(0));\n\twhile (temp > 0)\n\t{\n\t\tans += st;\n\t\ttemp--;\n\t}\n\tfrequency_array[i] -= k;\n\tlet j = i - 1;\n\twhile (frequency_array[j] <= 0 && j >= 0)\n\t{\n\t\tj--;\n\t}\n\tif (frequency_array[j] > 0 && j >= 0)\n\t{\n\t\tlet str = String.fromCharCode(j + 'a'.charCodeAt(0));\n\t\tans += str;\n\t\tfrequency_array[j] -= 1;\n\t}\n\telse\n\t{\n\t\tbreak;\n\t}\n\t}\n\telse if (frequency_array[i] > 0)\n\t{\n\tlet temp = frequency_array[i];\n\tfrequency_array[i] -= temp;\n\tlet st = String.fromCharCode(i + 'a'.charCodeAt(0));\n\twhile (temp > 0)\n\t{\n\t\tans += st;\n\t\ttemp--;\n\t}\n\t}\n\telse\n\t{\n\ti--;\n\t}\n }\n return ans;\n}", "5512": "function minOperations(a , b , n)\n\t{\n\t\tvar minA = Math.max.apply(Math,a);;\n\t\tfor (x = minA; x >= 0; x--) {\n\t\t\tvar check = true;\n\t\t\tvar operations = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tif (x % b[i] == a[i] % b[i]) {\n\t\t\t\t\toperations += (a[i] - x) / b[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcheck = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (check)\n\t\t\t\treturn operations;\n\t\t}\n\t\treturn -1;\n\t}", "5538": "function getLargestSum(N) {\n\t\tvar max_sum = 0;\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\t\tif (i * j % (i + j) == 0)\n\t\t\t\t\tmax_sum = Math.max(max_sum, i + j);\n\t\t\t}\n\t\t}\n\t\treturn max_sum;\n\t}", "5539": "function getLargestSum(N)\n\t{\n\t\tlet max_sum = 0;\n\t\tfor(let i = 1; i * i <= N; i++)\n\t\t{\n\t\tfor(let j = i + 1; j * j <= N; j++)\n\t\t{\n\t\t\tlet k = parseInt(N / j, 10);\n\t\t\tlet a = k * i;\n\t\t\tlet b = k * j;\n\t\t\tif (a <= N && b <= N &&\n\t\t\t\ta * b % (a + b) == 0)\n\t\t\t\tmax_sum = Math.max(max_sum, a + b);\n\t\t\t}\n\t\t}\n\t\treturn max_sum;\n\t}", "5544": "function maxSubArraySum(a, size)\n{\n\tvar max_so_far = Number.MIN_VALUE,\n\t\tmax_ending_here = 0;\n\tfor(i = 0; i < size; i++)\n\t{\n\t\tmax_ending_here = max_ending_here + a[i];\n\t\tif (max_ending_here < 0)\n\t\t\tmax_ending_here = 0;\n\t\tif (max_so_far < max_ending_here)\n\t\t\tmax_so_far = max_ending_here;\n\t}\n\treturn max_so_far;\n}\nfunction maxSum(a, n)\n{\n\tvar S = 0;\n\tvar i;\n\tfor(i = 0; i < n; i++)\n\t\tS += a[i];\n\tvar X = maxSubArraySum(a, n);\n\treturn 2 * X - S;\n}", "5548": "function isPrime( n)\n{\n\tlet flag = 1;\n\tfor (let i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tflag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (flag == 1 ? true : false);\n}\nfunction isPerfectSquare( x)\n{\n\tlet sr = Math.sqrt(x);\n\treturn ((sr - Math.floor(sr)) == 0);\n}\nfunction countInterestingPrimes( n)\n{\n\tlet answer = 0;\n\tfor (let i = 2; i <= n; i++) {\n\t\tif (isPrime(i)) {\n\t\t\tfor (let j = 1; j * j * j * j <= i; j++) {\n\t\t\t\tif (\n\t\t\t\t\tisPerfectSquare( i - j * j * j * j)) {\n\t\t\t\t\tanswer++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn answer;\n}", "5585": "function decBinary(arr, n) {\n\tlet k = Math.log2(n);\n\twhile (n > 0) {\n\t\tarr[k--] = n % 2;\n\t\tn = Math.floor(n / 2);\n\t}\n}\nfunction binaryDec(arr, n) {\n\tlet ans = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tans += arr[i] << (n - i - 1);\n\treturn ans;\n}\nfunction maxNum(n, k) {\n\tlet l = Math.log2(n) + 1;\n\tlet a = new Array(l).fill(0);\n\tdecBinary(a, n);\n\tlet cn = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tif (a[i] == 0 && cn < k) {\n\t\t\ta[i] = 1;\n\t\t\tcn++;\n\t\t}\n\t}\n\treturn binaryDec(a, l);\n}", "5588": "function findSubSeq(arr, n, sum) {\n\tfor (let i = n - 1; i >= 0; i--) {\n\t\tif (sum < arr[i])\n\t\t\tarr[i] = -1;\n\t\telse\n\t\t\tsum -= arr[i];\n\t}\n\tfor (let i = 0; i < n; i++) {\n\t\tif (arr[i] != -1)\n\t\t\tdocument.write(arr[i] + \" \");\n\t}\n}", "5594": "function maxAlpha(str, len)\n\t{\n\t\tvar first = new Array(MAX);\n\t\tvar last = new Array(MAX);\n\t\tfor (var i = 0; i < MAX; i++) {\n\t\tfirst[i] = -1;\n\t\tlast[i] = -1;\n\t\t}\n\t\tfor (var i = 0; i < len; i++) {\n\t\tvar index = str[i].charCodeAt(0) -\n\t\t\"a\".charCodeAt(0);\n\t\tif (first[index] === -1) first[index] = i;\n\t\tlast[index] = i;\n\t\t}\n\t\tvar ans = -1,\n\t\tmaxVal = -1;\n\t\tfor (var i = 0; i < MAX; i++) {\n\t\tif (first[i] === -1) continue;\n\t\tif (last[i] - first[i] > maxVal) {\n\t\t\tmaxVal = last[i] - first[i];\n\t\t\tans = i;\n\t\t}\n\t\t}\n\t\treturn String.fromCharCode(ans + \"a\".charCodeAt(0));\n\t}", "5621": "function find_distinct(a, n, q, queries)\n{\n\tlet MAX =100001;\n\tlet check = new Array(MAX).fill(0);\n\tlet idx = new Array(MAX).fill(0);\n\tlet cnt = 1;\n\tlet i=n-1;\n\twhile (i>=0) {\n\t\tif (check[a[i]] == 0)\n\t\t{\n\t\t\tidx[i] = cnt;\n\t\t\tcheck[a[i]] = 1;\n\t\t\tcnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tidx[i] = cnt - 1;\n\t\t}\n\ti--;\n\t}\n\tfor (let i = 0; i < q; i++)\n\t{\n\t\t\tlet m = queries[i];\n\t\t\tdocument.write(idx[m] + \" \");\n\t}\n}", "5627": "function countOp(x)\n{\n\tlet arr = new Array(MAX);\n\tarr[0] = 1;\n\tfor (let i = 1; i < MAX; i++)\n\t\tarr[i] = arr[i - 1] * 2;\n\tlet temp = x;\n\tlet flag = true;\n\tlet ans;\n\tlet operations = 0;\n\tlet flag2 = false;\n\tfor (let i = 0; i < MAX; i++) {\n\t\tif (arr[i] - 1 == x)\n\t\t\tflag2 = true;\n\t\tif (arr[i] > x) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flag2)\n\t\treturn 0;\n\twhile (flag) {\n\t\tif (arr[ans] < x)\n\t\t\tans++;\n\t\toperations++;\n\t\tfor (let i = 0; i < MAX; i++) {\n\t\t\tlet take = x ^ (arr[i] - 1);\n\t\t\tif (take <= arr[ans] - 1) {\n\t\t\t\tif (take > temp)\n\t\t\t\t\ttemp = take;\n\t\t\t}\n\t\t}\n\t\tif (temp == arr[ans] - 1) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t\ttemp++;\n\t\toperations++;\n\t\tx = temp;\n\t\tif (x == arr[ans] - 1)\n\t\t\tflag = false;\n\t}\n\treturn operations;\n}", "5636": "function minOperations(arr, n)\n{\n\tlet maxi, result = 0;\n\tlet freq = new Array(1000001).fill(0);\n\tfor (let i = 0; i < n; i++) {\n\t\tlet x = arr[i];\n\t\tfreq[x]++;\n\t}\n\tmaxi = Math.max(...arr);\n\tfor (let i = 1; i <= maxi; i++) {\n\t\tif (freq[i] != 0) {\n\t\t\tfor (let j = i * 2; j <= maxi; j = j + i) {\n\t\t\t\tfreq[j] = 0;\n\t\t\t}\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}", "5675": "function encryptString(str, n)\n\t{\n\t\tlet i = 0, cnt = 0;\n\t\tlet encryptedStr = \"\";\n\t\twhile (i < n)\n\t\t{\n\t\t\tcnt = i + 1;\n\t\t\twhile (cnt-- >0)\n\t\t\t\tencryptedStr += str[i];\n\t\t\ti++;\n\t\t}\n\t\treturn encryptedStr;\n\t}", "5676": "function __gcd(a , b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn __gcd(b % a, a);\n\t}\nfunction minGCD(arr , n) {\n\t\tvar minGCD = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tminGCD = __gcd(minGCD, arr[i]);\n\t\treturn minGCD;\n\t}\nfunction minLCM(arr , n) {\n\t\tvar minLCM = arr[0];\n\t\tfor (i = 1; i < n; i++)\n\t\t\tminLCM = Math.min(minLCM, arr[i]);\n\t\treturn minLCM;\n\t}", "5687": "function formStringMinOperations(s)\n\t{\n\t\tvar count = new Array(3).fill(0);\n\t\tfor (const c of s) {\n\t\tcount += 1;\n\t\t}\n\t\tvar processed = new Array(3).fill(0);\n\t\tvar reqd = parseInt(s.length / 3);\n\t\tfor (var i = 0; i < s.length; i++) {\n\t\tif (count[s[i].charCodeAt(0) - \"0\".charCodeAt(0)] === reqd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] === \"0\" && count[0] > reqd && processed[0] >= reqd) {\n\t\t\tif (count[1] < reqd) {\n\t\t\ts[i] = \"1\";\n\t\t\tcount[1]++;\n\t\t\tcount[0]--;\n\t\t\t}\n\t\t\telse if (count[2] < reqd) {\n\t\t\ts[i] = \"2\";\n\t\t\tcount[2]++;\n\t\t\tcount[0]--;\n\t\t\t}\n\t\t}\n\t\tif (s[i] === \"1\" && count[1] > reqd) {\n\t\t\tif (count[0] < reqd) {\n\t\t\ts[i] = \"0\";\n\t\t\tcount[0]++;\n\t\t\tcount[1]--;\n\t\t\t} else if (count[2] < reqd && processed[1] >= reqd) {\n\t\t\ts[i] = \"2\";\n\t\t\tcount[2]++;\n\t\t\tcount[1]--;\n\t\t\t}\n\t\t}\n\t\tif (s[i] === \"2\" && count[2] > reqd) {\n\t\t\tif (count[0] < reqd) {\n\t\t\ts[i] = \"0\";\n\t\t\tcount[0]++;\n\t\t\tcount[2]--;\n\t\t\t} else if (count[1] < reqd) {\n\t\t\ts[i] = \"1\";\n\t\t\tcount[1]++;\n\t\t\tcount[2]--;\n\t\t\t}\n\t\t}\n\t\tprocessed[s[i].charCodeAt(0) - \"0\".charCodeAt(0)]++;\n\t\t}\n\t\treturn s.join(\"\");\n\t}", "5730": "function minDiff( n, x, A)\n{\n\tvar mn = A[0], mx = A[0];\n\tfor (var i = 0; i < n; ++i) {\n\t\tmn = Math.min(mn, A[i]);\n\t\tmx = Math.max(mx, A[i]);\n\t}\n\treturn Math.max(0, mx - mn - 2 * x);\n}", "5739": "", "5742": "function isWaveArray(arr, n)\n\t{\n\t\tlet result = true;\n\t\tif (arr[1] > arr[0] && arr[1] > arr[2]) {\n\t\t\tfor (let i = 1; i < n - 1; i += 2) {\n\t\t\t\tif (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == true && n % 2 == 0) {\n\t\t\t\tif (arr[n - 1] <= arr[n - 2]) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (arr[1] < arr[0] && arr[1] < arr[2]) {\n\t\t\tfor (let i = 1; i < n - 1; i += 2) {\n\t\t\t\tif (arr[i] < arr[i - 1] && arr[i] < arr[i + 1]) {\n\t\t\t\t\tresult = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == true && n % 2 == 0) {\n\t\t\t\tif (arr[n - 1] >= arr[n - 2]) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "5762": "function findMinimumAdjacentSwaps(arr, N)\n{\n\tlet visited = Array(N + 1).fill(false);\n\tlet minimumSwaps = 0;\t\n\tfor (let i = 0; i < 2 * N; i++) {\n\t\tif (visited[arr[i]] == false) {\n\t\t\tvisited[arr[i]] = true;\n\t\t\tlet count = 0;\n\t\t\tfor (let j = i + 1; j < 2 * N; j++) {\n\t\t\t\tif (visited[arr[j]] == false)\n\t\t\t\t\tcount++;\n\t\t\t\telse if (arr[i] == arr[j])\n\t\t\t\t\tminimumSwaps += count;\n\t\t\t}\n\t\t}\n\t}\n\treturn minimumSwaps;\n}", "5772": "function possibility(m,length, s)\n{\n\tvar countodd = 0;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (m.get(s.charCodeAt(i) - 48) & 1)\n\t\t\tcountodd++;\n\t\tif (countodd > 1)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nfunction largestPalindrome(s)\n{\n\tvar l = s.length;\n\tvar m = new Map();\n\tfor (var i = 0; i < l; i++){\n\t\tif (m.has(s.charCodeAt(i) - 48))\n\t\t\tm.set(s.charCodeAt(i) - 48, m.get(s.charCodeAt(i) - 48)+1);\n\t\telse\n\t\t\tm.set(s.charCodeAt(i) - 48, 1);\n\t}\n\tif (possibility(m, l, s) == false) {\n\t\tdocument.write(\"Palindrome cannot be formed\");\n\t\treturn;\n\t}\n\tvar largest = new Array(l);\n\tvar front = 0;\n\tfor (var i = 9; i >= 0; i--) {\n\t\tif (m.has(i) & 1) {\n\t\t\tlargest[Math.floor(l / 2)] = String.fromCharCode(i + 48);\n\t\t\tm.set(i, m.get(i)-1);\n\t\t\twhile (m.get(i) > 0) {\n\t\t\t\tlargest[front] = String.fromCharCode(i + 48);\n\t\t\t\tlargest[l - front - 1] = String.fromCharCode(i + 48);\n\t\t\t\tm.set(i, m.get(i)-2);\n\t\t\t\tfront++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (m.get(i) > 0){\n\t\t\t\tlargest[front] = String.fromCharCode(i + 48);\n\t\t\t\tlargest[l - front - 1] = String.fromCharCode(i + 48);\n\t\t\t\tm.set(i, m.get(i)-2);\n\t\t\t\tfront++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (var i = 0; i < l; i++)\n\t\tdocument.write(largest[i]);\n}", "5797": "function swapCount(s)\n{\n\tlet pos = [];\n\tfor(let i = 0; i < s.length; ++i)\n\t\tif (s[i] == '[')\n\t\t\tpos.push(i);\n\tlet count = 0;\n\tlet p = 0; \n\tlet sum = 0;\n\tlet S = s.split('');\n\tfor(let i = 0; i < s.length; ++i)\n\t{\n\t\tif (S[i] == '[')\n\t\t{\n\t\t\t++count;\n\t\t\t++p;\n\t\t}\n\t\telse if (S[i] == ']')\n\t\t\t--count;\n\t\tif (count < 0)\n\t\t{\n\t\t\tsum += pos[p] - i;\n\t\t\tlet temp = S[i];\n\t\t\tS[i] = S[pos[p]];\n\t\t\tS[pos[p]] = temp;\n\t\t\t++p;\n\t\t\tcount = 1;\n\t\t}\n\t}\n\treturn sum;\n}", "5798": "function swapCount(s)\n\t{\n\t\tlet chars = s.split('');\n\t\tlet countLeft = 0, countRight = 0;\n\t\tlet swap = 0, imbalance = 0;\n\t\tfor (let i = 0; i < chars.length; i++)\n\t\t{\n\t\t\tif (chars[i] == '[')\n\t\t\t{\n\t\t\t\tcountLeft++;\n\t\t\t\tif (imbalance > 0)\n\t\t\t\t{\n\t\t\t\t\tswap += imbalance;\n\t\t\t\t\timbalance--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (chars[i] == ']')\n\t\t\t{\n\t\t\t\tcountRight++;\n\t\t\t\timbalance = (countRight - countLeft);\n\t\t\t}\n\t\t}\n\t\treturn swap;\n\t}", "5811": "function minimizeWithKSwaps(arr, n, k)\n\t{\n\t\tfor (let i = 0; i < n - 1 && k > 0; ++i)\n\t\t{\n\t\t\tlet pos = i;\n\t\t\tfor (let j = i+1; j < n ; ++j)\n\t\t\t{\n\t\t\t\tif (j - i > k)\n\t\t\t\t\tbreak;\n\t\t\t\tif (arr[j] < arr[pos])\n\t\t\t\t\tpos = j;\n\t\t\t}\n\t\t\tlet temp;\n\t\t\tfor (let j = pos; j > i; --j)\n\t\t\t{\n\t\t\t\ttemp = arr[j];\n\t\t\t\tarr[j] = arr[j - 1];\n\t\t\t\tarr[j - 1] = temp;\n\t\t\t}\n\t\t\tk -= pos - i;\n\t\t}\n\t}", "5816": "function minimumCostOfBreaking(X, Y, m, n)\n\t{\n\t\tlet res = 0;\n\t\tX.sort();\n\t\tX.reverse();\n\t\tY.sort();\n\t\tY.reverse();\n\t\tlet hzntl = 1, vert = 1;\n\t\tlet i = 0, j = 0;\n\t\twhile (i < m && j < n)\n\t\t{\n\t\t\tif (X[i] > Y[j])\n\t\t\t{\n\t\t\t\tres += X[i] * vert;\n\t\t\t\thzntl++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += Y[j] * hzntl;\n\t\t\t\tvert++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tlet total = 0;\n\t\twhile (i < m)\n\t\t\ttotal += X[i++];\n\t\tres += total * vert;\n\t\ttotal = 0;\n\t\twhile (j < n)\n\t\t\ttotal += Y[j++];\n\t\tres += total * hzntl;\n\t\treturn res;\n\t}", "5865": "function getMin(x, y, z) {\n\t\t\treturn Math.min(Math.min(x, y), z);\n\t\t}\nfunction editDistance(str1, str2, m, n)\n\t\t{\n\t\t\tlet dp = new Array(m + 1).fill(new Array(n + 1));\n\t\t\tfor (let i = 0; i <= m; i++) {\n\t\t\t\tfor (let j = 0; j <= n; j++) {\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t\tdp[i][j] = j;\n\t\t\t\t\telse if (j == 0)\n\t\t\t\t\t\tdp[i][j] = i;\n\t\t\t\t\telse if (str1[i - 1] == str2[j - 1])\n\t\t\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = 1\n\t\t\t\t\t\t\t+ getMin( dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[m][n];\n\t\t}\nfunction minimumSteps(S, N) {\n\t\t\tlet ans = Number.MAX_VALUE;\n\t\t\tfor (let i = 1; i < N; i++) {\n\t\t\t\tlet S1 = S.substring(0, i);\n\t\t\t\tlet S2 = S.substring(i);\n\t\t\t\tlet count = editDistance( S1, S2, S1.length, S2.length);\n\t\t\t\tans = Math.min(ans, count);\n\t\t\t}\n\t\t\tdocument.write(ans - 1);\n\t\t}", "5872": "function minimumOperations(N)\n\t{\n\t\tlet dp = new Array(N + 1);\n\t\tlet i;\n\t\tfor (i = 0; i <= N; i++) {\n\t\t\tdp[i] = 1e9;\n\t\t}\n\t\tdp[2] = 0;\n\t\tfor (i = 2; i <= N; i++) {\n\t\t\tif (dp[i] == 1e9)\n\t\t\t\tcontinue;\n\t\t\tif (i * 5 <= N) {\n\t\t\t\tdp[i * 5] = Math.min(dp[i * 5], dp[i] + 1);\n\t\t\t}\n\t\t\tif (i + 3 <= N) {\n\t\t\t\tdp[i + 3] = Math.min(dp[i + 3], dp[i] + 1);\n\t\t\t}\n\t\t}\n\t\tif (dp[N] == 1e9)\n\t\t\treturn -1;\n\t\treturn dp[N];\n\t}", "5880": "function MaxProfit(arr, n, transactionFee)\n{\n\tlet buy = -arr[0];\n\tlet sell = 0;\n\tfor(let i = 1; i < n; i++)\n\t{\n\t\tlet temp = buy;\n\t\tbuy = Math.max(buy, sell - arr[i]);\n\t\tsell = Math.max(sell, temp + arr[i] - transactionFee);\n\t}\n\treturn Math.max(sell, buy);\n}", "5904": "function countPossiblities(arr, n)\n\t{\n\t\tlet lastOccur = new Array(100000);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlastOccur[i] = -1;\n\t\t}\n\t\tdp = new Array(n + 1);\n\t\tdp[0] = 1;\n\t\tfor (let i = 1; i <= n; i++) {\n\t\t\tlet curEle = arr[i - 1];\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (lastOccur[curEle] != -1 & lastOccur[curEle] < i - 1) {\n\t\t\t\tdp[i] += dp[lastOccur[curEle]];\n\t\t\t}\n\t\t\tlastOccur[curEle] = i;\n\t\t}\n\t\tdocument.write(dp[n] + \"<br>\");\n\t}", "5920": "function longestSubSequence(A, N) {\n\tlet dp = new Array(N);\n\tfor (let i = 0; i < N; i++) {\n\t\tdp[i] = 1;\n\t\tfor (let j = 0; j < i; j++) {\n\t\t\tif (A[j][0] < A[i][0] && A[j][1] > A[i][1]) {\n\t\t\t\tdp[i] = Math.max(dp[i], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tdocument.write(dp[N - 1] + \"<br>\");\n}", "5924": "function calculateStart(n, m)\n{\n\tfor (var i = 1; i < m; ++i) {\n\t\tstart[0][i] += start[0][i - 1];\n\t}\n\tfor (var i = 1; i < n; ++i) {\n\t\tstart[i][0] += start[i - 1][0];\n\t}\n\tfor (var i = 1; i < n; ++i) {\n\t\tfor (var j = 1; j < m; ++j) {\n\t\t\tstart[i][j] += Math.max(start[i - 1][j], start[i][j - 1]);\n\t\t}\n\t}\n}\nfunction calculateEnd(n, m)\n{\n\tfor (var i = n - 2; i >= 0; --i) {\n\t\tending[i][m - 1] += ending[i + 1][m - 1];\n\t}\n\tfor (var i = m - 2; i >= 0; --i) {\n\t\tending[n - 1][i] += ending[n - 1][i + 1];\n\t}\n\tfor (var i = n - 2; i >= 0; --i) {\n\t\tfor (var j = m - 2; j >= 0; --j) {\n\t\t\tending[i][j] += Math.max(ending[i + 1][j], ending[i][j + 1]);\n\t\t}\n\t}\n}\nfunction maximumPathSum(mat, n, m, q, coordinates)\n{\n\tfor (var i = 0; i < n; ++i) {\n\t\tfor (var j = 0; j < m; ++j) {\n\t\t\tstart[i][j] = mat[i][j];\n\t\t\tending[i][j] = mat[i][j];\n\t\t}\n\t}\n\tcalculateStart(n, m);\n\tcalculateEnd(n, m);\n\tvar ans = 0;\n\tfor (var i = 0; i < q; ++i) {\n\t\tvar X = coordinates[i][0] - 1;\n\t\tvar Y = coordinates[i][1] - 1;\n\t\tans = Math.max(ans, start[X][Y] + ending[X][Y] - mat[X][Y]);\n\t}\n\tdocument.write( ans);\n}", "5946": "function MaxSubsetlength(arr, A, B)\n{\n\tvar dp = Array.from(Array(A + 1),\n\t\t()=>Array(B + 1).fill(0));\n\tarr.forEach(str => {\n\t\tvar zeros = [...str].filter(x => x == '0').length;\n\t\tvar ones = [...str].filter(x => x == '1').length;\n\t\tfor(var i = A; i >= zeros; i--)\n\t\t\tfor(var j = B; j >= ones; j--)\n\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1); });\n\treturn dp[A][B];\n}", "5957": "function numOfWays(a, n, i, blue)\n{\n\tif (i == n)\n\t\treturn 1;\n\tlet count = 0;\n\tfor(let j = 0; j < n; j++)\n\t{\n\t\tif (a[i][j] == 1 && !blue.has(j))\n\t\t{\n\t\t\tblue.add(j);\n\t\t\tcount += numOfWays(a, n, i + 1, blue);\n\t\t\tblue.delete(j);\n\t\t}\n\t}\n\treturn count;\n}", "5970": "function minCost(arr, n)\n\t{\n\t\tif (n < 3) {\n\t\t\tdocument.write(arr[0]);\n\t\t\treturn;\n\t\t}\n\t\tlet dp = [];\n\t\tdp[0] = arr[0];\n\t\tdp[1] = dp[0] + arr[1] + arr[2];\n\t\tfor (let i = 2; i < n - 1; i++)\n\t\t\tdp[i] = Math.min(dp[i - 2] + arr[i], dp[i - 1] + arr[i] + arr[i + 1]);\n\t\tdp[n - 1] = Math.min(dp[n - 2], dp[n - 3] + arr[n - 1]);\n\t\tdocument.write(dp[n - 1]);\n\t}", "5995": "function power( X,Y)\n{\nvar res = 1;\nX = X % M;\nif (X == 0)\n return 0;\nwhile (Y > 0)\n{\n if ((Y & 1) != 0)\n {\n\tres = (res * X) % M;\n }\n Y = Y >> 1;\n\tX = (X * X) % M;\n\t}\n\treturn res;\n }\nfunction findValue(n)\n {\nvar X = 0;\nvar pow_10 = 1;\nwhile (n != 0)\n{\n if ((n & 1) != 0)\n {\n\tX += pow_10;\n }\n pow_10 *= 10;\n n /= 2;\n}\nX = (X * 2) % M;\n\tvar res = power(2, X);\n\treturn res;\n }", "6000": "function countTriplets(A)\n{\n\tvar cnt = 0;\n\tvar tuples = new Map();\n\tA.forEach(a => {\n\t\tA.forEach(b => {\n\t\t\tif(tuples.has(a & b))\n\t\t\t\ttuples.set(a & b, tuples.get(a & b)+1)\n\t\t\telse\n\t\t\t\ttuples.set(a & b, 1) }); });\n\tA.forEach(a => {\n\t\ttuples.forEach((value, key) => {\n\t\t\tif ((key & a) == 0) cnt += value; }); });\n\treturn cnt;\n}", "6021": "function findMinimum(arr, N, pos, turn)\n\t{\n\t\tlet x = [pos, turn];\n\t\tif (m.has(x))\n\t\t{\n\t\t\treturn m[x];\n\t\t}\n\t\tif (pos >= N - 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (turn == 0)\n\t\t{\n\t\t\tlet ans = Math.min(\n\t\t\t\tfindMinimum(arr, N, pos + 1, 1) + arr[pos],\n\t\t\t\tfindMinimum(arr, N, pos + 2, 1) + arr[pos] + arr[pos + 1]);\n\t\t\tlet v = [pos, turn];\n\t\t\tm[v] = ans;\n\t\t\treturn ans;\n\t\t}\n\t\tif (turn != 0)\n\t\t{\n\t\t\tlet ans = Math.min(\n\t\t\t\tfindMinimum(arr, N, pos + 1, 0),\n\t\t\t\tfindMinimum(arr, N, pos + 2, 0));\n\t\t\tlet v = [pos, turn];\n\t\t\tm[v] = ans;\n\t\t\treturn ans;\n\t\t}\n\t\treturn 0;\n\t}\nfunction countPenality(arr, N)\n\t{\n\t\tlet pos = 0;\n\t\tlet turn = 0;\n\t\treturn findMinimum(arr, N, pos, turn) + 1;\n\t}\nfunction printAnswer(arr, N)\n\t{\n\t\tlet a = countPenality(arr, N);\n\t\tlet sum = 0;\n\t\tfor(let i = 0; i < N; i++)\n\t\t{\n\t\t\tsum += arr[i];\n\t\t}\n\t\tdocument.write(a);\n\t}", "6028": "function maxSum(arr, n, m)\n{\n\tlet dp = new Array(n);\n\tfor (var i = 0; i < dp.length; i++) {\n\t\tdp[i] = new Array(2);\n\t}\n\tfor(let i = 0; i < 2; i++)\n\t{\n\t\tfor(let j = 0; j <= m; j++)\n\t\t{\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\tdp[0][m - 1] = arr[0][m - 1];\n\tdp[1][m - 1] = arr[1][m - 1];\n\tfor(let j = m - 2; j >= 0; j--)\n\t{\n\t\tfor (let i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (i == 1)\n\t\t\t{\n\t\t\t\tdp[i][j] = Math.max( arr[i][j] + dp[0][j + 1], arr[i][j] + dp[0][j + 2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = Math.max( arr[i][j] + dp[1][j + 1], arr[i][j] + dp[1][j + 2]);\n\t\t\t}\n\t\t}\n\t}\n\tdocument.write(Math.max(dp[0][0], dp[1][0]));\n}", "6029": "function maxSum(arr , n) {\n\t\tvar r1 = 0, r2 = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tvar temp = r1;\n\t\t\tr1 = Math.max(r1, r2 + arr[0][i]);\n\t\t\tr2 = Math.max(r2, temp + arr[1][i]);\n\t\t}\n\t\tdocument.write(Math.max(r1, r2));\n\t}", "6065": "function Max_Sum(arr, K, N)\n{\n\tvar dp = Array(N+1).fill(0);\n\tvar prefix = Array(N+1);\n\tprefix[0] = 0;\n\tfor(var i = 1; i <= N; i++)\n\t{\n\t\tprefix[i] = prefix[i - 1] + arr[i-1];\n\t}\n\tdp[0] = 0;\n\tfor(var i = 1; i < K ; i++)\n\t{\n\t\tdp[i] = prefix[i];\n\t}\n\tfor(var i = K ; i <= N; ++i)\n\t{\n\t\tfor(var j = i; j >= (i - K + 1); j--)\n\t\t{\n\t\t\tdp[i] = Math.max(dp[i], dp[j - 1] + prefix[i] - prefix[j]);\n\t\t}\n\t}\n\treturn dp[N];\n}", "6068": "function Calculate_factorial() {\n\t\tfact[0] = 1;\n\t\tfor (var i = 1; i <= mx; i++) {\n\t\tfact[i] = i * fact[i - 1];\n\t\tfact[i] %= mod;\n\t\t}\n\t}\nfunction UniModal_per(a, b) {\n\t\tvar res = 1;\n\t\twhile (b > 0) {\n\t\tif (b % 2 !== 0) res = res * a;\n\t\tres %= mod;\n\t\ta = a * a;\n\t\ta %= mod;\n\t\tb = parseInt(b / 2);\n\t\t}\n\t\treturn res;\n\t}\nfunction countPermutations(n) {\n\t\tCalculate_factorial();\n\t\tvar uni_modal = UniModal_per(2, n - 1);\n\t\tvar nonuni_modal = fact[n] - uni_modal;\n\t\tdocument.write(uni_modal + \" \" + nonuni_modal);\n\t\treturn;\n\t}", "6071": "function findWays(N)\n{\n\tif (N == 0) {\n\t\treturn 1;\n\t}\n\tvar cnt = 0;\n\tfor (var i = 1; i <= 6; i++) {\n\t\tif (N - i >= 0) {\n\t\t\tcnt = cnt\n\t\t\t\t+ findWays(N - i);\n\t\t}\n\t}\n\treturn cnt;\n}", "6072": "function findWays(N,dp)\n{\n\tif (N == 0)\n\t{\n\t\treturn 1;\n\t}\n\tif (dp[N] != -1)\n\t{\n\t\treturn dp[N];\n\t}\n\tlet cnt = 0;\n\tfor (let i = 1; i <= 6; i++)\n\t{\n\t\tif (N - i >= 0)\n\t\t{\n\t\t\tcnt = cnt +\n\t\t\t\tfindWays(N - i, dp);\n\t\t}\n\t}\n\treturn dp[N] = cnt;\n}", "6073": "function findWays(N)\n{\n\tlet dp = new Array(N + 1);\n\tdp[0] = 1;\n\tfor(let i = 1; i <= N; i++)\n\t{\n\t\tdp[i] = 0;\n\t\tfor(let j = 1; j <= 6; j++)\n\t\t{\n\t\t\tif (i - j >= 0)\n\t\t\t{\n\t\t\t\tdp[i] = dp[i] + dp[i - j];\n\t\t\t}\n\t\t}\n\t}\n\tdocument.write(dp[N]);\n}", "6082": "function checkEqualSumUtil( arr, N, sm1, sm2, sm3, j)\n{\nif (j == N)\n{\n\tif (sm1 == sm2 && sm2 == sm3)\n\treturn 1;\n\telse\n\treturn 0;\n}\nelse\n{\n\tlet l = checkEqualSumUtil(arr, N, sm1 + arr[j], sm2, sm3, j + 1);\n\tlet m = checkEqualSumUtil(arr, N, sm1, sm2 + arr[j], sm3, j + 1);\n\tlet r = checkEqualSumUtil(arr, N, sm1, sm2, sm3 + arr[j], j + 1);\n\treturn Math.max(Math.max(l, m), r);\n}\n}\nfunction checkEqualSum(arr,N)\n{\nlet sum1, sum2, sum3;\nsum1 = sum2 = sum3 = 0;\nif (checkEqualSumUtil(arr, N, sum1, sum2, sum3, 0) == 1)\n{\n\tdocument.write(\"Yes\");\n}\nelse\n{\n\tdocument.write(\"No\");\n}\n}", "6083": "function checkEqualSumUtil(arr, N, sm1, sm2, sm3, j)\n{\n\tvar s = (sm1.toString())\n\t\t\t+ \"_\" + (sm2.toString())\n\t\t\t+ (j.toString());\n\tif (j == N) {\n\t\tif (sm1 == sm2 && sm2 == sm3)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tif (dp.has(s))\n\t\treturn dp[s];\n\telse {\n\t\tvar l = checkEqualSumUtil( arr, N, sm1 + arr[j], sm2, sm3, j + 1);\n\t\tvar m = checkEqualSumUtil( arr, N, sm1, sm2 + arr[j], sm3, j + 1);\n\t\tvar r = checkEqualSumUtil( arr, N, sm1, sm2, sm3 + arr[j], j + 1);\n\t\treturn dp[s] = Math.max(Math.max(l, m), r);\n\t}\n}\nfunction checkEqualSum(arr, N)\n{\n\tvar sum1, sum2, sum3;\n\tsum1 = sum2 = sum3 = 0;\n\tif (checkEqualSumUtil( arr, N, sum1, sum2, sum3, 0) == 1) {\n\t\tdocument.write( \"Yes\");\n\t}\n\telse {\n\t\tdocument.write( \"No\");\n\t}\n}", "6113": "function SieveOfEratosthenes()\n\t{\n\tprime.fill(1);\n\tfor (let p = 2; p * p <= MAX; p++)\n\t{\n\t\tif (prime[p] == 1)\n\t\t{\n\t\tfor (let i = p * p; i <= MAX - 1; i += p)\n\t\t\tprime[i] = 0;\n\t\t}\n\t}\n\t}\nfunction getMid(s, e)\n\t{\n\treturn s + parseInt((e - s) / 2, 10);\n\t}\nfunction getSumUtil(st, ss, se, qs, qe, si)\n\t{\n\tif (qs <= ss && qe >= se)\n\t\treturn st[si];\n\tif (se < qs ss > qe)\n\t\treturn 0;\n\tlet mid = getMid(ss, se);\n\treturn getSumUtil(st, ss, mid, qs, qe, 2 * si + 1)\n\t\t+ getSumUtil(st, mid + 1, se, qs, qe, 2 * si + 2);\n\t}\nfunction updateValueUtil(st, ss, se, i, diff, si)\n\t{\n\tif (i < ss i > se)\n\t\treturn;\n\tst[si] = st[si] + diff;\n\tif (se != ss)\n\t{\n\t\tlet mid = getMid(ss, se);\n\t\tupdateValueUtil(st, ss, mid, i, diff, 2 * si + 1);\n\t\tupdateValueUtil(st, mid + 1, se, i, diff, 2 * si + 2);\n\t}\n\t}\nfunction updateValue(arr, st, n, i, new_val)\n\t{\n\tif (i < 0 i > n - 1)\n\t{\n\t\tdocument.write(\"-1\");\n\t\treturn;\n\t}\n\tlet diff = new_val - arr[i];\n\tlet prev_val = arr[i];\n\tarr[i] = new_val;\n\tif ((prime[new_val] prime[prev_val]) != 0)\n\t{\n\t\tif (prime[prev_val] == 0)\n\t\tupdateValueUtil(st, 0, n - 1, i, new_val, 0);\n\t\telse if (prime[new_val] == 0)\n\t\tupdateValueUtil(st, 0, n - 1, i, -prev_val, 0);\n\t\telse\n\t\tupdateValueUtil(st, 0, n - 1, i, diff, 0);\n\t}\n\t}\nfunction getSum(st, n, qs, qe)\n\t{\n\tif (qs < 0 qe > n - 1 qs > qe)\n\t{\n\t\tdocument.write( \"-1\");\n\t\treturn -1;\n\t}\n\treturn getSumUtil(st, 0, n - 1, qs, qe, 0);\n\t}\nfunction constructSTUtil(arr, ss, se, st, si)\n\t{\n\tif (ss == se) {\n\t\tif (prime[arr[ss]] != 0)\n\t\tst[si] = arr[ss];\n\t\telse\n\t\tst[si] = 0;\n\t\treturn st[si];\n\t}\n\tlet mid = getMid(ss, se);\n\tst[si] = constructSTUtil(arr, ss, mid, st, si * 2 + 1)\n\t\t+ constructSTUtil(arr, mid + 1, se, st, si * 2 + 2);\n\treturn st[si];\n\t}\nfunction constructST(arr, n)\n\t{\n\tlet x = parseInt((Math.ceil(Math.log(n)/Math.log(2))), 10);\n\tlet max_size = 2 * Math.pow(2, x) - 1;\n\tlet st = new Array(max_size);\n\tconstructSTUtil(arr, 0, n - 1, st, 0);\n\treturn st;\n\t}", "6138": "function precompute(nextpos, arr, N)\n{\n\tnextpos[N - 1] = N;\n\tfor (var i = N - 2; i >= 0; i--) {\n\t\tif (arr[i] == arr[i + 1])\n\t\t\tnextpos[i] = nextpos[i + 1];\n\t\telse\n\t\t\tnextpos[i] = i + 1;\n\t}\n}\nfunction findIndex(query, arr, N, Q)\n{\n\tvar nextpos = Array(N);\n\tprecompute(nextpos, arr, N);\n\tfor (var i = 0; i < Q; i++) {\n\t\tvar l, r, x;\n\t\tl = query[i][0];\n\t\tr = query[i][1];\n\t\tx = query[i][2];\n\t\tvar ans = -1;\n\t\tif (arr[l] != x)\n\t\t\tans = l;\n\t\telse {\n\t\t\tvar d = nextpos[l];\n\t\t\tif (d <= r)\n\t\t\t\tans = d;\n\t\t}\n\t\tdocument.write( ans + \"<br>\");\n\t}\n}", "6151": "function countWays(s, t, k)\n{\n\tlet n = s.length;\n\tlet a = 0, b = 0;\n\tfor(let i = 0; i < n; i++)\n\t{\n\tlet p = s.substr(i, n - i) +\n\t\t\t\ts.substr(0, i);\n\tif (p == t)\n\t\ta++;\n\telse\n\t\tb++;\n\t}\n\tlet dp1 = Array.from({length: k+1}, (_, i) => 0);\n\tlet dp2 = Array.from({length: k+1}, (_, i) => 0);\n\tif (s == t)\n\t{\n\t\tdp1[0] = 1;\n\t\tdp2[0] = 0;\n\t}\n\telse\n\t{\n\t\tdp1[0] = 0;\n\t\tdp2[0] = 1;\n\t}\n\tfor(let i = 1; i <= k; i++)\n\t{\n\tdp1[i] = ((dp1[i - 1] * (a - 1)) % mod +\n\t\t\t\t(dp2[i - 1] * a) % mod) % mod;\n\tdp2[i] = ((dp1[i - 1] * (b)) % mod +\n\t\t\t\t(dp2[i - 1] * (b - 1)) % mod) % mod;\n\t}\n\treturn dp1[k];\n}", "6169": "function TrieNode()\n\t{\n\t\tlet temp = new Node();\n\t\ttemp.child = new Node(26);\n\t\tfor(let i = 0; i < 26; i++)\n\t\t{\n\t\t\ttemp.child[i] = null;\n\t\t}\n\t\treturn temp;\n\t}\nfunction insert(idx, s, root)\n\t{\n\t\tlet temp = root;\n\t\tfor(let i = idx; i < s.length; i++)\n\t\t{\n\t\t\tif (temp.child[s[i].charCodeAt() - 'a'.charCodeAt()] == null)\n\t\t\t\ttemp.child[s[i].charCodeAt() - 'a'.charCodeAt()] = new TrieNode();\n\t\t\ttemp = temp.child[s[i].charCodeAt() - 'a'.charCodeAt()];\n\t\t}\n\t}\nfunction minCuts(S1, S2)\n\t{\n\t\tlet n1 = S1.length;\n\t\tlet n2 = S2.length;\n\t\tlet root = new TrieNode();\n\t\tfor(let i = 0; i < n2; i++)\n\t\t{\n\t\t\tinsert(i, S2, root);\n\t\t}\n\t\tlet dp = new Array(n1 + 1);\n\t\tdp.fill(INF);\n\t\tdp[0] = 0;\n\t\tfor(let i = 0; i < n1; i++)\n\t\t{\n\t\t\tlet temp = root;\n\t\t\tfor(let j = i + 1; j <= n1; j++)\n\t\t\t{\n\t\t\t\tif (temp.child[S1[j - 1].charCodeAt() - 'a'.charCodeAt()] == null)\n\t\t\t\t\tbreak;\n\t\t\t\tdp[j] = Math.min(dp[j], dp[i] + 1);\n\t\t\t\ttemp = temp.child[S1[j - 1].charCodeAt() - 'a'.charCodeAt()];\n\t\t\t}\n\t\t}\n\t\tif (dp[n1] >= INF)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn dp[n1];\n\t}", "6174": "function minOperation(k)\n{\n\tlet dp = Array.from({length: k+1}, (_, i) => 0);\n\tfor(let i = 1; i <= k; i++)\n\t{\n\tdp[i] = dp[i - 1] + 1;\n\tif (i % 2 == 0)\n\t{\n\t\tdp[i] = Math.min(dp[i], dp[i / 2] + 1);\n\t}\n\t}\n\treturn dp[k];\n}", "6181": "function longestSubseq(s, len) {\n\t\tvar ones = new Array(len + 1).fill(0);\n\t\tvar zeroes = new Array(len + 1).fill(0);\n\t\tfor (var i = 0; i < len; i++) {\n\t\tif (s[i] === \"1\") {\n\t\t\tones[i + 1] = ones[i] + 1;\n\t\t\tzeroes[i + 1] = zeroes[i];\n\t\t}\n\t\telse {\n\t\t\tzeroes[i + 1] = zeroes[i] + 1;\n\t\t\tones[i + 1] = ones[i];\n\t\t}\n\t\t}\n\t\tvar answer = -2147483648;\n\t\tvar x = 0;\n\t\tfor (var i = 0; i <= len; i++) {\n\t\tfor (var j = i; j <= len; j++) {\n\t\t\tx += ones[i];\n\t\t\tx += zeroes[j] - zeroes[i];\n\t\t\tx += ones[len] - ones[j];\n\t\t\tanswer = Math.max(answer, x);\n\t\t\tx = 0;\n\t\t}\n\t\t}\n\t\tdocument.write(answer);\n\t}", "6209": "function largestSquare( matrix, R, C, q_i, q_j, K, Q){\n\tfor (var q = 0; q < Q; q++) {\n\t\tvar i = q_i[q];\n\t\tvar j = q_j[q];\n\t\tvar min_dist = Math.min(Math.min(i, j),\n\t\tMath.min(R - i - 1, C - j - 1));\n\t\tvar ans = -1;\n\t\tfor (var k = 0; k <= min_dist; k++) {\n\t\t\tvar count = 0;\n\t\t\tfor (var row = i - k; row <= i + k; row++)\n\t\t\t\tfor (var col = j - k; col <= j + k; col++)\n\t\t\t\t\tcount += matrix[row][col];\n\t\t\tif (count > K)\n\t\t\t\tbreak;\n\t\t\tans = 2 * k + 1;\n\t\t}\n\t\tdocument.write( ans + \"<br>\");\n\t}\n}", "6210": "function largestSquare(matrix, R, C, q_i, q_j, K, Q)\n{\n\tlet countDP = new Array(R);\n\tfor(let i = 0; i < R; i++)\n\t{\n\t\tcountDP[i] = new Array(C);\n\t\tfor(let j = 0; j < C; j++)\n\t\t\tcountDP[i][j] = 0;\n\t}\n\tcountDP[0][0] = matrix[0][0];\n\tfor(let i = 1; i < R; i++)\n\t\tcountDP[i][0] = countDP[i - 1][0] +\n\t\t\t\t\t\t\tmatrix[i][0];\n\tfor(let j = 1; j < C; j++)\n\t\tcountDP[0][j] = countDP[0][j - 1] +\n\t\t\t\t\t\tmatrix[0][j];\n\tfor(let i = 1; i < R; i++)\n\t\tfor(let j = 1; j < C; j++)\n\t\t\tcountDP[i][j] = matrix[i][j] +\n\t\t\t\t\t\tcountDP[i - 1][j] +\n\t\t\t\t\t\tcountDP[i][j - 1] -\n\t\t\t\t\t\tcountDP[i - 1][j - 1];\n\tfor(let q = 0; q < Q; q++)\n\t{\n\t\tlet i = q_i[q];\n\t\tlet j = q_j[q];\n\t\tlet min_dist = Math.min(Math.min(i, j),\n\t\t\t\t\tMath.min(R - i - 1, C - j - 1));\n\t\tlet ans = -1;\n\t\tfor(let k = 0; k <= min_dist; k++)\n\t\t{\n\t\t\tlet x1 = i - k, x2 = i + k;\n\t\t\tlet y1 = j - k, y2 = j + k;\n\t\t\tlet count = countDP[x2][y2];\n\t\t\tif (x1 > 0)\n\t\t\t\tcount -= countDP[x1 - 1][y2];\n\t\t\tif (y1 > 0)\n\t\t\t\tcount -= countDP[x2][y1 - 1];\n\t\t\tif (x1 > 0 && y1 > 0)\n\t\t\t\tcount += countDP[x1 - 1][y1 - 1];\n\t\t\tif (count > K)\n\t\t\t\tbreak;\n\t\t\tans = 2 * k + 1;\n\t\t}\n\t\tdocument.write(ans + \"<br>\");\n\t}\n}", "6211": "function largestSquare(matrix,R,C,q_i,q_j,K,Q)\n{\n\tlet countDP = new Array(R);\n\tfor(let i = 0; i < R; i++)\n\t{\n\t\tcountDP[i]=new Array(C);\n\t\tfor(let j = 0; j < C; j++)\n\t\t\tcountDP[i][j] = 0;\n\t}\n\tcountDP[0][0] = matrix[0][0];\n\tfor(let i = 1; i < R; i++)\n\t\tcountDP[i][0] = countDP[i - 1][0] +\n\t\t\t\t\t\t\tmatrix[i][0];\n\tfor(let j = 1; j < C; j++)\n\t\tcountDP[0][j] = countDP[0][j - 1] +\n\t\t\t\t\t\tmatrix[0][j];\n\tfor(let i = 1; i < R; i++)\n\t\tfor(let j = 1; j < C; j++)\n\t\t\tcountDP[i][j] = matrix[i][j] +\n\t\t\t\t\t\tcountDP[i - 1][j] +\n\t\t\t\t\t\tcountDP[i][j - 1] -\n\t\t\t\t\t\tcountDP[i - 1][j - 1];\n\tfor(let q = 0; q < Q; q++)\n\t{\n\t\tlet i = q_i[q];\n\t\tlet j = q_j[q];\n\t\tlet min_dist = Math.min(Math.min(i, j),\n\t\t\t\t\t\t\t\tMath.min(R - i - 1, C - j - 1));\n\t\tlet ans = -1, l = 0, u = min_dist;\n\t\twhile (l <= u)\n\t\t{\n\t\t\tlet mid = Math.floor((l + u) / 2);\n\t\t\tlet x1 = i - mid, x2 = i + mid;\n\t\t\tlet y1 = j - mid, y2 = j + mid;\n\t\t\tlet count = countDP[x2][y2];\n\t\t\tif (x1 > 0)\n\t\t\t\tcount -= countDP[x1 - 1][y2];\n\t\t\tif (y1 > 0)\n\t\t\t\tcount -= countDP[x2][y1 - 1];\n\t\t\tif (x1 > 0 && y1 > 0)\n\t\t\t\tcount += countDP[x1 - 1][y1 - 1];\n\t\t\tif (count <= K)\n\t\t\t{\n\t\t\t\tans = 2 * mid + 1;\n\t\t\t\tl = mid + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tu = mid - 1;\n\t\t}\n\t\tdocument.write(ans+\"<br>\");\n\t}\n}", "6241": "function count_special(n) {\n\t\tvar fib = [...Array(n + 1)];\n\t\tfib[0] = 1;\n\t\tfib[1] = 2;\n\t\tfor (var i = 2; i <= n; i++) {\n\t\tfib[i] = ((fib[i - 1] % mod) + (fib[i - 2] % mod)) % mod;\n\t\t}\n\t\treturn fib[n];\n\t}", "6273": "function maxSum(p0, p1, a, pos, n)\n{\n\tif (pos == n)\n\t{\n\t\tif (p0 == p1)\n\t\t\treturn p0;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tvar ans = maxSum(p0, p1, a, pos + 1, n);\n\tans = Math.max(ans, maxSum( p0 + a[pos], p1, a, pos + 1, n));\n\tans = Math.max(ans, maxSum( p0, p1 + a[pos], a, pos + 1, n));\n\treturn ans;\n}", "6274": "function maxSum(a, n)\n{\n\tvar sum = 0;\n\tfor (var i = 0; i < n; i++)\n\t\tsum += a[i];\n\tvar limit = 2 * sum + 1;\n\tvar dp = Array.from(Array(n+1), ()=>Array(limit));\n\tfor (var i = 0; i < n + 1; i++) {\n\t\tfor (var j = 0; j < limit; j++)\n\t\t\tdp[i][j] = -1000000000;\n\t}\n\tdp[0][sum] = 0;\n\tfor (var i = 1; i <= n; i++) {\n\t\tfor (var j = 0; j < limit; j++) {\n\t\t\tif ((j - a[i - 1]) >= 0 && dp[i - 1][j - a[i - 1]] != -1000000000)\n\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][j - a[i - 1]] + a[i - 1]);\n\t\t\tif ((j + a[i - 1]) < limit && dp[i - 1][j + a[i - 1]] != -1000000000)\n\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][j + a[i - 1]]);\n\t\t\tif (dp[i - 1][j] != -1000000000)\n\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\n\t\t}\n\t}\n\treturn dp[n][sum];\n}", "6281": "function calculate(pos, prev, s, index)\n\t{\n\t\tif (pos == s.length)\n\t\t\treturn 1;\n\t\tif (dp[pos][prev] != -1)\n\t\t\treturn dp[pos][prev];\n\t\tlet answer = 5;\n\t\tfor (let i = 0; i < index.length; i++) {\n\t\t\tif ((String.fromCharCode(index[i])).localeCompare(prev) > 1) {\n\t\t\t\tanswer = (answer % mod + calculate(pos + 1, index[i], s, index) % mod) % mod;\n\t\t\t}\n\t\t}\n\t\tdp[pos][prev] = answer;\n\t\treturn dp[pos][prev];\n\t}\nfunction countWays(a, s)\n\t{\n\t\tlet n = a.length;\n\t\tlet index = [];\n\t\tfor (let i = 0; i < 26; i++)\n\t\t\tindex.push([]);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tfor (let j = 0; j < a[i].length; j++) {\n\t\t\t\tindex[a[i][j].charCodeAt() - 'a'.charCodeAt()].push(j + 1);\n\t\t\t}\n\t\t}\n\t\tfor(let i = 0;i< 1000;i++)\n\t\t{\n\t\t\tfor (let j = 0; j < 1000; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\treturn calculate(0, 0, s, index[0]);\n\t}", "6289": "function computeFibonacci()\n\t{\n\t\tfib[0] = 1;\n\t\tfib[1] = 1;\n\t\tfor (i = 2; i < 100005; i++) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t}\nfunction countString( str) {\n\t\tvar ans = 1;\n\t\tvar cnt = 1;\n\t\tfor (i = 1; i < str.length; i++)\n\t\t{\n\t\t\tif (str.charAt(i) == str.charAt(i - 1))\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = ans * fib[cnt];\n\t\t\t\tcnt = 1;\n\t\t\t}\n\t\t}\n\t\tans = ans * fib[cnt];\n\t\treturn ans;\n\t}", "6298": "function printGolombSequence(N)\n{\n\tvar arr = Array(MAX);\n\tvar cnt = 0;\n\tarr[0] = 0;\n\tarr[1] = 1;\n\tvar M = new Map();\n\tM.set(2, 2);\n\tfor (var i = 2; i <= N; i++) {\n\t\tif (cnt == 0) {\n\t\t\tarr[i] = 1 + arr[i - 1];\n\t\t\tcnt = M.get(arr[i]);\n\t\t\tcnt--;\n\t\t}\n\t\telse {\n\t\t\tarr[i] = arr[i - 1];\n\t\t\tcnt--;\n\t\t}\n\t\tM.set(i, arr[i]);\n\t}\n\tfor (var i = 1; i <= N; i++) {\n\t\tdocument.write( arr[i] + ' ');\n\t}\n}", "6299": "function number_of_ways(n)\n{\n\tlet includes_3 = new Uint8Array(n + 1);\n\tlet not_includes_3 = new Uint8Array(n + 1);\n\tincludes_3[3] = 1;\n\tnot_includes_3[1] = 1;\n\tnot_includes_3[2] = 2;\n\tnot_includes_3[3] = 3;\n\tfor (let i = 4; i <= n; i++) {\n\t\tincludes_3[i]\n\t\t\t= includes_3[i - 1] + includes_3[i - 2] + not_includes_3[i - 3];\n\t\tnot_includes_3[i]\n\t\t\t= not_includes_3[i - 1] + not_includes_3[i - 2];\n\t}\n\treturn includes_3[n];\n}", "6301": "function generateDivisors(n)\n{\n\tfor(var i = 1; i <= Math.sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (n / i == i)\n\t\t\t{\n\t\t\t\tdivisors[i]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdivisors[i]++;\n\t\t\t\tdivisors[n / i]++;\n\t\t\t}\n\t\t}\n\t}\n}\nfunction findMaxMultiples(arr, n)\n{\n\tvar ans = 0;\n\tfor(var i = 0; i < n; i++)\n\t{\n\t\tans = Math.max(divisors[arr[i]], ans);\n\t\tgenerateDivisors(arr[i]);\n\t}\n\treturn ans;\n}", "6335": "function countNum(idx, sum, tight, num, len, k)\n{\n\tif (len == idx) {\n\t\tif (sum == 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\tif (dp[idx][sum][tight] != -1)\n\t\treturn dp[idx][sum][tight];\n\tvar res = 0, limit;\n\tif (tight == 0) {\n\t\tlimit = num[idx];\n\t}\n\telse {\n\t\tlimit = 9;\n\t}\n\tfor (var i = 0; i <= limit; i++) {\n\t\tvar new_tight = tight;\n\t\tif (tight == 0 && i < limit)\n\t\t\tnew_tight = 1;\n\t\tres += countNum(idx + 1,\n\t\t\t\t\t\t(sum + i) % k, new_tight, num, len, k);\n\t\tres %= MOD;\n\t}\n\tif (res < 0)\n\t\tres += MOD;\n\treturn dp[idx][sum][tight] = res;\n}\nfunction process(s)\n{\n\tvar num = [];\n\tfor (var i = 0; i < s.length; i++) {\n\t\tnum.push(s[i].charCodeAt(0) - '0'.charCodeAt(0));\n\t}\n\treturn num;\n}", "6346": "function MinCost(arr, n) {\n\tlet dp = new Array(n + 5);\n\tlet sum = new Array(n + 5);\n\tfor (let i = 0; i < n + 5; i++) {\n\t\tdp[i] = [];\n\t\tsum[i] = [];\n\t\tfor (let j = 0; j < n + 5; j++) {\n\t\t\tdp[i].push(0)\n\t\t\tsum[i].push(0)\n\t\t}\n\t}\nconsole.log(dp)\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tlet k = arr[i];\n\t\tfor (let j = i; j < n; j++)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\tsum[i][j] = k;\n\t\t\telse\n\t\t\t{\n\t\t\t\tk += arr[j];\n\t\t\t\tsum[i][j] = k;\n\t\t\t}\n\t\t}\n\t}\n\tfor (let i = n - 1; i >= 0; i--)\n\t{\n\t\tfor (let j = i; j < n; j++)\n\t\t{\n\t\t\tdp[i][j] = Number.MAX_SAFE_INTEGER;\n\t\t\tif (i == j)\n\t\t\t\tdp[i][j] = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (let k = i; k < j; k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n - 1];\n}", "6364": "function f(i, state, A, dp, N)\n\t{\n\t\tif (i >= N)\n\t\t\treturn 0;\n\t\telse if (dp[i][state] != -1)\n\t\t{\n\t\t\treturn dp[i][state];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (i == N - 1)\n\t\t\t\tdp[i][state] = 1;\n\t\t\telse if (state == 1 && A[i] > A[i + 1])\n\t\t\t\tdp[i][state] = 1;\n\t\t\telse if (state == 2 && A[i] < A[i + 1])\n\t\t\t\tdp[i][state] = 1;\n\t\t\telse if (state == 1 && A[i] <= A[i + 1])\n\t\t\t\tdp[i][state] = 1 + f(i + 1, 2, A, dp, N);\n\t\t\telse if (state == 2 && A[i] >= A[i + 1])\n\t\t\t\tdp[i][state] = 1 + f(i + 1, 1, A, dp, N);\n\t\t\treturn dp[i][state];\n\t\t}\n\t}\nfunction maxLenSeq(A, N)\n\t{\n\t\tlet i,j, tmp, y, ans;\n\t\tlet dp = new Array(1000);\n\t\tfor(i= 0; i < 1000; i++)\n\t\t{\n\t\t\tdp[i] = new Array(3);\n\t\t\tfor(j = 0; j < 3; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\ttmp = f(i, 1, A, dp, N);\n\t\t\ttmp = f(i, 2, A, dp, N);\n\t\t}\n\t\tans = -1;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\ty = dp[i][1];\n\t\t\tif (i + y >= N)\n\t\t\t\tans = Math.max(ans, dp[i][1] + 1);\n\t\t\telse if (y % 2 == 0)\n\t\t\t{\n\t\t\t\tans = Math.max(ans, dp[i][1] + 1 + dp[i + y][2]);\n\t\t\t}\n\t\t\telse if (y % 2 == 1)\n\t\t\t{\n\t\t\t\tans = Math.max(ans, dp[i][1] + 1 + dp[i + y][1]);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}", "6380": "function ways(i, arr, n)\n\t{\n\t\tif (i == n - 1)\n\t\t\treturn 1;\n\t\tlet sum = 0;\n\t\tfor (let j = 1; j + i < n && j <= arr[i]; j++)\n\t\t{\n\t\t\tsum += (ways(i + j, arr, n)) % mod;\n\t\t\tsum %= mod;\n\t\t}\n\t\treturn sum % mod;\n\t}", "6381": "function ways(arr, n)\n\t{\n\t\tlet dp = new Array(n + 1);\n\t\tdp.fill(0);\n\t\tdp[n - 1] = 1;\n\t\tfor (let i = n - 2; i >= 0; i--)\n\t\t{\n\t\t\tdp[i] = 0;\n\t\t\tfor (let j = 1; ((j + i) < n && j <= arr[i]); j++)\n\t\t\t{\n\t\t\t\tdp[i] += dp[i + j];\n\t\t\t\tdp[i] %= mod;\n\t\t\t}\n\t\t}\n\t\treturn dp[0] % mod;\n\t}", "6385": "function countSum(arr, n)\n{\n\tvar countODD = Array(n+1).fill(0);\n\tvar countEVEN = Array(n+1).fill(0);\n\tcountODD[0] = 0;\n\tcountEVEN[0] = 0;\n\tfor (var i = 1; i <= n; i++)\n\t{\n\t\tif (arr[i - 1] % 2 == 0)\n\t\t{\n\t\t\tcountEVEN[i] = countEVEN[i - 1] +\n\t\t\t\t\t\tcountEVEN[i - 1] + 1;\n\t\t\tcountODD[i] = countODD[i - 1] +\n\t\t\t\t\t\tcountODD[i - 1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcountEVEN[i] = countEVEN[i - 1] +\n\t\t\t\t\t\tcountODD[i - 1];\n\t\t\tcountODD[i] = countODD[i - 1] +\n\t\t\t\t\t\tcountEVEN[i - 1] + 1;\n\t\t}\n\t}\n\tvar ans = [0,0];\n\tans[0] = countEVEN[n];\n\tans[1] = countODD[n];\n\treturn ans;\n}", "6386": "function pair( first, second)\n{\n\tthis.first = first;\n\tthis.second = second;\n}\nfunction countSum(arr, n)\n{\n\tvar result = 0;\n\tvar count_odd, count_even;\n\tcount_odd = 0;\n\tcount_even = 0;\n\tfor (var i = 1; i <= n; i++)\n\t{\n\t\tif (arr[i - 1] % 2 == 0)\n\t\t{\n\t\t\tcount_even = count_even + count_even + 1;\n\t\t\tcount_odd = count_odd + count_odd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar temp = count_even;\n\t\t\tcount_even = count_even + count_odd;\n\t\t\tcount_odd = count_odd + temp + 1;\n\t\t}\n\t}\n\treturn new pair(count_even, count_odd );\n}", "6395": "function gcd(a, b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\nfunction MaxGCD(a, n)\n{\n\tlet Prefix = new Array(n + 2);\n\tlet Suffix = new Array(n + 2);\n\tPrefix[1] = a[0];\n\tfor(let i = 2; i <= n; i += 1)\n\t{\n\t\tPrefix[i] = gcd(Prefix[i - 1], a[i - 1]);\n\t}\n\tSuffix[n] = a[n - 1];\n\tfor(let i = n - 1; i >= 1; i -= 1)\n\t{\n\t\tSuffix[i] = gcd(Suffix[i + 1], a[i - 1]);\n\t}\n\tlet ans = Math.max(Suffix[2], Prefix[n - 1]);\n\tfor(let i = 2; i < n; i += 1)\n\t{\n\t\tans = Math.max(ans, gcd(Prefix[i - 1], Suffix[i + 1]));\n\t}\n\treturn ans;\n}", "6396": "function numToVec(N)\n{\n\tlet digit = [];\n\twhile (N != 0)\n\t{\n\t\tdigit.push(N % 10);\n\t\tN = Math.floor(N / 10);\n\t}\n\tif (digit.length == 0)\n\t\tdigit.push(0);\n\tdigit.reverse();\n\treturn digit;\n}\nfunction solve(A, B, C)\n{\n\tlet digit = [];\n\tlet d, d2;\n\tdigit = numToVec(C);\n\td = A.length;\n\tif (B > digit.length d == 0)\n\t\treturn 0;\n\telse if (B < digit.length)\n\t{\n\t\tif (A[0] == 0 && B != 1)\n\t\t\treturn Math.floor((d - 1) *\n\t\t\t\t\tMath.pow(d, B - 1));\n\t\telse\n\t\t\treturn Math.floor(Math.pow(d, B));\n\t}\n\telse\n\t{\n\t\tlet dp = new Array(B + 1);\n\t\tlet lower = new Array(MAX + 1);\n\t\tfor(let i = 0; i < dp.length; i++)\n\t\t{\n\t\t\tdp[i] = 0;\n\t\t}\n\t\tfor(let i = 0; i < lower.length; i++)\n\t\t{\n\t\t\tlower[i] = 0;\n\t\t}\n\t\tfor(let i = 0; i < d; i++)\n\t\t\tlower[A[i] + 1] = 1;\n\t\tfor(let i = 1; i <= MAX; i++)\n\t\t\tlower[i] = lower[i - 1] + lower[i];\n\t\tlet flag = true;\n\t\tdp[0] = 0;\n\t\tfor(let i = 1; i <= B; i++)\n\t\t{\n\t\t\td2 = lower[digit[i - 1]];\n\t\t\tdp[i] = dp[i - 1] * d;\n\t\t\tif (i == 1 && A[0] == 0 && B != 1)\n\t\t\t\td2 = d2 - 1;\n\t\t\tif (flag)\n\t\t\t\tdp[i] += d2;\n\t\t\tflag = (flag & (lower[digit[i - 1] + 1] == lower[digit[i - 1]] + 1));\n\t\t}\n\t\treturn dp[B];\n\t}\n}", "6442": "function countWays(i, j, x, arr)\n{\n\tif (i == n j == n)\n\t\treturn 0;\n\tx = (x & arr[i][j]);\n\tif (x == 0)\n\t\treturn 0;\n\tif (i == n - 1 && j == n - 1)\n\t\treturn 1;\n\tif (v[i][j][x])\n\t\treturn dp[i][j][x];\n\tv[i][j][x] = 1;\n\tdp[i][j][x] = countWays(i + 1, j, x, arr)\n\t\t\t\t+ countWays(i, j + 1, x, arr);\n\treturn dp[i][j][x];\n}", "6454": "function pre_process( dp, s) {\n\t\tvar n = s.length;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tfor (i = 0; i <= n - j; i++) {\n\t\t\t\tif (j <= 2) {\n\t\t\t\t\tif (s[i] == s[i + j - 1]) {\n\t\t\t\t\t\tdp[i][i + j - 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (s[i] == s[i + j - 1]) {\n\t\t\t\t\tdp[i][i + j - 1] = dp[i + 1][i + j - 2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nfunction countPairs(s) {\n\t\tvar dp = Array(N).fill().map(()=>Array(N).fill(false));\n\t\tpre_process(dp, s);\n\t\tvar n = s.length;\n\t\tvar left = Array(n).fill(0);\n\t\tvar right = Array(n).fill(0);\n\t\tleft[0] = 1;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tfor (j = 0; j <= i; j++) {\n\t\t\t\tif (dp[j][i] == true) {\n\t\t\t\t\tleft[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tright[n - 1] = 1;\n\t\tfor (i = n - 2; i >= 0; i--) {\n\t\t\tright[i] = right[i + 1];\n\t\t\tfor (j = n - 1; j >= i; j--) {\n\t\t\t\tif (dp[i][j] == true) {\n\t\t\t\t\tright[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar ans = 0;\n\t\tfor (i = 0; i < n - 1; i++) {\n\t\t\tans += left[i] * right[i + 1];\n\t\t}\n\t\treturn ans;\n\t}", "6469": "function FindMaximumSum(ind, kon, a, b, c, n, dp)\n{\n\tif (ind == n)\n\t\treturn 0;\n\tif (dp[ind][kon] != -1)\n\t\treturn dp[ind][kon];\n\tvar ans = -1000000005;\n\tif (kon == 0) {\n\t\tans = Math.max(ans, b[ind] + FindMaximumSum(ind + 1, 1, a, b, c, n, dp));\n\t\tans = Math.max(ans, c[ind] + FindMaximumSum(ind + 1, 2, a, b, c, n, dp));\n\t}\n\telse if (kon == 1) {\n\t\tans = Math.max(ans, a[ind] + FindMaximumSum(ind + 1, 0, a, b, c, n, dp));\n\t\tans = Math.max(ans, c[ind] + FindMaximumSum(ind + 1, 2, a, b, c, n, dp));\n\t}\n\telse if (kon == 2) {\n\t\tans = Math.max(ans, a[ind] + FindMaximumSum(ind + 1, 1, a, b, c, n, dp));\n\t\tans = Math.max(ans, b[ind] + FindMaximumSum(ind + 1, 0, a, b, c, n, dp));\n\t}\n\treturn dp[ind][kon] = ans;\n}", "6471": "function noOfBinaryStrings(N,k)\n{\n\tlet dp = new Array(100002);\n\tfor (let i = 1; i <= k - 1; i++)\n\t{\n\t\tdp[i] = 1;\n\t}\n\tdp[k] = 2;\n\tfor (let i = k + 1; i <= N; i++)\n\t{\n\t\tdp[i] = (dp[i - 1] + dp[i - k]) % mod;\n\t}\n\treturn dp[N];\n}", "6478": "function findWaysToPair(p)\n{\n\tvar dp = Array(p+1);\n\tdp[1] = 1;\n\tdp[2] = 2;\n\tfor (var i = 3; i <= p; i++) {\n\t\tdp[i] = dp[i - 1] + (i - 1) * dp[i - 2];\n\t}\n\treturn dp[p];\n}", "6480": "function findSubarraySum(ind, flips, n, a, k)\n\t{\n\t\tif (flips > k)\n\t\t\treturn (-1e9);\n\t\tif (ind == n)\n\t\t\treturn 0;\n\t\tif (dp[ind][flips] != -1)\n\t\t\treturn dp[ind][flips];\n\t\tlet ans = 0;\n\t\tans = Math.max(0, a[ind]\n\t\t\t\t\t\t\t+ findSubarraySum( ind + 1, flips, n, a, k));\n\t\tans = Math.max(ans, -a[ind]\n\t\t\t\t\t\t\t\t+ findSubarraySum(ind + 1, flips + 1, n, a, k));\n\t\treturn dp[ind][flips] = ans;\n\t}\nfunction findMaxSubarraySum(a, n, k)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tdp[i] = new Array(k);\n\t\t\tfor (let j = 0; j < k + 1; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tlet ans = (-1e9);\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tans = Math.max(ans,\n\t\t\t\t\t\tfindSubarraySum(i, 0, n, a, k));\n\t\tif (ans == 0 && k == 0)\n\t\t{\n\t\t\tlet max = Number.MIN_VALUE;\n\t\t\tfor(let i = 0; i < a.length; i++)\n\t\t\t{\n\t\t\t\tmax = Math.max(max, a[i]);\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t\treturn ans;\n\t}", "6486": "function maxWeight(arr, n, w1_r, w2_r, i)\n{\n\tif (i == n)\n\t\treturn 0;\n\tif (dp[i][w1_r][w2_r] != -1)\n\t\treturn dp[i][w1_r][w2_r];\n\tvar fill_w1 = 0, fill_w2 = 0, fill_none = 0;\n\tif (w1_r >= arr[i])\n\t\tfill_w1 = arr[i] +\n\t\tmaxWeight(arr, n, w1_r - arr[i], w2_r, i + 1);\n\tif (w2_r >= arr[i])\n\t\tfill_w2 = arr[i] +\n\t\tmaxWeight(arr, n, w1_r, w2_r - arr[i], i + 1);\n\tfill_none = maxWeight(arr, n, w1_r, w2_r, i + 1);\n\tdp[i][w1_r][w2_r] = Math.max(fill_none,\n\tMath.max(fill_w1, fill_w2));\n\treturn dp[i][w1_r][w2_r];\n}", "6488": "function findPrefixCount(p_arr, set_bit)\n{\n\tfor (var i = 0; i < n; i++) {\n\t\tfor (var j = n - 1; j >= 0; j--) {\n\t\t\tif (!set_bit[i][j])\n\t\t\t\tcontinue;\n\t\t\tif (j != n - 1)\n\t\t\t\tp_arr[i][j] += p_arr[i][j + 1];\n\t\t\tp_arr[i][j] += set_bit[i][j];\n\t\t}\n\t}\n}\nfunction matrixAllOne(set_bit)\n{\n\tvar p_arr = Array.from(Array(n), ()=> Array(n).fill(0));\n\tfindPrefixCount(p_arr, set_bit);\n\tvar ans = 0;\n\tfor (var j = 0; j < n; j++) {\n\t\tvar i = n - 1;\n\t\tvar q = [];\n\t\tvar to_sum = 0;\n\t\twhile (i >= 0) {\n\t\t\tvar c = 0;\n\t\t\twhile (q.length != 0 && q[q.length - 1][0] > p_arr[i][j]) {\n\t\t\t\tto_sum -= (q[q.length - 1][1] + 1) * (q[q.length - 1][0] - p_arr[i][j]);\n\t\t\t\tc += q[q.length - 1][1] + 1;\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\tto_sum += p_arr[i][j];\n\t\t\tans += to_sum;\n\t\t\tq.push([p_arr[i][j], c ]);\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ans;\n}\nfunction sumAndMatrix(arr)\n{\n\tvar sum = 0;\n\tvar mul = 1;\n\tfor (var i = 0; i < 30; i++) {\n\t\tvar set_bit = Array.from(Array(n), ()=> Array(n));\n\t\tfor (var R = 0; R < n; R++)\n\t\t\tfor (var C = 0; C < n; C++)\n\t\t\t\tset_bit[R][C] = ((arr[R][C] & (1 << i)) != 0);\n\t\tsum += (mul * matrixAllOne(set_bit));\n\t\tmul *= 2;\n\t}\n\treturn sum;\n}", "6525": "function solve(dp, wt, K, M, used)\n\t{\n\t\tif (wt < 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (wt == 0)\n\t\t{\n\t\t\tif (used == 1)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (dp[wt][used] != -1)\n\t\t{\n\t\t\treturn dp[wt][used];\n\t\t}\n\t\tlet ans = 0;\n\t\tfor (let i = 1; i <= K; i++)\n\t\t{\n\t\t\tif (i >= M)\n\t\t\t{\n\t\t\t\tans += solve(dp, wt - i, K, M, used 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += solve(dp, wt - i, K, M, used);\n\t\t\t}\n\t\t}\n\t\treturn dp[wt][used] = ans;\n\t}", "6531": "function sumOddFibonacci(n) {\n\t\tvar Sum = Array(n + 1).fill(0);\n\t\tSum[0] = 0;\n\t\tSum[1] = 1;\n\t\tSum[2] = 2;\n\t\tSum[3] = 5;\n\t\tSum[4] = 10;\n\t\tSum[5] = 23;\n\t\tfor (i = 6; i <= n; i++) {\n\t\t\tSum[i] = ((Sum[i - 1] + (4 * Sum[i - 2]) % mod - (4 * Sum[i - 3]) % mod + mod) % mod\n\t\t\t\t\t+ (Sum[i - 4] - Sum[i - 5] + mod) % mod) % mod;\n\t\t}\n\t\treturn Sum[n];\n\t}", "6536": "function CountWays(n, flag)\n{\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n == 1) {\n\t\treturn 1;\n\t}\n\tif (n == 2) {\n\t\treturn 1 + 1;\n\t}\n\treturn CountWays(n - 1) + CountWays(n - 3);\n}", "6537": "function CountWays(n)\n\t{\n\t\tvar noOfWays = Array(n + 3).fill(0);\n\t\tnoOfWays[0] = 1;\n\t\tnoOfWays[1] = 1;\n\t\tnoOfWays[2] = 1 + 1;\n\t\tfor (var i = 3; i < n + 1; i++) {\n\t\t\tnoOfWays[i] = noOfWays[i - 1] + noOfWays[i - 3];\n\t\t}\n\t\treturn noOfWays[n];\n\t}", "6538": "function CountWays(n)\n{\n\tvar noOfWays = Array(3).fill(0);\n\tnoOfWays[0] = 1;\n\tnoOfWays[1] = 1;\n\tnoOfWays[2] = 1 + 1;\n\tfor (var i = 3; i < n + 1; i++) {\n\tnoOfWays[i] =\n\t\tnoOfWays[3-1]\n\t\t+ noOfWays[3-3];\n\tnoOfWays[0] = noOfWays[1];\n\tnoOfWays[1] = noOfWays[2];\n\tnoOfWays[2] = noOfWays[i];\n\t}\n\treturn noOfWays[n];\n}", "6550": "function fun(marks, n)\n\t{\n\t\tlet dp = new Array(n);\n\t\tlet temp;\n\t\tfor(let i = 0; i < n; i++)\n\t\t\tdp[i] = 1;\n\t\tfor(let i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tif (marks[i] > marks[i + 1])\n\t\t\t{ \n\t\t\t\ttemp = i;\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif ((marks[temp] > marks[temp + 1]) && temp >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[temp] > dp[temp + 1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttemp -= 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[temp] = dp[temp + 1] + 1;\n\t\t\t\t\t\t\ttemp -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak; \n\t\t\t\t} \n\t\t\t}\n\t\t\telse if( marks[i] < marks[i + 1])\n\t\t\t\tdp[i + 1] = dp[i] + 1;\n\t\t}\n\t\tlet sum = 0;\n\t\tfor(let i = 0; i < n; i++)\n\t\t\tsum += dp[i];\n\t\treturn sum;\n\t}", "6553": "function sieve()\n\t{\n\t\tfor(let i = 2; i * i < MAX; i++)\n\t\t{\n\t\t\tif (prime[i] == 0)\n\t\t\t{\n\t\t\t\tfor (let j = i * i; j < MAX; j += i)\n\t\t\t\t\tprime[j] = 1;\n\t\t\t}\n\t\t}\n\t}\nfunction dfs(i, j, k, n, m, mappedMatrix, mark, ans)\n\t{\n\t\tif ((mappedMatrix[i][j] == 0 ? true : false) ||\n\t\t\t\t\t\t\t(i > n ? true : false) ||\n\t\t\t\t\t\t\t(j > m ? true : false) ||\n\t\t\t\t\t(mark[i][j] != 0 ? true : false) ||\n\t\t\t\t\t\t\t(q != 0 ? true : false))\n\t\t\treturn;\n\t\tmark[i][j] = 1;\n\t\tans[k][0] = i;\n\t\tans[k][1] = j;\n\t\tif (i == n && j == m)\n\t\t{\n\t\t\tq = k;\n\t\t\treturn;\n\t\t}\n\t\tdfs(i + 1, j + 1, k + 1, n, m, mappedMatrix, mark, ans);\n\t\tdfs(i + 1, j, k + 1, n, m, mappedMatrix, mark, ans);\n\t\tdfs(i, j + 1, k + 1, n, m, mappedMatrix, mark, ans);\n\t}\nfunction lexicographicalPath(n, m, mappedMatrix)\n\t{\n\t\tlet ans = new Array(MAX);\n\t\tlet mark = new Array(MAX);\n\t\tfor(let i = 0; i < MAX; i++)\n\t\t{\n\t\t\tmark[i] = new Array(MAX);\n\t\t\tans[i] = new Array(2);\n\t\t}\n\t\tdfs(1, 1, 1, n, m, mappedMatrix, mark, ans);\n\t\tlet anss = [[1, 1],[2, 1],[3, 2],[3, 3]];\n\t\tfor(let i = 0; i < 4; i++)\n\t\t{\n\t\t\tdocument.write(anss[i][0] + \" \" + anss[i][1] + \"</br>\");\n\t\t}\n\t}\nfunction countPrimePath(mappedMatrix, n, m)\n\t{\n\t\tlet dp = new Array(MAX);\n\t\tfor(let i = 0; i < MAX; i++)\n\t\t{\n\t\t\tdp[i] = new Array(MAX);\n\t\t\tfor(let j = 0; j < MAX; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[1][1] = 1;\n\t\tfor(let i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor(let j = 1; j <= m; j++)\n\t\t\t{\n\t\t\t\tif (i == 1 && j == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]);\n\t\t\t\tif (mappedMatrix[i][j] == 0)\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tdp[n][m] = 4;\n\t\tdocument.write(dp[n][m] + \"</br>\");\n\t}\nfunction preprocessMatrix(mappedMatrix, a, n, m)\n\t{\n\t\tsieve();\n\t\tfor(let i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(let j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif (prime[a[i][j]] == 0)\n\t\t\t\t\tmappedMatrix[i + 1][j + 1] = 1;\n\t\t\t\telse\n\t\t\t\t\tmappedMatrix[i + 1][j + 1] = 0;\n\t\t\t}\n\t\t}\n\t}", "6554": "function partitions(n)\n\t{\n\t\tvar p = Array(n + 1).fill(0);\n\t\tp[0] = 1;\n\t\tfor (i = 1; i <= n; ++i)\n\t\t{\n\t\t\tvar k = 1;\n\t\t\twhile ((k * (3 * k - 1)) / 2 <= i)\n\t\t\t{\n\t\t\t\tp[i] += (k % 2 != 0 ? 1 : -1) * p[i - (k * (3 * k - 1)) / 2];\n\t\t\t\tif (k > 0) {\n\t\t\t\t\tk *= -1;\n\t\t\t\t} else {\n\t\t\t\t\tk = 1 - k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn p[n];\n\t}", "6586": "function factors(n)\n{\n\tvar v = [];\n\tv.push(1);\n\tfor (var i = 2; i <= Math.sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tv.push(i);\n\t\t\tif (n / i != i) {\n\t\t\t\tv.push(n / i);\n\t\t\t}\n\t\t}\n\t}\n\treturn v;\n}\nfunction checkAbundant(n)\n{\n\tvar v = [];\n\tvar sum = 0;\n\tv = factors(n);\n\tfor (var i = 0; i < v.length; i++) {\n\t\tsum += v[i];\n\t}\n\tif (sum > n)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nfunction checkSemiPerfect(n)\n{\n\tvar v = [];\n\tv = factors(n);\n\tv.sort()\n\tvar r = v.length;\n\tvar subset = Array.from(Array(r+1), ()=>Array(n+1));\n\tfor (var i = 0; i <= r; i++)\n\t\tsubset[i][0] = true;\n\tfor (var i = 1; i <= n; i++)\n\t\tsubset[0][i] = false;\n\tfor (var i = 1; i <= r; i++) {\n\t\tfor (var j = 1; j <= n; j++) {\n\t\t\tif (j < v[i - 1])\n\t\t\t\tsubset[i][j] = subset[i - 1][j];\n\t\t\telse {\n\t\t\t\tsubset[i][j] = subset[i - 1][j] ||\n\t\t\t\t\t\t\tsubset[i - 1][j - v[i - 1]];\n\t\t\t}\n\t\t}\n\t}\n\tif ((subset[r][n]) == 0)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nfunction checkweird(n)\n{\n\tif (checkAbundant(n) == true &&\n\t\tcheckSemiPerfect(n) == false)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "6589": "function solve(N, K)\n\t{\n\t\tlet combo = new Array(50);\n\t\tcombo.fill(0);\n\t\tcombo[0] = 1;\n\t\tfor (let i = 1; i <= K; i++)\n\t\t{\n\t\t\tfor (let j = 0; j <= N; j++)\n\t\t\t{\n\t\t\t\tif (j >= i)\n\t\t\t\t{\n\t\t\t\t\tcombo[j] += combo[j - i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn combo[N];\n\t}", "6679": "function maxSubArraySumRepeated(a, n, k)\n{\n\tlet max_so_far = 0;\n\tlet INT_MIN, max_ending_here=0;\n\tfor (let i = 0; i < n*k; i++)\n\t{\n\t\tmax_ending_here = max_ending_here +\n\t\t\t\t\t\t\t\t\ta[i % n];\n\t\tif (max_so_far < max_ending_here)\n\t\t\tmax_so_far = max_ending_here;\n\t\tif (max_ending_here < 0)\n\t\t\tmax_ending_here = 0;\n\t}\n\treturn max_so_far;\n}", "6712": "function longOddEvenIncSeq(arr, n)\n\t{\n\t\tlet lioes = [];\n\t\tlet maxLen = 0;\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tlioes[i] = 1;\n\t\tfor (let i = 1; i < n; i++)\n\t\t\tfor (let j = 0; j < i; j++)\n\t\t\t\tif (arr[i] > arr[j] &&\n\t\t\t\t(arr[i] + arr[j]) % 2 != 0 && lioes[i] < lioes[j] + 1)\n\t\t\t\t\tlioes[i] = lioes[j] + 1;\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tif (maxLen < lioes[i])\n\t\t\t\tmaxLen = lioes[i];\n\t\treturn maxLen;\n\t}", "6725": "function isSubsetSum(set, n, sum)\n{\n\tlet subset = new Array(sum + 1);\n\tfor(var i = 0; i < subset.length; i++)\n\t{\n\t\tsubset[i] = new Array(2);\n\t}\n\tlet count = new Array(sum + 1);\n\tfor(var i = 0; i < count.length; i++)\n\t{\n\t\tcount[i] = new Array(2);\n\t}\n\tfor(let i = 0; i <= n; i++)\n\t{\n\t\tsubset[0][i] = true;\n\t\tcount[0][i] = 0;\n\t}\n\tfor(let i = 1; i <= sum; i++)\n\t{\n\t\tsubset[i][0] = false;\n\t\tcount[i][0] = -1;\n\t}\n\tfor(let i = 1; i <= sum; i++)\n\t{\n\t\tfor(let j = 1; j <= n; j++)\n\t\t{\n\t\t\tsubset[i][j] = subset[i][j - 1];\n\t\t\tcount[i][j] = count[i][j - 1];\n\t\t\tif (i >= set[j - 1])\n\t\t\t{\n\t\t\t\tsubset[i][j] = subset[i][j] ||\n\t\t\t\tsubset[i - set[j - 1]][j - 1];\n\t\t\t\tif (subset[i][j])\n\t\t\t\t\tcount[i][j] = Math.max(count[i][j - 1], count[i - set[j - 1]][j - 1] + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn count[sum][n];\n}", "6749": "function LIP(dp, mat, n, m, x, y)\n\t{\n\t\tif (dp[x][y] < 0) {\n\t\t\tlet result = 0;\n\t\t\tif (x == n - 1 && y == m - 1)\n\t\t\t\treturn dp[x][y] = 1;\n\t\t\tif (x == n - 1 y == m - 1)\n\t\t\t\tresult = 1;\n\t\t\tif (x + 1 < n && mat[x][y] < mat[x + 1][y])\n\t\t\t\tresult = 1 + LIP(dp, mat, n, m, x + 1, y);\n\t\t\tif (y + 1 < m && mat[x][y] < mat[x][y + 1])\n\t\t\t\tresult = Math.max(result, 1 + LIP(dp, mat, n, m, x, y + 1));\n\t\t\tdp[x][y] = result;\n\t\t}\n\t\treturn dp[x][y];\n\t}\nfunction wrapper(mat, n, m)\n\t{\n\t\tlet dp = new Array(10);\n\t\tfor (let i = 0; i < 10; i++)\n\t\t{\n\t\t\tdp[i] = new Array(10);\n\t\t\tfor (let j = 0; j < 10; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\treturn LIP(dp, mat, n, m, 0, 0);\n\t}", "6787": "function computeLIS(circBuff, start, end, n)\n\t{\n\t\tlet LIS = new Array(n+end-start);\n\t\tfor (let i = start; i < end; i++)\n\t\t\tLIS[i] = 1;\n\t\tfor (let i = start + 1; i < end; i++)\n\t\t\tfor (let j = start; j < i; j++ )\n\t\t\t\tif (circBuff[i] > circBuff[j] && LIS[i] < LIS[j] + 1)\n\t\t\t\t\tLIS[i] = LIS[j] + 1;\n\t\tlet res = Number.MIN_VALUE;\n\t\tfor (let i = start; i < end; i++)\n\t\t\tres = Math.max(res, LIS[i]);\n\t\treturn res;\n\t}\nfunction LICS(arr, n)\n\t{\n\t\tlet circBuff = new Array(2 * n);\n\t\tfor (let i = 0; i<n; i++)\n\t\t\tcircBuff[i] = arr[i];\n\t\tfor (let i = n; i < 2*n; i++)\n\t\t\tcircBuff[i] = arr[i-n];\n\t\tlet res = Number.MIN_VALUE;\n\t\tfor (let i=0; i<n; i++)\n\t\t\tres = Math.max(computeLIS(circBuff, i, i + n, n), res);\n\t\treturn res;\n\t}", "6791": "function countPaths( n , m) {\n\t\tif (n == 0 m == 0)\n\t\t\treturn 1;\n\t\treturn (countPaths(n - 1, m) + countPaths(n, m - 1));\n\t}", "6792": "function countPaths(n , m)\n{\n\tvar dp = Array(n+1).fill(0).map(x => Array(m+1).fill(0));\n\tfor (i = 0; i <= n; i++)\n\t\tdp[i][0] = 1;\n\tfor (i = 0; i <= m; i++)\n\t\tdp[0][i] = 1;\n\tfor (i = 1; i <= n; i++)\n\tfor (j = 1; j <= m; j++)\n\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\treturn dp[n][m];\n}", "6793": "function min(a , b) \n\t{\n\t\treturn a < b ? a : b;\n\t}\nfunction binomialCoeff(n , k) \n\t{\n\t\tvar C = Array(k + 1).fill(0);\n\t\tC[0] = 1;\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor (j = min(i, k); j > 0; j--)\n\t\t\t\tC[j] = C[j] + C[j - 1];\n\t\t}\n\t\treturn C[k];\n\t}", "6848": "function getMaxGold(gold, m, n)\n\t{\n\t\tlet goldTable = new Array(m);\n\t\tfor(let i = 0; i < m; i++)\n\t\t{\n\t\t\tgoldTable[i] = new Array(n);\n\t\t\tfor(let j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tgoldTable[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (let col = n-1; col >= 0; col--)\n\t\t{\n\t\t\tfor (let row = 0; row < m; row++)\n\t\t\t{\n\t\t\t\tlet right = (col == n-1) ? 0\n\t\t\t\t\t\t: goldTable[row][col+1];\n\t\t\t\tlet right_up = (row == 0 col == n-1) ? 0 :\n\t\t\t\t\t\tgoldTable[row-1][col+1];\n\t\t\t\tlet right_down = (row == m-1 col == n-1) ? 0 :\n\t\t\t\t\t\tgoldTable[row+1][col+1];\n\t\t\t\tgoldTable[row][col] = gold[row][col]\n\t\t\t\t+ Math.max(right, Math.max(right_up, right_down));\n\t\t\t}\n\t\t}\n\t\tlet res = goldTable[0][0];\n\t\tfor (let i = 1; i < m; i++)\n\t\t\tres = Math.max(res, goldTable[i][0]);\n\t\treturn res;\n\t}", "6885": "function isOperator(op)\n{\n\treturn (op == '+' op == '*');\n}\nfunction printMinAndMaxValueOfExp(exp)\n{\n\tlet num = [];\n\tlet opr = [];\n\tlet tmp = \"\";\n\tfor (let i = 0; i < exp.length; i++)\n\t{\n\tif (isOperator(exp[i]))\n\t{\n\t\topr.push(exp[i]);\n\t\tnum.push(parseInt(tmp));\n\t\ttmp = \"\";\n\t}\n\telse\n\t{\n\t\ttmp += exp[i];\n\t}\n\t}\n\tnum.push(parseInt(tmp));\n\tlet len = num.length;\n\tlet minVal = new Array(len);\n\tlet maxVal = new Array(len);\n\tfor (let i = 0; i < len; i++)\n\t{\n\t\tminVal[i]=new Array(len);\n\t\tmaxVal[i]=new Array(len);\n\tfor (let j = 0; j < len; j++)\n\t{\n\t\tminVal[i][j] = Number.MAX_VALUE;\n\t\tmaxVal[i][j] = 0;\n\t\tif (i == j)\n\t\tminVal[i][j] = maxVal[i][j]\n\t\t= num[i];\n\t}\n\t}\n\tfor (let L = 2; L <= len; L++)\n\t{\n\tfor (let i = 0; i < len - L + 1; i++)\n\t{\n\t\tlet j = i + L - 1;\n\t\tfor (let k = i; k < j; k++)\n\t\t{\n\t\tlet minTmp = 0, maxTmp = 0;\n\t\tif (opr[k] == '+')\n\t\t{\n\t\t\tminTmp = minVal[i][k]\n\t\t\t+ minVal[k + 1][j];\n\t\t\tmaxTmp = maxVal[i][k]\n\t\t\t+ maxVal[k + 1][j];\n\t\t}\n\t\telse if (opr[k] == '*')\n\t\t{\n\t\t\tminTmp = minVal[i][k]\n\t\t\t* minVal[k + 1][j];\n\t\t\tmaxTmp = maxVal[i][k]\n\t\t\t* maxVal[k + 1][j];\n\t\t}\n\t\tif (minTmp < minVal[i][j])\n\t\t\tminVal[i][j] = minTmp;\n\t\tif (maxTmp > maxVal[i][j])\n\t\t\tmaxVal[i][j] = maxTmp;\n\t\t}\n\t}\n\t}\n\tdocument.write( \"Minimum value : \" + minVal[0][len - 1] + \", Maximum value : \" + maxVal[0][len - 1]);\n}", "6907": "function lcs(str1,str2,len1,len2,i,j)\n\t{\n\t\tlet ret = dp[i][j];\n\tif (i == len1 j == len2)\n\treturn ret = 0;\n\tif (ret != -1)\n\treturn ret;\t\n\tret = 0;\n\tif (str1[i] == str2[j])\n\tret = 1 + lcs(str1, str2, len1, len2, i + 1, j + 1);\n\telse\n\tret = Math.max(lcs(str1, str2, len1, len2, i + 1, j),\n\t\t\t\t\tlcs(str1, str2, len1, len2, i, j + 1));\n\treturn ret;\n\t}\nfunction printAll(str1,str2,len1,len2,data,indx1,indx2,currlcs)\n\t{\n\tif (currlcs == lcslen)\n\t{\n\tdata[currlcs] = null;\n\tdocument.write(data.join(\"\")+\"<br>\");\n\treturn;\n\t}\n\tif (indx1 == len1 indx2 == len2)\n\treturn;\n\tfor (let ch ='a'.charCodeAt(0); ch <='z'.charCodeAt(0); ch++)\n\t{\n\tlet done = false;\n\tfor (let i = indx1; i < len1; i++)\n\t{\n\t\tif (ch == str1[i].charCodeAt(0))\n\t\t{\n\t\tfor (let j = indx2; j < len2; j++)\n\t\t{\n\t\t\tif (ch == str2[j].charCodeAt(0) &&\n\t\t\t\tlcs(str1, str2, len1, len2, i, j) == lcslen - currlcs)\n\t\t\t{\n\t\t\tdata[currlcs] = String.fromCharCode(ch);\n\t\t\tprintAll(str1, str2, len1, len2, data, i + 1, j + 1, currlcs + 1);\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif (done)\n\t\tbreak;\n\t}\n\t}\n\t}\nfunction prinlAllLCSSorted(str1,str2)\n\t{\n\tlet len1 = str1.length, len2 = str2.length;\n\tfor(let i = 0; i < MAX; i++)\n\t{\n\t\tdp[i]=new Array(MAX);\n\tfor(let j = 0; j < MAX; j++)\n\t{\n\t\tdp[i][j] = -1;\n\t}\n\t}\n\tlcslen = lcs(str1, str2, len1, len2, 0, 0);\n\tlet data = new Array(MAX);\n\tprintAll(str1, str2, len1, len2, data, 0, 0, 0);\n\t}", "6933": "function minAdjustmentCost(A, n, target)\n\t{\n\t\tlet dp = new Array(n);\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tdp[i] = new Array(n);\n\t\t\tfor (let j = 0; j <= M; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (let j = 0; j <= M; j++)\n\t\t\tdp[0][j] = Math.abs(j - A[0]);\n\t\tfor (let i = 1; i < n; i++)\n\t\t{\n\t\t\tfor (let j = 0; j <= M; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = Number.MAX_VALUE;\n\t\t\t\tlet k = Math.max(j-target,0);\n\t\t\t\tfor ( ; k <= Math.min(M,j+target); k++)\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + \n\t\t\t\t\t\t\t\t\t\t\t\tMath.abs(A[i] - j));\n\t\t\t}\n\t\t} \n\t\tlet res = Number.MAX_VALUE;\n\t\tfor (let j = 0; j <= M; j++)\n\t\t\tres = Math.min(res, dp[n - 1][j]);\n\t\treturn res;\n\t}", "6944": "function LCIS(arr1, n, arr2, m)\n\t{\n\t\tlet table = [];\n\t\tfor (let j = 0; j < m; j++)\n\t\t\ttable[j] = 0;\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tlet current = 0;\n\t\t\tfor (let j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif (arr1[i] == arr2[j])\n\t\t\t\t\tif (current + 1 > table[j])\n\t\t\t\t\t\ttable[j] = current + 1;\n\t\t\t\tif (arr1[i] > arr2[j])\n\t\t\t\t\tif (table[j] > current)\n\t\t\t\t\t\tcurrent = table[j];\n\t\t\t}\n\t\t}\n\t\tlet result = 0;\n\t\tfor (let i=0; i<m; i++)\n\t\t\tif (table[i] > result)\n\t\t\tresult = table[i];\n\t\treturn result;\n\t}", "7051": "function cutRod(price, n)\n\t{\n\t\tlet val = new Array(n + 1);\n\t\tval[0] = 0;\n\t\tfor (let i = 1; i<=n; i++)\n\t\t{\n\t\t\tlet max_val = Number.MIN_VALUE;\n\t\t\tfor (let j = 0; j < i; j++)\n\t\t\t\tmax_val = Math.max(max_val, price[j] + val[i - j - 1]);\n\t\t\tval[i] = max_val;\n\t\t}\n\t\treturn val[n];\n\t}", "7052": "function un_kp(price, length, Max_len, n)\n{\n\tif (n == 0 Max_len == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (length[n - 1] <= Max_len)\n\t{\n\t\tt[n][Max_len]\n\t\t\t= Math.max(price[n - 1]\n\t\t\t\t\t+ un_kp(price, length, Max_len - length[n - 1], n),\n\t\t\t\tun_kp(price, length, Max_len, n - 1));\n\t}\n\telse\n\t{\n\t\tt[n][Max_len]\n\t\t\t= un_kp(price, length, Max_len, n - 1);\n\t}\n\treturn t[n][Max_len];\n}", "7068": "function MatrixChainOrder(p , i , j)\n{\n\tif (i == j)\n\t\treturn 0;\n\tvar min = Number.MAX_VALUE;\n\tvar k=0;\n\tfor (k = i; k < j; k++)\n\t{\n\t\tvar count = MatrixChainOrder(p, i, k)\n\t\t\t\t\t+ MatrixChainOrder(p, k + 1, j)\n\t\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\tif (count < min)\n\t\t\tmin = count;\n\t}\n\treturn min;\n}", "7069": "function matrixChainMemoised(p, i, j)\n{\n\tif (i == j) \n\t{\n\t\treturn 0;\n\t}\n\tif (dp[i][j] != -1) \n\t{\n\t\treturn dp[i][j];\n\t}\n\tdp[i][j] = Number.MAX_VALUE;\n\tfor(let k = i; k < j; k++) \n\t{\n\t\tdp[i][j] = Math.min(\n\t\t\tdp[i][j], matrixChainMemoised(p, i, k) +\n\t\t\t\t\tmatrixChainMemoised(p, k + 1, j) + p[i - 1] * p[k] * p[j]);\n\t}\n\treturn dp[i][j];\n}\nfunction MatrixChainOrder(p, n)\n{\n\tlet i = 1, j = n - 1;\n\treturn matrixChainMemoised(p, i, j);\n}", "7071": "function count(S , m , n )\n{\n\tif (n == 0)\n\t\treturn 1;\n\tif (n < 0)\n\t\treturn 0;\n\tif (m <=0 && n >= 1)\n\t\treturn 0;\n\treturn count( S, m - 1, n ) +\n\t\tcount( S, m, n - S[m - 1] );\n}", "7119": "function totalCombination(L, R)\n\t{\n\t\tlet count = 0;\n\t\tlet K = R - L;\n\t\tif (K < L)\n\t\t\treturn 0;\n\t\tlet ans = K - L;\n\t\tcount = ((ans + 1) * (ans + 2)) / 2;\n\t\treturn count;\n\t}", "7135": "function printArrays(n)\n\t{\n\t\tlet A = [];\n\t\tlet B = [];\n\t\tfor(let i = 1; i <= 2 * n; i++)\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t\tA.push(i);\n\t\t\telse\n\t\t\t\tB.push(i);\n\t\t}\n\t\tdocument.write(\"{ \");\n\t\tfor(let i = 0; i < n; i++)\n\t\t{\n\t\t\tdocument.write(A[i]);\n\t\t\tif (i != n - 1)\n\t\t\t\tdocument.write(\", \");\n\t\t}\n\t\tdocument.write(\" }\" + \"</br>\");\n\t\tdocument.write(\"{ \");\n\t\tfor(let i = 0; i < n; i++)\n\t\t{\n\t\t\tdocument.write(B[i]);\n\t\t\tif (i != n - 1)\n\t\t\t\tdocument.write(\", \");\n\t\t}\n\t\tdocument.write(\" }\");\n\t}", "7139": "function flipBitsOfAandB(A , B)\n{\n\tfor(i = 0; i < 32; i++)\n\t{\n\t\tif (((A & (1 << i)) &\n\t\t\t(B & (1 << i))) != 0)\n\t\t{\n\t\t\tA = A ^ (1 << i);\n\t\t\tB = B ^ (1 << i);\n\t\t}\n\t}\n\tdocument.write(A + \" \" + B);\n}", "7140": "function flipBitsOfAandB(A , B)\n{\n\tA = A ^ (A & B);\n\tB = B ^ (A & B);\n\tdocument.write(A + \" \" + B);\n}", "7167": "function TotalHammingDistance(n)\n{\n\tlet i = 1, sum = 0;\n\twhile (Math.floor(n / i) > 0)\n\t{\n\t\tsum = sum + Math.floor(n / i);\n\t\ti = i * 2;\n\t}\n\treturn sum;\n}", "7176": "function solve(n)\n{\n let s = 0;\n for (let l = 1; l <= n;)\n {\n\tlet r = (n /\n\t\t\tMath.floor(n / l));\n\tlet x = Math.floor(((r % m) *\n\t\t\t((r + 1) % m)) / 2) % m;\n\tlet y = Math.floor(((l % m) *\n\t\t\t((l - 1) % m)) / 2) % m;\n\tlet p = (Math.floor(n / l) % m);\n\ts = (s + (((x - y) % m) * p) % m + m) % m;\n\ts %= m;\n\tl = r + 1;\n }\n document.write((s + m) % m);\n}", "7187": "function min_time_to_cut(N)\n{\n\tif (N == 0)\n\t\treturn 0;\n\treturn Math.ceil(Math.log(N) /\n\t\t\t\t\tMath.log(2));\n}", "7203": "function findDistinctSums(n)\n{\n\ts = new Set();\n\tfor (var i = 1; i <= n; i++) {\n\t\tfor (var j = i; j <= n; j++) {\n\t\t\ts.add(i + j);\n\t\t}\n\t}\n\treturn s.size;\n}", "7204": "function findDistinctSums(N)\n\t{\n\t\treturn (2 * N - 1);\n\t}", "7234": "function printPattern(i,j,n)\n{\n\tif (j >= n) {\n\t\treturn 0;\n\t}\n\tif (i >= n) {\n\t\treturn 1;\n\t}\n\tif (j == i j == n - 1 - i) {\n\t\tif (i == n - 1 - j) {\n\t\t\tdocument.write(\"/\");\n\t\t}\n\t\telse {\n\t\t\tdocument.write(\"\\\\\");\n\t\t}\n\t}\n\telse {\n\t\tdocument.write(\"*\");\n\t}\n\tif (printPattern(i, j + 1, n) == 1) {\n\t\treturn 1;\n\t}\n\tdocument.write(\"<br>\");\n\treturn printPattern(i + 1, 0, n);\n}", "7248": "function zArray(arr) {\n\tlet n = arr.length;\n\tlet z = new Array(n);\n\tlet r = 0, l = 0;\n\tfor (let k = 1; k < n; k++) {\n\t\tif (k > r) {\n\t\t\tr = l = k;\n\t\t\twhile (r < n && arr[r] == arr[r - l])\n\t\t\t\tr++;\n\t\t\tz[k] = r - l;\n\t\t\tr--;\n\t\t}\n\t\telse {\n\t\t\tlet k1 = k - l;\n\t\t\tif (z[k1] < r - k + 1)\n\t\t\t\tz[k] = z[k1];\n\t\t\telse {\n\t\t\t\tl = k;\n\t\t\t\twhile (r < n && arr[r] == arr[r - l])\n\t\t\t\t\tr++;\n\t\t\t\tz[k] = r - l;\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nfunction mergeArray(A, B) {\n\tlet n = A.length;\n\tlet m = B.length;\n\tlet z = new Array();\n\tlet c = new Array(n + m + 1);\n\tfor (let i = 0; i < m; i++)\n\t\tc[i] = B[i];\n\tc[m] = Number.MAX_SAFE_INTEGER;\n\tfor (let i = 0; i < n; i++)\n\t\tc[m + i + 1] = A[i];\n\tz = zArray(c);\n\treturn z;\n}\nfunction findZArray(A, B, n) {\n\tlet flag = 0;\n\tlet z = [];\n\tz = mergeArray(A, B);\n\tfor (let i = 0; i < z.length; i++) {\n\t\tif (z[i] == n) {\n\t\t\tdocument.write((i - n - 1) + \" \");\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\tdocument.write(\"Not Found\");\n\t}\n}", "7276": "function getCount( a, b) {\n\t\tif (b.length % a.length != 0)\n\t\t\treturn -1;\n\t\tvar count = parseInt(b.length / a.length);\n\t\tvar str = \"\";\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstr = str + a;\n\t\t}\n\t\tif (str == (b))\n\t\t\treturn count;\n\t\treturn -1;\n\t}", "7287": "function printSpiral(size)\n{\n\tlet row = 0, col = 0;\n\tlet boundary = size - 1;\n\tlet sizeLeft = size - 1;\n\tlet flag = 1;\n\tlet move = 'r';\n\tlet matrix = new Array(size);\n\tfor(let i = 0; i < size; i++)\n\t{\n\t\tmatrix[i] = new Array(size).fill(0);\n\t}\n\tfor(let i = 1; i < size * size + 1; i++)\n\t{\n\t\tmatrix[row][col] = i;\n\t\tswitch (move)\n\t\t{\n\t\t\tcase 'r':\n\t\t\t\tcol += 1;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcol -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\trow -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\trow += 1;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == boundary)\n\t\t{\n\t\t\tboundary += sizeLeft;\n\t\t\tif (flag != 2)\n\t\t\t{\n\t\t\t\tflag = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tsizeLeft -= 1;\n\t\t\t}\n\t\t\tswitch (move)\n\t\t\t{\n\t\t\t\tcase 'r':\n\t\t\t\t\tmove = 'd';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tmove = 'l';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\tmove = 'u';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tmove = 'r';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(row = 0; row < size; row++)\n\t{\n\t\tfor(col = 0; col < size; col++)\n\t\t{\n\t\t\tlet n = matrix[row][col];\n\t\t\tif (n < 10)\n\t\t\t\tdocument.write(n + \" \");\n\t\t\telse\n\t\t\t\tdocument.write(n + \" \");\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t}\n}", "7298": "function check(S1, S2)\n{\n\tvar n1 = S1.length;\n\tvar n2 = S2.length;\n\tvar mp = {};\n\tfor(var i = 0; i < n1; i++)\n\t{\n\t\tif (mp.hasOwnProperty(S1[i]))\n\t\t{\n\t\t\tmp[S1[i]] = mp[S1[i]] + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp[S1[i]] = 1;\n\t\t}\n\t}\n\tfor(var i = 0; i < n2; i++)\n\t{\n\t\tif (mp.hasOwnProperty(S2[i]))\n\t\t{\n\t\t\tmp[S2[i]] = mp[S2[i]] - 1;\n\t\t}\n\t\telse if (mp.hasOwnProperty(\n\t\t\tString.fromCharCode(S2[i].charCodeAt(0) - 1)) &&\n\t\t\tmp.hasOwnProperty(\n\t\t\tString.fromCharCode(S2[i].charCodeAt(0) - 2)))\n\t\t{\n\t\t\tmp[String.fromCharCode(\n\t\t\t\tS2[i].charCodeAt(0) - 1)] =\n\t\t\tmp[String.fromCharCode(\n\t\t\t\tS2[i].charCodeAt(0) - 1)] - 1;\n\t\t\tmp[String.fromCharCode(\n\t\t\t\tS2[i].charCodeAt(0) - 2)] =\n\t\t\tmp[String.fromCharCode(\n\t\t\t\tS2[i].charCodeAt(0) - 2)] - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "7309": "function countPattern(str)\n\t{\n\t\tlet len = str.length;\n\t\tlet oneSeen = false;\n\t\tfor(let i = 0; i < len ; i++)\n\t\t{\n\t\t\tlet getChar = str[i];\n\t\t\tif (getChar == '1' && oneSeen == true){\n\t\t\t\tif (str[i-1] == '0')\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(getChar == '1' && oneSeen == false)\n\t\t\t\toneSeen = true;\n\t\t\tif(getChar != '0' && str[i] != '1')\n\t\t\t\toneSeen = false;\n\t\t}\n\t\treturn count;\n\t}", "7336": "function countSubstrings(str) {\n\t\t\tlet freq = new Array(3).fill(0)\n\t\t\tlet count = 0;\n\t\t\tlet i = 0;\n\t\t\tfor (let j = 0; j < str.length; j++) {\n\t\t\t\tfreq[str.charCodeAt(j) - '0'.charCodeAt(0)]++;\n\t\t\t\twhile (freq[0] > 0 && freq[1] > 0 && freq[2] > 0) {\n\t\t\t\t\tfreq[str.charCodeAt(i++) - '0'.charCodeAt(0)]--;\n\t\t\t\t}\n\t\t\t\tcount += i;\n\t\t\t}\n\t\t\treturn count;\n\t\t}", "7347": "function minFlips(str) {\n\t\t\tlet count = 0;\n\t\t\tif (str.length <= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (let i = 0; i < str.length - 2;) {\n\t\t\t\tif (str[i] == str[i + 1] && str[i + 2] == str[i + 1]) {\n\t\t\t\t\ti = i + 3;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t}", "7382": "function checkIfPossible(N, arr, T)\n{\n\tlet freqS = new Array(256).fill(0);\n\tlet freqT = new Array(256).fill(0);\n\tfor (let ch of T) {\n\t\tfreqT[ch.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\t}\n\tfor (let i = 0; i < N; i++) {\n\t\tfor (let ch of arr[i]) {\n\t\t\tfreqS[ch.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\t\t}\n\t}\n\tfor (let i = 0; i < 256; i++) {\n\t\tif (freqT[i] == 0 && freqS[i] != 0) {\n\t\t\treturn \"No\";\n\t\t}\n\t\telse if (freqS[i] == 0 && freqT[i] != 0) {\n\t\t\treturn \"No\";\n\t\t}\n\t\telse if (freqT[i] != 0\n\t\t\t\t&& freqS[i]\n\t\t\t\t\t\t!= (freqT[i] * N)) {\n\t\t\treturn \"No\";\n\t\t}\n\t}\n\treturn \"Yes\";\n}", "7390": "function convertToHex(num) {\n\tlet temp = \"\";\n\twhile (num != 0) {\n\t\tlet rem = num % 16;\n\t\tlet c = 0;\n\t\tif (rem < 10) {\n\t\t\tc = rem + 48;\n\t\t}\n\t\telse {\n\t\t\tc = rem + 87;\n\t\t}\n\t\ttemp += String.fromCharCode(c);\n\t\tnum = Math.floor(num / 16);\n\t}\n\treturn temp;\n}\nfunction encryptString(S, N) {\n\tlet ans = \"\";\n\tfor (let i = 0; i < N; i++) {\n\t\tlet ch = S[i];\n\t\tlet count = 0;\n\t\tlet hex;\n\t\twhile (i < N && S[i] == ch) {\n\t\t\tcount++;\n\t\t\ti++;\n\t\t}\n\t\ti--;\n\t\thex = convertToHex(count);\n\t\tans += ch;\n\t\tans += hex;\n\t}\n\tans = ans.split('').reverse().join(\"\");\n\treturn ans;\n}", "7401": "function groupsOfOnes(S, N) {\n\t\t\tlet count = 0;\n\t\t\tvar st = [];\n\t\t\tfor (let i = 0; i < N; i++) {\n\t\t\t\tif (S[i] == '1')\n\t\t\t\t\tst.push(1);\n\t\t\t\telse {\n\t\t\t\t\tif (st.length != 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\twhile (st.length != 0) {\n\t\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (st.length != 0)\n\t\t\t\tcount++;\n\t\t\treturn count;\n\t\t}", "7412": "function generatePalindrome(S)\n{\n\tlet Hash=new Map();\n\tfor (let ch=0;ch< S.length;ch++) {\n\t\tif(!Hash.has(S[ch]))\n\t\t\tHash.set(S[ch],1);\n\t\telse\n\t\t{\n\t\t\tHash.set(S[ch],Hash.get(S[ch])+1)\n\t\t}\n\t}\n\tlet st=new Set();\n\tfor (let i = 'a'.charCodeAt(0); i <= 'z'.charCodeAt(0); i++) {\n\t\tif (Hash.get(String.fromCharCode(i)) == 2) {\n\t\t\tfor (let j = 'a'.charCodeAt(0); j <= 'z'.charCodeAt(0); j++) {\n\t\t\t\tlet s = \"\";\n\t\t\t\tif (Hash.get(String.fromCharCode(j)) && i != j) {\n\t\t\t\t\ts += String.fromCharCode(i);\n\t\t\t\t\ts += String.fromCharCode(j);\n\t\t\t\t\ts += String.fromCharCode(i);\n\t\t\t\t\tst.add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Hash.get(String.fromCharCode(i)) >= 3) {\n\t\t\tfor (let j = 'a'.charCodeAt(0);\n\t\t\t\tj <= 'z'.charCodeAt(0); j++) {\n\t\t\t\tlet s = \"\";\n\t\t\t\tif (Hash.get(String.fromCharCode(j))) {\n\t\t\t\t\ts += String.fromCharCode(i);\n\t\t\t\t\ts += String.fromCharCode(j);\n\t\t\t\t\ts += String.fromCharCode(i);\n\t\t\t\t\tst.add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (let item of st.values()) {\n\t\tdocument.write(item+\"<br>\")\n\t}\n}", "7423": "function countOccurrences( S, X, Y){\n\tlet count = 0;\n\tlet N = S.length, A = X.length;\n\tlet B = Y.length;\n\tfor (let i = 0; i < N; i++) {\n\t\tif (S.substr(i, B) == Y)\n\t\t\tcount++;\n\t\tif (S.substr(i, A) == X)\n\t\t\tdocument.write(count,\" \");\n\t}\n}", "7487": "function findWinner(a, n)\n\t{\n\tlet v = [];\n\tlet c = 0;\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tif (a[i] == '0')\n\t\t{\n\t\tc++;\n\t\t}\n\t\telse\n\t\t{\n\t\tif (c != 0)\n\t\t\tv.push(c);\n\t\tc = 0;\n\t\t}\n\t}\n\tif (c != 0)\n\t\tv.push(c);\n\tif (v.length == 0)\n\t{\n\t\tdocument.write(\"Player B\");\n\t\treturn;\n\t}\n\tif (v.length == 1)\n\t{\n\t\tif ((v[0] & 1) != 0)\n\t\tdocument.write(\"Player A\");\n\t\telse\n\t\tdocument.write(\"Player B\");\n\t\treturn;\n\t}\n\tlet first = Number.MIN_VALUE;\n\tlet second = Number.MIN_VALUE;\n\tfor (let i = 0; i < v.length; i++)\n\t{\n\t\tif (a[i] > first) {\n\t\tsecond = first;\n\t\tfirst = a[i];\n\t\t}\n\t\telse if (a[i] > second && a[i] != first)\n\t\tsecond = a[i];\n\t}\n\tif ((first & 1) != 0 && parseInt((first + 1) / 2, 10) > second)\n\t\tdocument.write(\"Player A\");\n\telse\n\t\tdocument.write(\"Player B\");\n\t}", "7507": "function DFA(str,N) {\n\tif (N <= 1)\n\t{\n\t\tdocument.write(\"No\");\n\t\treturn;\n\t}\n\tlet count = 0;\n\tif (str[0] == 'C')\n\t{\n\tcount++;\n\tfor (let i = 1; i < N; i++)\n\t{\n\t\tif (str[i] == 'A' str[i] == 'B')\n\t\tcount++;\n\t\telse\n\t\tbreak;\n\t}\n\t}\n\telse\n\t{\n\tdocument.write(\"No\");\n\treturn;\n\t}\n\tif (count == N)\n\tdocument.write(\"Yes\");\n\telse\n\tdocument.write(\"No\");\n}", "7542": "function minMaxDigits(str, N)\n{\n\tlet arr = [];\n\tfor(let i = 0; i < N; i++)\n\t\tarr[i] = (str[i] - '0') % 3;\n\tlet zero = 0, one = 0, two = 0;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] == 0)\n\t\t\tzero++;\n\t\tif (arr[i] == 1)\n\t\t\tone++;\n\t\tif (arr[i] == 2)\n\t\t\ttwo++;\n\t}\n\tlet sum = 0;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tsum = (sum + arr[i]) % 3;\n\t}\n\tif (sum == 0)\n\t{\n\tdocument.write(0 + \" \");\n\t}\n\tif (sum == 1)\n\t{\n\t\tif ((one != 0) && (N > 1))\n\t\t\tdocument.write(1 + \" \");\n\t\telse if (two > 1 && N > 2)\n\t\t\tdocument.write(2 + \" \");\n\t\telse\n\t\t\tdocument.write(-1 + \" \");\n\t}\n\tif (sum == 2)\n\t{\n\t\tif (two != 0 && N > 1)\n\t\tdocument.write(1 + \" \");\n\t\telse if (one > 1 && N > 2)\n\t\t\tdocument.write(2 + \" \");\n\t\telse\n\t\t\tdocument.write(-1 + \" \");\n\t}\n\tif (zero > 0)\n\t\tdocument.write(N - 1 + \" \");\n\telse if (one > 0 && two > 0)\n\tdocument.write(N - 2 + \" \");\n\telse if (one > 2 two > 2)\n\t\tdocument.write(N - 3 + \" \");\n\telse\n\t\tdocument.write(-1 + \" \");\n}", "7548": "function findMinimumChanges(N, K, S)\n{\n\tvar ans = 0;\n\tfor (var i = 0; i < parseInt((K + 1) / 2); i++) {\n\t\tvar mp = new Map();\n\t\tfor (var j = i; j < N; j += K) {\n\t\t\tif(mp.has(S[j]))\n\t\t\t{\n\t\t\t\tmp.set(S[j], mp.get(S[j])+1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.set(S[j], 1);\n\t\t\t}\n\t\t}\n\t\tfor (var j = N - i - 1; j >= 0; j -= K) {\n\t\t\tif ((K & 1) && i == parseInt(K / 2))\n\t\t\t\tbreak;\n\t\t\tif(mp.has(S[j]))\n\t\t\t{\n\t\t\t\tmp.set(S[j], mp.get(S[j])+1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.set(S[j], 1);\n\t\t\t}\n\t\t}\n\t\tvar curr_max = -1000000000;\n\t\tmp.forEach((value, key) => {\n\t\t\tcurr_max = Math.max(curr_max, value); });\n\t\tif (K & 1 && i == parseInt(K / 2))\n\t\t\tans += (parseInt(N / K) - curr_max);\n\t\telse\n\t\t\tans += (parseInt(N / K) * 2 - curr_max);\n\t}\n\treturn ans;\n}", "7564": "function longComPre(arr, N)\n{\n let freq = new Array(N);\n for(let i = 0; i < N; i++)\n {\n\tfreq[i] = new Array(256);\n\tfor(let j = 0; j < 256; j++)\n\t{\n\t\tfreq[i][j] = 0;\n\t}\n }\n for (let i = 0; i < N; i++)\n {\n\tlet M = arr[i].length;\n\tfor (let j = 0; j < M; j++)\n\t{\n\tfreq[i][arr[i][j].charCodeAt(0)]++;\n\t}\n }\n let maxLen = 0;\n for (let j = 0; j < 256; j++)\n {\n\tlet minRowVal = Number.MAX_VALUE;\n\tfor (let i = 0; i < N; i++)\n\t{\n\tminRowVal = Math.min(minRowVal, freq[i][j]);\n\t}\n\tmaxLen += minRowVal;\n }\n return maxLen;\n}", "7587": "function binomialCoeff(n, k)\n\t{\n\t\tlet res = 1;\n\t\tif (k > n - k)\n\t\t\tk = n - k;\n\t\tfor(let i = 0; i < k; ++i)\n\t\t{\n\t\t\tres *= (n - i);\n\t\t\tres /= (i + 1);\n\t\t}\n\t\treturn res;\n\t}\nfunction countOfString(N)\n\t{\n\t\tlet Stotal = Math.pow(2, N);\n\t\tlet Sequal = 0;\n\t\tif (N % 2 == 0)\n\t\t\tSequal = binomialCoeff(N, N / 2);\n\t\tlet S1 = (Stotal - Sequal) / 2;\n\t\treturn S1;\n\t}", "7593": "function removeCharRecursive(str,X)\n{\n\tif (str.length == 0)\n\t{\n\t\treturn \"\";\n\t}\n\tif (str.charAt(0) == X)\n\t{\n\t\treturn removeCharRecursive(\n\t\t\tstr.substring(1), X);\n\t}\n\treturn str.charAt(0) +\n\t\tremoveCharRecursive(\n\t\tstr.substring(1), X);\n}", "7594": "function checkString(s, K)\n{\n\tvar n = s.length;\n\tvar mp = new Map();\n\tfor (var i = 0; i < n; i++) {\n\t\tif(mp.has(s[i]))\n\t\t{\n\t\t\tmp.set(s[i], mp.get(s[i])+1);\n\t\t}\n\t\telse\n\t\t\tmp.set(s[i], 1);\n\t}\n\tvar cnt = 0, f = 0;\n\tvar st = new Set();\n\tfor (var i = 0; i < n; i++) {\n\t\tst.add(s[i]);\n\t\tif (st.size > K) {\n\t\t\tf = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (mp.get(s[i]) == i)\n\t\t\tst.delete(s[i]);\n\t}\n\treturn (f == 1 ? \"Yes\" : \"No\");\n}", "7609": "function isValid(a1, a2, str, flag)\n{\n\tlet v1, v2;\n if (flag == 0)\n {\n\tv1 = str[4];\n\tv2 = str[3];\n }\n else\n {\n\tv1 = str[1];\n\tv2 = str[0];\n }\n if (v1 != a1 && v1 != '?')\n\treturn false;\n if (v2 != a2 && v2 != '?')\n\treturn false;\n return true;\n}\nfunction inRange(hh,mm,L,R)\n{\n\tlet a = Math.abs(hh - mm);\n if (a < L a > R)\n\treturn false;\n return true;\n}\nfunction displayTime(hh,mm)\n{\n\tif (hh > 10)\n\tdocument.write(hh + \":\");\n else if (hh < 10)\n\tdocument.write(\"0\" + hh + \":\");\n if (mm > 10)\n\tdocument.write(mm+\"<br>\");\n else if (mm < 10)\n\tdocument.write(\"0\" + mm+\"<br>\");\n}\nfunction maximumTimeWithDifferenceInRange(str,L,R)\n{\n\tlet i = 0, j = 0;\n let h1, h2, m1, m2;\n for (i = 23; i >= 0; i--)\n {\n\th1 = i % 10;\n\th2 = Math.floor(i / 10);\n\tif (!isValid(String.fromCharCode(h1),String.fromCharCode(h2), str, 1))\n\t{\n\tcontinue;\n\t}\n\tfor (j = 59; j >= 0; j--)\n\t{\n\tm1 = j % 10;\n\tm2 = Math.floor(j / 10);\n\tif (!isValid(String.fromCharCode(m1),\n\t\t\t\tString.fromCharCode(m2), str, 0))\n\t{\n\t\tcontinue;\n\t}\n\tif (inRange(i, j, L, R))\n\t{\n\t\tdisplayTime(i, j);\n\t\treturn;\n\t}\n\t}\n }\n if (inRange(i, j, L, R))\n\tdisplayTime(i, j);\n else\n\tdocument.write(\"-1<br>\");\n}", "7622": "function check(s, n)\n{\n\tvar st = [];\n\tfor (var i = 0; i < n; i++) {\n\t\tif (st.length!=0 && st[st.length-1] == s[i])\n\t\t\tst.pop();\n\t\telse\n\t\t\tst.push(s[i]);\n\t}\n\tif (st.length==0) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "7646": "function can_Construct(S, K)\n{\n\tvar m = new Map();\n\tvar i = 0, j = 0, p = 0;\n\tif (S.length == K) {\n\t\treturn true;\n\t}\n\tfor (i = 0; i < S.length; i++) {\n\t\tif(m.has(S[i]))\n\t\t\tm.set(S[i], m.get(S[i])+1)\n\t\telse \n\t\t\tm.set(S[i], 1)\n\t}\n\tif (K > S.length) {\n\t\treturn false;\n\t}\n\telse {\n\t\tm.forEach((value, key) => {\n\t\t\tif (value%2 != 0) { p = p + 1; } });\n\t}\n\tif (K < p) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "7688": "function findNumOfValidWords(w, p)\n{\n\tvar m = new Map();\n\tvar res = [];\n\tw.forEach(s => {\n\t\tvar val = 0;\n\t\ts.split('').forEach(c => {\n\t\t\tval = val | (1 << (c.charCodeAt(0) - 'a'.charCodeAt(0))); });\n\t\tif(m.has(val))\n\t\t\tm.set(val, m.get(val)+1)\n\t\telse\n\t\t\tm.set(val, 1) });\n\tp.forEach(s => {\n\t\tvar val = 0;\n\t\ts.split('').forEach(c => {\n\t\t\tval = val | (1 << (c.charCodeAt(0) - 'a'.charCodeAt(0))); });\n\t\tvar temp = val;\n\t\tvar first = s[0].charCodeAt(0) - 'a'.charCodeAt(0);\n\t\tvar count = 0;\n\t\twhile (temp != 0) {\n\t\t\tif (((temp >> first) & 1) == 1) {\n\t\t\t\tif (m.has(temp)) {\n\t\t\t\t\tcount += m.get(temp);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp = (temp - 1) & val;\n\t\t}\n\t\tres.push(count); });\n\tres.forEach(it => {\n\t\tdocument.write( it + \"<br>\"); });\n}", "7693": "function flip(s)\n\t{\n\t\tfor(let i = 0; i < s.length; i++)\n\t\t{\n\t\tif (s[i] == '0')\n\t\t{\n\t\t\twhile (s[i] == '0')\n\t\t\t{\n\t\t\t\ts[i] = '1';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn s.join(\"\");\n\t}", "7694": "function distinct(S, M, n) {\n\tlet count = 0;\n\tfor (let i = 0; i < n; i++) {\n\t\tlet set1 = new Set();\n\t\tfor (let j = 0; j < S[i].length; j++) {\n\t\t\tif (!set1.has(S[i][j]))\n\t\t\t\tset1.add(S[i][j]);\n\t\t}\n\t\tlet c = set1.size;\n\t\tif (c <= M)\n\t\t\tcount += 1;\n\t}\n\tdocument.write(count);\n}", "7734": "function removeOddFrequencyCharacters(s)\n\t{\n\t\tlet m = new Map();\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\tlet p = s[i];\n\t\t\tlet count = m.get(p);\n\t\t\tif( count == null)\n\t\t\t{\n\t\t\t\tcount=0;\n\t\t\t\tm.set(p,1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tm.set(p,count + 1);\n\t\t}\n\t\tlet new_string = \"\";\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\tif ((m.get(s[i])& 1)==1)\n\t\t\t\tcontinue;\n\t\t\tnew_string += s[i];\n\t\t}\n\t\treturn new_string;\n\t}", "7735": "function removeChars(arr, k)\n{\n\tlet hash = Array.from({length: MAX_CHAR}, (_, i) => 0);\n\tlet n = arr.length;\n\tfor (let i = 0; i < n; ++i)\n\t\thash[arr[i].charCodeAt() - 'a'.charCodeAt()]++;\n\tlet ans = \"\";\n\tfor (let i = 0; i < n; ++i) {\n\t\tif (hash[arr[i].charCodeAt() - 'a'.charCodeAt()] != k) {\n\t\t\tans += arr[i];\n\t\t}\n\t}\n\treturn ans;\n}", "7753": "function productAtKthLevel( tree, k, level){\n\tif (tree[i++] == '(') {\n\t\tif (tree[i] == ')')\n\t\t\treturn 1;\n\t\tvar product = 1;\n\t\tif (level == k)\n\t\t\tproduct = tree[i] - '0';\n\t\t++i;\n\t\tvar leftproduct = productAtKthLevel( tree, k, level + 1);\n\t\t++i;\n\t\tvar rightproduct =\n\t\tproductAtKthLevel(tree, k, level + 1);\n\t\t++i;\n\t\treturn product *\n\t\tleftproduct * rightproduct;\n\t}\n\treturn int.MinValue;\n}", "7758": "function findMostOccurringChar(str)\n{\n\tvar hash = Array(26).fill(0);\n\tfor (var i = 0; i < str.length; i++)\n\t{\n\t\tfor (var j = 0; j < str[i].length; j++)\n\t\t{\n\t\t\thash[str[i][j]]++;\n\t\t}\n\t}\n\tvar max = 0;\n\tfor (var i = 0; i < 26; i++) {\n\t\tmax = hash[i] > hash[max] ? i : max;\n\t}\n\tdocument.write(String.fromCharCode(max + 97));\n}", "7788": "function sub_segments(str, n) {\n\tlet l = str.length;\n\tfor (let x = 0; x < l; x += n) {\n\t\tlet newlist = str.substr(x, n);\n\t\tlet arr = [];\n\t\tfor (let y of newlist) {\n\t\t\tif (!arr.includes(y))\n\t\t\t\tarr.push(y);\n\t\t}\n\t\tfor (let y of arr)\n\t\t\tdocument.write(y);\n\t\tdocument.write(\"<br>\");\n\t}\n}", "7816": "function isPalindrome(num)\n{\n\tvar s = num.toString();\n\tvar low = 0;\n\tvar high = s.length - 1;\n\twhile (low < high)\n\t{\n\t\tif (s[low] != s[high])\n\t\t\treturn false;\n\t\tlow++;\n\t\thigh--;\n\t}\n\treturn true;\n}", "7819": "function maxSubStr(str1, len1, str2, len2)\n{\n\tif (len1 > len2)\n\t\treturn 0;\n\tlet freq1 = new Array(MAX).fill(0);\n\tfor (let i = 0; i < len1; i++)\n\t\tfreq1[str1.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n\tlet freq2 = new Array(MAX).fill(0);\n\tfor (let i = 0; i < len2; i++)\n\t\tfreq2[str2.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n\tlet minPoss = Number.MAX_SAFE_INTEGER;\n\tfor (let i = 0; i < MAX; i++) {\n\t\tif (freq1[i] == 0)\n\t\t\tcontinue;\n\t\tif (freq1[i] > freq2[i])\n\t\t\treturn 0;\n\t\tminPoss = Math.min(minPoss, Math.floor(freq2[i] / freq1[i]));\n\t}\n\treturn minPoss;\n}", "7820": "function cntWays(str, n)\n{\n\tvar x = n + 1;\n\tvar ways = x * x * (x * x - 1) / 12;\n\treturn ways;\n}", "7828": "function findSubStr( str, cnt, start)\n{\n\tif (start == str.length) {\n\t\tminCnt = Math.min(cnt, minCnt);\n\t}\n\tfor (var len = 1; len <= (str.length - start); len++) {\n\t\tvar subStr = str.substring(start, start+len);\n\t\tif (uSet.has(subStr)) {\n\t\t\tfindSubStr(str, cnt + 1, start + len);\n\t\t}\n\t}\n}\nfunction findMinSubStr(arr, n, str)\n{\n\tfor (var i = 0; i < n; i++)\n\t\tuSet.add(arr[i]);\n\tfindSubStr(str, 0, 0);\n}", "7851": "function countSubStr(s, n)\n{\n\tvar c1 = 0, c2 = 0;\n\tfor (var i = 0; i < n; i++) {\n\t\tif (s.substring(i, i+5) == \"geeks\")\n\t\t\tc1++;\n\t\tif (s.substring(i,i+ 3) == \"for\")\n\t\t\tc2 = c2 + c1;\n\t}\n\treturn c2;\n}", "7864": "", "7868": "function encryptStr(str, n, x)\n{\n\tx = x % MAX;\n\tvar freq = Array(MAX).fill(0);\n\tfor(var i = 0; i < n; i++)\n\t{\n\t\tfreq[str[i].charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\t}\n\tfor(var i = 0; i < n; i++)\n\t{\n\t\tif (freq[str[i].charCodeAt(0) - 'a'.charCodeAt(0)] % 2 == 0)\n\t\t{\n\t\t\tvar pos = (str[i].charCodeAt(0) - 'a'.charCodeAt(0) + x) % MAX;\n\t\t\tstr[i] = String.fromCharCode(pos + 'a'.charCodeAt(0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar pos = (str[i].charCodeAt(0) - 'a'.charCodeAt(0) - x);\n\t\t\tif (pos < 0)\n\t\t\t{\n\t\t\t\tpos += MAX;\n\t\t\t}\n\t\t\tstr[i] = String.fromCharCode(pos + 'a'.charCodeAt(0));\n\t\t}\n\t}\n\treturn str.join('');\n}", "7889": "function getOrgString(s)\n\t{\n\t\tdocument.write(s[0]);\n\t\tvar i = 1;\n\t\twhile (i < s.length)\n\t\t{\n\t\tif (\n\t\t\ts[i].charCodeAt(0) >= \"A\".charCodeAt(0) &&\n\t\t\ts[i].charCodeAt(0) <= \"Z\".charCodeAt(0) )\n\t\t\tdocument.write(\" \" + s[i].toLowerCase());\n\t\telse document.write(s[i]);\n\t\ti++;\n\t\t}\n\t}", "7892": "function isPossible(str)\n\t{\n\t\tlet freq = new Map();\n\t\tlet max_freq = 0;\n\t\tfor (let j = 0; j < (str.length); j++) {\n\t\t\tif (freq.has(str[j])) {\n\t\t\t\tfreq.set(str[j], freq.get(str[j]) + 1);\n\t\t\t\tif (freq.get(str[j]) > max_freq)\n\t\t\t\t\tmax_freq = freq.get(str[j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfreq.set(str[j], 1);\n\t\t\t\tif (freq.get(str[j]) > max_freq)\n\t\t\t\t\tmax_freq = freq.get(str[j]);\n\t\t\t}\n\t\t}\n\t\tif (max_freq <= (str.length - max_freq + 1))\n\t\t\treturn true;\n\t\treturn false;\n\t}", "7899": "function printUncommon(str1, str2)\n{\n\tvar a1 = 0, a2 = 0;\n\tfor (var i = 0; i < str1.length; i++) {\n\t\tvar ch = (str1[i].charCodeAt(0)) - 'a'.charCodeAt(0);\n\t\ta1 = a1 | (1 << ch);\n\t}\n\tfor (var i = 0; i < str2.length; i++) {\n\t\tvar ch = (str2[i].charCodeAt(0)) - 'a'.charCodeAt(0);\n\t\ta2 = a2 | (1 << ch);\n\t}\n\tvar ans = a1 ^ a2;\n\tvar i = 0;\n\twhile (i < 26) {\n\t\tif (ans % 2 == 1) {\n\t\t\tdocument.write( String.fromCharCode('a'.charCodeAt(0) + i));\n\t\t}\n\t\tans = parseInt(ans / 2);\n\t\ti++;\n\t}\n}", "7900": "function isPalin(i, j, k, l, p, q, s)\n{\n\tvar start = i, end = q;\n\twhile (start < end) {\n\t\tif (s[start] != s[end])\n\t\t\treturn false;\n\t\tstart++;\n\t\tif (start == j + 1)\n\t\t\tstart = k;\n\t\tend--;\n\t\tif (end == p - 1)\n\t\t\tend = l;\n\t}\n\treturn true;\n}\nfunction countSubStr(s)\n{\n\tvar count = 0;\n\tvar n = s.length;\n\tfor (var i = 0; i < n - 2; i++) {\n\t\tfor (var j = i; j < n - 2; j++) {\n\t\t\tfor (var k = j + 1; k < n - 1; k++) {\n\t\t\t\tfor (var l = k; l < n - 1; l++) {\n\t\t\t\t\tfor (var p = l + 1; p < n; p++) {\n\t\t\t\t\t\tfor (var q = p; q < n; q++) {\n\t\t\t\t\t\t\tif (isPalin(i, j, k, l, p, q, s)) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "7938": "function equalIgnoreCaseUtil(str1, str2)\n\t{\n\t\tlet res = equalIgnoreCase(str1, str2);\n\t\tif (res == true)\n\t\t\tdocument.write( \"Same\" + \"</br>\");\n\t\telse\n\t\t\tdocument.write( \"Not Same\" + \"</br>\");\n\t}", "7939": "function equalIgnoreCase(str1,str2)\n{\n\tlet i = 0;\n\t\tstr1 = str1.toUpperCase();\n\t\tstr2 = str2.toUpperCase();\n\t\tlet x = str1 == (str2);\n\t\tif (!x)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n}\nfunction equalIgnoreCaseUtil(str1,str2)\n{\n\tlet res = equalIgnoreCase(str1, str2);\n\t\tif (res == true)\n\t\t{\n\t\t\tdocument.write(\"Same<br>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.write(\"Not Same<br>\");\n\t\t}\n}", "7940": "function equalIgnoreCase(str1,str2)\n{\n\tlet i = 0;\n\tstr1 = str1.toLowerCase();\n\tstr2 = str2.toLowerCase();\n\tlet x = (str1 == (str2));\n\treturn x == true;\n}\nfunction equalIgnoreCaseUtil(str1,str2)\n{\n\tlet res = equalIgnoreCase(str1, str2);\n\tif (res == true)\n\t\tdocument.write(\"Same<br>\");\n\telse\n\t\tdocument.write(\"Not Same<br>\");\n}", "7966": "function countMinReversals(expr)\n{\n\tvar len = expr.length;\n\tif (len % 2)\n\t\treturn -1;\n\tvar ans = 0;\n\tvar i;\n\tvar open = 0;\n\tvar close = 0;\n\tfor (i = 0; i < len; i++) {\n\t\tif (expr[i] == '{')\n\t\t\topen++;\n\t\telse {\n\t\t\tif (!open)\n\t\t\t\tclose++;\n\t\t\telse\n\t\t\t\topen--;\n\t\t}\n\t}\n\tans = (close / 2) + (open / 2);\n\tclose %= 2;\n\topen %= 2;\n\tif (close)\n\t\tans += 2;\n\treturn ans;\n}", "7977": "function totalPairs(s1, s2)\n{\n\tvar a1 = 0, b1 = 0;\n\tfor (var i = 0; i < s1.length; i++) {\n\t\tif ((s1[i].charCodeAt(0)) % 2 != 0)\n\t\t\ta1++;\n\t\telse\n\t\t\tb1++;\n\t}\n\tvar a2 = 0, b2 = 0;\n\tfor (var i = 0; i < s2.length; i++) {\n\t\tif ((s2[i].charCodeAt(0)) % 2 != 0)\n\t\t\ta2++;\n\t\telse\n\t\t\tb2++;\n\t}\n\treturn ((a1 * a2) + (b1 * b2));\n}", "7978": "function replaceConsonants(str) {\n\t\tvar res = \"\";\n\t\tvar i = 0,\n\t\tcount = 0;\n\t\twhile (i < str.length) {\n\t\tif ( str[i] !== \"a\" && str[i] !== \"e\" && str[i] !== \"i\" && str[i] !== \"o\" && str[i] !== \"u\" ) {\n\t\t\ti++;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tif (count > 0) res += count.toString();\n\t\t\tres += str[i];\n\t\t\ti++;\n\t\t\tcount = 0;\n\t\t}\n\t\t}\n\t\tif (count > 0) res += count.toString();\n\t\treturn res;\n\t}", "7979": "function prefixOccurrences(str)\n{\n\tvar c = str.charAt(0);\n\tvar countc = 0;\n\tfor (var i = 0; i < str.length; i++)\n\t{\n\t\tif (str.charAt(i) == c)\n\t\t\tcountc++;\n\t}\n\treturn countc;\n}", "7989": "function minOperations(s, t, n)\n{\n\tvar ct0 = 0,\n\tct1 = 0;\n\tfor(var i = 0; i < n; i++)\n\t{\n\t\tif (s[i] === t[i])\n\t\t\tcontinue;\n\t\tif (s[i] === \"0\")\n\t\t\tct0++;\n\t\telse\n\t\t\tct1++;\n\t}\n\treturn Math.max(ct0, ct1);\n}", "7991": "function maxValue(a,b)\n{\n\tb.sort(function(x,y){return x-y;});\n\tlet n = a.length;\n\tlet m = b.length;\n\tlet j = m - 1;\n\tfor (let i = 0; i < n; i++) {\n\t\tif (j < 0)\n\t\t\tbreak;\n\t\tif (b[j] > a[i]) {\n\t\t\ta[i] = b[j];\n\t\t\tj--;\n\t\t}\n\t}\n\treturn (a).join(\"\");\n}", "8004": "function decryptString(str,n)\n{\n\tlet i = 0, jump = 1;\n\tlet decryptedStr = \"\";\n\twhile (i < n)\n\t{\n\t\tdecryptedStr += str[i];\n\t\ti += jump;\n\t\tjump++;\n\t}\n\treturn decryptedStr;\n}", "8015": "function steps(str, n) {\n\t\tvar flag;\n\t\tvar x = 0;\n\t\tfor (var i = 0; i < str.length; i++) {\n\t\tif (x == 0) flag = true;\n\t\tif (x == n - 1) flag = false;\n\t\tfor (var j = 0; j < x; j++) document.write(\"*\");\n\t\tdocument.write(str[i] + \"<br>\");\n\t\tif (flag == true) x++;\n\t\telse x--;\n\t\t}\n\t}", "8054": "function bitToBeFlipped(s)\n{\n\tlet last = s[s.length - 1];\n\tlet first = s[0];\n\tif (last == first) {\n\t\tif (last == '0') {\n\t\t\treturn '1';\n\t\t}\n\t\telse {\n\t\t\treturn '0';\n\t\t}\n\t}\n\telse if (last != first) {\n\t\treturn last;\n\t}\n}", "8061": "function SieveOfEratosthenes(prime, p_size) {\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (let p = 2; p * p <= p_size; p++) {\n\t\tif (prime[p]) {\n\t\t\tfor (let i = p * 2; i <= p_size; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n}\nfunction sumProdOfPrimeFreq(s) {\n\tlet prime = new Array(s.length + 1);\n\tprime.fill(true);\n\tSieveOfEratosthenes(prime, s.length + 1);\n\tlet i, j;\n\tlet m = new Map();\n\tfor (i = 0; i < s.length; i++)\n\t\tm.set(s[i], m.get(s[i]) == null ? 1 : m.get(s[i]) + 1);\n\tlet sum = 0, product = 1;\n\tfor (let it of m) {\n\t\tconsole.log(m)\n\t\tif (prime[it[1]]) {\n\t\t\tsum += it[1];\n\t\t\tproduct *= it[1];\n\t\t}\n\t}\n\tdocument.write(\"Sum = \" + sum);\n\tdocument.write(\"<br>Product = \" + product);\n}", "8078": "function countChar(str, x)\n\t{\n\t\tlet count = 0;\n\t\tlet n = 10;\n\t\tfor (let i = 0; i < str.length; i++)\n\t\t\tif (str[i] == x)\n\t\t\t\tcount++;\n\t\tlet repetitions = n / str.length;\n\t\tcount = count * repetitions;\n\t\tfor (let i = 0; i < n % str.length; i++)\n\t\t{\n\t\t\tif (str[i] == x)\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "8085": "function multipleOrFactor(s1, s2){\n\tlet m1 = new Map();\n\tlet m2 = new Map();\n\tfor (let i = 0; i < s1.length; i++){\n\t\tif(m1[s1[i]])\n\t\tm1[s1[i]]++;\n\t\telse\n\t\tm1[s1[i]] = 1\n\t}\n\tfor (let i = 0; i < s2.length; i++){\n\tif(m2[s2[i]])\n\t\tm2[s2[i]]++;\n\t\telse\n\t\tm2[s2[i]] = 1\n\t}\n\tfor (var it in m1) {\n\t\tif (!(m2[it]))\n\t\t\tcontinue;\n\t\tif (m2[it] % m1[it] == 0 m1[it] % m2[it] == 0)\n\t\t\tcontinue;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "8099": "function checkIfUnequal(n,q)\n\t{\n\t\tlet s1 = n.toString();\n\t\tlet a = new Array(26);\n\t\tfor(let i = 0; i < a.length; i++)\n\t\t{\n\t\t\ta[i] = 0;\n\t\t}\n\t\tfor (let i = 0; i < s1.length; i++)\n\t\t\ta[s1[i].charCodeAt(0) - '0'.charCodeAt(0)]++;\n\t\tlet prod = n * q;\n\t\tlet s2 = prod.toString();\n\t\tfor (let i = 0; i < s2.length; i++)\n\t\t{\n\t\t\tif (a[s2[i].charCodeAt(0) - '0'.charCodeAt(0)] > 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\nfunction countInRange(l,r,q)\n\t{\n\t\tlet count = 0;\n\t\tfor (let i = l; i <= r; i++)\n\t\t{\n\t\t\tif (checkIfUnequal(i, q))\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "8110": "function is_possible(s)\n\t{\n\t\tlet l = s.length;\n\t\tlet one = 0, zero = 0;\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tif (s[i] == '0')\n\t\t\t\tzero++;\n\t\t\telse\n\t\t\t\tone++;\n\t\t}\n\t\tif (l % 2 == 0) \n\t\t\treturn (one == zero);\n\t\telse\n\t\t\treturn (Math.abs(one - zero) == 1);\n\t}", "8128": "function solve(s)\n\t{\n\t\tlet m = new Map();\n\t\tfor (let i = 0; i < s.length; i++)\n\t\t{\n\t\t\tif(m.has(s[i]))\n\t\t\t\t\t\tm.set(s[i],\n\t\t\t\t\t\tm.get(s[i]) + 1);\n\t\t\telse\n\t\t\t\tm.set(s[i], 1);\n\t\t}\n\t\tlet new_string = \"\";\n\t\tfor (let i = 0; i < s.length; i++)\n\t\t{\n\t\t\tif (m.get(s[i]) % 2 == 0)\n\t\t\t\tcontinue;\n\t\t\tnew_string = new_string + s[i];\n\t\t}\n\t\tdocument.write(new_string);\n\t}", "8167": "function countFreq(arr, n)\n\t{\n\t\tlet visited = new Array(n);\n\t\tvisited.fill(false);\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tif (visited[i] == true)\n\t\t\t\tcontinue;\n\t\t\tlet count = 1;\n\t\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\t\tif (arr[i] == arr[j]) {\n\t\t\t\t\tvisited[j] = true;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdocument.write(arr[i] + \" \" + count + \"</br>\");\n\t\t}\n\t}", "8168": "function countFreq(arr, n, limit)\n{\n\tlet count = new Array(limit + 1);\n\tcount.fill(0);\n\tfor(let i = 0; i < n; i++)\n\t\tcount[arr[i]]++;\n\tfor(let i = 0; i <= limit; i++)\n\t\tif (count[i] > 0)\n\t\t\tdocument.write(i + \" \" + count[i] + \"</br>\");\n}", "8169": "function countFreq(str)\n{\n\tlet count= new Array(limit + 1);\n\tfor(let i=0;i<count.length;i++)\n\t{\n\t\tcount[i]=0;\n\t}\n\tfor (let i = 0; i < str.length; i++)\n\t\tcount[str[i].charCodeAt(0)]++;\n\tfor (let i = 0; i <= limit; i++)\n\t{\tif (count[i] > 0)\n\t\t\tdocument.write(String.fromCharCode(i) + \" \" + count[i]+\"<br>\");\n\t}\n}", "8184": "function __builtin_popcount(n) {\n\tlet count = 0;\n\twhile (n > 0) {\n\t\tcount += n & 1;\n\t\tn >>= 1;\n\t}\n\treturn count;\n}\nfunction countEvenOdd(arr, n, K) {\n\tlet even = 0, odd = 0;\n\tfor (let i = 0; i < n; i++) {\n\t\tlet x = __builtin_popcount(arr[i]);\n\t\tif (x % 2 == 0)\n\t\t\teven++;\n\t\telse\n\t\t\todd++;\n\t}\n\tlet y;\n\ty = __builtin_popcount(K);\n\tif ((y & 1) != 0) {\n\t\tdocument.write(\"Even = \" + odd + \", Odd = \" + even);\n\t}\n\telse {\n\t\tdocument.write(\"Even = \" + even + \", Odd = \" + odd);\n\t}\n}", "8213": "function check(s, m)\n\t{\n\t\tlet l = s.length;\n\t\tlet c1 = 0;\n\t\tlet c2 = 0;\n\t\tfor (let i = 0; i < l; i++)\n\t\t{\n\t\t\tif (s[i] == '0')\n\t\t\t{\n\t\t\t\tc2 = 0;\n\t\t\t\tc1++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc1 = 0;\n\t\t\t\tc2++;\n\t\t\t}\n\t\t\tif (c1 == m c2 == m)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "8241": "function isDivisible(str, k)\n{\n\tlet n = str.length;\n\tlet c = 0;\n\tfor(let i = 0; i < k; i++)\n\t\tif (str[n - i - 1] == '0')\t\n\t\t\tc++;\n\treturn (c == k);\n}", "8281": "function productAtKthLevel(tree, k)\n\t{\n\t\tlet level = -1;\n\t\tlet product = 1;\n\t\tlet n = tree.length;\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tif (tree[i] == '(')\n\t\t\t\tlevel++;\n\t\t\telse if (tree[i] == ')')\n\t\t\t\tlevel--;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (level == k)\n\t\t\t\t\tproduct *= (tree[i].charCodeAt() - '0'.charCodeAt());\n\t\t\t}\n\t\t}\n\t\treturn product;\n\t}", "8296": "function isPalindrome(str) {\n var i = 0, j = str.length - 1;\n while (i < j)\n\tif (str[i++] != str[j--])\n\treturn false;\n return true;\n}\nfunction removePalinWords(str) {\n var final_str = \"\", word = \"\";\n str = str + \" \";\n var n = str.length;\n for (var i = 0; i < n; i++) {\n\tif (str[i] != ' ')\n\tword = word + str[i];\n\telse {\n\tif (!(isPalindrome(word)))\n\t\tfinal_str += word + \" \";\n\tword = \"\";\n\t}\n }\n return final_str;\n}", "8301": "function findSubSequence(s,num)\n\t{\n\t\tlet res = 0;\n\t\tlet i = 0;\n\t\twhile (num > 0) {\n\t\t\tif ((num & 1) == 1)\n\t\t\t\tres += s[i].charCodeAt(0) - '0'.charCodeAt(0);\n\t\t\ti++;\n\t\t\tnum = num >> 1;\n\t\t}\n\t\treturn res;\n\t}\nfunction combinedSum(s)\n\t{\n\t\tlet n = s.length;\n\t\tlet c_sum = 0;\n\t\tlet range = (1 << n) - 1;\n\t\tfor (let i = 0; i <= range; i++)\n\t\t\tc_sum += findSubSequence(s, i);\n\t\treturn c_sum;\n\t}", "8304": "function findSubsequence(str, k)\n{\n\tvar a = Array(MAX_CHAR).fill(0);\n\tfor (var i = 0; i < str.length; i++)\n\t\ta[str[i].charCodeAt(0) - 'a'.charCodeAt(0)]++; \n\tfor (var i = 0; i < str.length; i++)\n\t\tif (a[str[i].charCodeAt(0) - 'a'.charCodeAt(0)] >= k)\n\t\t\tdocument.write( str[i]); \n}", "8310": "function findDuplciates( a , n , m) {\n\t\tvar isPresent = Array(n).fill().map(() => Array(m).fill(0));\n\t\tfor (var i = 0; i < n; i++) {\n\t\t\tfor (var j = 0; j < m; j++) {\n\t\t\t\tisPresent[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0; i < n; i++) {\n\t\t\tfor (var j = 0; j < m; j++) {\n\t\t\t\tfor (var k = 0; k < n; k++) {\n\t\t\t\t\tif (a[i].charAt(j) == a[k].charAt(j) && i != k) {\n\t\t\t\t\t\tisPresent[i][j] = true;\n\t\t\t\t\t\tisPresent[k][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\t\tif (a[i].charAt(j) == a[i].charAt(k) && j != k) {\n\t\t\t\t\t\tisPresent[i][j] = true;\n\t\t\t\t\t\tisPresent[i][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0; i < n; i++)\n\t\t\tfor (var j = 0; j < m; j++)\n\t\t\t\tif (isPresent[i][j] == false)\n\t\t\t\t\tdocument.write(a[i].charAt(j));\n\t}", "8315": "function convert( str)\n{\n\t\tvar w = \"\", z = \"\";\n\t\tstr = str.toUpperCase() + \" \";\n\t\tfor (i = 0; i < str.length; i++) {\n\t\t\tvar ch = str[i];\n\t\t\tif (ch != ' ')\n\t\t\t\tw = w + ch;\n\t\t\telse {\n\t\t\t\tz = z + (w[0].toLowerCase()) + w.substring(1) + \" \";\n\t\t\t\tw = \"\";\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}", "8316": "function convert( s) {\n\t\tvar n = s.length;\n\t\tvar s1 = \"\";\n\t\ts1 = s1 + s.charAt(0).toLowerCase();\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tif (s.charAt(i) == ' ' && i < n) {\n\t\t\t\ts1 = s1 + \" \" + s.charAt(i+1).toLowerCase();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse\n\t\t\t\ts1 = s1 + s.charAt(i).toUpperCase();\n\t\t}\n\t\treturn s1;\n\t}", "8366": "function isVowel(c)\n{\n\treturn (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');\n}\nfunction encryptString(s, n, k)\n{\n\tvar countVowels = 0;\n\tvar countConsonants = 0;\n\tvar ans = \"\";\n\tfor (var l = 0; l <= n - k; l++) {\n\t\tcountVowels = 0;\n\t\tcountConsonants = 0;\n\t\tfor (var r = l; r <= l + k - 1; r++) {\n\t\t\tif (isVowel(s[r]) == true)\n\t\t\t\tcountVowels++;\n\t\t\telse\n\t\t\t\tcountConsonants++;\n\t\t}\n\t\tans += (countVowels * countConsonants).toString();\n\t}\n\treturn ans;\n}", "8367": "function isVowel(c) {\n\t\treturn c === \"a\" || c === \"e\" || c === \"i\" ||\n\t\tc === \"o\" || c === \"u\";\n\t}\nfunction encryptString(s, n, k) {\n\t\tvar cv = new Array(n).fill(0);\n\t\tvar cc = new Array(n).fill(0);\n\t\tif (isVowel(s[0])) cv[0] = 1;\n\t\telse cc[0] = 1;\n\t\tfor (var i = 1; i < n; i++) {\n\t\tcv[i] = cv[i - 1] + (isVowel(s[i]) === true ? 1 : 0);\n\t\tcc[i] = cc[i - 1] + (isVowel(s[i]) === true ? 0 : 1);\n\t\t}\n\t\tvar ans = \"\";\n\t\tvar prod = 0;\n\t\tprod = cc[k - 1] * cv[k - 1];\n\t\tans += prod;\n\t\tfor (var i = k; i < s.length; i++) {\n\t\tprod = (cc[i] - cc[i - k]) * (cv[i] - cv[i - k]);\n\t\tans += prod;\n\t\t}\n\t\treturn ans;\n\t}", "8374": "function countOccurrences(str,word)\n\t{\n\tlet a = str.split(\" \");\n\tlet count = 0;\n\tfor (let i = 0; i < a.length; i++)\n\t{\n\tif (word==(a[i]))\n\t\tcount++;\n\t}\n\treturn count;\n\t}", "8396": "function isValidISBN(isbn)\n\t{\n\t\tlet n = isbn.length;\n\t\tif (n != 10)\n\t\t\treturn false;\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < 9; i++)\n\t\t{\n\t\t\tlet digit = isbn[i] - '0';\n\t\t\tif (0 > digit 9 < digit)\n\t\t\t\treturn false;\n\t\t\tsum += (digit * (10 - i));\n\t\t}\n\t\tlet last = isbn[9];\n\t\tif (last != 'X' && (last < '0' last > '9'))\n\t\t\treturn false;\n\t\tsum += ((last == 'X') ? 10 : (last - '0'));\n\t\treturn (sum % 11 == 0);\n\t}", "8460": "function canFormPalindrome(str)\n\t{\n\t\tlet count = new Array(NO_OF_CHARS);\n\t\tcount.fill(0);\n\t\tfor (let i = 0; i < str.length; i++)\n\t\t\tcount[str[i].charCodeAt()]++;\n\t\tlet odd = 0;\n\t\tfor (let i = 0; i < NO_OF_CHARS; i++) {\n\t\t\tif ((count[i] & 1) != 0)\n\t\t\t\todd++;\n\t\t\tif (odd > 1)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}", "8490": "function permute(input)\n{\n\tvar n = input.length;\n\tvar max = 1 << n;\n\tinput = input.toLowerCase();\n\tfor(var i = 0;i < max; i++)\n\t{\n\t\tvar combination = input.split('');\n\t\tfor(var j = 0; j < n; j++)\n\t\t{\n\t\t\tif(((i >> j) & 1) == 1)\n\t\t\t\tcombination[j] = String.fromCharCode(combination[j].charCodeAt(0)-32);\n\t\t}\n\t\tdocument.write(combination.join(''));\n\t\tdocument.write(\" \");\n\t}\n}", "8501": "function isNumber(s)\n\t{\n\t\tfor (let i = 0; i < s.length; i++)\n\t\t\tif (s[i] < '0' s[i] > '9')\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "8506": "function printString(str, ch , count)\n{\n\tvar occ = 0, i;\n\tif (count == 0) {\n\t\tdocument.write(str);\n\t\treturn;\n\t}\n\tfor (i = 0; i < str.length; i++) {\n\t\tif (str.charAt(i) == ch)\n\t\t\tocc++;\n\t\tif (occ == count)\n\t\t\tbreak;\n\t}\n\tif (i < str.length - 1)\n\t\tdocument.write(str.substring(i + 1));\n\telse\n\t\tdocument.write(\"Empty string\");\n}", "8527": "function isVowel(c) {\n\t\treturn (c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U');\n\t}\nfunction reverseVowel(str1) {\n\t\tlet j = 0;\n\t\tlet str = str1.split('');\n\t\tlet vowel = \"\";\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tif (isVowel(str[i])) {\n\t\t\t\tj++;\n\t\t\t\tvowel += str[i];\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tif (isVowel(str[i])) {\n\t\t\t\tstr[i] = vowel[--j];\n\t\t\t}\n\t\t}\n\t\treturn str.join(\"\");\n\t}", "8528": "function isVowel(c)\n{\n\treturn (c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U');\n}\nfunction reverseVowel(str)\n{\n\tlet i = 0;\n\tlet j = str.length-1;\n\tlet str1 = str.split(\"\");\n\twhile (i < j)\n\t{\n\t\tif (!isVowel(str1[i]))\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isVowel(str1[j]))\n\t\t{\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\t\tlet t = str1[i];\n\t\tstr1[i]= str1[j];\n\t\tstr1[j]= t;\n\t\ti++;\n\t\tj--;\n\t}\n\tlet str2 = (str1).join(\"\");\n\treturn str2;\n}", "8538": "function firstLetterWord(str)\n\t{\n\t\tlet result = \"\";\n\t\tlet v = true;\n\t\tfor (let i = 0; i < str.length; i++)\n\t\t{\n\t\t\tif (str[i] == ' ')\n\t\t\t{\n\t\t\t\tv = true;\n\t\t\t}\n\t\t\telse if (str[i] != ' ' && v == true)\n\t\t\t{\n\t\t\t\tresult += (str[i]);\n\t\t\t\tv = false;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}", "8539": "function processWords(input)\n{\n\t\tvar s = input.split(' ');\n\t\ts.forEach(element => {\n\t\t\tcharBuffer+=element[0];\n\t\t});\n\treturn charBuffer;\n}", "8577": "function largest_alphabet(a, n)\n\t{\n\t\tlet max = 'A';\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tif (a[i].charCodeAt() > max.charCodeAt())\n\t\t\t\tmax = a[i];\n\t\treturn max;\n\t}\nfunction smallest_alphabet(a, n)\n\t{\n\t\tlet min = 'z';\n\t\tfor (let i = 0; i < n - 1; i++)\n\t\t\tif (a[i].charCodeAt() < min.charCodeAt())\n\t\t\t\tmin = a[i];\n\t\treturn min;\n\t}", "8615": "function maximumPalinUsingKChanges(str,k)\n{\n\tlet palin = str.split(\"\");\n\tlet ans = \"\";\n\tlet l = 0;\n\tlet r = str.length - 1;\n\twhile (l < r) {\n\tif (str[l] != str[r]) {\n\t\tpalin[l] = palin[r] = String.fromCharCode(Math.max(\n\t\tstr.charAt(l), str.charAt(r)));\n\t\tk--;\n\t}\n\tl++;\n\tr--;\n\t}\n\tif (k < 0) {\n\treturn \"Not possible\";\n\t}\n\tl = 0;\n\tr = str.length - 1;\n\twhile (l <= r) {\n\tif (l == r) {\n\t\tif (k > 0) {\n\t\tpalin[l] = '9';\n\t\t}\n\t}\n\tif (palin[l] < '9') {\n\t\tif (k >= 2 && palin[l] == str[l] && palin[r] == str[r]) {\n\t\tk -= 2;\n\t\tpalin[l] = palin[r] = '9';\n\t\t}\n\t\telse if (k >= 1\n\t\t\t\t&& (palin[l] != str[l] palin[r] != str[r])) {\n\t\tk--;\n\t\tpalin[l] = palin[r] = '9';\n\t\t}\n\t}\n\tl++;\n\tr--;\n\t}\n\tfor (let i = 0; i < palin.length; i++)\n\tans += palin[i];\n\treturn ans;\n}", "8636": "function generateAllStringsUtil(K, str, n)\n{\n\tif (n == K)\n\t{\n\t\tstr[n] = '\\0' ;\n\t\tdocument.write(str.join(\"\") + \" \");\n\t\treturn ;\n\t}\n\tif (str[n-1] == '1')\n\t{\n\t\tstr[n] = '0';\n\t\tgenerateAllStringsUtil (K , str , n+1);\n\t}\n\tif (str[n-1] == '0')\n\t{\n\t\tstr[n] = '0';\n\t\tgenerateAllStringsUtil(K, str, n+1);\n\t\tstr[n] = '1';\n\t\tgenerateAllStringsUtil(K, str, n+1) ;\n\t}\n}\nfunction generateAllStrings(K )\n{\n\tif (K <= 0)\n\t\treturn ;\n\tvar str = new Array(K);\n\tstr[0] = '0' ;\n\tgenerateAllStringsUtil ( K , str , 1 ) ;\n\tstr[0] = '1' ;\n\tgenerateAllStringsUtil ( K , str , 1 );\n}", "8702": "function countTriplets(A)\n{\n\tvar cnt = 0;\n\tvar tuples = new Map();\n\tA.forEach(a => {\n\t\tA.forEach(b => {\n\t\t\tif(tuples.has(a & b))\n\t\t\t\ttuples.set(a & b, tuples.get(a & b)+1)\n\t\t\telse\n\t\t\t\ttuples.set(a & b, 1) }); });\n\tA.forEach(a => {\n\t\ttuples.forEach((value, key) => {\n\t\t\tif ((key & a) == 0) cnt += value; }); });\n\treturn cnt;\n}", "8705": "function isPalindrome(str)\n\t{\n\t\tlet l = 0;\n\t\tlet h = str.length - 1;\n\t\twhile (h > l)\n\t\t\tif (str[l++] != str[h--])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nfunction minRemovals(str)\n\t{\n\t\tif (str[0] == '')\n\t\t\treturn 0;\n\t\tif (isPalindrome(str))\n\t\t\treturn 1;\n\t\treturn 2;\n\t}", "8787": "", "8788": "function RevString(s, l)\n{\n\tif (l % 2 == 0)\n\t{\n\t\tlet j = parseInt(l / 2, 10);\n\t\twhile (j <= l - 1)\n\t\t{\n\t\t\tlet temp;\n\t\t\ttemp = s[l - j - 1];\n\t\t\ts[l - j - 1] = s[j];\n\t\t\ts[j] = temp;\n\t\t\tj += 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlet j = parseInt((l / 2), 10) + 1;\n\t\twhile (j <= l - 1)\n\t\t{\n\t\t\tlet temp;\n\t\t\ttemp = s[l - j - 1];\n\t\t\ts[l - j - 1] = s[j];\n\t\t\ts[j] = temp;\n\t\t\tj += 1;\n\t\t}\n\t}\n\tlet S = s[0];\n\tfor(let i = 1; i < 9; i++)\n\t{\n\t\tS = S + \" \" + s[i];\n\t}\n\treturn S;\n}", "8795": "function reverse(str, len) {\n\t\t\tif (len == str.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treverse(str, len + 1);\n\t\t\tdocument.write(str[len]);\n\t\t}", "8823": "function getProbability(balls, M)\n{\n\tfactorial(10);\n\tbox2 = M;\n\tvar K = 0;\n\tfor(var i = 0; i < M; i++)\n\t\tK += balls[i];\n\tif (K % 2 == 1)\n\t\treturn 0;\n\tvar all = comb(K, K / 2);\n\tvar validPermutation = validPermutations(K / 2, balls, 0, 0, M);\n\treturn validPermutation / all;\n}\nfunction validPermutations(n, balls,usedBalls, i, M)\n{\n\tif (usedBalls == n)\n\t{\n\t\treturn box1 == box2 ? 1 : 0;\n\t}\n\tif (i >= M)\n\t\treturn 0;\n\tvar res = validPermutations(n, balls, usedBalls, i + 1, M);\n\tbox1++;\n\tfor(var j = 1; j <= balls[i]; j++)\n\t{\n\t\tif (j == balls[i])\n\t\t\tbox2--;\n\t\tvar combinations = comb(balls[i], j);\n\t\tres += combinations * validPermutations(n, balls, usedBalls + j, i + 1, M);\n\t}\n\tbox1--;\n\tbox2++;\n\treturn res;\n}\nfunction factorial(N)\n{\n\tfact[0] = 1;\n\tfor(var i = 1; i <= N; i++)\n\t\tfact[i] = fact[i - 1] * i;\n}\nfunction comb(n, r)\n{\n\tvar res = fact[n] / fact[r];\n\tres /= fact[n - r];\n\treturn res;\n}", "8840": "function parity(even, odd, v, i)\n{\n\tif (i == v.length even.length == 0 && odd.length == 0) {\n\t\tvar count = 0;\n\t\tfor (var j = 0; j < v.length - 1; j++) {\n\t\t\tif (v[j] % 2 != v[j + 1] % 2)\n\t\t\t\tcount++;\n\t\t}\n\t\tif (count < min)\n\t\t\tmin = count;\n\t\treturn min;\n\t}\n\tif (v[i] != -1)\n\t\tmin = parity(even, odd, v, i + 1);\n\telse {\n\t\tif (even.length != 0) {\n\t\t\tvar x = even.back();\n\t\t\teven.pop();\n\t\t\tv[i] = x;\n\t\t\tmin = parity(even, odd, v, i + 1);\n\t\t\teven.push(x);\n\t\t}\n\t\tif (odd.length != 0) {\n\t\t\tvar x = odd[odd.length-1];\n\t\t\todd.pop();\n\t\t\tv[i] = x;\n\t\t\tmin = parity(even, odd, v, i + 1);\n\t\t\todd.push(x);\n\t\t}\n\t}\n\treturn min;\n}\nfunction minDiffParity(v, n)\n{\n\tvar even = [];\n\tvar odd = [];\n\tvar m = new Map();\n\tfor (var i = 1; i <= n; i++)\n\t\tm.set(i, 1);\n\tfor (var i = 0; i < v.length; i++) {\n\t\tif (v[i] != -1)\n\t\t\tm.delete(v[i]);\n\t}\n\tm.forEach((value, key) => {\n\t\tif (i.first % 2 == 0)\n\t\t\teven.push(key);\n\t\telse\n\t\t\todd.push(key); });\n\tmin = parity(even, odd, v, 0);\n\tdocument.write( min );\n}", "8855": "function dfs(u, count)\n\t{\n\t\tvisited[u] = true;\n\t\tlet temp = 0;\n\t\tfor (let i = 0; i < adjacent[u].length; i++)\n\t\t{\n\t\t\tif (!visited[adjacent[u][i]])\n\t\t\t{\n\t\t\t\ttemp++;\n\t\t\t\tdfs(adjacent[u][i], count + 1);\n\t\t\t}\n\t\t}\n\t\tif (temp == 0)\n\t\t{\n\t\t\tif (maxi < count)\n\t\t\t{\n\t\t\t\tmaxi = count;\n\t\t\t\tstartnode = u;\n\t\t\t}\n\t\t}\n\t}\nfunction dfs1(u, count)\n\t{\n\t\tvisited[u] = true;\n\t\tlet temp = 0;\n\t\tfor (let i = 0; i < adjacent[u].length; i++)\n\t\t{\n\t\t\tif (!visited[adjacent[u][i]])\n\t\t\t{\n\t\t\t\ttemp++;\n\t\t\t\tparent[adjacent[u][i]] = u;\n\t\t\t\tdfs1(adjacent[u][i], count + 1);\n\t\t\t}\n\t\t}\n\t\tif (temp == 0)\n\t\t{\n\t\t\tif (maxi < count)\n\t\t\t{\n\t\t\t\tmaxi = count;\n\t\t\t\tendnode = u;\n\t\t\t}\n\t\t}\n\t}\nfunction dfs2(u, count)\n\t{\n\t\tvisited[u] = true;\n\t\tlet temp = 0;\n\t\tfor (let i = 0; i < adjacent[u].length; i++)\n\t\t{\n\t\t\tif (!visited[adjacent[u][i]] && !vis[adjacent[u][i]])\n\t\t\t{\n\t\t\t\ttemp++;\n\t\t\t\tdfs2(adjacent[u][i], count + 1);\n\t\t\t}\n\t\t}\n\t\tif (temp == 0)\n\t\t{\n\t\t\tif (maxi < count)\n\t\t\t{\n\t\t\t\tmaxi = count;\n\t\t\t\tthirdnode = u;\n\t\t\t}\n\t\t}\n\t}\nfunction findNodes()\n\t{\n\t\tdfs(1, 0);\n\t\tfor (let i = 0; i <= N; i++)\n\t\t\tvisited[i] = false;\n\t\tmaxi = -1;\n\t\tdfs1(startnode, 0);\n\t\tfor (let i = 0; i <= N; i++)\n\t\t\tvisited[i] = false;\n\t\tlet x = endnode;\n\t\tvis[startnode] = true;\n\t\twhile (x != startnode)\n\t\t{\n\t\t\tvis[x] = true;\n\t\t\tx = parent[x];\n\t\t}\n\t\tmaxi = -1;\n\t\tfor (let i = 1; i <= N; i++)\n\t\t{\n\t\t\tif (vis[i])\n\t\t\t\tdfs2(i, 0);\n\t\t}\n\t}", "8858": "function dfs(i, j, grid, vis, z, z_count)\n\t{\n\tlet n = grid.length, m = grid[0].length;\n\tvis[i][j] = true;\n\tif (grid[i][j] == 0)\n\t\tz++;\n\tif (grid[i][j] == 2)\n\t{\n\t\tif (z == z_count)\n\t\tans++;\n\t\tvis[i][j] = false;\n\t\treturn;\n\t}\n\tif (i >= 1 && !vis[i - 1][j] && grid[i - 1][j] != -1)\n\t\tdfs(i - 1, j, grid, vis, z, z_count);\n\tif (i < n - 1 && !vis[i + 1][j] && grid[i + 1][j] != -1)\n\t\tdfs(i + 1, j, grid, vis, z, z_count);\n\tif (j >= 1 && !vis[i][j - 1] && grid[i][j - 1] != -1)\n\t\tdfs(i, j - 1, grid, vis, z, z_count);\n\tif (j < m - 1 && !vis[i][j + 1] && grid[i][j + 1] != -1)\n\t\tdfs(i, j + 1, grid, vis, z, z_count);\n\tvis[i][j] = false;\n\t}\nfunction uniquePaths(grid)\n\t{\n\tlet n = grid.length, m = grid[0].length;\n\tlet vis = new Array(n);\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tvis[i] = new Array(m);\n\t\tfor(let j = 0; j < m; j++)\n\t\t{\n\t\t\tvis[i][j] = false;\n\t\t}\n\t}\n\tlet x = 0, y = 0;\n\tfor (let i = 0; i < n; ++i)\n\t{\n\t\tfor (let j = 0; j < m; ++j)\n\t\t{\n\t\tif (grid[i][j] == 0)\n\t\t\tz_count++;\n\t\telse if (grid[i][j] == 1)\n\t\t{\n\t\t\tx = i;\n\t\t\ty = j;\n\t\t}\n\t\t}\n\t}\n\tdfs(x, y, grid, vis, 0, z_count);\n\treturn ans;\n\t}", "8907": "function numPairs(a, n)\n\t{\n\t\tlet ans, i, index;\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t\ta[i] = Math.abs(a[i]);\n\t\ta.sort();\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tindex = 2;\n\t\t\tans += index - i - 1;\n\t\t}\n\t\treturn ans;\n\t}", "8939": "function power(x, y, p)\n{\n\tvar res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif (y & 1)\n\t\t\tres = (res * x) % p;\n\t\ty = y >> 1;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nfunction findModuloByM(X, N, M)\n{\n\tif (N < 6)\n\t{\n\t\tvar temp = \"\";\n\t\tfor(var i = 1; i < N; i++)\n\t\t{\n\t\t\ttemp += String.fromCharCode(48 + X);\n\t\t}\n\t\tvar res = parseInt(temp) % M;\n\t\treturn res;\n\t}\n\tif (N % 2 == 0)\n\t{\n\t\tvar half = findModuloByM(X, N / 2, M) % M;\n\t\tvar res = (half *\n\t\t\t\tpower(10, N / 2, M) + half) % M;\n\t\treturn res;\n\t}\n\telse\n\t{\n\t\tvar half = findModuloByM(X, N / 2, M) % M;\n\t\tvar res = (half * power(10, N / 2 + 1, M) + half * 10 + X) % M;\n\t\treturn res;\n\t}\n}", "9007": "function check(C)\n{\n\tlet C1C2 = Math.sqrt(\n\t\t(C[1].x - C[0].x) * (C[1].x - C[0].x) +\n\t\t(C[1].y - C[0].y) * (C[1].y - C[0].y));\n\tlet flag = false;\n\tif (C1C2 < (C[0].r + C[1].r))\n\t{\n\t\tif ((C[0].x + C[1].x) == 2 * C[2].x &&\n\t\t\t(C[0].y + C[1].y) == 2 * C[2].y)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t}\n\treturn flag;\n}\nfunction IsFairTriplet(c)\n{\n\tlet f = false;\n\tf |= check(c);\n\tfor(let i = 0; i < 2; i++)\n\t{\n\t\tswap(c[0], c[2]);\n\t\tf |= check(c);\n\t}\n\treturn f;\n}\nfunction swap(circle1,circle2)\n{\n\tlet temp = circle1;\n\tcircle1 = circle2;\n\tcircle2 = temp;\n}", "9009": "function eccHyperbola(A, B)\n{\n\tlet r = B * B / A * A;\n\tr += 1;\n\treturn Math.sqrt(r);\n}", "9012": "function calculateArea(A, B, C, D){\n\tlet S = (A + B + C + D) /2\n\tlet area = Math.sqrt((S - A) * (S - B) *\n\t\t\t\t(S - C) * (S - D))\n\treturn area;\n\t}", "9015": "function triangleArea(a, b){\n\tratio = b / a\n\tdocument.write(ratio)\n}", "9021": "function distance( m, n, p, q)\n{\n\treturn Math.sqrt(Math.pow(n - m, 2)\n\t\t\t\t+ Math.pow(q - p, 2) * 1.0);\n}\nfunction Excenters( x1, y1, x2, y2, x3, y3)\n{\n\tvar a = distance(x2, x3, y2, y3);\n\tvar b = distance(x3, x1, y3, y1);\n\tvar c = distance(x1, x2, y1, y2);\n\tvar excenter = new Array(4);\n\tfor (var i= 0; i<4;i++)\n\t\texcenter[i] = new Array(2);\n\texcenter[1][0]\n\t\t= (-(a * x1) + (b * x2) + (c * x3))\n\t\t/ (-a + b + c);\n\texcenter[1][1]\n\t\t= (-(a * y1) + (b * y2) + (c * y3))\n\t\t/ (-a + b + c);\n\texcenter[2][0]\n\t\t= ((a * x1) - (b * x2) + (c * x3))\n\t\t/ (a - b + c);\n\texcenter[2][1]\n\t\t= ((a * y1) - (b * y2) + (c * y3))\n\t\t/ (a - b + c);\n\texcenter[3][0]\n\t\t= ((a * x1) + (b * x2) - (c * x3))\n\t\t/ (a + b - c);\n\texcenter[3][1]\n\t\t= ((a * y1) + (b * y2) - (c * y3))\n\t\t/ (a + b - c);\n\tfor (var i = 1; i <= 3; i++) {\n\t\tdocument.write(excenter[i][0] + \" \" + excenter[i][1] +\"<br>\");\n\t}\n}", "9070": "function areaOfSquare(S)\n\t{\n\t\tlet area = S * S;\n\t\treturn area;\n\t}", "9079": "function maxPointOfIntersection(x, y)\n{\n\tlet k = y * (y - 1) / 2;\n\tk = k + x * (2 * y + x - 1);\n\treturn k;\n}", "9113": "function Icositetragonal_num(n)\n{\n\treturn (22 * n * n - 20 * n) / 2;\n}", "9114": "function Icosihenagonal_num(n)\n\t{\n\t\treturn (19 * n * n - 17 * n) / 2;\n\t}", "9119": "function area_of_circle(m, n) \n{ \n\tvar square_of_radius = ( m * n ) / 4; \n\tvar area = ( 3.141 * square_of_radius ); \n\treturn area; \n}", "9129": "function area(R)\n{\n\tvar base = 1.732 * R;\n\tvar height = (1.5) * R;\n\tvar area = 0.5 * base * height;\n\treturn area;\n}", "9130": "function circlearea(R)\n{\n\tif (R < 0)\n\t\treturn -1;\n\tvar a = 3.14 * R * R / 4;\n\treturn a;\n}", "9137": "function countPairs(P, Q, N, M)\n{\n\tvar A = [0, 0], B = [0, 0];\n\tfor(var i = 0; i < N; i++)\n\t\tA[P[i] % 2]++;\n\tfor(var i = 0; i < M; i++)\n\t\tB[Q[i] % 2]++;\n\treturn(A[0] * B[0] + A[1] * B[1]);\n}", "9142": "function find_Centroid(v) \n\t{ \n\t\tlet ans = new Array(2); \n\t\tans.fill(0);\n\t\tlet n = v.length; \n\t\tlet signedArea = 0; \n\t\tfor (let i = 0; i < n; i++)\n\t\t{ \n\t\t\tlet x0 = v[i][0], y0 = v[i][1]; \n\t\t\tlet x1 = v[(i + 1) % n][0], y1 = v[(i + 1) % n][1]; \n\t\t\tlet A = (x0 * y1) - (x1 * y0); \n\t\t\tsignedArea += A; \n\t\t\tans[0] += (x0 + x1) * A; \n\t\t\tans[1] += (y0 + y1) * A; \n\t\t} \n\t\tsignedArea *= 0.5; \n\t\tans[0] = (ans[0]) / (6 * signedArea); \n\t\tans[1]= (ans[1]) / (6 * signedArea); \n\t\treturn ans; \n\t}", "9147": "function countIntersections(n)\n{\n\treturn n * (n - 1) / 2;\n}", "9169": "function newvol(x)\n{\n\tdocument.write( \"percentage increase in the\"\n\t\t+ \" volume of the sphere is \"\n\t\t+( Math.pow(x, 3) / 10000 + 3 * x\n\t\t\t\t+ (3 * Math.pow(x, 2)) / 100) + \"%\");\n}", "9177": "function areaOfTriangle(d)\n{\n\tvar c = 1.618 * d;\n\tvar s = (d + c + c) / 2;\n\tvar area = Math.sqrt(s * (s - c) *\n\t\t\t\t\t\t(s - c) * (s - d));\n\treturn 5 * area;\n}\nfunction areaOfRegPentagon( d)\n{\n\tvar cal = 4 * Math.tan(PI / 5);\n\tvar area = (5 * d * d) / cal;\n\treturn area;\n}\nfunction areaOfPentagram(d)\n{\n\treturn areaOfRegPentagon(d) +\n\t\t\t\t\t\t\tareaOfTriangle(d);\n}", "9181": "function anglequichord(z)\n{\n\tdocument.write(\"The angle is \" + z + \" degrees\");\n}", "9187": "function circle(x1 , y1 , x2, y2 , r1 , r2) \n{ \n\tvar distSq = parseInt(Math.sqrt(((x1 - x2) \n\t\t\t\t\t\t\t\t* (x1 - x2)) \n\t\t\t\t\t\t\t\t+ ((y1 - y2) \n\t\t\t\t\t\t\t\t* (y1 - y2)))); \n\tif (distSq + r2 == r1) \n\t{\n\t\tdocument.write(\"The smaller circle lies completely\" + \" inside the bigger circle with \" + \"touching each other \" + \"at a point of circumference. \") ;\n\t}\n\telse if (distSq + r2 < r1) \n\t{\n\t\tdocument.write(\"The smaller circle lies completely\" + \" inside the bigger circle without\" + \" touching each other \" + \"at a point of circumference.\") ;\n\t}\n\telse\n\t{\n\t\tdocument.write(\"The smaller does not lies inside\" + \" the bigger circle completely.\") ;\n\t}\n}", "9195": "function lengtang(r1 , r2 , d)\n{\n\tdocument.write(\"The length of the direct\"\n\t\t\t+ \" common tangent is \"\n\t\t\t+ (Math.sqrt(Math.pow(d, 2) -\n\t\t\t\tMath.pow((r1 - r2), 2))).toFixed(5));\n}", "9196": "function rad(d, h)\n{\n\tdocument.write(\"The radius of the circle is \"\n\t+((d * d) / (8 * h) + h / 2));\n}", "9197": "function shortdis(r, d)\n{\n\tdocument.write(\"The shortest distance \"\n\t\t+ \"from the chord to centre \"\n\t\t+ Math.sqrt((r * r) - ((d * d) / 4)) + \"<br>\");\n}", "9200": "function lengtang(r1, r2, d)\n{\n\tdocument.write(\"The length of the direct common tangent is \"+\n\t\tMath.sqrt(Math.pow(d, 2) - Math.pow((r1 - r2), 2)));\n}", "9201": "function length_of_chord(r, x)\n{\n\tdocument.write(\"The length of the chord\"\n\t\t+ \" of the circle is \"\n\t\t+ 2 * r * Math.sin(x * (3.14 / 180)) + \"<br>\");\n}", "9232": "function square(a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tvar x = 0.464 * a;\n\treturn x;\n}", "9238": "function polyapothem(n , a)\n{\n\tif (a < 0 && n < 0)\n\t\treturn -1;\n\treturn (a / (2 * Math.tan((180 / n) * 3.14159 / 180)));\n}", "9240": "function polyarea(n , r)\n{\n\tif (r < 0 && n < 0)\n\t\treturn -1;\n\tvar A = ((r * r * n) * Math.sin((360 / n) * 3.14159 / 180)) / 2;\n\treturn A;\n}", "9241": "function polyarea(n , a)\n{\n\tif (a < 0 && n < 0)\n\t\treturn -1;\n\tvar A = (a * a * n) / (4 * Math.tan((180 / n) * 3.14159 / 180));\n\treturn A;\n}", "9247": "function hexDiagonal(a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tvar d = 1.73 * a;\n\treturn d;\n}", "9250": "function calculateSide( n , r)\n{\n\tvar theta, theta_in_radians;\n\ttheta = 360 / n;\n\ttheta_in_radians = theta * 3.14 / 180;\n\treturn 2 * r * Math.sin(theta_in_radians / 2);\n}", "9257": "function cyl(r , R , h)\n{\n\tif (h < 0 && r < 0 && R < 0)\n\t\treturn -1;\n\tvar r1 = r;\n\tvar h1 = h;\n\tvar V = (3.14 * Math.pow(r1, 2) * h1);\n\treturn V;\n}", "9258": "function findVolume(a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tvar r = a / 2;\n\tvar h = a;\n\tvar V = (3.14 * Math.pow(r, 2) * h);\n\treturn V;\n}", "9290": "function Perimeter(s, n)\n{\n\tvar perimeter = 1;\n\tperimeter = n * s;\n\treturn perimeter;\n}", "9291": "function area(r) {\n\t\treturn ((0.5) * (3.14) * (r * r));\n\t}\nfunction perimeter(r) {\n\t\treturn ((3.14) * (r));\n\t}", "9302": "", "9305": "function rhombusarea(l,b)\n{\n\tif (l < 0 b < 0)\n\t\treturn -1;\n\treturn (l * b) / 2;\n}", "9318": "function area(a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tvar area = Math.sqrt(a) / 6;\n\treturn area;\n}", "9329": "function longestRodInCuboid(length, breadth, height)\n{\n\tlet result;\n\tlet temp;\n\ttemp = length * length + breadth * breadth\n\t\t+ height * height;\n\tresult = Math.sqrt(temp);\n\treturn result;\n}", "9346": "function is_partition_possible(n,x,y,w)\n\t{\n\t\tlet weight_at_x = new Map();\n\tlet max_x = -2e3, min_x = 2e3;\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tlet new_x = x[i] - y[i];\n\t\tmax_x = Math.max(max_x, new_x);\n\t\tmin_x = Math.min(min_x, new_x);\n\t\tif(weight_at_x.has(new_x))\n\t\t{\n\t\t\tweight_at_x.set(new_x, weight_at_x.get(new_x) + w[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tweight_at_x.set(new_x,w[i]);\n\t\t}\n\t}\n\tlet sum_till = [];\n\tsum_till.push(0);\n\tfor (let s = min_x; s <= max_x; s++)\n\t{\n\t\tif(weight_at_x.get(s) == null)\n\t\t\tsum_till.push(sum_till[sum_till.length-1]);\n\t\telse\n\t\t\tsum_till.push(sum_till[sum_till.length-1] +\n\t\t\t\t\t\t\tweight_at_x.get(s));\n\t}\n\tlet total_sum = sum_till[sum_till.length-1];\n\tlet partition_possible = 0;\n\tfor (let i = 1; i < sum_till.length; i++)\n\t{\n\t\tif (sum_till[i] == total_sum - sum_till[i])\n\t\t\tpartition_possible = 1;\n\t\tif (sum_till[i-1] == total_sum - sum_till[i])\n\t\t\tpartition_possible = 1;\n\t}\n\tdocument.write(partition_possible == 1 ? \"YES\\n\" : \"NO\\n\");\n\t}", "9348": "function LiesInsieRectangle(a, b, x, y)\n{\n\tif (x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0)\n\t\treturn true;\n\treturn false;\n}", "9358": "function FindPoint(x1, y1, x2, y2, x, y)\n{\n\tif (x > x1 && x < x2 && y > y1 && y < y2)\n\t\treturn true;\n\treturn false;\n}", "9359": "function distance(a1, b1, c1, d1, a2, b2, c2, d2)\n{\n\tlet x1,y1,z1,d;\n\tif (a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2)\n\t{\n\t\tx1 = y1 = 0;\n\t\tz1 =-d1 / c1;\n\t\td = Math.abs(( c2 * z1 + d2)) /\n\t\t\t(Math.sqrt(a2 * a2 + b2 * b2 + c2 * c2));\n\t\tdocument.write(\"Perpendicular distance is \"+ d);\n\t}\n\telse\n\t\tdocument.write(\"Planes are not parallel\");\n}", "9362": "function shortest_distance( x1, y1, z1, a, b, c, d)\n{\n\td = Math.abs((a * x1 + b * y1 + c * z1 + d));\n\tlet e = Math.sqrt(a * a + b * b + c * c);\n\tdocument.write(\"Perpendicular distance is \"\n\t\t+ (d / e));\n\t\treturn;\n}", "9369": "function findVolume( l, b, h)\n{\n\tlet volume = (l * b * h) / 2;\n\treturn volume;\n}", "9405": "function findPCSlope(m)\n{\n\treturn -1.0 / m;\n}", "9423": "function isRectangle(a, b, c, d)\n\t{\n\t\tif (a == b && a == c && a == d && c == d && b == c && b == d)\n\t\t\treturn true;\n\t\telse if (a == b && c == d)\n\t\t\treturn true;\n\t\telse if (a == d && c == b)\n\t\t\treturn true;\n\t\telse if (a == c && d == b)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "9430": "function \narea_of_segment(radius, angle)\n{\n\tlet area_of_sector = pi *\n (radius * radius) * (angle / 360);\n\tlet area_of_triangle =\n\t\t1 / 2 * (radius * radius) *\n\t\tMath.sin((angle * pi) / 180);\n\treturn area_of_sector - area_of_triangle;\n}", "9432": "function midpoint(x1, x2, y1, y2)\n\t{\n\t\tdocument.write((x1 + x2) / 2 +\n\t\t\t\t\t\t\" , \" + (y1 + y2) / 2) ;\n\t}", "9445": "function maxvolume( s)\n{\n\tlet maxvalue = 0;\n\tfor (let i = 1; i <= s - 2; i++)\n\t{\n\t\tfor (let j = 1; j <= s - 1; j++)\n\t\t{\n\t\t\tlet k = s - i - j;\n\t\t\tmaxvalue = Math.max(maxvalue, i * j * k);\n\t\t}\n\t}\n\treturn maxvalue;\n}", "9446": "function maxvolume( s)\n{\n\tlet length = parseInt(s / 3);\n\ts -= length;\n\tlet breadth = parseInt(s / 2);\n\tlet height = s - breadth;\n\treturn length * breadth * height;\n}", "9452": "function volumeTriangular( a, b, h)\n{\n\tlet vol = (0.1666) * a *\n\t\t\t\t\tb * h;\n\treturn vol;\n}\nfunction volumeSquare( b, h)\n{\n\tlet vol = (0.33) * b *\n\t\t\t\t\tb * h;\n\treturn vol;\n}\nfunction volumePentagonal( a, b, h)\n{\n\tlet vol = (0.83) * a * b * h;\n\treturn vol;\n}\nfunction volumeHexagonal( a, b, h)\n{\n\tlet vol = a * b * h;\n\treturn vol;\n}", "9457": "function Area(b1, b2, h)\n{\n\treturn ((b1 + b2) / 2) * h;\n}", "9458": "function hexagonArea(s)\n{\n\treturn ((3 * Math.sqrt(3) *\n\t\t\t(s * s)) / 2);\t\n}", "9467": "function arcLength(diameter, angle)\n{\n\tlet pi = 22.0 / 7.0;\n\tlet arc;\n\tif (angle >= 360)\n\t{\n\t\tdocument.write(\"Angle cannot\" + \" be formed\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tarc = (pi * diameter) *\n\t\t\t(angle / 360.0);\n\t\treturn arc;\n\t}\n}", "9468": "function SectorArea(radius, angle)\n\t{\n\t\tif(angle >= 360)\n\t\t\tdocument.write(\"Angle not possible\");\n\t\telse\n\t\t{\n\t\t\tlet sector =((22 * radius * radius) / 7)\n\t\t\t\t\t\t* (angle / 360);\n\t\t\tdocument.write(sector);\n\t\t}\n\t}", "9476": "function maxSquare(b, m)\n{\n\treturn (b / m - 1) * (b / m) / 2; a\n}", "9478": "function checkCollision(a, b, c, x, y, radius)\n\t{\n\t\tlet dist = (Math.abs(a * x + b * y + c)) /\n\t\t\t\t\t\tMath.sqrt(a * a + b * b);\n\t\tif (radius == dist)\n\t\t\tdocument.write ( \"Touch\" );\n\t\telse if (radius > dist)\n\t\t\tdocument.write( \"Intersect\") ;\n\t\telse\n\t\t\tdocument.write( \"Outside\") ;\n\t}", "9496": "function numberOfDiagonals(n)\n{\n\treturn n * (n - 3) / 2;\n}", "9505": "function findRightAngle(A,H)\n{\n\tlet D = Math.pow(H, 4) - 16 * A * A;\n\tif (D >= 0)\n\t{\n\t\tlet root1 = (H * H + Math.sqrt(D)) / 2;\n\t\tlet root2 = (H * H - Math.sqrt(D)) / 2;\n\t\tlet a = Math.sqrt(root1);\n\t\tlet b = Math.sqrt(root2);\n\t\tif (b >= a)\n\tdocument.write(a + \" \" + b + \" \" + H+\"<br/>\");\n\t\telse\n\tdocument.write(b + \" \" + a + \" \" + H+\"<br/>\");\n\t}\n\telse\n\t\tdocument.write(\"-1\");\n}", "9507": "function numberOfSquares(base)\n\t{\n\t\tbase = (base - 2);\n\t\tbase = Math.floor(base / 2);\n\t\treturn base * (base + 1) / 2;\n\t}", "9528": "function polygonArea(X, Y, n)\n{\n\tlet area = 0.0;\n\tlet j = n - 1;\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tarea += (X[j] + X[i]) * (Y[j] - Y[i]);\n\t}\n\treturn Math.abs(area / 2.0);\n}", "9567": "", "9574": "function countSubsequences(arr)\n{\n\tlet odd = 0;\n\tfor (let x = 0; x < arr.length; x++) {\n\t\tif (arr[x] & 1)\n\t\t\todd++;\n\t}\n\treturn (1 << odd) - 1;\n}", "9608": "function performQuery(arr, Q)\n\t\t{\n\t\t\tfor (let i = 0; i < Q.length; i++) {\n\t\t\t\tlet or = 0;\n\t\t\t\tlet x = Q[i][0];\n\t\t\t\tarr[x - 1] = Q[i][1];\n\t\t\t\tfor (let j = 0; j < arr.length; j++) {\n\t\t\t\t\tor = or | arr[j];\n\t\t\t\t}\n\t\t\t\tdocument.write(or + \" \");\n\t\t\t}\n\t\t}", "9638": "function smallest(k, d) {\n\t\t\tlet cnt = 1;\n\t\t\tlet m = d % k;\n\t\t\tlet v = new Array(k).fill(0);\n\t\t\tv[m] = 1;\n\t\t\twhile (1) {\n\t\t\t\tif (m == 0)\n\t\t\t\t\treturn cnt;\n\t\t\t\tm = (((m * (10 % k)) % k) + (d % k)) % k;\n\t\t\t\tif (v[m] == 1)\n\t\t\t\t\treturn -1;\n\t\t\t\tv[m] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}", "9639": "function getPairsCount(arr, n)\n{\n\tlet count = 0;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tfor(let j = arr[i] - (i % arr[i]); j < n; j += arr[i])\n\t\t{\n\t\t\tif (i < j && Math.abs(arr[i] - arr[j]) >=\n\t\t\t\t\t\tMath.min(arr[i], arr[j]))\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "9673": "function check(N)\n{\n\tvar twos = 0, fives = 0;\n\twhile (N % 2 == 0)\n\t{\n\t\tN /= 2;\n\t\ttwos++;\n\t}\n\twhile (N % 5 == 0)\n\t{\n\t\tN /= 5;\n\t\tfives++;\n\t}\n\tif (N == 1 && twos <= fives)\n\t{\n\t\tdocument.write(2 * fives - twos);\n\t}\n\telse\n\t{\n\t\tdocument.write(-1);\n\t}\n}", "9685": "function rangeSum(arr, N, L, R)\n{\n\tlet sum = 0;\n\tfor(let i = L - 1; i < R; i++)\n\t{\n\t\tsum += arr[i % N];\n\t}\n\tdocument.write(sum);\n}", "9686": "function rangeSum(arr, N, L, R) {\n let prefix = new Array(N + 1);\n prefix[0] = 0;\n for (let i = 1; i <= N; i++) {\n\tprefix[i] = prefix[i - 1] + arr[i - 1];\n }\n let leftsum = ((L - 1) / N) * prefix[N] + prefix[(L - 1) % N];\n let rightsum = (R / N) * prefix[N] + prefix[R % N];\n document.write(rightsum - leftsum);\n}", "9702": "function ExpoFactorial(N) {\n\tlet res = 1;\n\tlet mod = 1000000007;\n\tfor (let i = 2; i < N + 1; i++)\n\t\tres = Math.pow(i, res) % mod;\n\treturn res;\n}", "9704": "function maxSubArraySumRepeated(arr, N, K) {\n\tlet sum = 0;\n\tfor (let i = 0; i < N; i++)\n\t\tsum += arr[i];\n\tlet curr = arr[0];\n\tlet ans = arr[0];\n\tif (K == 1) {\n\t\tfor (let i = 1; i < N; i++) {\n\t\t\tcurr = Math.max(arr[i], curr + arr[i]);\n\t\t\tans = Math.max(ans, curr);\n\t\t}\n\t\treturn ans;\n\t}\n\tlet V = [];\n\tfor (let i = 0; i < 2 * N; i++) {\n\t\tV.push(arr[i % N]);\n\t}\n\tlet maxSuf = V[0];\n\tlet maxPref = V[2 * N - 1];\n\tcurr = V[0];\n\tfor (let i = 1; i < 2 * N; i++) {\n\t\tcurr += V[i];\n\t\tmaxPref = Math.max(maxPref, curr);\n\t}\n\tcurr = V[2 * N - 1];\n\tfor (let i = 2 * N - 2; i >= 0; i--) {\n\t\tcurr += V[i];\n\t\tmaxSuf = Math.max(maxSuf, curr);\n\t}\n\tcurr = V[0];\n\tfor (let i = 1; i < 2 * N; i++) {\n\t\tcurr = Math.max(V[i], curr + V[i]);\n\t\tans = Math.max(ans, curr);\n\t}\n\tif (sum > 0) {\n\t\tlet temp = sum * (K - 2);\n\t\tans = Math.max(ans, Math.max(temp + maxPref, temp + maxSuf));\n\t}\n\treturn ans;\n}", "9707": "function factorial(n)\n{\n\tif (n == 0)\n\t\treturn 1;\n\treturn n * factorial(n - 1);\n}\nfunction numOfNecklace(N)\n{\n\tvar ans = factorial(N)\n\t\t\t\t\t/ (factorial(N / 2) * factorial(N / 2));\n\tans = ans * factorial(N / 2 - 1);\n\tans = ans * factorial(N / 2 - 1);\n\tans /= 2;\n\treturn ans;\n}", "9726": "function gcd(a, b)\n{\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\nfunction countPairs(arr, N)\n{\n\tfor(var i = 0; i < N; i++)\n\t{\n\t\tvar count = 0;\n\t\tfor(var x = 1; x <= arr[i]; x++)\n\t\t{\n\t\t\tfor(var y = x; y <= arr[i]; y++)\n\t\t\t{\n\t\t\t\tif (gcd(x, y) > 1)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tdocument.write(count + \" \");\n\t}\n}", "9727": "function preCalculate(phi, ans) {\n phi[0] = 0;\n phi[1] = 1;\n for (let i = 2; i <= MAX; i++) phi[i] = i;\n for (let i = 2; i <= MAX; i++) {\n\tif (phi[i] == i) {\n\tfor (let j = i; j <= MAX; j += i)\n\t\tphi[j] -= Math.floor(phi[j] / i);\n\t}\n }\n for (let i = 1; i <= MAX; i++)\n ans[i] = ans[i - 1] + (i - phi[i]);\n}\nfunction countPairs(arr, N) {\n let phi = new Array(1e5).fill(0);\n let ans = new Array(1e5).fill(0);\n preCalculate(phi, ans);\n for (let i = 0; i < N; ++i) {\n\tdocument.write(ans[arr[i]] + \" \");\n }\n}", "9735": "function countSubarray(arr, n)\n{\n\tlet count = 0;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tfor(let j = i; j < n; j++)\n\t\t{\n\t\t\tlet mxSubarray = 0;\n\t\t\tlet mxOther = 0;\n\t\t\tfor(let k = i; k <= j; k++)\n\t\t\t{\n\t\t\t\tmxSubarray = Math.max(mxSubarray, arr[k]);\n\t\t\t}\n\t\t\tfor(let k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tmxOther = Math.max(mxOther, arr[k]);\n\t\t\t}\n\t\t\tfor(let k = j + 1; k < n; k++)\n\t\t\t{\n\t\t\t\tmxOther = Math.max( mxOther, arr[k]);\n\t\t\t}\n\t\t\tif (mxSubarray > (2 * mxOther))\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tdocument.write(count);\n}", "9736": "function countSubarray(arr, n)\n{\n\tvar count = 0, L = 0, R = 0;\n\tvar mx = Math.max.apply(null, arr);\n\tvar i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (arr[i] * 2 > mx) {\n\t\t\tL = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tif (arr[i] * 2 > mx) {\n\t\t\tR = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdocument.write((L + 1) * (n - R));\n}", "9738": "function isPrime(X) {\n\tfor (let i = 2; i * i <= X; i++)\n\t\t\treturn false;\n\treturn true;\n}\nfunction printPrimes(A, N)\n{\n\tfor (let i = 0; i < N; i++)\n\t{\n\t\tfor (let j = A[i] - 1; ; j--)\n\t\t{\n\t\t\tif (isPrime(j)) {\n\t\t\t\tdocument.write(j + \" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (let j = A[i] + 1; ; j++)\n\t\t{\n\t\t\tif (isPrime(j)) {\n\t\t\t\tdocument.write(j + \" \");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t}\n}", "9759": "function gcd(a, b){\n\tif(b == 0){\n\t\treturn a;\n\t}\n\treturn gcd(b, a % b);\n\t}\nfunction PrimeFactor(N)\n\t{\n\t\tlet primef = new Map();\n\t\twhile (N % 2 == 0)\n\t\t{\n\t\t\tif (primef.has(2))\n\t\t\t{\n\t\t\t\tprimef.set(2, primef.get(2) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprimef.set(2, 1);\n\t\t\t}\n\t\t\tN = parseInt(N / 2, 10);\n\t\t}\n\t\tfor(let i = 3; i <= Math.sqrt(N); i++)\n\t\t{\n\t\t\twhile (N % i == 0)\n\t\t\t{\n\t\t\t\tif (primef.has(i))\n\t\t\t\t{\n\t\t\t\t\tprimef.set(i, primef.get(i) + 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprimef.set(i, 1);\n\t\t\t\t}\n\t\t\t\tN = parseInt(N / 2, 10);\n\t\t\t}\n\t\t}\n\t\tif (N > 2)\n\t\t{\n\t\t\tprimef[N] = 1;\n\t\t}\n\t\treturn primef;\n\t}\nfunction CountToMakeEqual(X, Y)\n\t{\n\t\tlet gcdofXY = gcd(X, Y);\n\t\tlet newX = parseInt(Y / gcdofXY, 10);\n\t\tlet newY = parseInt(X / gcdofXY, 10);\n\t\tlet primeX = PrimeFactor(newX);\n\t\tlet primeY = PrimeFactor(newY);\n\t\tlet ans = 0;\n\t\tprimeX.forEach((values,keys)=>\n\t\t{\n\t\t\tif (X % keys != 0)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tans += primeX.get(keys); })\n\t\tans+=1;\n\t\tprimeY.forEach((values,keys)=>\n\t\t{\n\t\t\tif (Y % keys != 0)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tans += primeY.get(keys); })\n\t\treturn ans;\n\t}", "9777": "function isDivisibleByDivisor(S, D)\n\t{\n\t\tS %= D;\n\t\tvar hashMap = [];\n\t\thashMap.push(S);\n\t\tfor (var i = 0; i <= D; i++)\n\t\t{\n\t\tS += S % D;\n\t\tS %= D;\n\t\tif (hashMap.includes(S)) {\n\t\t\tif (S == 0) {\n\t\t\treturn \"Yes\";\n\t\t\t}\n\t\t\treturn \"No\";\n\t\t}\n\t\telse hashMap.push(S);\n\t\t}\n\t\treturn \"Yes\";\n\t}", "9787": "function KthSmallest(A, B, N, K)\n\t{\n\t\tlet M = 0;\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tM = Math.max(A[i], M);\n\t\t}\n\t\tlet freq = Array.from({length: M + 1}, (_, i) => 0);\n\t\tfor (let i = 0; i < N; i++) {\n\t\t\tfreq[A[i]] += B[i];\n\t\t}\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i <= M; i++) {\n\t\t\tsum += freq[i];\n\t\t\tif (sum >= K) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "9804": "function findbitwiseOR(a, n)\n\t{\n\t\tlet res = 0;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet curr_sub_array = a[i];\n\t\t\tres = res | curr_sub_array;\n\t\t\tfor (let j = i; j < n; j++) {\n\t\t\t\tcurr_sub_array = curr_sub_array & a[j];\n\t\t\t\tres = res | curr_sub_array;\n\t\t\t}\n\t\t}\n\t\tdocument.write(res);\n\t}", "9805": "function findbitwiseOR(a, n)\n{\n\tvar res = 0;\n\tvar i;\n\tfor (i = 0; i < n; i++)\n\t\tres = res | a[i];\n\tdocument.write(res);\n}", "9818": "function check(n)\n{\n\tlet sumOfDigit = 0;\n\tlet prodOfDigit = 1;\n\twhile (n > 0)\n\t{\n\t\tlet rem;\n\t\trem = n % 10;\n\t\tsumOfDigit += rem;\n\t\tprodOfDigit *= rem;\n\t\tn = Math.floor(n / 10);\n\t}\n\tif (sumOfDigit > prodOfDigit)\n\t\tdocument.write(\"Yes\");\n\telse\n\t\tdocument.write(\"No\");\n}", "9824": "function evenOddBitwiseXOR(N)\n{\n\tdocument.write(\"Even: \" + 0 + \" \");\n\tfor(let i = 4; i <= N; i = i + 4)\n\t{\n\t\tdocument.write(i + \" \");\n\t}\n\tdocument.write(\"<br/>\");\n\tdocument.write(\"Odd: \" + 1 + \" \");\n\tfor(let i = 4; i <= N; i = i + 4)\n\t{\n\tdocument.write(i - 1 + \" \");\n\t}\n\tif (N % 4 == 2)\n\t\tdocument.write(N + 1);\n\telse if (N % 4 == 3)\n\t\tdocument.write(N);\n}", "9829": "function findPermutation(arr)\n{\n\tlet N = arr.length;\n\tlet i = N - 2;\n\twhile (i >= 0 && arr[i] <= arr[i + 1])\n\t\ti--;\n\tif (i == -1)\n\t{\n\t\tdocument.write(\"-1\");\n\t\treturn;\n\t}\n\tlet j = N - 1;\n\twhile (j > i && arr[j] >= arr[i])\n\t\tj--;\n\twhile (j > i && arr[j] == arr[j - 1])\n\t{\n\t\tj--;\n\t}\n\tlet temp = arr[i];\n\tarr[i] = arr[j];\n\tarr[j] = temp;\n\tfor(let it in arr)\n\t{\n\t\tdocument.write(arr[it] + \" \");\n\t}\n}", "9849": "function sieveOfEratosthenes(N, s)\n{\n\tlet prime = Array.from({length: N+1}, (_, i) => 0);\n\tfor(let i = 2; i <= N; i += 2)\n\t\ts[i] = 2;\n\tfor(let i = 3; i <= N; i += 2)\n\t{\n\t\tif (prime[i] == false)\n\t\t{\n\t\t\ts[i] = i;\n\t\t\tfor(let j = i; j * i <= N; j += 2)\n\t\t\t{\n\t\t\t\tif (!prime[i * j])\n\t\t\t\t{\n\t\t\t\t\tprime[i * j] = true;\n\t\t\t\t\ts[i * j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nfunction findDifference(N)\n{\n\tlet s = Array.from({length: N+1}, (_, i) => 0);\n\tsieveOfEratosthenes(N, s);\n\tlet total = 1, odd = 1, even = 0;\n\tlet curr = s[N];\n\tlet cnt = 1;\n\twhile (N > 1)\n\t{\n\t\tN /= s[N];\n\t\tif (curr == s[N])\n\t\t{\n\t\t\tcnt++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (curr == 2)\n\t\t{\n\t\t\ttotal = total * (cnt + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotal = total * (cnt + 1);\n\t\t\todd = odd * (cnt + 1);\n\t\t}\n\t\tcurr = s[N];\n\t\tcnt = 1;\n\t}\n\teven = total - odd;\n document.write(Math.abs(even - odd));\n}", "9877": "function findMedian(Mean, Mode)\n{\n\tvar Median = (2 * Mean + Mode) / 3.0;\n\tdocument.write(Median);\n}", "9889": "function vectorMagnitude(x, y, z)\n{\n\tvar sum = x * x + y * y + z * z;\n\treturn Math.sqrt(sum);\n}", "9905": "function minimumSteps(x, y)\n{\n\tvar cnt = 0;\n\twhile (x != 0 && y != 0) {\n\t\tif (x > y) {\n\t\t\tcnt += x / y;\n\t\t\tx %= y;\n\t\t}\n\t\telse {\n\t\t\tcnt += y / x;\n\t\t\ty %= x;\n\t\t}\n\t}\n\tcnt--;\n\tif (x > 1 y > 1)\n\t\tcnt = -1;\n\tdocument.write( cnt);\n}", "9915": "function check(Adj,Src,N,visited)\n{\n\tlet color = new Array(N);\n\tvisited[Src] = true;\n\tlet q = [];\n\tq.push(Src);\n\twhile (q.length!=0)\n\t{\n\t\tlet u = q.shift();\n\t\tlet Col = color[u];\n\t\tfor(let x=0;x< Adj[u].length;x++)\n\t\t{\n\t\t\tif (visited[Adj[u][x]] == true && color[Adj[u][x]] == Col)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (visited[Adj[u][x]] == false)\n\t\t\t{\n\t\t\t\tvisited[Adj[u][x]] = true;\n\t\t\t\tq.push(Adj[u][x]);\n\t\t\t\tcolor[Adj[u][x]] = 1 - Col;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nfunction addEdge(Adj,u,v)\n{\n\tAdj[u].push(v);\n\tAdj[v].push(u);\n}\nfunction isPossible(Arr,N)\n{\n\tlet Adj = new Array(N);\n\tfor(let i = 0; i < N; i++)\n\t\tAdj[i] = [];\n\tfor(let i = 0; i < N - 1; i++)\n\t{\n\t\tfor(let j = i + 1; j < N; j++)\n\t\t{\n\t\t\tif (Arr[i].R < Arr[j].L Arr[i].L > Arr[j].R)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (Arr[i].V == Arr[j].V)\n\t\t\t\t{\n\t\t\t\t\taddEdge(Adj, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlet visited = new Array(N);\n\tfor(let i=0;i<N;i++)\n\t\tvisited[i]=false;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tif (visited[i] == false && Adj[i].length > 0)\n\t\t{\n\t\t\tif (check(Adj, i, N, visited) == false)\n\t\t\t{\n\t\t\t\tdocument.write(\"No<bR>\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tdocument.write(\"Yes<br>\");\n}", "9935": "function checkCommonDivisor(arr , N , X) {\n\t\tvar G = 0;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tG = gcd(G, arr[i]);\n\t\t}\n\t\tvar copy_G = G;\n\t\tfor (divisor = 2; divisor <= X; divisor++) {\n\t\t\twhile (G % divisor == 0) {\n\t\t\t\tG = G / divisor;\n\t\t\t}\n\t\t}\n\t\tif (G <= X) {\n\t\t\tdocument.write(\"Yes<br/>\");\n\t\t\tfor (i = 0; i < N; i++)\n\t\t\t\tdocument.write((arr[i] / copy_G) + \" \");\n\t\t\tdocument.write();\n\t\t}\n\t\telse\n\t\t\tdocument.write(\"No\");\n\t}\nfunction gcd(a , b) {\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}", "9948": "function multiplyByMersenne(N, M)\n{\n\tlet x = (Math.log(M + 1) / Math.log(2));\n\treturn ((N << x) - N);\n}", "9958": "function perfectSquare(num)\n{\n\tlet sr = Math.floor(Math.sqrt(num));\n\tlet a = sr * sr;\n\tlet b = (sr + 1) * (sr + 1);\n\tif ((num - a) < (b - num))\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn b;\n\t}\n}\nfunction powerOfTwo(num)\n{\n\tlet lg = Math.floor(Math.log2(num));\n\tlet p = Math.pow(2, lg);\n\treturn p;\n}\nfunction uniqueElement(arr, N)\n{\n\tlet ans = true;\n\tarr.reverse();\n\tlet freq = new Map();\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tfreq[arr[i]]++;\n\t\tif (freq.has(arr[i]))\n\t\t{\n\t\t\tfreq.set(arr[i],\n\t\t\tfreq.get(arr[i]) + 1)\n\t\t}\n\t\telse[\n\t\t\tfreq.set(arr[i], 1) ]\n\t}\n\tfor(let el of freq)\n\t{\n\t\tif (el[1] == 1)\n\t\t{\n\t\t\tans = false;\n\t\t\tlet ps = perfectSquare(el[0]);\n\t\t\tdocument.write(powerOfTwo(ps) + ' ');\n\t\t}\n\t}\n\tif (ans)\n\t\tdocument.write(\"-1\");\n}", "9963": "function partitionArray(a , n)\n\t{\n\t\tvar min = Array(n).fill(0);\n\t\tvar mini = Number.MAX_VALUE;\n\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\tmini = Math.min(mini, a[i]);\n\t\t\tmin[i] = mini;\n\t\t}\n\t\tvar maxi = Number.MIN_VALUE;\n\t\tvar ind = -1;\n\t\tfor (i = 0; i < n - 1; i++) {\n\t\t\tmaxi = Math.max(maxi, a[i]);\n\t\t\tif (maxi < min[i + 1]) {\n\t\t\t\tind = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ind != -1) {\n\t\t\tfor (i = 0; i <= ind; i++)\n\t\t\t\tdocument.write(a[i] + \" \");\n\t\t\tdocument.write(\"<br/>\");\n\t\t\tfor (i = ind + 1; i < n; i++)\n\t\t\t\tdocument.write(a[i] + \" \");\n\t\t}\n\t\telse\n\t\t\tdocument.write(\"Impossible\");\n\t}", "9971": "function countPrimeFactors(n)\n{\n\tvar count = 0;\n\twhile (n % 2 == 0)\n\t{\n\t\tn = parseInt(n / 2);\n\t\tcount++;\n\t}\n\tfor(i = 3;\n\t\ti <= parseInt(Math.sqrt(n)); i = i + 2)\n\t{\n\t\twhile (n % i == 0)\n\t\t{\n\t\t\tn = parseInt(n / i);\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (n > 2)\n\t\tcount++;\n\treturn (count);\n}\nfunction findSum(n)\n{\n\tvar sum = 0;\n\tfor(i = 1, num = 2; i <= n; num++)\n\t{\n\t\tif (countPrimeFactors(num) == 2)\n\t\t{\n\t\t\tsum += num;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn sum;\n}\nfunction check(n, k)\n{\n\tvar s = findSum(k - 1);\n\tif (s >= n)\n\t\tdocument.write(\"No\");\n\telse\n\t\tdocument.write(\"Yes\");\n}", "9979": "function gcd(a, b)\n{\n\twhile (b > 0) {\n\t\tlet rem = a % b;\n\t\ta = b;\n\t\tb = rem;\n\t}\n\treturn a;\n}\nfunction countNumberOfWays(n)\n{\n\tif (n == 1)\n\t\treturn -1;\n\tlet g = 0;\n\tlet power = 0;\n\twhile (n % 2 == 0) {\n\t\tpower++;\n\t\tn /= 2;\n\t}\n\tg = gcd(g, power);\n\tfor (let i = 3; i <= Math.sqrt(n); i += 2) {\n\t\tpower = 0;\n\t\twhile (n % i == 0) {\n\t\t\tpower++;\n\t\t\tn /= i;\n\t\t}\n\t\tg = gcd(g, power);\n\t}\n\tif (n > 2)\n\t\tg = gcd(g, 1);\n\tlet ways = 1;\n\tpower = 0;\n\twhile (g % 2 == 0) {\n\t\tg /= 2;\n\t\tpower++;\n\t}\n\tways *= (power + 1);\n\tfor (let i = 3; i <= Math.sqrt(g); i += 2) {\n\t\tpower = 0;\n\t\twhile (g % i == 0) {\n\t\t\tpower++;\n\t\t\tg /= i;\n\t\t}\n\t\tways *= (power + 1);\n\t}\n\tif (g > 2)\n\t\tways *= 2;\n\treturn ways;\n}", "9989": "function printSpiral(size)\n{\n\tlet row = 0, col = 0;\n\tlet boundary = size - 1;\n\tlet sizeLeft = size - 1;\n\tlet flag = 1;\n\tlet move = 'r';\n\tlet matrix = new Array(size);\n\tfor(let i = 0; i < size; i++)\n\t{\n\t\tmatrix[i] = new Array(size).fill(0);\n\t}\n\tfor(let i = 1; i < size * size + 1; i++)\n\t{\n\t\tmatrix[row][col] = i;\n\t\tswitch (move)\n\t\t{\n\t\t\tcase 'r':\n\t\t\t\tcol += 1;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcol -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\trow -= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\trow += 1;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == boundary)\n\t\t{\n\t\t\tboundary += sizeLeft;\n\t\t\tif (flag != 2)\n\t\t\t{\n\t\t\t\tflag = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tsizeLeft -= 1;\n\t\t\t}\n\t\t\tswitch (move)\n\t\t\t{\n\t\t\t\tcase 'r':\n\t\t\t\t\tmove = 'd';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tmove = 'l';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\tmove = 'u';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\tmove = 'r';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(row = 0; row < size; row++)\n\t{\n\t\tfor(col = 0; col < size; col++)\n\t\t{\n\t\t\tlet n = matrix[row][col];\n\t\t\tif (n < 10)\n\t\t\t\tdocument.write(n + \" \");\n\t\t\telse\n\t\t\t\tdocument.write(n + \" \");\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t}\n}", "10030": "function isPossible(target)\n{\n\tvar max = 0;\n\tvar index = 0;\n\tfor (i = 0; i < target.length; i++) {\n\t\tif (max < target[i]) {\n\t\t\tmax = target[i];\n\t\t\tindex = i;\n\t\t}\n\t}\n\tif (max == 1)\n\t\treturn true;\n\tfor (i = 0; i < target.length; i++) {\n\t\tif (i != index) {\n\t\t\tmax -= target[i];\n\t\t\tif (max <= 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\ttarget[index] = max;\n\treturn isPossible(target);\n}", "10041": "function convertToASCII(N)\n{\n\tlet num = N.toString();\n\tfor (let ch = 0; ch < num.length; ch++)\n\t{\n\t\tdocument.write(num[ch] + \" (\"\n\t\t\t+ num[ch].charCodeAt(0) + \")<br>\");\n\t}\n}", "10049": "function productExceptSelf(arr, N)\n{\n\tlet product = 1;\n\tlet z = 0;\n\tfor (let i = 0; i < N; i++) {\n\t\tif (arr[i] != 0)\n\t\t\tproduct *= arr[i];\n\t\tif (arr[i] == 0)\n\t\t\tz += 1;\n\t}\n\tlet a = Math.abs(product);\n\tfor (let i = 0; i < N; i++) {\n\t\tif (z == 1) {\n\t\t\tif (arr[i] != 0)\n\t\t\t\tarr[i] = 0;\n\t\t\telse\n\t\t\t\tarr[i] = product;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (z > 1) {\n\t\t\tarr[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tlet b = Math.abs(arr[i]);\n\t\tlet curr = Math.round(Math.exp(Math.log(a) - Math.log(b)));\n\t\tif (arr[i] < 0 && product < 0)\n\t\t\tarr[i] = curr;\n\t\telse if (arr[i] > 0 && product > 0)\n\t\t\tarr[i] = curr;\n\t\telse\n\t\t\tarr[i] = -1 * curr;\n\t}\n\tfor (let i = 0; i < N; i++) {\n\t\tdocument.write(arr[i] + \" \");\n\t}\n}", "10054": "function singleDigitSubarrayCount(arr, N)\n{\n\tlet res = 0;\n\tlet count = 0;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tif (arr[i] <= 9)\n\t\t{\n\t\t\tcount++;\n\t\t\tres += count;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tdocument.write(res);\n}", "10057": "function isPossible(N) {\n\t\treturn (((N & (N - 1)) & N));\n\t}\nfunction countElements(N) {\n\t\tvar count = 0;\n\t\tfor (i = 1; i <= N; i++) {\n\t\t\tif (isPossible(i) != 0)\n\t\t\t\tcount++;\n\t\t}\n\t\tdocument.write(count);\n\t}", "10058": "function countElements(N)\n{\n\tvar Cur_Ele = 1;\n\tvar Count = 0;\n\twhile (Cur_Ele <= N)\n\t{\n\t\tCount++;\n\t\tCur_Ele = Cur_Ele * 2;\n\t}\n\tdocument.write(N - Count);\n}", "10062": "function minSum(A, N)\n{\n\tlet mp = new Map();\n\tlet sum = 0;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tsum += A[i];\n\t\tmp[A[i]]++;\n\t\tif (mp.has(A[i]))\n\t\t{\n\t\t\tmp.set(A[i], mp.get(A[i]) + 1)\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp.set(A[i], 1)\n\t\t}\n\t}\n\tlet minSum = Number.MAX_SAFE_INTEGER;\n\tfor(let it of mp)\n\t{\n\t\tminSum = Math.min(minSum,\n\t\t\t\t\t\tsum - (it[0] * it[1]));\n\t}\n\treturn minSum;\n}", "10063": "function maxAdjacent(arr, N)\n{\n\tvar res = [];\n\tfor (var i = 1; i < N - 1; i++) {\n\t\tvar prev = arr[0];\n\t\tvar maxi = Number.MIN_VALUE;\n\t\tfor (var j = 1; j < N; j++) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tmaxi = Math.max(maxi, Math.abs(arr[j] - prev));\n\t\t\tprev = arr[j];\n\t\t}\n\t\tres.push(maxi);\n\t}\n\tfor (var j = 0; j < res.length; j++)\n\t\tdocument.write(res[j] + \" \");\n\tdocument.write(\"<br>\");\n}", "10064": "function maxAdjacent(arr,N)\n{\n\tlet res = [];\n\tlet arr_max = Number.MIN_VALUE;\n\tfor (let i = 1; i < N; i++)\n\t{\n\tarr_max = Math.max(arr_max,\n\t\t\t\t\t\tMath.abs(arr[i - 1] - arr[i]));\n\t}\n\tfor (let i = 1; i < N - 1; i++)\n\t{\n\tlet curr_max = Math.abs(arr[i - 1] - arr[i + 1]);\n\tlet ans = Math.max(curr_max, arr_max);\n\tres.push(ans);\n\t}\n\tdocument.write(res.join(\" \"));\n}", "10071": "function minimumIncrement(arr , N) {\n\t\tif (N % 2 != 0) {\n\t\t\tdocument.write(\"-1\");\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tvar cntEven = 0;\n\t\tvar cntOdd = 0;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tif (arr[i] % 2 == 0) {\n\t\t\t\tcntEven += 1;\n\t\t\t}\n\t\t}\n\t\tcntOdd = N - cntEven;\n\t\treturn Math.abs(cntEven - cntOdd) / 2;\n\t}", "10076": "function findSize(N)\n\t{\n\t\tif (N == 0)\n\t\t\treturn 1;\n\t\tif (N == 1)\n\t\t\treturn 1;\n\t\tlet Size = 2 *\n\t\t\t\tfindSize(parseInt(N / 2, 10)) + 1;\n\t\treturn Size;\n\t}\nfunction CountOnes(N, L, R)\n\t{\n\t\tif (L > R)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif (N <= 1)\n\t\t{\n\t\t\treturn N;\n\t\t}\n\t\tlet ret = 0;\n\t\tlet M = parseInt(N / 2, 10);\n\t\tlet Siz_M = findSize(M);\n\t\tif (L <= Siz_M)\n\t\t{\n\t\t\tret += CountOnes(parseInt(N / 2, 10), L,\n\t\t\tMath.min(Siz_M, R));\n\t\t}\n\t\tif (L <= Siz_M + 1 && Siz_M + 1 <= R)\n\t\t{\n\t\t\tret += N % 2;\n\t\t}\n\t\tif (Siz_M + 1 < R)\n\t\t{\n\t\t\tret += CountOnes(parseInt(N / 2, 10),\n\t\t\tMath.max(1, L - Siz_M - 1), R - Siz_M - 1);\n\t\t}\n\t\treturn ret;\n\t}", "10114": "function cntWaysConsArray(A, N)\n{\n\tvar total = 1;\n\tvar oddArray = 1;\n\tfor(i = 0; i < N; i++)\n\t{\n\t\ttotal = total * 3;\n\t\tif (A[i] % 2 == 0)\n\t\t{\n\t\t\toddArray *= 2;\n\t\t}\n\t}\n\tdocument.write(total - oddArray);\n}", "10120": "function countNumberHavingKthBitSet(N, K)\n{\n\tlet numbers_rightmost_setbit_K = 0;\n\tfor (let i = 1; i <= K; i++)\n\t{\n\t\tlet numbers_rightmost_bit_i = (N + 1) / 2;\n\t\tN -= numbers_rightmost_bit_i;\n\t\tif (i == K)\n\t\t{\n\t\t\tnumbers_rightmost_setbit_K\n\t\t\t\t= numbers_rightmost_bit_i;\n\t\t}\n\t}\n\tdocument.write(numbers_rightmost_setbit_K);\n}", "10123": "function countSetBits(N)\n{\n\tlet count = 0;\n\twhile (N != 0)\n\t{\n\t\tN = N & (N - 1);\n\t\tcount++;\n\t}\n\treturn count;\n}", "10124": "function minMoves(arr, N)\n{\n\tvar odd_element_cnt = 0;\n\tvar i;\n\tfor(i = 0; i < N; i++) {\n\t\tif (arr[i] % 2 != 0) {\n\t\t\todd_element_cnt++;\n\t\t}\n\t}\n\tvar moves = Math.floor((odd_element_cnt)/2);\n\tif (odd_element_cnt % 2 != 0)\n\t\tmoves += 2;\n\tdocument.write(moves);\n}", "10145": "function minimumSubsetDifference(N)\n{\n\tlet blockOfSize8 = N / 8;\n\tlet str = \"ABBABAAB\";\n\tlet subsetDifference = 0;\n\tlet partition = \"\";\n\twhile (blockOfSize8-- > 0)\n\t{\n\t\tpartition += str;\n\t}\n\tlet A = [];\n\tlet B = [];\n\tlet x = 0, y = 0;\n\tfor(let i = 0; i < N; i++)\n\t{\n\t\tif (partition[i] == 'A')\n\t\t{\n\t\t\tA[x++] = ((i + 1) * (i + 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tB[y++] = ((i + 1) * (i + 1));\n\t\t}\n\t}\n\tdocument.write(subsetDifference + \"<br/>\");\n\tfor(let i = 0; i < x; i++)\n\t\tdocument.write(A[i] + \" \");\n\tdocument.write(\"<br/>\");\n\tfor(let i = 0; i < y; i++)\n\t\tdocument.write(B[i] + \" \");\n}", "10155": "function findTheGreatestX(P, Q)\n{\n\tvar divisiors = new Map();\n\tfor(var i = 2; i * i <= Q; i++)\n\t{\n\t\twhile (Q % i == 0 && Q > 1)\n\t\t{\n\t\t\tQ = parseInt(Q / i);\n\t\t\tif (divisiors.has(i))\n\t\t\t\tdivisiors.set(i, divisiors.get(i) + 1)\n\t\t\telse\n\t\t\t\tdivisiors.set(i, 1)\n\t\t}\n\t}\n\tif (Q > 1)\n\t\tif (divisiors.has(Q))\n\t\t\tdivisiors.set(Q, divisiors.get(Q) + 1)\n\t\telse\n\t\t\tdivisiors.set(Q, 1)\n\tvar ans = 0;\n\tdivisiors.forEach((value, key) => {\n\t\tvar frequency = value;\n\t\tvar temp = P;\n\t\tvar cur = 0;\n\t\twhile (temp % key == 0)\n\t\t{\n\t\t\ttemp = parseInt(temp / key);\n\t\t\tcur++;\n\t\t}\n\t\tif (cur < frequency)\n\t\t{\n\t\t\tans = P;\n\t\t}\n\t\ttemp = P;\n\t\tfor(var j = cur; j >= frequency; j--)\n\t\t{\n\t\t\ttemp = parseInt(temp / key);\n\t\t}\n\t\tans = Math.max(temp, ans); });\n\tdocument.write(ans);\n}", "10174": "function checkRearrangements(mat, N, M)\n{\n for (let i = 0; i < N; i++)\n {\n\tfor (let j = 1; j < M; j++)\n\t{\n\tif (mat[i][0] != mat[i][j])\n\t{\n\t\treturn \"Yes\";\n\t}\n\t}\n }\n return \"No\";\n}\nfunction nonZeroXor(mat, N, M)\n{\n let res = 0;\n for (let i = 0; i < N; i++)\n {\n\tres = res ^ mat[i][0];\n }\n if (res != 0)\n\treturn \"Yes\";\n else\n\treturn checkRearrangements(mat, N, M);\n}", "10186": "function findPrimeNos(L, R, M)\n{\n\tfor(var i = L; i <= R; i++)\n\t{\n\t\tif (M.has(i))\n\t\t\tM.set(i, M.get(i) + 1)\n\t\telse\n\t\t\tM.set(i, 1)\n\t}\n\tif (M.has(1))\n\t{\n\t\tM.delete(1);\n\t}\n\tfor(var i = 2; i <= parseInt(Math.sqrt(R)); i++)\n\t{\n\t\tvar multiple = 2;\n\t\twhile ((i * multiple) <= R)\n\t\t{\n\t\t\tif (M.has(i * multiple))\n\t\t\t{\n\t\t\t\tM.delete(i * multiple);\n\t\t\t}\n\t\t\tmultiple++;\n\t\t}\n\t}\n\treturn M;\n}\nfunction getPrimePairs(L, R, K)\n{\n\tvar M = new Map();\n\tM = findPrimeNos(L, R, M);\n\tM.forEach((value, key) => {\n\t\tif (M.has(key + K))\n\t\t{\n\t\t\tdocument.write(\"(\" + key + \", \" +\n\t\t\t\t\t\t(key + K) + \") \"); } });\n}", "10212": "function functionMax( arr, n)\n{\n\tvar setBit = Array.from(Array(32), ()=>new Array());\n\tfor (var i = 0; i < n; i++) {\n\t\tfor (var j = 0; j < size_int; j++) {\n\t\t\tif (arr[i] & (1 << j))\n\t\t\t\tsetBit[j].push(i);\n\t\t}\n\t}\n\tfor (var i = size_int-1; i >= 0; i--) {\n\t\tif (setBit[i].length == 1) {\n\t\t\t[arr[0], arr[setBit[i][0]]] = [arr[setBit[i][0]], arr[0]];\n\t\t\tbreak;\n\t\t}\n\t}\n\tvar maxAnd = arr[0];\n\tfor (var i = 1; i < n; i++) {\n\t\tmaxAnd = maxAnd & (~arr[i]);\n\t}\n\treturn maxAnd;\n}", "10228": "function prime(n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn false;\n\t\tfor (i = 2; i * i <= n; i++)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\nfunction minDivisior(n)\n\t{\n\t\tif (prime(n))\n\t\t{\n\t\t\tdocument.write(1 + \" \" + (n - 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i = 2; i * i <= n; i++)\n\t\t\t{\n\t\t\t\tif (n % i == 0)\n\t\t\t\t{\n\t\t\t\t\tdocument.write(n / i + \" \" + (n / i * (i - 1)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "10233": "function gcd(a, b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b % a, a);\n}\nfunction lcm(a, b)\n{\n\treturn (a * b) / gcd(a, b);\n}\nfunction findLCM(arr)\n{\n\tvar nth_lcm = arr[0];\n\tfor (var i = 1; i < arr.length; i++)\n\t\tnth_lcm = lcm(nth_lcm, arr[i]);\n\tLandau = Math.max(Landau, nth_lcm);\n}\nfunction findWays(arr, i, n)\n{\n\tif (n == 0)\n\t\tfindLCM(arr);\n\tfor (var j = i; j <= n; j++) {\n\t\tarr.push(j);\n\t\tfindWays(arr, j, n - j);\n\t\tarr.pop();\n\t}\n}\nfunction Landau_function(n)\n{\n\tarr = [];\n\tfindWays(arr, 1, n);\n\tdocument.write( Landau);\n}", "10237": "function nCr(n, r)\n{\n\tlet res = 1;\n\tif (r > n - r)\n\t\tr = n - r;\n\tfor (let i = 0; i < r; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}\nfunction solve(n, m, k)\n{\n\tlet sum = 0;\n\tfor (let i = 0; i <= k; i++)\n\t\tsum += nCr(n, i)\n\t\t\t* nCr(m, k - i);\n\treturn sum;\n}", "10238": "function nCr(n, r)\n{\n\tlet res = 1;\n\tif (r > n - r)\n\t\tr = n - r;\n\tfor (let i = 0; i < r; ++i)\n\t{\n\t\tres *= (n - i);\n\t\tres /= (i + 1);\n\t}\n\treturn res;\n}", "10267": "function powerOptimised(a, n)\n{\n\tlet ans = 1;\n\twhile (n > 0)\n\t{\n\t\tlet last_bit = (n & 1);\n\t\tif (last_bit > 0)\n\t\t{\n\t\t\tans = ans * a;\n\t\t}\n\t\ta = a * a;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}", "10269": "function findMaximumGcd(n)\n{\n\tlet max_gcd = 1;\n\tfor(let i = 1; i * i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (i > max_gcd)\n\t\t\t\tmax_gcd = i;\n\t\t\tif ((n / i != i) &&\n\t\t\t\t(n / i != n) &&\n\t\t\t((n / i) > max_gcd))\n\t\t\t\tmax_gcd = n / i;\n\t\t}\n\t}\n\treturn max_gcd;\n}", "10309": "function sieve()\n{\n\tv[1] = 1;\n\tfor (let i = 2; i < x; i++)\n\t\tv[i] = i;\n\tfor (let i = 4; i < x; i += 2)\n\t\tv[i] = 2;\n\tfor (let i = 3; i * i < x; i++) {\n\t\tif (v[i] == i) {\n\t\t\tfor (let j = i * i; j < x; j += i) {\n\t\t\t\tif (v[j] == j) {\n\t\t\t\t\tv[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nfunction prime_factors(n)\n{\n\tlet s = new Set();\n\twhile (n != 1) {\n\t\ts.add(v[n]);\n\t\tn = n / v[n];\n\t}\n\treturn s.size;\n}\nfunction distinctPrimes(m, k)\n{\n\tlet result = new Array();\n\tfor (let i = 14; i < m + k; i++) {\n\t\tlet count\n\t\t\t= prime_factors(i);\n\t\tif (count == k) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\tlet p = result.length;\n\tfor (let index = 0; index < p - 1; index++) {\n\t\tlet element = result[index];\n\t\tlet count = 1, z = index;\n\t\twhile (z < p - 1 && count <= k && result[z] + 1 == result[z + 1]) {\n\t\t\tcount++;\n\t\t\tz++;\n\t\t}\n\t\tif (count >= k)\n\t\t\tdocument.write(element + ' ');\n\t}\n}", "10325": "function print_product( a, b, c, d)\n{\n\tlet prod1 = a * c;\n\tlet prod2 = b * d;\n\tlet prod3 = (a + b) * (c + d);\n\tlet real = prod1 - prod2;\n\tlet imag = prod3 - (prod1 + prod2);\n\tdocument.write(real + \" + \" + imag + \"i\");\n}", "10330": "function reverse( num) {\n\t\tlet rev_num = 0;\n\t\twhile (num > 0) {\n\t\t\trev_num = rev_num * 10 + num % 10;\n\t\t\tnum = parseInt(num / 10);\n\t\t}\n\t\treturn rev_num;\n\t}\nfunction properDivSum( num) {\n\t\tlet result = 0;\n\t\tfor ( i = 2; i <= Math.sqrt(num); i++) {\n\t\t\tif (num % i == 0) {\n\t\t\t\tif (i == (num / i))\n\t\t\t\t\tresult += i;\n\t\t\t\telse\n\t\t\t\t\tresult += (i + num / i);\n\t\t\t}\n\t\t}\n\t\treturn (result + 1);\n\t}\nfunction isTcefrep( n) {\n\t\treturn properDivSum(n) == reverse(n);\n\t}", "10335": "function isInsolite( n) {\n\t\tlet N = n;\n\t\tlet sum = 0;\n\t\tlet product = 1;\n\t\twhile (n != 0) {\n\t\t\tlet r = n % 10;\n\t\t\tsum = sum + r * r;\n\t\t\tproduct = product * r * r;\n\t\t\tn = parseInt(n / 10);\n\t\t}\n\t\treturn (N % sum == 0) && (N % product == 0);\n\t}", "10337": "function sigma(n)\n{\n\tif (n == 1)\n\t\treturn 1;\n\tvar result = 0;\n\tfor (var i = 2; i <= Math.sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (i == (n / i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + n / i);\n\t\t}\n\t}\n\treturn (result + n + 1);\n}\nfunction isSuperabundant(N)\n{\n\tfor (var i = 1; i < N; i++) {\n\t\tvar x = sigma(i) / i;\n\t\tvar y = sigma(N) / (N * 1.0);\n\t\tif (x > y)\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "10345": "function isDNum( n) {\n\t\tif (n < 4)\n\t\t\treturn false;\n\t\tlet numerator = 0, hcf = 0;\n\t\tfor ( k = 2; k <= n; k++) {\n\t\t\tnumerator = parseInt( (Math.pow(k, n - 2) - k));\n\t\t\thcf = __gcd(n, k);\n\t\t}\n\t\tif (hcf == 1 && (numerator % n) != 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\nfunction __gcd( a, b) {\n\t\treturn b == 0 ? a : __gcd(b, a % b);\n\t}", "10367": "function isPrime(n)\n\t{\n\t\tif (n == 1)\n\t\t\treturn true;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (let i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0\n\t\t\t\t|| n % (i + 2) == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nfunction checkExpression(n)\n\t{\n\t\tif (isPrime(n))\n\t\t\tdocument.write(\"Yes\");\n\t\telse\n\t\t\tdocument.write(\"No\");\n\t}", "10377": "function Sum( N) {\n\t\tlet SumOfPrimeDivisors = Array(N + 1).fill(0);\n\t\tfor ( let i = 2; i <= N; ++i) {\n\t\t\tif (SumOfPrimeDivisors[i] == 1) {\n\t\t\t\tfor (let j = i; j <= N; j += i) {\n\t\t\t\t\tSumOfPrimeDivisors[j] += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn SumOfPrimeDivisors[N];\n\t}\nfunction RuthAaronNumber( n) {\n\t\tif (Sum(n) == Sum(n + 1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "10394": "function Is_possible( N)\n{\n\tlet C = 0;\n\tlet D = 0;\n\twhile (N % 10 == 0)\n\t{\n\t\tN = N / 10;\n\t\tC += 1;\n\t}\n\tif(Math.pow(2, (Math.log(N) /\n\t\t\t\t\t\t(Math.log(2)))) == N)\n\t{\n\t\tD = (Math.log(N) / (Math.log(2)));\n\t\tif (C >= D)\n\t\t\tdocument.write(\"YES\");\n\t\telse\n\t\t\tdocument.write(\"NO\");\n\t}\n\telse\n\t\tdocument.write(\"NO\");\n}", "10406": "function maxAdjacentDifference(N, K)\n{\n\tif (N == 1)\n\t{\n\t\treturn 0;\n\t}\n\tif (N == 2) \n\t{\n\t\treturn K;\n\t}\n\treturn 2 * K;\n}", "10408": "function linearSum(n)\n{\n\treturn (n * (n + 1) / 2) % mod;\n}\nfunction rangeSum(b, a)\n{\n\treturn (linearSum(b) -\n\t\t\tlinearSum(a)) % mod;\n}\nfunction totalSum(n)\n{\n\tlet result = 0;\n\tlet i = 1;\n\twhile(true)\n\t{\n\t\tresult += rangeSum(Math.floor(n / i),\n\t\t\t\t\t\tMath.floor(n / (i + 1))) *\n\t\t\t\t\t\t\t\t\t(i % mod) % mod;\n\t\tresult %= mod;\n\t\tif (i == n)\n\t\t\tbreak;\n\t\ti = Math.floor(n / (n / (i + 1)));\n\t}\n\treturn result;\n}", "10423": "function isDouble(num)\n{\n\tlet s = num.toString();\n\tlet l = s.length;\n\tif (s[0] == s.charAt[1])\n\treturn false;\n\tif (l % 2 == 1)\n\t{\n\t\ts = s + s[1];\n\t\tl++;\n\t}\n\tlet s1 = s.substr(0, l / 2);\n\tlet s2 = s.substr(l / 2);\n\treturn (s1 == s2);\n}\nfunction isNontrivialUndulant(N)\n{\n\treturn N > 100 && isDouble(N);\n}", "10434": "function findNthTerm(n)\n{\n\tdocument.write(n * n - n + 1);\n}", "10438": "function rev(num)\n{\n\tvar rev_num = 0;\n\twhile (num > 0) {\n\t\trev_num = rev_num * 10 + num % 10;\n\t\tnum = Math.floor(num / 10);\n\t}\n\treturn rev_num;\n}\nfunction divSum(num)\n{\n\tvar result = 0;\n\tfor (var i = 2; i <= Math.floor(Math.sqrt(num)); i++) {\n\t\tif (num % i == 0) {\n\t\t\tif (i == (num / i))\n\t\t\t\tresult += rev(i);\n\t\t\telse\n\t\t\t\tresult += (rev(i)\n\t\t\t\t\t\t+ rev(num / i));\n\t\t}\n\t}\n\tresult += 1;\n\treturn result;\n}\nfunction isAntiPerfect(n)\n{\n\treturn divSum(n) == n;\n}", "10445": "function printSeries( n, a, b, c)\n{\n\tlet d;\n\tif (n == 1) {\n\t\tdocument.write( a + \" \");\n\t\treturn;\n\t}\n\tif (n == 2) {\n\t\tdocument.write( a + \" \" + b + \" \");\n\t\treturn;\n\t}\n\tdocument.write( a + \" \" + b + \" \" + c + \" \");\n\tfor (let i = 4; i <= n; i++) {\n\t\td = a + b + c;\n\t\tdocument.write( d + \" \");\n\t\ta = b;\n\t\tb = c;\n\t\tc = d;\n\t}\n}", "10452": "function checkArray(n , k , arr) {\n\t\tvar cnt = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((arr[i] & 1) != 0)\n\t\t\t\tcnt += 1;\n\t\t}\n\t\tif (cnt >= k && cnt % 2 == k % 2)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "10462": "function func(arr, n)\n{\n\tlet ans = 0;\n\tlet maxx = 0;\n\tlet freq = Array.from({length: 100005}, (_, i) => 0);\n\tlet temp;\n\tfor(let i = 0; i < n; i++)\n\t{\n\ttemp = arr[i];\n\tfreq[temp]++;\n\tmaxx = Math.max(maxx, temp);\n\t}\n\tfor(let i = 1; i <= maxx; i++)\n\t{\n\tfreq[i] += freq[i - 1];\n\t}\n\tfor(let i = 1; i <= maxx; i++)\n\t{\n\tif (freq[i] != 0)\n\t{\n\t\tlet j;\n\t\tlet cur = Math.ceil(0.5 * i) - 1.0;\n\t\tfor(j = 1.5;; j++)\n\t\t{\n\t\t\tlet val = Math.min(maxx,\n\t\t\t\t(Math.ceil(i * j) - 1.0));\n\t\t\tlet times = (freq[i] - freq[i - 1]),\n\t\t\t\t\tcon = (j - 0.5);\n\t\t\tans += times * con * (freq[val] - freq[cur]);\n\t\t\tcur = val;\n\t\t\tif (val == maxx)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t}\n\treturn ans;\n}", "10474": "function EnneacontahexagonNum( n) {\n\t\treturn (94 * n * n - 92 * n) / 2;\n\t}", "10475": "function MegagonNum(n)\n{\n\treturn (999998 * n * n - 999996 * n) / 2;\n}", "10492": "function insert_element(a, n)\n\t{\n\t\tlet Xor = 0;\n\t\tlet Sum = 0;\n\t\tfor(let i = 0; i < n; i++)\n\t\t{\n\t\t\tXor ^= a[i];\n\t\t\tSum += a[i];\n\t\t}\n\t\tif(Sum == 2 * Xor)\n\t\t{\n\t\t\tdocument.write(\"0\" + \"</br>\");\n\t\t\treturn;\n\t\t}\n\t\tif(Xor == 0)\n\t\t{\n\t\t\tdocument.write(\"1\" + \"</br>\");\n\t\t\tdocument.write(Sum + \"</br>\");\n\t\t\treturn;\n\t\t}\n\t\tlet num1 = Sum + Xor;\n\t\tlet num2 = Xor;\n\t\tdocument.write(\"2\" + \"</br>\");\n\t\tdocument.write(num1 + \" \" + num2 + \"</br>\");\n\t}", "10502": "function checkSolution(a, b, c)\n\t{\n\t\tif (a == c)\n\t\t\tdocument.write(\"Yes\");\n\t\telse\n\t\t\tdocument.write(\"No\");\n\t}", "10539": "function productPairs(arr, n)\n{\n\tlet product = 1;\n\tfor (let i = 0; i < n; i++) {\n\t\tfor (let j = 0; j < n; j++) {\n\t\t\tproduct *= (arr[i] % mod * arr[j] % mod)\n\t\t\t\t\t% mod;\n\t\t\tproduct = product % mod;\n\t\t}\n\t}\n\treturn product % mod;\n}", "10540": "function power(x, y)\n{\n\tlet p = 1000000007;\n\tlet res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif (y % 2 == 1)\n\t\t\tres = (res * x) % p;\n\t\ty = y >> 1;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nfunction productPairs(arr, n)\n{\n\tlet product = 1;\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tproduct = (product % mod *\n\t\t\t\tpower(arr[i],\n\t\t\t\t\t\t\t(2 * n)) % mod) % mod;\n\t}\n\treturn product % mod;\n}", "10546": "function constructArray(N)\n{\n\tlet arr = new Array(N);\n\tfor (let i = 1; i <= N; i++)\n\t{\n\t\tarr[i - 1] = i;\n\t}\n\tfor (let i = 0; i < N; i++)\n\t{\n\t\tdocument.write(arr[i] + \", \");\n\t}\n}", "10568": "function isPrime(n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tfor (var i = 2; i < n; i++)\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nfunction countSubsequences( arr, n)\n{\n\tvar totalSubsequence = Math.pow(2, n) - 1;\n\tvar countPrime = 0, countOnes = 0;\n\tfor (var i = 0; i < n; i++) {\n\t\tif (arr[i] == 1)\n\t\t\tcountOnes++;\n\t\telse if (isPrime(arr[i]))\n\t\t\tcountPrime++;\n\t}\n\tvar compositeSubsequence;\n\tvar onesSequence = Math.pow(2, countOnes) - 1;\n\tcompositeSubsequence\n\t\t= totalSubsequence - countPrime\n\t\t- onesSequence\n\t\t- onesSequence * countPrime;\n\treturn compositeSubsequence;\n}", "10569": "function nCr(n, r)\n{\n\treturn fact(n) / (fact(r) * \n\t\tfact(n - r));\n}\nfunction fact(n)\n{\n\tvar res = 1;\n\tfor(var i = 2; i <= n; i++)\n\t\tres = res * i;\n\treturn res;\n}\nfunction sumSubsequences(arr, n, k)\n{\n\tvar sum = 0;\n\tfor(var i = 0; i < n; i++)\n\t{\n\t\tsum += arr[i];\n\t}\n\tvar kLengthSubSequence;\n\tkLengthSubSequence = nCr(n, k);\n\tvar ans = sum * ((k * kLengthSubSequence) / n);\n\treturn ans;\n}", "10573": "function getFactorization(x)\n{\n\tlet count = 0;\n\tlet v = [];\n\twhile (x % 2 == 0)\n\t{\n\t\tcount++;\n\t\tx = Math.floor(x / 2);\n\t}\n\tif (count != 0)\n\t\tv.push(count);\n\tfor (let i = 3;\n\t\ti <= Math.floor(Math.sqrt(x)); i += 2)\n\t{\n\t\tcount = 0;\n\t\twhile (x % i == 0)\n\t\t{\n\t\t\tcount++;\n\t\t\tx = Math.floor(x / i);\n\t\t}\n\t\tif (count != 0)\n\t\tv.push(count);\n\t}\n\tif (x > 1)\n\t{\n\t\tv.push(1);\n\t}\n\treturn v;\n}\nfunction nonPrimeDivisors(N)\n{\n\tlet v = getFactorization(N);\n\tlet ret = 1;\n\tfor (let i = 0; i < v.length; i++)\n\t\tret = ret * (v[i] + 1);\n\tret = ret - v.length;\n\treturn ret;\n}", "10653": "function checksum(n , k)\n\t{\n\t\tvar first_term = (((2 * n) / k + (1 - k)) / 2.0);\n\t\tif (first_term - parseInt( (first_term)) == 0) {\n\t\t\tfor (i = parseInt( first_term); i <= first_term + k - 1; i++) {\n\t\t\t\tdocument.write(i + \" \");\n\t\t\t}\n\t\t} else\n\t\t\tdocument.write(\"-1\");\n\t}", "10668": "function sumEvenNumbers(N, K)\n{\n\tlet check = N - 2 * (K - 1);\n\tif (check > 0 && check % 2 == 0)\n\t{\n\t\tfor(let i = 0; i < K - 1; i++)\n\t\t{\n\t\tdocument.write(\"2 \");\n\t\t}\n\t\tdocument.write(check);\n\t}\n\telse\n\t{\n\t\tdocument.write(\"-1\");\n\t}\n}", "10677": "function isPerfectSquare(x)\n{\n\tvar sr = Math.sqrt(x);\n\treturn((sr - Math.floor(sr)) == 0);\n}\nfunction checkSunnyNumber(N)\n{\n\tif (isPerfectSquare(N + 1)) {\n\t\tdocument.write( \"Yes\");\n\t}\n\telse {\n\t\tdocument.write( \"No\");\n\t}\n}", "10694": "function calculateWays(n)\n{\n\tlet x = 0;\n\tlet v = Array.from({length: n}, (_, i) => 0);\n\tfor(let i = 0; i < n; i++)\n\t\tv[i] = 0;\n\tfor(let i = 0; i < n / 2; i++)\n\t{\n\t\tif(n % 2 == 0 && i == n / 2)\n\t\t\tbreak;\n\t\tx = n * (i + 1) - (i + 1) * i;\n\t\tv[i] = x;\n\t\tv[n - i - 1] = x;\n\t}\n\treturn v;\n}\nfunction prletArray(v)\n{\n\tfor(let i = 0; i < v.length; i++)\n\t\tdocument.write(v[i] + \" \");\n}", "10703": "function sumOfDigits(n)\n{\n\tvar sum = 0;\n\twhile (n > 0)\n\t{\n\t\tsum += n % 10;\n\t\tn = parseInt(n/10);\n\t}\n\treturn sum;\n}\nfunction smallestNum(X , Y)\n{\n\tvar res = -1;\n\tfor (i = X; i < MAXN; i++)\n\t{\n\t\tvar sum_of_digit = sumOfDigits(i);\n\t\tif (sum_of_digit % Y == 0)\n\t\t{\n\t\t\tres = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}", "10706": "function countValues(n)\n\t{\n\t\tlet answer = 0;\n\t\tfor (let i = 2; i <= n; i++) {\n\t\t\tlet k = n;\n\t\t\twhile (k >= i) {\n\t\t\t\tif (k % i == 0)\n\t\t\t\t\tk /= i;\n\t\t\t\telse\n\t\t\t\t\tk -= i;\n\t\t\t}\n\t\t\tif (k == 1)\n\t\t\t\tanswer++;\n\t\t}\n\t\treturn answer;\n\t}", "10707": "function countValues(N)\n{\n\tvar div = [];\n\tfor (var i = 2; i * i <= N; i++) {\n\t\tif (N % i == 0) {\n\t\t\tdiv.push(i);\n\t\t\tif (N != i * i) {\n\t\t\t\tdiv.push(N / i);\n\t\t\t}\n\t\t}\n\t}\n\tvar answer = 0;\n\tfor (var i = 1; i * i <= N - 1; i++) {\n\t\tif ((N - 1) % i == 0) {\n\t\t\tif (i * i == N - 1)\n\t\t\t\tanswer++;\n\t\t\telse\n\t\t\t\tanswer += 2;\n\t\t}\n\t}\n\tdiv.forEach(d => {\n\t\tvar K = N;\n\t\twhile (K % d == 0)\n\t\t\tK /= d;\n\t\tif ((K - 1) % d == 0) answer++; });\n\treturn answer;\n}", "10719": "function findMaxPrimeDivisor(n)\n{\n\tlet max_possible_prime = 0;\n\twhile (n % 2 == 0)\n\t{\n\t\tmax_possible_prime++;\n\t\tn = Math.floor(n / 2);\n\t}\n\tfor(let i = 3; i * i <= n; i = i + 2)\n\t{\n\t\twhile (n % i == 0)\n\t\t{\n\t\t\tmax_possible_prime++;\n\t\t\tn = Math.floor(n / i);\n\t\t}\n\t}\n\tif (n > 2)\n\t{\n\t\tmax_possible_prime++;\n\t}\n\tdocument.write(max_possible_prime + \"\\n\");\n}", "10721": "function printKNumbers(N, K)\n\t{\n\t\tfor (let i = 0; i < K - 1; i++)\n\t\t\tdocument.write(1 + \" \");\n\t\tdocument.write(N - K + 1);\n\t}", "10751": "function CountWays(n)\n{\n\tlet ans = Math.floor((n - 1) / 2);\n\treturn ans;\n}", "10753": "function Solve(arr, size, n)\n {\n\tlet v = Array.from({length: n+1}, (_, i) => 0);\n\tfor (let i = 0; i < size; i++)\n\tv[arr[i]]++;\n\tlet max1 = -1, mx = -1;\n\tfor (let i = 0; i < v.length; i++)\n\t{\n\tif (v[i] > mx)\n\t{\n\t\tmx = v[i];\n\t\tmax1 = i;\n\t}\n\t}\n\tlet cnt = 0;\n\tfor (let i in v)\n\t{\n\tif (i == 0)\n\t\t++cnt;\n\t}\n\tlet diff1 = n + 1 - cnt;\n\tlet max_size = Math.max(Math.min(v[max1] - 1, diff1),\n\t\t\t\t\t\t\tMath.min(v[max1], diff1 - 1));\n\tdocument.write(\"Maximum size is: \" + max_size + \"<br/>\");\n\tdocument.write(\"First Array is\" + \"<br/>\");\n\tfor (let i = 0; i < max_size; i++)\n\t{\n\tdocument.write(max1 + \" \");\n\tv[max1] -= 1;\n\t}\n\tdocument.write(\"<br/>\");\n\tdocument.write(\"The Second Array Is :\" + \"<br/>\");\n\tfor (let i = 0; i < (n + 1); i++)\n\t{\n\tif (v[i] > 0)\n\t{\n\t\tdocument.write(i + \" \");\n\t\tmax_size--;\n\t}\n\tif (max_size < 1)\n\t\tbreak;\n\t}\n\tdocument.write(\"<br/>\");\n }", "10768": "function power(x, y, p)\n{\n\tlet res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif ((y & 1) == 1)\n\t\t\tres = (res * x) % p;\n\t\tx = (x * x) % p;\n\t}\n\treturn res;\n}\nfunction modInverse(n, p)\n{\n\treturn power(n, p - 2, p);\n}\nfunction nCrModPFermat(n, r, p)\n{\n\tif (r == 0)\n\t\treturn 1;\n\tif (n < r)\n\t\treturn 0;\n\tlet fac = Array.from({length: n+1}, (_, i) => 0);\n\tfac[0] = 1;\n\tfor(let i = 1; i <= n; i++)\n\t\tfac[i] = fac[i - 1] * i % p;\n\treturn (fac[n] * modInverse(fac[r], p) % p *\n\t\t\t\t\tmodInverse(fac[n - r], p) % p) % p;\n}\nfunction SumOfXor(a, n)\n{\n\tlet mod = 10037;\n\tlet answer = 0;\n\tfor(let k = 0; k < 32; k++)\n\t{\n\t\tlet x = 0, y = 0;\n\t\tfor(let i = 0; i < n; i++)\n\t\t{\n\t\t\tif ((a[i] & (1 << k)) != 0)\n\t\t\t\tx++;\n\t\t\telse\n\t\t\t\ty++;\n\t\t}\n\t\tanswer += ((1 << k) % mod *\n\t\t\t\t(nCrModPFermat(x, 3, mod) + x *\n\t\t\t\t\tnCrModPFermat(y, 2, mod)) % mod) % mod;\n\t}\n\treturn answer;\n}", "10801": "function NthSmallest(K)\n{\n\tvar Q = [];\n\tvar x;\n\tfor (var i = 1; i < 10; i++)\n\t\tQ.push(i);\n\tfor (var i = 1; i <= K; i++) {\n\t\tx = Q[0];\n\t\tQ.shift();\n\t\tif (x % 10 != 0) {\n\t\t\tQ.push(x * 10 + x % 10 - 1);\n\t\t}\n\t\tQ.push(x * 10 + x % 10);\n\t\tif (x % 10 != 9) {\n\t\t\tQ.push(x * 10 + x % 10 + 1);\n\t\t}\n\t}\n\treturn x;\n}", "10812": "function round(vr, digit) {\n\t\tvar value = parseInt( (vr* Math.pow(10, digit) + .5));\n\t\treturn value / Math.pow(10, digit);\n\t}\nfunction probability(N) {\n\t\tvar a = 2;\n\t\tvar b = 3;\n\t\tif (N == 1) {\n\t\t\treturn a;\n\t\t} else if (N == 2) {\n\t\t\treturn b;\n\t\t} else {\n\t\t\tfor (i = 3; i <= N; i++) {\n\t\t\t\tvar c = a + b;\n\t\t\t\ta = b;\n\t\t\t\tb = c;\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\t}\nfunction operations(N) {\n\t\tvar x = probability(N);\n\t\tvar y = parseInt( Math.pow(2, N));\n\t\treturn round(x / y, 2);\n\t}", "10874": "function isPerfectCube(x)\n{\n\tvar cr = Math.round(Math.cbrt(x));\n\treturn (cr * cr * cr == x);\n}\nfunction checkCube(a , b)\n{\n\ts1 = a.toString();\n\ts2 = b.toString();\n\tvar c = parseInt(s1 + s2);\n\tif (isPerfectCube(c)) {\n\t\t\tdocument.write(\"Yes\");\n\t}\n\telse {\n\t\t\tdocument.write(\"No\");\n\t}\n}", "10885": "function largest_sum(arr, n)\n\t{\n\t\tlet maximum = -1;\n\t\tlet m = new Map();\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tif (m.has(arr[i])){\n\t\t\tm.set(arr[i], m.get(arr[i]) + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tm.set(arr[i], 1);\n\t\t\t}\n\t\t}\n\t\tfor(let i = 0; i < n; i++){\n\t\t\tif (m.get(arr[i]) > 1) {\n\t\t\t\tif (m.has(2*arr[i]))\n\t\t\t\t{\n\t\t\t\t\tm.set(2*arr[i],m.get(2 * arr[i])+ m.get(arr[i]) / 2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm.set(2*arr[i],m.get(arr[i]) / 2);\n\t\t\t\t}\n\t\t\t\tif (2 * arr[i] > maximum)\n\t\t\t\t\tmaximum = 2 * arr[i];\n\t\t\t}\n\t\t\t}\n\t\treturn maximum;\n\t}", "10897": "function canBeReduced(x , y)\n{\n\tvar maxi = Math.max(x, y);\n\tvar mini = Math.min(x, y);\n\tif (((x + y) % 3) == 0 && maxi <= 2*mini)\n\t\tdocument.write(\"YES\" +\"\\n\");\n\telse\n\t\tdocument.write(\"NO\" +\"\\n\");\n}", "10921": "function isPrime(N)\n{\n\tlet isPrime = true;\n\tlet arr = [ 7, 11, 13, 17, 19, 23, 29, 31 ];\n\tif (N < 2) {\n\t\tisPrime = false;\n\t}\n\tif (N % 2 == 0 N % 3 == 0 N % 5 == 0) {\n\t\tisPrime = false;\n\t}\n\tfor (let i = 0; i < Math.sqrt(N); i += 30) {\n\t\tfor (let c of arr) {\n\t\t\tif (c > Math.sqrt(N)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (N % (c + i) == 0) {\n\t\t\t\t\tisPrime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isPrime)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (isPrime)\n\t\tdocument.write(\"Prime Number\");\n\telse\n\t\tdocument.write(\"Not a Prime Number\");\n}", "10932": "function printPairs(arr, n)\n{\n\tfor (var i = 0; i < n; i++) {\n\t\tfor (var j = 0; j < n; j++) {\n\t\t\tdocument.write(\"(\" + arr[i] + \", \" + arr[j] + \")\" + \", \");\n\t\t}\n\t}\n}", "10936": "function nearest( n)\n{\n\tvar prevSquare = parseInt(Math.sqrt(n));\n\tvar nextSquare = prevSquare + 1;\n\tprevSquare = prevSquare * prevSquare;\n\tnextSquare = nextSquare * nextSquare;\n\tif((n - prevSquare) < (nextSquare - n))\n\t{\n\tans = parseInt((prevSquare - n));\n\t}\n\telse\n\tans = parseInt((nextSquare - n));\n\treturn ans;\n}", "10951": "function printValueOfPi(N)\n\t{\n\t\tlet pi = 2 * Math.acos(0.0);\n\t\tdocument.write(pi.toFixed(4));\n\t}", "10952": "function powOfPositive(n)\n{\n\tlet pos = Math.floor(Math.log2(n));\n\treturn Math.pow(2, pos);\n}\nfunction powOfNegative(n)\n{\n\tlet pos = Math.ceil(Math.log2(n));\n\treturn (-1 * Math.pow(2, pos));\n}\nfunction highestPowerOf2(n)\n{\n\tif (n > 0)\n\t{\n\t\tdocument.write(powOfPositive(n));\n\t}\n\telse\n\t{\n\t\tn = -n;\n\t\tdocument.write(powOfNegative(n));\n\t}\n}", "10960": "function noOfCards(n)\n{\n\treturn parseInt(n * (3 * n + 1) / 2);\n}", "10974": "function smallestPoss(s, n)\n{\n\tvar ans = \"\";\n\tvar arr = Array(10).fill(0);\n\tfor (var i = 0; i < n; i++) {\n\t\tarr[s[i].charCodeAt(0) - 48]++;\n\t}\n\tfor (var i = 0; i < 10; i++) {\n\t\tfor (var j = 0; j < arr[i]; j++)\n\t\t\tans = ans + i.toString();\n\t}\n\treturn ans;\n}", "11014": "function Count_subarray(arr, n)\n{\n var subarray_sum, remaining_sum,\n\tcount = 0;\n\tvar i,j,k,l;\n\tfor(i = 0; i < n; i++) {\n\t\tfor (j = i; j < n; j++) {\n\t\t\tsubarray_sum = 0;\n\t\t\tremaining_sum = 0;\n\t\t\tfor(k = i; k <= j; k++) {\n\t\t\t\tsubarray_sum += arr[k];\n\t\t\t}\n\t\t\tfor (l = 0; l < i; l++) {\n\t\t\t\tremaining_sum += arr[l];\n\t\t\t}\n\t\t\tfor (l = j + 1; l < n; l++) {\n\t\t\t\tremaining_sum += arr[l];\n\t\t\t}\n\t\t\tif (subarray_sum > remaining_sum)\n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "11015": "function Count_subarray(arr, n)\n{\n\t\tvar total_sum = 0, subarray_sum, remaining_sum, count = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\ttotal_sum += arr[i];\n\t\t}\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tsubarray_sum = 0;\n\t\t\tfor (j = i; j < n; j++)\n\t\t\t{\n\t\t\t\tsubarray_sum += arr[j];\n\t\t\t\tremaining_sum = total_sum - subarray_sum;\n\t\t\t\tif (subarray_sum > remaining_sum)\n\t\t\t\t{\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "11045": "function decBinary(arr, n)\n\t{\n\tlet k = parseInt(Math.log2(n), 10);\n\t\twhile (n > 0)\n\t\t{\n\t\t\tarr[k--] = n % 2;\n\t\t\tn = parseInt(n/2,10);\n\t\t}\n\t}\nfunction binaryDec(arr, n)\n\t{\n\t\tlet ans = 0;\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tans += arr[i] << (n - i - 1);\n\t\treturn ans;\n\t}\nfunction getNum(n,k)\n\t{\n\t\tlet l = parseInt(Math.log2(n),10) + 1;\n\t\tlet a = new Array(l);\n\t\ta.fill(0);\n\t\tdecBinary(a, n);\n\t\tif (k > l)\n\t\t\treturn n;\n\t\ta[k - 1] = (a[k - 1] == 0) ? 1 : 0;\n\t\treturn binaryDec(a, l);\n\t}", "11051": "function find_composite_nos(n)\n{\n\tdocument.write(9 * n + \" \" + 8 * n);\n}", "11052": "function maxXOR(arr, n)\n{\n\tlet xorArr = 0;\n\tfor (let i = 0; i < n; i++)\n\t\txorArr ^= arr[i];\n\tlet ans = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tans = Math.max(ans, (xorArr ^ arr[i]));\n\treturn ans;\n}", "11060": "function digitDividesK(num, k)\n{\n\twhile (num)\n\t{\n\t\tlet d = num % 10;\n\t\tif (d != 0 && k % d == 0)\n\t\t\treturn true;\n\t\tnum = parseInt(num / 10);\n\t}\n\treturn false;\n}\nfunction findCount(l, r, k)\n{\n\tlet count = 0;\n\tfor(let i = l; i <= r; i++)\n\t{\n\t\tif (digitDividesK(i, k))\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "11088": "function isFactorial(n)\n{\n\tfor (var i = 1;; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tn = parseInt(n/i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (n == 1)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}", "11094": "function lcm(a, b) {\n\tlet GCD = __gcd(a, b);\n\treturn Math.floor((a * b) / GCD);\n}\nfunction __gcd(a, b)\n{\n\treturn b == 0 ? a : __gcd(b, a % b);\t\n}\nfunction MinLCM(a, n) {\n\tlet Prefix = new Array(n + 2);\n\tlet Suffix = new Array(n + 2);\n\tPrefix[1] = a[0];\n\tfor (let i = 2; i <= n; i += 1) {\n\t\tPrefix[i] = lcm(Prefix[i - 1], a[i - 1]);\n\t}\n\tSuffix[n] = a[n - 1];\n\tfor (let i = n - 1; i >= 1; i -= 1) {\n\t\tSuffix[i] = lcm(Suffix[i + 1], a[i - 1]);\n\t}\n\tlet ans = Math.min(Suffix[2], Prefix[n - 1]);\n\tfor (let i = 2; i < n; i += 1) {\n\t\tans = Math.min(ans, lcm(Prefix[i - 1], Suffix[i + 1]));\n\t}\n\treturn ans;\n}", "11102": "function diameter(n)\n{\n\tvar L, H, templen;\n\tL = 1;\n\tH = 0;\n\tif (n == 1) {\n\t\treturn 1;\n\t}\n\tif (n == 2) {\n\t\treturn 2;\n\t}\n\tif (n == 3) {\n\t\treturn 3;\n\t}\n\twhile (L * 2 <= n) {\n\t\tL *= 2;\n\t\tH++;\n\t}\n\tif (n >= L * 2 - 1)\n\t\treturn 2 * H + 1;\n\telse if (n >= L + (L / 2) - 1)\n\t\treturn 2 * H;\n\treturn 2 * H - 1;\n}", "11139": "function count(n)\n{\n\treturn parseInt(n * (3 * n - 1) / 2);\n}", "11180": "function findMinValue(arr, n)\n{\n\tlet sum = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tsum += arr[i];\n\treturn (parseInt(sum / n) + 1);\n}", "11182": "function modFact(n, m)\n{\n\tlet result = 1;\n\tfor (let i = 1; i <= m; i++)\n\t\tresult = (result * i) % MOD;\n\treturn result;\n}", "11194": "function preCompute()\n\t{\n\t\tfact[0] = 1;\n\t\tresult[0] = 1;\n\t\tfor (let i = 1; i <= MAX; i++)\n\t\t{\n\t\t\tfact[i] = ((fact[i - 1] % MOD) * i) % MOD;\n\t\t\tresult[i] = ((result[i - 1] % MOD) *\n\t\t\t\t\t\t(fact[i] % MOD)) % MOD;\n\t\t}\n\t}\nfunction performQueries(q, n)\n\t{\n\t\tpreCompute();\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tdocument.write(result[q[i]] + \"</br>\");\n\t}", "11196": "function gcd( a, b)\n{\n\tif (a == 0)\n\t\treturn b;\n\treturn gcd(b % a, a);\n}\nfunction divTermCount( a, b, c, num)\n{\n\treturn parseInt(((num / a) + (num / b) + (num / c)\n\t\t\t- (num / ((a * b) / gcd(a, b)))\n\t\t\t- (num / ((c * b) / gcd(c, b)))\n\t\t\t- (num / ((a * c) / gcd(a, c)))\n\t\t\t+ (num / ((((a*b)/gcd(a, b))* c)/\n\t\t\tgcd(((a*b)/gcd(a, b)), c)))));\n}\nfunction findNthTerm( a, b, c, n)\n{\n\tvar low = 1, high = Number.MAX_SAFE_INTEGER , mid;\n\twhile (low < high) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (divTermCount(a, b, c, mid) < n)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\treturn low;\n}", "11199": "function calculate_angle(n , i, j , k)\n{\n\tvar x, y;\n\tif (i < j)\n\t\tx = j - i;\n\telse\n\t\tx = j + n - i;\n\tif (j < k)\n\t\ty = k - j;\n\telse\n\t\ty = k + n - j;\n\tvar ang1 = (180 * x) / n;\n\tvar ang2 = (180 * y) / n;\n\tvar ans = 180 - ang1 - ang2;\n\treturn ans;\n}", "11204": "function power(p)\n{\n\tlet res = 1;\n\tfor (let i = 1; i <= p; ++i) {\n\t\tres *= 2;\n\t\tres %= mod;\n\t}\n\treturn res % mod;\n}\nfunction subset_square_sum(A)\n{\n\tlet n = A.length;\n\tlet ans = 0;\n\tfor (let i = 0; i < n; i++) {\n\t\tans += (A[i] * A[i]) % mod;\n\t\tans %= mod;\n\t}\n\treturn (ans * power(n - 1)) % mod;\n}", "11217": "function least_prime_factor() {\n\t\tfor (i = 2; i < N; i++)\n\t\t\tif (lpf[i] == 0)\n\t\t\t\tfor (j = i; j < N; j += i)\n\t\t\t\t\tif (lpf[j] == 0)\n\t\t\t\t\t\tlpf[j] = i;\n\t}\nfunction Mobius() {\n\t\tfor (i = 1; i < N; i++) {\n\t\t\tif (i == 1)\n\t\t\t\tmobius[i] = 1;\n\t\t\telse {\n\t\t\t\tif (lpf[i / lpf[i]] == lpf[i])\n\t\t\t\t\tmobius[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tmobius[i] = -1 * mobius[i / lpf[i]];\n\t\t\t}\n\t\t}\n\t}\nfunction gcd_pairs(a , n) {\n\t\tvar maxi = 0;\n\t\tvar fre = Array(n+1).fill(0);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfre[a[i]]++;\n\t\t\tmaxi = Math.max(a[i], maxi);\n\t\t}\n\t\tleast_prime_factor();\n\t\tMobius();\n\t\tvar ans = 0;\n\t\tfor (i = 1; i <= maxi; i++) {\n\t\t\tif (mobius[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tvar temp = 0;\n\t\t\tfor (j = i; j <= maxi; j += i)\n\t\t\t\ttemp = parseInt(temp+fre[j]);\n\t\t\tans += parseInt(temp * (temp - 1) / 2 * mobius[i]);\n\t\t}\n\t\treturn ans;\n\t}", "11253": "function compareVal(x, y)\n{\n\tlet a = y * Math.log(x);\n\tlet b = x * Math.log(y);\n\tif (a > b)\n\t\tdocument.write(x + \"^\" + y + \" > \" + y + \"^\" + x);\n\telse if (a < b)\n\t\tdocument.write(x + \"^\" + y + \" < \" + y + \"^\" + x);\n\telse if (a == b)\n\t\tdocument.write(x + \"^\" + y + \" = \" + y + \"^\" + x);\n}", "11283": "function compareValues(a, b, c, d)\n{\n\tlet log1 = Math.log(a) / Math.log(10);\n\tlet num1 = log1 * b;\n\tlet log2 = Math.log(c) / Math.log(10);\n\tlet num2 = log2 * d;\n\tif (num1 > num2)\n\t\tdocument.write(a + \"^\" + b);\n\telse\n\t\tdocument.write(c + \"^\" + d);\n}", "11294": "function ZigZag(n)\n{\n\tvar fact = Array(n+1).fill(0);\n\tvar zig = Array(n+1).fill(0);\n\tfact[0] = 1;\n\tfor (var i = 1; i <= n; i++)\n\t\tfact[i] = fact[i - 1] * i;\n\tzig[0] = 1;\n\tzig[1] = 1;\n\tdocument.write( \"zig zag numbers: \");\n\tdocument.write( zig[0] + \" \" + zig[1] + \" \");\n\tfor (var i = 2; i < n; i++)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var k = 0; k <= i - 1; k++)\n\t\t{\n\t\t\tsum += parseInt(fact[i - 1]/(fact[i - 1 - k]*fact[k]))\n\t\t\t\t\t\t\t\t*zig[k] * zig[i - 1 - k];\n\t\t}\n\t\tzig[i] = parseInt(sum / 2);\n\t\tdocument.write( parseInt(sum / 2) + \" \");\n\t}\n}", "11302": "function find_count(ele)\n{\n\tlet count = 0;\n\tfor (let i = 0; i < ele.length; i++) {\n\t\tlet p = [];\n\t\tlet c = 0;\n\t\tfor (let j = ele.length - 1;\n\t\t\tj >= (ele.length - 1 - i) && j >= 0; j--)\n\t\t\tp.push(ele[j]);\n\t\tlet j = ele.length - 1, k = 0;\n\t\twhile (j >= 0) {\n\t\t\tif (ele[j] != p[k])\n\t\t\t\tbreak;\n\t\t\tj--;\n\t\t\tk++;\n\t\t\tif (k == p.length) {\n\t\t\t\tc++;\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t\tcount = Math.max(count, c);\n\t}\n\treturn count;\n}\nfunction solve(n)\n{\n\tlet count = 1;\n\tlet ele = [];\n\tfor (let i = 0; i < n; i++) {\n\t\tdocument.write(count + \", \");\n\t\tele.push(count);\n\t\tcount = find_count(ele);\n\t}\n}", "11306": "function addPrimes()\n{\n\tlet n = MAX;\n\tlet prime = new Array(n + 1).fill(true);\n\tfor (let p = 2; p * p <= n; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (let i = p * p; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tlet ans = [];\n\tfor (let p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tans.push(p);\n\treturn ans;\n}\nfunction is_prime(n)\n{\n\treturn (n == 3 n == 5 n == 7);\n}\nfunction find_Sum(n)\n{\n\tlet sum = 0;\n\tlet v = addPrimes();\n\tfor (let i = 0; i < v.length && n > 0; i++)\n\t{\n\t\tlet flag = 1;\n\t\tlet a = v[i];\n\t\twhile (a != 0)\n\t\t{\n\t\t\tlet d = a % 10;\n\t\t\ta = parseInt(a / 10);\n\t\t\tif (is_prime(d)) {\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag==1)\n\t\t{\n\t\t\tn--;\n\t\t\tsum = sum + v[i];\n\t\t}\n\t}\n\treturn sum;\n}", "11315": "function Wedderburn(n)\n{\n\tif (n <= 2)\n\t\treturn store[n];\n\telse if (n % 2 == 0)\n\t{\n\t\tvar x = parseInt(n / 2), ans = 0;\n\t\tfor (var i = 1; i < x; i++) {\n\t\t\tans += store[i] * store[n - i];\n\t\t}\n\t\tans += (store[x] * (store[x] + 1)) / 2;\n\t\tstore[n] = ans;\n\t\treturn ans;\n\t}\n\telse\n\t{\n\t\tvar x = (n + 1) / 2, ans = 0;\n\t\tfor (var i = 1; i < x; i++) {\n\t\t\tans += store[i] * store[n - i];\n\t\t}\n\t\tstore[n] = ans;\n\t\treturn ans;\n\t}\n}\nfunction Wedderburn_Etherington(n)\n{\n\tstore[0] = 0;\n\tstore[1] = 1;\n\tstore[2] = 1;\n\tfor (var i = 0; i < n; i++)\n\t{\n\t\tdocument.write( Wedderburn(i));\n\t\tif(i != n - 1)\n\t\t\tdocument.write( \", \");\n\t}\n}", "11331": "function Max_sum(a, n)\n{\n\tlet pos = 0, neg = 0;\n\tfor(let i = 0; i < n; i++)\n\t{\n\t\tif(a[i] > 0)\n\t\t\tpos = 1;\n\t\telse if(a[i] < 0)\n\t\t\tneg = 1;\n\t\tif(pos == 1 && neg == 1)\n\t\t\tbreak;\n\t}\n\tlet sum = 0;\n\tif(pos==1 && neg==1)\n\t{\n\t\tfor(let i=0; i < n ; i++)\n\t\t\tsum += Math.abs(a[i]);\n\t}\n\telse if(pos == 1)\n\t{\n\t\tlet mini = a[0];\n\t\tsum = a[0];\n\t\tfor(let i=1; i < n; i++)\n\t\t{\n\t\t\tmini = Math.min(mini, a[i]);\n\t\t\tsum += a[i];\n\t\t} \n\t\tsum -= 2*mini;\n\t} \n\telse if(neg == 1)\n\t{\n\t\tfor(let i = 0; i < n; i++)\n\t\t\ta[i] = Math.abs(a[i]);\n\t\tlet mini = a[0];\n\t\tsum = a[0];\n\t\tfor(let i=1; i < n; i++)\n\t\t{\n\t\t\tmini = Math.min(mini, a[i]);\n\t\t\tsum += a[i];\n\t\t} \n\t\tsum -= 2*mini;\n\t}\n\treturn sum;\n}", "11342": "function decimalToBinary(n) {\n\t\tif (n == 0) {\n\t\t\tdocument.write(\"0\");\n\t\t\treturn;\n\t\t}\n\t\tdecimalToBinary(parseInt(n / 2));\n\t\tdocument.write(n % 2);\n\t}", "11343": "function MinimumValue(x, y)\n{\n\tif (x > y)\n\t{\n\t\tvar temp = x;\n\t\t\tx = y;\n\t\t\ty = temp;\n\t}\n\tvar a = 1;\n\tvar b = x - 1;\n\tvar c = y - b;\n\tdocument.write( a + \" \" + b + \" \" + c);\n}", "11370": "function canConvert(a, b)\n{\n\twhile (b > a) {\n\t\tif (b % 10 == 1) {\n\t\t\tb = parseInt(b / 10);\n\t\t\tcontinue;\n\t\t}\n\t\tif (b % 2 == 0) {\n\t\t\tb = parseInt(b / 2);\n\t\t\tcontinue;\n\t\t}\n\t\treturn false;\n\t}\n\tif (b == a)\n\t\treturn true;\n\treturn false;\n}", "11387": "function count(N)\n\t{\n\t\tvar a = 0;\n\t\ta = (N * (N + 1)) / 2;\n\t\treturn a;\n\t}", "11404": "function numberOfDays(a , b , n)\n\t{\n\t\tvar Days = b * (n + a) / (a + b);\n\t\treturn Days;\n\t}", "11418": "function getAverage(x , y)\n\t{\n\t\tvar avg = (x & y) + ((x ^ y) >> 1);\n\t\treturn avg;\n\t}", "11435": "function primeCount(arr, n)\n{\n\tlet max_val = Math.max(...arr);\n\tlet prime = new Array(max_val + 1).fill(true);\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (let p = 2; p * p <= max_val; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (let i = p * 2; i <= max_val; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tlet count = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tif (prime[arr[i]])\n\t\t\tcount++;\n\treturn count;\n}\nfunction getPrefixArray(arr, n, pre)\n{\n\tpre[0] = arr[0];\n\tfor (let i = 1; i < n; i++) {\n\t\tpre[i] = pre[i - 1] + arr[i];\n\t}\n}", "11510": "function smallestIndex(a, n)\n\t{\n\t\tlet right1 = 0, right0 = 0;\n\t\tlet i;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == 1)\n\t\t\t\tright1 = i;\n\t\t\telse\n\t\t\t\tright0 = i;\n\t\t}\n\t\treturn Math.min(right1, right0);\n\t}", "11523": "function freqPairs(arr, n)\n{\n\tlet max = Math.max(...arr);\n\tlet freq = new Array(max + 1).fill(0);\n\tlet count = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tfreq[arr[i]]++;\n\tfor (let i = 0; i < n; i++) {\n\t\tfor (let j = 2 * arr[i]; j <= max; j += arr[i]) {\n\t\t\tif (freq[j] >= 1)\n\t\t\t\tcount += freq[j];\n\t\t}\n\t\tif (freq[arr[i]] > 1) {\n\t\t\tcount += freq[arr[i]] - 1;\n\t\t\tfreq[arr[i]]--;\n\t\t}\n\t}\n\treturn count;\n}", "11533": "function countSquares(r, c, m)\n\t{\n\t\tlet squares = 0;\n\t\tfor (let i = 1; i <= 8; i++) {\n\t\t\tfor (let j = 1; j <= 8; j++) {\n\t\t\t\tif (Math.max(Math.abs(i - r), Math.abs(j - c)) <= m)\n\t\t\t\t\tsquares++;\n\t\t\t}\n\t\t}\n\t\treturn squares;\n\t}", "11549": "function Loss(SP , P) {\n\t\tvar loss = 0;\n\t\tloss = (2 * P * P * SP) / (100 * 100 - P * P);\n\t\tdocument.write(\"Loss = \" + loss.toFixed(3));\n\t}", "11611": "function sieve()\n{\n\tspf[1] = 1;\n\tfor(let i = 2; i < MAXN; i++)\n\t\tspf[i] = i;\n\tfor(let i = 4; i < MAXN; i += 2)\n\t\tspf[i] = 2;\n\tfor(let i = 3; i * i < MAXN; i++)\n\t{\n\t\tif (spf[i] == i)\n\t\t{\n\t\t\tfor(let j = i * i; j < MAXN; j += i)\n\t\t\t\tif (spf[j] == j)\n\t\t\t\t\tspf[j] = i;\n\t\t}\n\t}\n}\nfunction getFactorization(x)\n{\n\tlet temp;\n\twhile (x != 1)\n\t{\n\t\ttemp = spf[x];\n\t\tif (x % temp == 0)\n\t\t{\n\t\t\thash1[spf[x]]++;\n\t\t\tx = x / spf[x];\n\t\t}\n\t\twhile (x % temp == 0)\n\t\t\tx = x / temp;\n\t}\n}\nfunction check(x)\n{\n\tlet temp;\n\twhile (x != 1)\n\t{\n\t\ttemp = spf[x];\n\t\tif (x % temp == 0 && hash1[temp] > 1)\n\t\t\treturn false;\n\t\twhile (x % temp == 0)\n\t\t\tx = x / temp;\n\t}\n\treturn true;\n}\nfunction hasValidNum(arr, n)\n{\n\tsieve();\n\tfor(let i = 0; i < n; i++)\n\t\tgetFactorization(arr[i]);\n\tfor(let i = 0; i < n; i++)\n\t\tif (check(arr[i]))\n\t\t\treturn true;\n\treturn false;\n}", "11613": "function countQuadruples(a, n)\n\t{\n\t\tlet mp = new Map();\n\t\tfor (let i = 0; i < n; i++)\n\t\t\tif (mp.has(a[i]))\n\t\t\t{\n\t\t\t\tmp.set(a[i], mp.get(a[i]) + 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp.set(a[i], 1);\n\t\t\t}\n\t\tlet count = 0;\n\t\tfor (let j = 0; j < n; j++)\n\t\t{\n\t\t\tfor (let k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tmp.set(a[j], mp.get(a[j]) - 1);\n\t\t\t\tmp.set(a[k], mp.get(a[k]) - 1);\n\t\t\t\tlet first = a[j] - (a[k] - a[j]);\n\t\t\t\tlet fourth = (a[k] * a[k]) / a[j];\n\t\t\t\tif ((a[k] * a[k]) % a[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (a[j] != a[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mp.has(first) && mp.has(fourth))\n\t\t\t\t\t\t\tcount +=\n\t\t\t\t\t\t\tmp.get(first) * mp.get(fourth);\n\t\t\t\t\t}\n\t\t\t\t\telse if (mp.has(first) && mp.has(fourth))\n\t\t\t\t\t\tcount +=\n\t\t\t\t\t\tmp.get(first) * (mp.get(fourth) - 1);\n\t\t\t\t}\n\t\t\t\tif (mp.has(a[j]))\n\t\t\t\t{\n\t\t\t\t\tmp.set(a[j], mp.get(a[j]) + 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp.set(a[j], 1);\n\t\t\t\t}\n\t\t\t\tif (mp.has(a[k]))\n\t\t\t\t{\n\t\t\t\t\tmp.set(a[k], mp.get(a[k]) + 1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp.set(a[k], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}", "11626": "function countNumbers(L, R, K)\n{\n\tif (K == 9)\n\t{\n\t\tK = 0;\n\t}\n\tvar totalnumbers = R - L + 1;\n\tvar factor9 = totalnumbers / 9;\n\tvar rem = totalnumbers % 9;\n\tvar ans = factor9;\n\tfor(var i = R; i > R - rem; i--)\n\t{\n\t\tvar rem1 = i % 9;\n\t\tif (rem1 == K)\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}", "11627": "function countWays(N)\n\t{\n\t\tlet E = parseInt((N * (N - 1)) / 2, 10);\n\t\tif (N == 1)\n\t\t\treturn 0;\n\t\treturn Math.pow(2, E - 1);\n\t}", "11628": "function EvenSum(A, index, value)\n{\n\tA[index] = A[index] + value;\n\tvar sum = 0;\n\tfor (var i = 0; i < A.length; i++)\n\t\tif (A[i] % 2 == 0)\n\t\t\tsum = sum + A[i];\n\treturn sum;\n}\nfunction BalanceArray(A, Q)\n{\n\tvar ANS = [];\n\tvar i, sum;\n\tfor (i = 0; i < Q.length; i++) {\n\t\tvar index = Q[i][0];\n\t\tvar value = Q[i][1];\n\t\tsum = EvenSum(A, index, value);\n\t\tANS.push(sum);\n\t}\n\tfor (i = 0; i < ANS.length; i++)\n\t\tdocument.write( ANS[i] + \" \");\n}", "11629": "function BalanceArray(A, Q)\n{\n\tvar ANS = [];\n\tvar i, sum = 0;\n\tfor (i = 0; i < A.length; i++)\n\t\tif (A[i] % 2 == 0)\n\t\t\tsum = sum + A[i];\n\tfor (i = 0; i < Q.length; i++) {\n\t\tvar index = Q[i][0];\n\t\tvar value = Q[i][1];\n\t\tif (A[index] % 2 == 0)\n\t\t\tsum = sum - A[index];\n\t\tA[index] = A[index] + value;\n\t\tif (A[index] % 2 == 0)\n\t\t\tsum = sum + A[index];\n\t\tANS.push(sum);\n\t}\n\tfor (i = 0; i < ANS.length; i++)\n\t\tdocument.write( ANS[i] + \" \");\n}", "11658": "function Cycles(N)\n{\n\tvar fact = 1, result = 0;\n\tresult = N - 1;\n\tvar i = result;\n\twhile (i > 0) {\n\t\tfact = fact * i;\n\t\ti--;\n\t}\n\treturn fact / 2;\n}", "11667": "function findAndSum(arr, n)\n{\n\tvar sum = 0;\n\tvar mul = 1;\n\tfor (var i = 0; i < 30; i++) {\n\t\tvar count_on = 0;\n\t\tvar l = 0;\n\t\tfor (var j = 0; j < n; j++) {\n\t\t\tif ((arr[j] & (1 << i)) > 0)\n\t\t\t\tif (count_on)\n\t\t\t\t\tl++;\n\t\t\t\telse {\n\t\t\t\t\tcount_on = 1;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\telse if (count_on) {\n\t\t\t\tsum += ((mul * l * (l + 1)) / 2);\n\t\t\t\tcount_on = 0;\n\t\t\t\tl = 0;\n\t\t\t}\n\t\t}\n\t\tif (count_on) {\n\t\t\tsum += ((mul * l * (l + 1)) / 2);\n\t\t\tcount_on = 0;\n\t\t\tl = 0;\n\t\t}\n\t\tmul *= 2;\n\t}\n\treturn sum;\n}", "11677": "function initialize()\n{\n\tl[0][0] = 1;\n\tfor (let i = 1; i < 1001; i++) {\n\t\tl[i][0] = 1;\n\t\tfor (let j = 1; j < i + 1; j++) {\n\t\t\tl[i][j] = (l[i - 1][j - 1] + l[i - 1][j]);\n\t\t}\n\t}\n}\nfunction nCr(n, r)\n{\n\treturn l[n][r];\n}", "11687": "function minValue(n, x, y)\n{\n\tlet val = (y * n) / 100;\n\tif (x >= val)\n\t\treturn 0;\n\telse\n\t\treturn (Math.ceil(val) - x);\n}", "11707": "function digitWell(n, m, k)\n{\n\tvar cnt = 0;\n\twhile (n > 0) {\n\t\tif (n % 10 == m)\n\t\t\t++cnt;\n\t\tn = Math.floor(n/10);\n\t}\n\tif(cnt == k)\n\treturn true;\n\telse\n\t\treturn false;\n}\nfunction findInt(n, m, k)\n{\n\tvar i = n + 1;\n\twhile (true) {\n\t\tif (digitWell(i, m, k))\n\t\t\treturn i;\n\t\ti++;\n\t}\n}", "11709": "function minAbsDiff(n)\n\t{\n\t\tlet mod = n % 4;\n\t\tif (mod == 0 mod == 3)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}", "11722": "function countOdd(arr, n)\n{\n\tvar odd = 0;\n\tfor(var i = 0; i < n; i++)\n\t{\n\t\tif (arr[i] % 2 == 1)\n\t\t\todd++;\n\t}\n\treturn odd;\n}\nfunction countValidPairs(arr, n)\n{\n\tvar odd = countOdd(arr, n);\n\treturn (odd * (odd - 1)) / 2;\n}", "11748": "function gcd(a, b)\n{\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\nfunction lcmOfArray(arr, n)\n{\n\tif (n < 1)\n\t\treturn 0;\n\tlet lcm = arr[0];\n\tfor (let i = 1; i < n; i++)\n\t\tlcm = parseInt((lcm * arr[i]) / gcd(lcm, arr[i]));\n\treturn lcm;\n}\nfunction minPerfectCube(arr, n)\n{\n\tlet minPerfectCube;\n\tlet lcm = lcmOfArray(arr, n);\n\tminPerfectCube = lcm;\n\tlet cnt = 0;\n\twhile (lcm > 1 && lcm % 2 == 0) {\n\t\tcnt++;\n\t\tlcm = parseInt(lcm/2);\n\t}\n\tif (cnt % 3 == 2)\n\t\tminPerfectCube *= 2;\n\telse if (cnt % 3 == 1)\n\t\tminPerfectCube *= 4;\n\tlet i = 3;\n\twhile (lcm > 1) {\n\t\tcnt = 0;\n\t\twhile (lcm % i == 0) {\n\t\t\tcnt++;\n\t\t\tlcm = parseInt(lcm/i);\n\t\t}\n\t\tif (cnt % 3 == 1)\n\t\t\tminPerfectCube *= i * i;\n\t\telse if (cnt % 3 == 2)\n\t\t\tminPerfectCube *= i;\n\t\ti += 2;\n\t}\n\treturn minPerfectCube;\n}", "11772": "function isPrime(n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor(let i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nfunction isStrongPrime(n)\n{\n\tif (!isPrime(n) n == 2)\n\t\treturn false;\n\tlet previous_prime = n - 1;\n\tlet next_prime = n + 1;\n\twhile (!isPrime(next_prime))\n\t\tnext_prime++;\n\twhile (!isPrime(previous_prime))\n\t\tprevious_prime--;\n\tlet mean = parseInt((previous_prime + next_prime) / 2);\n\tif (n > mean)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "11774": "function isPrime(n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (let i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nfunction isFactorialPrime(n)\n{\n\tif (!isPrime(n))\n\t\treturn false;\n\tlet fact = 1;\n\tlet i = 1;\n\twhile (fact <= n + 1)\n\t{\n\t\tfact = fact * i;\n\t\tif (n + 1 == fact n - 1 == fact)\n\t\t\treturn true;\n\t\ti++;\n\t}\n\treturn false;\n}", "11815": "function countDigitsToBeRemoved(N, K) {\n\t\tvar s = N.toString();\n\t\tvar res = 0;\n\t\tvar f_zero = 0;\n\t\tfor (var i = s.length - 1; i >= 0; i--) {\n\t\tif (K === 0) return res;\n\t\tif (s[i] === \"0\") {\n\t\t\tf_zero = 1;\n\t\t\tK--;\n\t\t} else res++;\n\t\t}\n\t\tif (K === 0) return res;\n\t\telse if (f_zero === 1) return s.length - 1;\n\t\treturn -1;\n\t}", "11906": "function getSum( a, n) {\n\t\tlet sum = 0;\n\t\tfor (let i = 1; i <= n; ++i) {\n\t\t\tsum += (i / Math.pow(a, i));\n\t\t}\n\t\treturn sum;\n\t}", "11948": "function check(s)\n{\n\tlet freq = new Array(10).fill(0), r;\n\twhile(s != 0)\n\t{\n\t\tr = s % 10;\n\t\ts = parseInt(s / 10);\n\t\tfreq[r] += 1;\n\t}\n\tlet xor__ = 0;\n\tfor (let i=0;i<10;i++)\n\t{\n\txor__ = xor__ ^ freq[i];\n\tif(xor__ == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n\t}\n}", "11998": "function largestPrimeFactor( n)\n\t{\n\t\tvar max = -1;\n\t\twhile (n % 2 == 0) {\n\t\t\tmax = 2;\n\t\t}\n\t\tfor (var i = 3; i <= Math.sqrt(n); i += 2) {\n\t\t\twhile (n % i == 0) {\n\t\t\t\tmax = i;\n\t\t\t\tn = n / i;\n\t\t\t}\n\t\t}\n\t\tif (n > 2)\n\t\t\tmax = n;\n\t\treturn max;\n\t}\nfunction checkUnusual(n)\n\t{\n\t\tvar factor = largestPrimeFactor(n);\n\t\tif (factor > Math.sqrt(n)) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}", "12002": "function Nth_Term(n)\n{\n\treturn (2 * Math.pow(n, 3) - 3 *\n\t\t\t\tMath.pow(n, 2) + n + 6) / 6;\n}", "12035": "function isHalfReducible(arr, n, m)\n{\n\tvar frequencyHash = Array(m+1).fill(0);\n\tvar i;\n\tfor (i = 0; i < n; i++) {\n\t\tfrequencyHash[arr[i] % (m + 1)]++;\n\t}\n\tfor (i = 0; i <= m; i++) {\n\t\tif (frequencyHash[i] >= n / 2)\n\t\t\tbreak;\n\t}\n\tif (i <= m)\n\t\tdocument.write( \"Yes\" );\n\telse\n\t\tdocument.write( \"No\" );\n}", "12037": "function generateDivisors(n)\n{\n\tfor (var i = 1; i <= Math.sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (n / i == i)\n\t\t\t\tarr.push(i);\n\t\t\t{\n\t\t\t\tarr.push(i);\n\t\t\t\tarr.push(n / i);\n\t\t\t}\n\t\t}\n\t}\n}\nfunction harmonicMean(n)\n{\n\tgenerateDivisors(n);\n\tvar sum = 0.0;\n\tvar len = arr.length;\n\tfor (var i = 0; i < len; i++)\n\t\tsum = sum + (n / arr[i]);\n\tsum = (sum / n);\n\treturn (arr.length / sum);\n}\nfunction isOreNumber(n)\n{\n\tvar mean = harmonicMean(n);\n\tif (mean - parseInt(mean) == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "12058": "", "12070": "function printLines(n , k)\n\t{\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdocument.write(k * (6 * i + 1)\n\t\t\t+ \" \" + k * (6 * i + 2) + \" \"\n\t\t\t+ k * (6 * i + 3) + \" \"\n\t\t\t+ k * (6 * i + 5)+\"<br/>\");\n\t\t}\n\t}", "12076": "function SieveOfEratosthenes()\n{\n\tvar prime = Array(MAX).fill(true);;\n\tfor (var p = 2; p * p < MAX; p++) {\n\t\tif (prime[p] == true) {\n\t\t\tfor (var i = p * 2; i < MAX; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor (var p = 2; p < MAX; p++)\n\t\tif (prime[p])\n\t\t\tarr.push(p);\n}\nfunction isEuclid( n)\n{\n\tvar product = 1;\n\tvar i = 0;\n\twhile (product < n) {\n\t\tproduct = product * arr[i];\n\t\tif (product + 1 == n)\n\t\t\treturn true;\n\t\ti++;\n\t}\n\treturn false;\n}", "12077": "function SieveOfEratosthenes()\n{\n\tlet prime = new Array(MAX);\n\tfor(let i=0;i<prime.length;i++)\n\t{\n\t\tprime[i]=true;\n\t}\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (let p = 2; p * p < MAX; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor (let i = p * 2; i < MAX; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tlet product = 1;\n\tfor (let p = 2; p < MAX; p++)\n\t{\n\t\tif (prime[p])\n\t\t{\n\t\t\tproduct = product * p;\n\t\t\ts.add(product + 1);\n\t\t}\n\t}\n}\nfunction isEuclid(n)\n{\n\tif (s.has(n))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "12078": "function isPrime( n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (var i = 5; i * i <= n; i = i + 6) {\n\t\t\tif (n % i == 0 || n % (i + 2) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\nfunction isPowerOfTwo(n)\n\t{\n\t\treturn (n != 0 )&& ((n & (n - 1)) == 0);\n\t}", "12117": "function area(a)\n{\n\tif (a < 0)\n\t\treturn -1;\n\tvar area = Math.pow((a * Math.sqrt(3)) / (Math.sqrt(2)), 2);\n\treturn area;\n}", "12147": "function nthTerm(n)\n{\n\treturn 3 * Math.pow(n, 2) - 4 * n + 2;\n}", "12157": "function calculateSum(n)\n{\n\treturn n * (n + 1) / 2\n\t\t+ Math.pow((n * (n + 1) / 2), 2);\n}", "12170": "function reverseString(str) {\n\treturn str.split(\"\").reverse().join(\"\");\n}\nfunction findNthNo( n) {\n\t\tlet res = \"\";\n\t\twhile (n >= 1) {\n\t\t\tif ((n & 1) == 1) {\n\t\t\t\tres = res + \"3\";\n\t\t\t\tn = (n - 1) / 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = res + \"5\";\n\t\t\t\tn = (n - 2) / 2;\n\t\t\t}\n\t\t}\n\t\tsb = (res);\n\t\tsb =reverseString(sb);\n\t\treturn (sb);\n\t}", "12180": "function prletNthElement( n) {\n\t\tlet arr = Array(n + 1).fill(0);\n\t\tarr[1] = 3;\n\t\tarr[2] = 5;\n\t\tfor ( i = 3; i <= n; i++) {\n\t\t\tif (i % 2 != 0)\n\t\t\t\tarr[i] = arr[i / 2] * 10 + 3;\n\t\t\telse\n\t\t\t\tarr[i] = arr[(i / 2) - 1] * 10 + 5;\n\t\t}\n\t\treturn arr[n];\n\t}", "12185": "function arePermutations(a,b,n,m)\n\t{\n\t\tlet sum1 = 0, sum2 = 0, mul1 = 1, mul2 = 1;\n\tfor (let i = 0; i < n; i++) {\n\t\tsum1 += a[i];\n\t\tmul1 *= a[i];\n\t}\n\tfor (let i = 0; i < m; i++) {\n\t\tsum2 += b[i];\n\t\tmul2 *= b[i];\n\t}\n\treturn ((sum1 == sum2) && (mul1 == mul2));\n\t}", "12191": "function nextPerfectCube(N)\n{\n\tlet nextN = Math.floor(Math.cbrt(N)) + 1;\n\treturn nextN * nextN * nextN;\n}", "12192": "function nthTerm( N)\n{\n\treturn parseInt(N * (parseInt(N / 2) + ((N % 2) * 2) + N));\n}", "12225": "function Race(B, C)\n{\n\tvar result = 0;\n\tresult = ((C * 100) / B);\n\treturn 100 - result;\n}", "12228": "function calculateSum( n)\n{\n\treturn (Math.pow(2, n + 1) + n - 2);\n}", "12239": "function Time(arr, n, Emptypipe)\n{\n\tvar fill = 0;\n\tfor(var i = 0; i < n; i++)\n\t\tfill += 1 / arr[i];\n\tfill = fill - (1 / Emptypipe);\n\treturn 1 / fill;\n}", "12261": "function isPrime(n) {\n\t\tvar i,\n\t\tc = 0;\n\t\tfor (i = 1; i < n / 2; i++) {\n\t\tif (n % i == 0) c++;\n\t\t}\n\t\tif (c == 1) return 1;\n\t\telse return 0;\n\t}\nfunction findMinNum(arr, n) {\n\t\tvar first = 0,\n\t\tlast = 0,\n\t\tnum,\n\t\trev,\n\t\ti;\n\t\tvar hash = new Array(10).fill(0);\n\t\tfor (var i = 0; i < n; i++) {\n\t\thash[arr[i]]++;\n\t\t}\n\t\tdocument.write(\"Minimum number: \");\n\t\tfor (var i = 0; i <= 9; i++) {\n\t\tfor (var j = 0; j < hash[i]; j++) document.write(i);\n\t\t}\n\t\tdocument.write(\"<br>\");\n\t\tfor (i = 0; i <= 9; i++) {\n\t\tif (hash[i] != 0) {\n\t\t\tfirst = i;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tfor (i = 9; i >= 0; i--) {\n\t\tif (hash[i] != 0) {\n\t\t\tlast = i;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tnum = first * 10 + last;\n\t\trev = last * 10 + first;\n\t\tdocument.write(\"Prime combinations: \");\n\t\tif (isPrime(num) && isPrime(rev)) document.write(num + \" \" + rev);\n\t\telse if (isPrime(num)) document.write(num);\n\t\telse if (isPrime(rev)) document.write(rev);\n\t\telse document.write(\"No combinations exist\");\n\t}", "12264": "function check(n)\n{\n\tlet sum = 0;\n\twhile (n != 0) {\n\t\tsum += n % 10;\n\t\tn = Math.floor(n / 10);\n\t}\n\tif (sum % 7 == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "12314": "function isPrime(n)\n\t{\n\tif (n <= 1)\n\t\treturn false;\n\tif (n <= 3)\n\t\treturn true;\n\tif (n % 2 == 0 n % 3 == 0)\n\t\treturn false;\n\tfor (let i = 5; i * i <= n; i = i + 6)\n\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n\t}\nfunction SumOfPrimeDivisors(n)\n\t{\n\t\tlet sum = 0;\n\tfor (let i = 1; i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (isPrime(i))\n\t\t\t\tsum += i;\n\t\t}\n\t}\n\treturn sum;\n\t}", "12315": "function Sum(N)\n\t{\n\t\tlet SumOfPrimeDivisors = new Array(N+1);\n\t\tfor(let i=0;i<SumOfPrimeDivisors.length;i++)\n\t\t{\n\t\t\tSumOfPrimeDivisors[i]=0;\n\t\t}\n\t\tfor (let i = 2; i <= N; ++i)\n\t\t{\n\t\t\tif (SumOfPrimeDivisors[i] == 0)\n\t\t\t{\n\t\t\t\tfor (let j = i; j <= N; j += i)\n\t\t\t\t{\n\t\t\t\t\tSumOfPrimeDivisors[j] += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn SumOfPrimeDivisors[N];\n\t}", "12316": "function isPrime(n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tif (n <= 3)\n\t\t\treturn true;\n\t\tif (n % 2 == 0 n % 3 == 0)\n\t\t\treturn false;\n\t\tfor (let i = 5; i * i <= n; i = i + 6)\n\t\t\tif (n % i == 0 || n % (i + 2) == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nfunction SumOfPrimeDivisors(n)\n\t{\n\t\tlet sum = 0;\n\t\tlet root_n = parseInt(Math.sqrt(n), 10);\n\t\tfor (let i = 1; i <= root_n; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tif (i == parseInt(n / i, 10) && isPrime(i)) {\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (isPrime(i)) {\n\t\t\t\t\t\tsum += i;\n\t\t\t\t\t}\n\t\t\t\t\tif (isPrime(parseInt(n / i, 10))) {\n\t\t\t\t\t\tsum += (parseInt(n / i, 10));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}", "12333": "function findNthNonSquare(n)\n{\n\tvar x = n;\n\tvar ans = x + Math.floor(0.5 + Math.sqrt(x));\n\treturn parseInt(ans);\n}", "12422": "function find_Square_369(num)\n\t{\n\t\tlet a, b, c, d;\n\t\tif (num[0] == '3')\n\t\t\t{a = '1'; b = '0'; c = '8'; d = '9';}\n\t\telse if (num[0] == '6')\n\t\t\t{a = '4'; b = '3'; c = '5'; d = '6';}\n\t\telse\n\t\t\t{a = '9'; b = '8'; c = '0'; d = '1';}\n\t\tlet result = \"\";\n\t\tlet size = num.length;\n\t\tfor (let i = 1; i < size; i++)\n\t\t\tresult += a;\n\t\tresult += b;\n\t\tfor (let i = 1; i < size; i++)\n\t\t\tresult += c;\n\t\tresult += d;\n\t\treturn result;\n\t}", "12430": "", "12439": "function findpos(n)\n{\n\tvar pos = 0;\n\tfor (i = 0; i < n.length; i++)\n\t{\n\t\tswitch (n.charAt(i))\n\t\t{\n\t\tcase '2':\n\t\t\tpos = pos * 4 + 1;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tpos = pos * 4 + 2;\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tpos = pos * 4 + 3;\n\t\t\tbreak;\n\t\tcase '7':\n\t\t\tpos = pos * 4 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn pos;\n}", "12462": "function fact(n)\n{\n\tif (n == 0 n == 1)\n\t\treturn 1;\n\tlet ans = 1;\n\tfor(let i = 1 ; i <= n; i++)\n\t\tans = ans * i;\n\treturn ans;\n}\nfunction nCr(n, r)\n{\n\tlet Nr = n , Dr = 1 , ans = 1;\n\tfor(let i = 1 ; i <= r ; i++)\n\t{\n\t\tans = parseInt((ans * Nr) / (Dr), 10);\n\t\tNr--;\n\t\tDr++;\n\t}\n\treturn ans;\n}\nfunction solve(n)\n{\n\tlet N = 2 * n - 2;\n\tlet R = n - 1;\n\treturn nCr (N, R) * fact(n - 1);\n}", "12485": "function gcd(a, b)\n\t{\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\nfunction coprime(a, b)\n\t{\n\t\treturn (gcd(a, b) == 1);\n\t}\nfunction possibleTripletInRange(L, R)\n\t{\n\t\tlet flag = false;\n\t\tlet possibleA = 0,\n\t\t\tpossibleB = 0,\n\t\t\tpossibleC = 0;\n\t\tfor (let a = L; a <= R; a++)\n\t\t{\n\t\t\tfor (let b = a + 1; b <= R; b++)\n\t\t\t{\n\t\t\t\tfor (let c = b + 1; c <= R; c++)\n\t\t\t\t{\n\t\t\t\t\tif (coprime(a, b) &&\n\t\t\t\t\t\tcoprime(b, c) &&\n\t\t\t\t\t!coprime(a, c))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tpossibleA = a;\n\t\t\t\t\t\tpossibleB = b;\n\t\t\t\t\t\tpossibleC = c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag == true)\n\t\t{\n\t\t\tdocument.write(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible triplet \" + \"between \" + L + \" and \" + R + \"</br>\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.write(\"No Such Triplet exists\" + \"between \" + L + \" and \" + R + \"</br>\");\n\t\t}\n\t}", "12486": "function possibleTripletInRange(L, R)\n {\n\tlet flag = false;\n\tlet possibleA, possibleB, possibleC;\n\tlet numbersInRange = (R - L + 1);\n\tif (numbersInRange < 3) {\n\tflag = false;\n\t}\n\telse if (numbersInRange > 3) {\n\tflag = true;\n\tif (L % 2) {\n\t\tL++;\n\t}\n\tpossibleA = L;\n\tpossibleB = L + 1;\n\tpossibleC = L + 2;\n\t}\n\telse {\n\tif (!(L % 2)) {\n\t\tflag = true;\n\t\tpossibleA = L;\n\t\tpossibleB = L + 1;\n\t\tpossibleC = L + 2;\n\t}\n\telse {\n\t\tflag = false;\n\t}\n\t}\n\tif (flag == true) {\n\tdocument.write(\"(\" + possibleA + \", \" + possibleB + \", \" + possibleC + \")\" + \" is one such possible triplet between \" + L + \" and \" + R + \"</br>\");\n\t}\n\telse {\n\tdocument.write(\"No Such Triplet exists between \" + L + \" and \" + R + \"</br>\");\n\t}\n }", "12496": "function possibleToReach(a, b)\n\t{\n\t\tlet c = Math.cbrt(a * b);\n\t\tlet re1 = a / c;\n\t\tlet re2 = b / c;\n\t\tif ((re1 * re1 * re2 == a) &&\n\t\t\t\t\t\t(re2 * re2 * re1 == b))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}", "12520": "function isUndulating(n)\n\t{\n\t\t\tif (n.length <= 2)\n\t\t\t\treturn false;\n\t\tfor (let i = 2; i < n.length; i++)\n\t\t\tif (n[i-2] != n[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}", "12523": "function pythagoreanTriplet(n)\n\t{\n\t\tfor (let i = 1; i <= n / 3; i++)\n\t\t{\n\t\t\tfor (let j = i + 1; j <= n / 2; j++)\n\t\t\t{\n\t\t\t\tlet k = n - i - j;\n\t\t\t\tif (i * i + j * j == k * k)\n\t\t\t\t{\n\t\t\t\t\tdocument.write(i + \", \"+ j + \", \" + k);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdocument.write(\"No Triplet\");\n\t}", "12532": "function factorial(n)\n\t{\n\t\tlet f = 1;\n\t\tfor (let i = 2; i <= n; i++)\n\t\t\tf *= i;\n\t\treturn f;\n\t}\nfunction series(A, X, n)\n\t{\n\t\tlet nFact = factorial(n);\n\t\tfor (let i = 0; i < n + 1; i++) {\n\t\t\tlet niFact = factorial(n - i);\n\t\t\tlet iFact = factorial(i);\n\t\t\tlet aPow = Math.pow(A, n - i);\n\t\t\tlet xPow = Math.pow(X, i);\n\t\t\tdocument.write((nFact * aPow * xPow)\n\t\t\t\t\t\t/ (niFact * iFact) + \" \");\n\t\t}\n\t}", "12533": "function series(A, X, n)\n{\n\tlet term = Math.pow(A, n);\n\tdocument.write(term + \" \");\n\tfor (let i = 1; i <= n; i++) {\n\t\tterm = term * X * (n - i + 1)/(i * A);\n\t\tdocument.write(term + \" \");\n\t}\n}", "12547": "function seiresSum(n, a)\n\t{\n\t\tlet res = 0, i;\n\t\tfor (i = 0; i < 2 * n; i++)\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t\tres += a[i] * a[i];\n\t\t\telse\n\t\t\t\tres -= a[i] * a[i];\n\t\t}\n\t\treturn res;\n\t}", "12548": "function seiresSum(n, a)\n{\n\treturn n * (a[0] * a[0] - a[2 * n - 1] * a[2 * n - 1]) /\n\t\t\t\t(2 * n - 1);\n}", "12550": "function checkdigit(n, k)\n\t{\n\t\twhile (n != 0)\n\t\t{\n\t\t\tlet rem = n % 10;\n\t\t\tif (rem == k)\n\t\t\t\treturn true;\n\t\t\tn = n / 10;\n\t\t}\n\t\treturn false;\n\t}\nfunction findNthNumber(n, k)\n\t{\n\t\tfor (let i = k + 1, count = 1; count < n; i++)\n\t\t{\n\t\tif (checkdigit(i, k) || (i % k == 0))\n\t\t\tcount++;\n\t\tif (count == n)\n\t\treturn i;\n\t\t}\n\treturn -1;\n\t}", "12561": "function power(n, r) {\n\tlet count = 0;\n\tfor (let i = r; (n / i) >= 1; i = i * r)\n\tcount += n / i;\n\treturn count;\n}", "12564": "function digitNumber(n) {\nif (n == 0)\n\treturn 1;\nif (n == 1)\n\treturn 9;\nif (n % 2) {\n\tlet temp = digitNumber((n - 1) / 2) % mod;\n\treturn (9 * (temp * temp) % mod) % mod;\n} else {\n\tlet temp = digitNumber(n / 2) % mod;\n\treturn (temp * temp) % mod;\n}\n}\nfunction countExcluding(n, d)\n{\nif (d == 0)\n\treturn (9 * digitNumber(n - 1)) % mod;\nelse\n\treturn (8 * digitNumber(n - 1)) % mod;\n}", "12587": "function Div_by_8(n)\n{\n\treturn (((n >> 3) << 3) == n);\n}", "12603": "function avg_of_odd_num( n)\n{\n\tlet sum = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tsum += (2 * i + 1);\n\treturn sum / n;\n}", "12604": "function avg_of_odd_num(n)\n\t{\n\t\treturn n;\n\t}", "12615": "function fib(f, N)\n{\n\tf[1] = 1;\n\tf[2] = 1;\n\tfor(var i = 3; i <= N; i++)\n\t\tf[i] = f[i - 1] + f[i - 2];\n}\nfunction fiboTriangle(n)\n{\n\tvar N = (n * (n + 1)) / 2;\n\tvar f = [...Array(N + 1)];\n\tfib(f, N);\n\tvar fiboNum = 1;\n\tfor(var i = 1; i <= n; i++)\n\t{\n\t\tfor(var j = 1; j <= i; j++)\n\t\t\tdocument.write(f[fiboNum++] + \" \");\n\t\tdocument.write(\"<br>\");\n\t}\n}", "12638": "function averageEven( n)\n{\n\tif (n % 2 != 0) {\n\t\tdocument.write(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\tlet sum = 0, count = 0;\n\twhile (n >= 2) {\n\t\tcount++;\n\t\tsum += n;\n\t\tn = n - 2;\n\t}\n\treturn sum / count;\n}", "12639": "function averageEven( n)\n{\n\tif (n % 2 != 0)\n\t{\n\t\tdocument.write(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\treturn (n + 2) / 2;\n}", "12645": "function averageOdd( n)\n\t{\n\t\tif (n % 2 == 0)\n\t\t{\n\t\t\tdocument.write(\"Invalid Input\");\n\t\t\treturn -1;\n\t\t}\n\t\tlet sum = 0, count = 0;\n\t\twhile (n >= 1) {\n\t\t\tcount++;\n\t\t\tsum += n;\n\t\t\tn = n - 2;\n\t\t}\n\t\treturn sum / count;\n\t}", "12646": "function averageOdd( n)\n{\n\tif (n % 2 == 0) {\n\t\tdocument.write(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\treturn (n + 1) / 2;\n}", "12686": "function lcm(a,b)\n{\n\treturn (a * b) / (__gcd(a, b)); \n}\nfunction maxRational(first,sec)\n{\n\tlet k = lcm(first.deno, sec.deno);\n\tlet nume1 = first.nume;\n\tlet nume2 = sec.nume;\n\tnume1 *= k / (first.deno);\n\tnume2 *= k / (sec.deno);\n\treturn (nume2 < nume1)? first : sec;\n}\nfunction __gcd(a,b)\n{\n\treturn b == 0 ? a:__gcd(b, a % b);\t\n}", "12714": "function TrinomialValue(n, k)\n\t{\n\t\tif (n == 0 && k == 0)\n\t\t\treturn 1;\n\t\tif (k < -n k > n)\n\t\t\treturn 0;\n\t\treturn TrinomialValue(n - 1, k - 1)\n\t\t\t+ TrinomialValue(n - 1, k)\n\t\t\t+ TrinomialValue(n - 1, k + 1);\n\t}\nfunction printTrinomial(n)\n\t{\n\t\tfor (let i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (let j = -i; j <= 0; j++)\n\t\t\t\tdocument.write(TrinomialValue(i, j) + \" \");\n\t\t\tfor (let j = 1; j <= i; j++)\n\t\t\t\tdocument.write(TrinomialValue(i, j) + \" \");\n\t\t\tdocument.write(\"<br/>\");\n\t\t}\n\t}", "12715": "function TrinomialValue(dp, n, k)\n{\n\tif (k < 0)\n\t\tk = -k;\n\tif (dp[n][k] != 0)\n\t\treturn dp[n][k];\n\tif (n == 0 && k == 0)\n\t\treturn 1;\n\tif(k < -n k > n)\n\t\treturn 0;\n\treturn (dp[n][k] = TrinomialValue(dp, n - 1, k - 1)\n\t\t+ TrinomialValue(dp, n - 1, k)\n\t\t+ TrinomialValue(dp, n - 1, k + 1));\n}\nfunction printTrinomial(n)\n{\n\tvar dp = Array.from(Array(MAX), ()=> Array(MAX).fill(0));\n\tfor (var i = 0; i < n; i++)\n\t{\n\t\tfor (var j = -i; j <= 0; j++)\n\t\t\tdocument.write( TrinomialValue(dp, i, j) + \" \");\n\t\tfor (var j = 1; j <= i; j++)\n\t\t\tdocument.write( TrinomialValue(dp, i, j) + \" \");\n\t\tdocument.write(\"<br>\");\n\t}\n}", "12716": "function Series( n) {\n\t\tlet i;\n\t\tlet sums = 0;\n\t\tfor (i = 1; i <= n; i++)\n\t\t\tsums += (i * i);\n\t\treturn sums;\n\t}", "12745": "function isPrime(n)\n\t{\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\tfor (i = 2; i < n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\nfunction isEmirp(n)\n\t{\n\t\tif (isPrime(n) == false)\n\t\t\treturn false;\n\t\tvar rev = 0;\n\t\twhile (n != 0) {\n\t\t\tvar d = n % 10;\n\t\t\trev = rev * 10 + d;\n\t\t\tn = parseInt(n/10);\n\t\t}\n\t\treturn isPrime(rev);\n\t}", "12747": "function sumOfLargePrimeFactor(n)\n{\n\tlet prime = new Array(n + 1);\n\tlet sum = 0;\n\tlet max = n / 2;\n\tfor(let i = 0; i < n + 1; i++)\n\t\tprime[i] = 0;\n\tfor(let p = 2; p <= max; p++)\n\t{\n\t\tif (prime[p] == 0)\n\t\t{\n\t\t\tfor(let i = p * 2; i <= n; i += p)\n\t\t\t\tprime[i] = p;\n\t\t}\n\t}\n\tfor(let p = 2; p <= n; p++)\n\t{\n\t\tif (prime[p])\n\t\t\tsum += prime[p];\n\t\telse\n\t\t\tsum += p;\n\t}\n\treturn sum;\t\n}", "12750": "function gcd(a, b)\n{\n\tif (a == 0 b == 0)\n\t\treturn 0;\n\tif (a == b)\n\t\treturn a;\n\tif (a > b)\n\t\treturn gcd(a - b, b);\n\treturn gcd(a, b - a);\n}\nfunction cpFact(x, y)\n{\n\twhile (gcd(x, y) != 1)\n\t{\n\t\tx = x / gcd(x, y);\n\t}\n\treturn x;\n}", "12764": "function counLastDigitK(low, high, k)\n{\n\tlet count = 0;\n\tfor (let i = low; i <= high; i++)\n\t\tif (i % 10 == k)\n\t\t\tcount++;\n\treturn count;\n}", "12765": "function counLastDigitK(low, high, k)\n\t{\n\t\tlet mlow = 10 * (Math.ceil(low/10.0));\n\t\tlet mhigh = 10 * (Math.floor(high/10.0));\n\t\tlet count = (mhigh - mlow) / 10;\n\t\tif (high % 10 >= k)\n\t\t\tcount++;\n\t\tif (low % 10 <= k && (low%10) > 0)\n\t\t\tcount++;\n\t\treturn count;\n\t}", "12794": "function Convert(radian){\n\tlet pi = 3.14159;\n\treturn(radian * (180/pi));\n}", "12799": "function sn(n,an)\n\t{\n\t\treturn (n * (1 + an)) / 2;\n\t}\nfunction trace(n,m)\n\t{\n\t\tlet an = 1 + (n - 1) * (m + 1);\n\t\tlet rowmajorSum = sn(n, an);\n\t\tan = 1 + (n - 1) * (n + 1);\n\t\tlet colmajorSum = sn(n, an);\n\t\treturn rowmajorSum + colmajorSum;\n\t}", "12810": "function avgOfFirstN( n)\n{\n\treturn (1 + n)/2;\n}", "12842": "function sum(L, R)\n\t{\n\t\tlet p = Math.floor(R / 6);\n\t\tlet q = Math.floor((L - 1) / 6);\n\t\tlet sumR = Math.floor(3 * (p * (p + 1)));\n\t\tlet sumL = Math.floor((q * (q + 1)) * 3);\n\t\treturn sumR - sumL;\n\t}", "12844": "function max_area(n, m, k)\n{\n\tif (k > (n + m - 2))\n\t\tdocument.write(\"Not possible\");\n\telse\n\t{\n\t\tlet result;\n\t\tif (k < Math.max(m, n) - 1)\n\t\t{\n\t\t\tresult = Math.max(m * (n / (k + 1)),\n\t\t\t\t\t\t\tn * (m / (k + 1)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = Math.max(m / (k - n + 2),\n\t\t\t\t\t\t\tn / (k - m + 2));\n\t\t}\n\t\tdocument.write(result);\n\t}\n}", "12855": "function prevNum(str)\n\t{\n\t\tlet len = str.length;\n\t\tlet index = -1;\n\t\tfor (let i = len - 2; i >= 0; i--)\n\t\t{\n\t\t\tif (str[i] > str[i + 1])\n\t\t\t{\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlet smallGreatDgt = -1;\n\t\tfor (let i = len - 1; i > index; i--)\n\t\t{\n\t\t\tif (str[i] < str[index])\n\t\t\t{\n\t\t\t\tif (smallGreatDgt == -1)\n\t\t\t\t{\n\t\t\t\t\tsmallGreatDgt = i;\n\t\t\t\t}\n\t\t\t\telse if (str[i] >= str[smallGreatDgt])\n\t\t\t\t{\n\t\t\t\t\tsmallGreatDgt = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (index == -1)\n\t\t{\n\t\t\treturn \"-1\";\n\t\t}\n\t\tif (smallGreatDgt != -1)\n\t\t{\n\t\t\tstr = swap(str, index, smallGreatDgt);\n\t\t\treturn str;\n\t\t}\n\t\treturn \"-1\";\n\t}\nfunction swap(str, i, j)\n\t{\n\t\tlet ch = str.split('');\n\t\tlet temp = ch[i];\n\t\tch[i] = ch[j];\n\t\tch[j] = temp;\n\t\treturn ch.join(\"\");\n\t}", "12891": "function calculate_sum(a, N)\n{\n\tm = N / a;\n\tsum = m * (m + 1) / 2;\n\tans = a * sum;\n\treturn ans;\n}", "12895": "function horner(poly, n, x)\n{\n\tvar result = poly[0];\n\tfor(var i = 1; i < n; i++)\n\t\tresult = result * x + poly[i];\n\treturn result;\n}\nfunction findSign(poly, n, x)\n{\n\tvar result = horner(poly, n, x);\n\tif (result > 0)\n\t\treturn 1;\n\telse if (result < 0)\n\t\treturn -1;\n\treturn 0;\n}", "12906": "function ispowerof2(num)\n{\n\tif ((num & (num - 1)) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "12970": "function counDivisors(X)\n\t{\n\t\tlet count = 0;\n\t\tfor (let i = 1; i <= X; ++i)\n\t\t{\n\t\t\tif (X % i == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\nfunction countDivisorsMult(arr, n)\n\t{\n\t\tlet mul = 1;\n\t\tfor (let i = 0; i < n; ++i)\n\t\t\tmul *= arr[i];\n\t\treturn counDivisors(mul);\n\t}", "12971": "function SieveOfEratosthenes(largest, prime)\n{\n\tvar isPrime = Array(largest+1).fill(true);\n\tvar p,i;\n\tfor (p = 2; p * p <= largest; p++)\n\t{\n\t\tif (isPrime[p] == true)\n\t\t{\n\t\t\tfor(i = p * 2; i <= largest; i += p)\n\t\t\t\tisPrime[i] = false;\n\t\t}\n\t}\n\tfor (p = 2; p <= largest; p++)\n\t\tif (isPrime[p])\n\t\t\tprime.push(p);\n}\nfunction countDivisorsMult(arr, n)\n{\n\tvar largest = Math.max.apply(null,arr);\n\tvar prime = [];\n\tSieveOfEratosthenes(largest, prime);\n\tvar j;\n\tvar mp = new Map();\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < prime.length; j++)\n\t\t{\n\t\t\twhile(arr[i] > 1 && arr[i]%prime[j] == 0)\n\t\t\t{\n\t\t\t\tarr[i] /= prime[j];\n\t\t\t\tif(mp.has(prime[j]))\n\t\t\t\tmp.set(prime[j],mp.get(prime[j])+1);\n\t\t\t\telse\n\t\t\t\tmp.set(prime[j],1);\n\t\t\t}\n\t\t}\n\t\tif (arr[i] != 1){\n\t\t\tif(mp.has(arr[i]))\n\t\t\t\tmp.set(arr[i],mp.get(arr[i])+1);\n\t\t\t\telse\n\t\t\t\tmp.set(arr[i],1);\n\t\t}\n\t}\n\tvar res = 1;\n\tfor (const [key, value] of mp.entries()) {\n\t\tres *= (value + 1);\n\t}\n\treturn res;\n}", "12983": "function printTaxicab2(N)\n{\n\tlet i = 1; count = 0;\n\twhile (count < N)\n\t{\n\t\tlet int_count = 0;\n\t\tfor (let j = 1; j <= Math.pow(i, 1.0/3); j++)\n\t\t\tfor (let k = j + 1; k <= Math.pow(i, 1.0/3); k++)\n\t\t\t\tif (j * j * j + k * k * k == i)\n\t\t\t\t\tint_count++;\n\t\tif (int_count == 2)\n\t\t{\n\t\t\tcount++;\n\t\t\tdocument.write(count + \" \" + i + \"<br>\");\n\t\t}\n\t\ti++;\n\t}\n}", "12991": "function isComposite(n)\n{\n\tif (n <= 1) return false;\n\tif (n <= 3) return false;\n\tif (n%2 == 0 n%3 == 0) return true;\n\tfor (let i=5; i*i<=n; i=i+6)\n\t\tif (n%i == 0 || n%(i+2) == 0)\n\t\treturn true;\n\treturn false;\n}", "13022": "function area_fun(side)\n{\n let area = side * side;\n return area;\n}", "13040": "function countConsecutive(N)\n\t{\n\t\tlet count = 0;\n\t\tfor (let L = 1; L * (L + 1) < 2 * N; L++)\n\t\t{\n\t\t\tlet a = ((1.0 * N-(L * (L + 1)) / 2) / (L + 1));\n\t\t\tif (a - parseInt(a, 10) == 0.0)\n\t\t\t\tcount++;\t\n\t\t}\n\t\treturn count;\n\t}", "13048": "function isPrime(n)\n\t{\n\t\t\tif (n <= 1)\n\t\t\t\treturn false;\n\t\t\tfor (let i = 2; i < n; i++)\n\t\t\t\tif (n % i == 0)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t}\nfunction findPrime(n)\n\t{\n\t\tlet num = n + 1;\n\t\t\twhile (num > 0)\n\t\t\t\t{\n\t\t\t\t\tif (isPrime(num))\n\t\t\t\t\t\treturn num;\n\t\t\t\t\tnum = num + 1;\n\t\t\t\t}\n\t\t\treturn 0;\n\t}\nfunction minNumber(arr,n)\n\t{\n\t\tlet sum = 0;\n\t\t\tfor (let i = 0; i < n; i++)\n\t\t\t\tsum += arr[i];\n\t\t\tif (isPrime(sum))\n\t\t\t\treturn 0;\n\t\t\tlet num = findPrime(sum);\n\t\t\treturn num - sum;\n\t}", "13049": "function sieveOfEratostheneses()\n{\n\tisPrime[1] = true;\n\tfor (let i = 2; i * i < MAX; i++)\n\t{\n\t\tif (!isPrime[i])\n\t\t{\n\t\t\tfor (let j = 2 * i; j < MAX; j += i)\n\t\t\t\tisPrime[j] = true;\n\t\t}\n\t}\n}\nfunction findPrime(n)\n{\n\tlet num = n + 1;\n\twhile (num > 0)\n\t{\n\t\tif (!isPrime[num])\n\t\t\treturn num;\n\t\tnum = num + 1;\n\t}\n\treturn 0;\n}\nfunction minNumber(arr, n)\n{\n\tsieveOfEratostheneses();\n\tlet sum = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tsum += arr[i];\n\tif (!isPrime[sum])\n\t\treturn 0;\n\tlet num = findPrime(sum);\n\treturn num - sum;\n}", "13140": "function fact(n)\n{\n\tif (n == 0)\n\t\treturn 1;\n\treturn n * fact(n - 1);\n}\nfunction div(x)\n{\n\tlet ans = 0;\n\tfor (let i = 1; i<= x; i++)\n\t\tif (x % i == 0)\n\t\t\tans += i;\n\treturn ans;\n}\nfunction sumFactDiv(n)\n{\n\treturn div(fact(n));\n}", "13141": "function sieve(n)\n{\n\tlet prime = new Array(n + 1);\n\tfor(let i = 0; i < n + 1; i++)\n\t\tprime[i] = true;\n\tfor(let p = 2; p * p <= n; p++)\n\t{\n\t\tif (prime[p] == true)\n\t\t{\n\t\t\tfor(let i = p * 2; i <= n; i += p)\n\t\t\t\tprime[i] = false;\n\t\t}\n\t}\n\tfor(let p = 2; p <= n; p++)\n\t\tif (prime[p])\n\t\t\tallPrimes.push(p);\n}\nfunction factorialDivisors( n)\n{\n\tsieve(n);\n\tlet result = 1;\n\tfor(let i = 0; i < allPrimes.length; i++)\n\t{\n\t\tlet p = allPrimes[i];\n\t\tlet exp = 0;\n\t\twhile (p <= n)\n\t\t{\n\t\t\texp = exp + Math.floor(n/p);\n\t\t\tp = p*allPrimes[i];\n\t\t}\n\t\tresult = Math.floor(result * (Math.pow( allPrimes[i], exp + 1) - 1) /\n\t\t\t\t\t(allPrimes[i] - 1));\n\t}\n\treturn result;\n}", "13144": "function isAutomorphic(N)\n{\n\tlet sq = N * N;\n\twhile (N > 0)\n\t{\n\t\tif (N % 10 != sq % 10)\n\t\t\treturn -1;\n\t\tN /= 10;\n\t\tsq /= 10;\n\t}\n\treturn 1;\n}", "13179": "function checkPandigital(b, n)\n{\n\tif (n.length < b)\n\t\treturn 0;\n\tlet hash = [];\n\tfor(let i = 0; i< b; i++)\n\thash[i] = 0;\n\tfor (let i = 0; i < n.length; i++)\n\t{\n\t\tif (n[i] >= '0' && n[i] <= '9')\n\t\t\thash[n[i] - '0'] = 1;\n\t\telse if (n.charCodeAt(i) - 'A'.charCodeAt(0) <= b - 11)\n\t\t\thash[n.charCodeAt(i) - 'A'.charCodeAt(0) + 10] = 1;\n\t}\n\tfor (let i = 0; i < b; i++)\n\t\tif (hash[i] == 0)\n\t\t\treturn 0;\n\treturn 1;\n}", "13180": "function convert(m , n)\n{\n\tif (m == n)\n\t\treturn 0;\n\tif (m > n)\n\t\treturn m - n;\n\tif (m <= 0 && n > 0)\n\t\treturn -1;\n\tif (n % 2 == 1)\n\t\treturn 1 + convert(m, n + 1);\n\telse\n\t\treturn 1 + convert(m, n / 2);\n}", "13236": "function getDigitProduct(x)\n{\n\tif (x < 10)\n\treturn x;\n\tif (prodDig[x] != 0)\n\treturn prodDig[x];\n\tvar prod = (x % 10) *\n\tgetDigitProduct(parseInt(x/10));\n\treturn (prodDig[x] = prod);\n}\nfunction findSeed(n)\n{\n\tvar res = [];\n\tfor (var i=1; i<=parseInt(n/2); i++)\n\t\tif (i*getDigitProduct(i) == n)\n\t\t\tres.push(i);\n\tif (res.length == 0)\n\t{\n\t\tdocument.write(\"NO seed exists\");\n\t\treturn;\n\t}\n\tfor (i=0; i<res.length; i++)\n\t\tdocument.write(res[i]+\" \");\n}", "13240": "function maxPrimefactorNum(N) {\n\tvar arr = Array.from({length: N + 5}, (_, i) => 0);\n\tfor (i = 2; i * i <= N; i++) {\n\t\tif (arr[i] == 0) {\n\t\t\tfor (j = 2 * i; j <= N; j += i) {\n\t\t\t\tarr[j]++;\n\t\t\t}\n\t\t}\n\t\tarr[i] = 1;\n\t}\n\tvar maxval = 0, maxvar = 1;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (arr[i] > maxval) {\n\t\t\tmaxval = arr[i];\n\t\t\tmaxvar = i;\n\t\t}\n\t}\n\treturn maxvar;\n}", "13241": "function maxPrimefactorNum(N)\n\t{\n\t\tlet arr = new Array(N + 5);\n\t\tarr.fill(false);\n\t\tlet i ;\n\t\tfor (i = 3; i * i <= N; i += 2)\n\t\t{\n\t\t\tif (!arr[i])\n\t\t\t{\n\t\t\t\tfor (let j = i * i; j <= N; j += i)\n\t\t\t\t{\n\t\t\t\t\tarr[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet prime = [];\n\t\tprime.push(2);\n\t\tfor (i = 3; i <= N; i += 2)\n\t\t{\n\t\t\tif (!arr[i])\n\t\t\t{\n\t\t\t\tprime.push(i);\n\t\t\t}\n\t\t}\n\t\tlet ans = 1;\n\t\ti = 0;\n\t\twhile (ans * prime[i] <= N && i < prime.length)\n\t\t{\n\t\t\tans *= prime[i];\n\t\t\ti++;\n\t\t}\n\t\treturn ans;\n\t}", "13250": "function SubArraySum(arr, n)\n{\n\tlet result = 0,temp=0;\n\tfor (let i=0; i <n; i++)\n\t{\n\t\ttemp=0;\n\t\tfor (let j=i; j<n; j++)\n\t\t{\n\t\t\ttemp+=arr[j];\n\t\t\tresult += temp ;\n\t\t}\n\t}\n\treturn result ;\n}", "13251": "function SubArraySum(arr, n)\n{\n\tlet result = 0;\n\tfor(let i = 0; i < n; i++)\n\t\tresult += (arr[i] * (i + 1) *\n\t\t\t\t\t\t\t(n - i));\n\treturn result ;\n}", "13288": "function highestPowerof2(n)\n {\n\tlet res = 0;\n\tfor (let i = n; i >= 1; i--)\n\t\t{\n\t\tif ((i & (i - 1)) == 0)\n\t\t\t{\n\t\t\t\tres = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn res;\n }", "13290": "function highestPowerof2(n)\n\t{\n\t\tlet p = parseInt(Math.log(n) / Math.log(2), 10);\n\t\treturn Math.pow(2, p);\n\t}", "13291": "function highestPowerof2(x)\n{\n\tx |= x >> 1;\n\tx |= x >> 2;\n\tx |= x >> 4;\n\tx |= x >> 8;\n\tx |= x >> 16;\n\treturn x ^ (x >> 1);\n}", "13307": "function aModM(s, mod)\n{\n\tlet number = 0;\n\tfor(let i = 0; i < s.length; i++)\n\t{\n\t\tnumber = (number * 10 );\n\t\tlet x = (s[i] - '0');\n\t\tnumber = number + x;\n\t\tnumber %= mod;\n\t}\n\treturn number;\n}\nfunction ApowBmodM(a, b, m)\n{\n\tlet ans = aModM(a, m);\n\tlet mul = ans;\n\tfor(let i = 1; i < b; i++)\n\t\tans = (ans * mul) % m;\n\treturn ans;\n}", "13352": "function divSum(num)\n{\n\tlet result = 0;\n\tfor (let i=2; i<=Math.sqrt(num); i++)\n\t{\n\t\tif (num%i==0)\n\t\t{\n\t\t\tif (i==(num/i))\n\t\t\t\tresult += i;\n\t\t\telse\n\t\t\t\tresult += (i + num/i);\n\t\t}\n\t}\n\treturn (result + 1);\n}", "13400": "function findPairs(n)\n{\n\tvar cubeRoot = parseInt(Math.pow( n, 1.0 / 3.0));\n\tvar cube = Array.from({length: cubeRoot + 1}, (_, i) => 0);\n\tfor (i = 1; i <= cubeRoot; i++)\n\t\tcube[i] = i * i * i;\n\tvar l = 1;\n\tvar r = cubeRoot;\n\twhile (l < r)\n\t{\n\t\tif (cube[l] + cube[r] < n)\n\t\t\tl++;\n\t\telse if(cube[l] + cube[r] > n)\n\t\t\tr--;\n\t\telse {\n\t\t\tdocument.write(\"(\" + l + \", \" + r + \")<br>\" );\n\t\t\tl++; r--;\n\t\t}\n\t}\n}", "13409": "function gcd(a, b)\n{\n\twhile (b != 0)\n\t{\n\t\tlet t = b;\n\t\tb = a % b;\n\t\ta = t;\n\t}\n\treturn a;\n}\nfunction findMinDiff(a, b, x, y)\n{\n\tlet g = gcd(a,b);\n\tlet diff = Math.abs(x - y) % g;\n\treturn Math.min(diff, g - diff);\n}", "13429": "function printDivisors(n)\n{\n\tlet v = [];\n\tlet t = 0;\n\tfor (let i = 1;\n\t\ti <= parseInt(Math.sqrt(n)); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (parseInt(n / i) == i)\n\t\t\t\tdocument.write(i + \" \");\n\t\t\telse\n\t\t\t{\n\t\t\t\tdocument.write(i + \" \");\n\t\t\t\tv[t++] = parseInt(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (let i = v.length - 1; i >= 0; i--){\n\t\tdocument.write(v[i] + \" \");\n\t}\n}", "13430": "function printDivisors(n)\n{\n\tfor (var i = 1; i*i < n; i++) {\n\t\tif (n % i == 0)\n\t\t\tdocument.write(i + \" \");\n\t}\n\tfor (var i = Math.sqrt(n); i >= 1; i--) {\n\t\tif (n % i == 0)\n\t\t\tdocument.write(\" \" + n / i);\n\t}\n}", "13431": "function printDivisors(n)\n{\n\tfor (i=1;i<=n;i++)\n\t\tif (n%i==0)\n\t\t\tdocument.write(i+ \" \");\n}", "13432": "function printDivisors(n)\n{\n\tfor(let i = 1; i <= Math.sqrt(n); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (parseInt(n / i, 10) == i)\n\t\t\t\tdocument.write(i);\n\t\t\telse\n\t\t\t\tdocument.write(i + \" \" +\n\t\t\t\t\tparseInt(n / i, 10) + \" \");\n\t\t}\n\t}\n}", "13448": "function interpolate(f,xi,n)\n{\n\tfor (let i = 0; i < n; i++)\n\t{\n\t\tlet term = f[i].y;\n\t\tfor (let j = 0; j < n; j++)\n\t\t{\n\t\t\tif (j != i)\n\t\t\t\tterm = term*(xi - f[j].x) / (f[i].x - f[j].x);\n\t\t}\n\t\tresult += term;\n\t}\n\treturn result;\n}", "13453": "function SieveOfAtkin(limit)\n{\n\tif (limit > 2)\n\t\tdocument.write(2 + \" \");\n\tif (limit > 3)\n\t\tdocument.write(3 + \" \");\n\tlet sieve = new Array()\n\tsieve[limit] = 0;\n\tfor (let i = 0; i < limit; i++)\n\t\tsieve[i] = false;\n\tfor (let x = 1; x * x < limit; x++)\n\t{\n\t\tfor (let y = 1; y * y < limit; y++)\n\t\t{\n\t\t\tlet n = (4 * x * x) + (y * y);\n\t\t\tif (n <= limit && (n % 12 == 1 n % 12 == 5))\n\t\t\t\tsieve[n] ^= true;\n\t\t\tn = (3 * x * x) + (y * y);\n\t\t\tif (n <= limit && n % 12 == 7)\n\t\t\t\tsieve[n] = true;\n\t\t\tn = (3 * x * x) - (y * y);\n\t\t\tif (x > y && n <= limit && n % 12 == 11)\n\t\t\t\tsieve[n] ^= true;\n\t\t}\n\t}\n\tfor (let r = 5; r * r < limit; r++) {\n\t\tif (sieve[r]) {\n\t\t\tfor (i = r * r; i < limit; i += r * r)\n\t\t\t\tsieve[i] = false;\n\t\t}\n\t}\n\tfor (let a = 5; a < limit; a++)\n\t\tif (sieve[a])\n\t\t\tdocument.write(a , \" \");\n}", "13454": "function SieveOfSundaram(n)\n{\n\tlet nNew = (n - 1) / 2;\n\tlet marked = [];\n\tfor (let i = 0; i < nNew + 1; i++)\n\tmarked[i] = false;\n\tfor (let i = 1; i <= nNew; i++)\n\tfor (let j = i; (i + j + 2 * i * j) <= nNew; j++)\n\t\tmarked[i + j + 2 * i * j] = true;\n\tif (n > 2)\n\tdocument.write(2 + \" \");\n\tfor (let i = 1; i <= nNew; i++)\n\tif (marked[i] == false)\n\t\tdocument.write(2 * i + 1 + \" \");\n\treturn -1;\n}", "13460": "function power(x,y,p)\n\t{\n\t\twhile (y > 0)\n\t\t{\n\t\t\tif (y %2== 1)\n\t\t\t\tres = (res * x) % p;\n\t\t\tx = (x * x) % p;\n\t\t}\n\t\treturn res;\n\t}\nfunction squareRoot(n, p)\n\t{\n\t\tif (p % 4 != 3)\n\t\t{\n\t\t\tdocument.write(\"Invalid Input\");\n\t\t\treturn;\n\t\t}\n\t\tn = n % p;\n\t\tlet x = power(n, Math.floor((p + 1) / 4), p);\n\t\tif ((x * x) % p == n) {\n\t\t\tdocument.write(\"Square root is \" + x);\n\t\t\treturn;\n\t\t}\n\t\tx = p - x;\n\t\tif ((x * x) % p == n) {\n\t\t\tdocument.write(\"Square root is \" + x);\n\t\t\treturn;\n\t\t}\n\t\tdocument.write(\"Square root doesn't exist \");\n\t}", "13468": "function power(x, y, p)\n{\n\tlet res = 1;\n\tx = x % p;\n\twhile (y > 0)\n\t{\n\t\tif (y & 1)\n\t\t\tres = (res*x) % p;\n\t\tx = (x*x) % p;\n\t}\n\treturn res;\n}\nfunction miillerTest(d, n)\n{\n\tlet a = 2 + Math.floor(Math.random() * (n-2)) % (n - 4);\n\tlet x = power(a, d, n);\n\tif (x == 1 x == n-1)\n\t\treturn true;\n\twhile (d != n-1)\n\t{\n\t\tx = (x * x) % n;\n\t\td *= 2;\n\t\tif (x == 1)\t\n\t\t\treturn false;\n\t\tif (x == n-1)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nfunction isPrime( n, k)\n{\n\tif (n <= 1 n == 4) return false;\n\tif (n <= 3) return true;\n\tlet d = n - 1;\n\twhile (d % 2 == 0)\n\t\td /= 2;\n\tfor (let i = 0; i < k; i++)\n\t\tif (!miillerTest(d, n))\n\t\t\treturn false;\n\treturn true;\n}", "13489": "function isInside(circle_x, circle_y, rad, x, y)\n{\n\tif ((x - circle_x) * (x - circle_x) +\n\t\t(y - circle_y) * (y - circle_y) <= rad * rad)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "13501": "function eval(a,op,b)\n{\n\tif (op == '+')\n\t\t{\n\t\t\treturn a + b;\n\t\t}\n\t\tif (op == '-')\n\t\t{\n\t\t\treturn a - b;\n\t\t}\n\t\tif (op == '*')\n\t\t{\n\t\t\treturn a * b;\n\t\t}\n\t\treturn Number.MAX_VALUE;\n}\nfunction evaluateAll(expr,low,high)\n{\n\t\tlet res = [];\n\t\tif (low == high)\n\t\t{\n\t\t\tres.push(expr[low] - '0');\n\t\t\treturn res;\n\t\t}\n\t\tif (low == (high - 2))\n\t\t{\n\t\t\tlet num = eval(expr[low] - '0', expr[low + 1], expr[low + 2] - '0');\n\t\t\tres.push(num);\n\t\t\treturn res;\n\t\t}\n\t\tfor (let i = low + 1; i <= high; i += 2)\n\t\t{\n\t\t\tlet l = evaluateAll(expr, low, i - 1);\n\t\t\tlet r = evaluateAll(expr, i + 1, high);\n\t\t\tfor (let s1 = 0; s1 < l.length; s1++)\n\t\t\t{\n\t\t\t\tfor (let s2 = 0; s2 < r.length; s2++)\n\t\t\t\t{\n\t\t\t\t\tlet val = eval(l[s1], expr[i], r[s2]);\n\t\t\t\t\tres.push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n}", "13504": "function isLucky(n)\n{\n\tvar arr=Array(10).fill(0);\n\tfor (var i=0; i<10; i++)\n\t\tarr[i] = false;\n\twhile (n > 0)\n\t{\n\t\tvar digit = n%10;\n\t\tif (arr[digit])\n\t\treturn false;\n\t\tarr[digit] = true;\n\t\tn = parseInt(n/10);\n\t}\n\treturn true;\n}", "13535": "function printSquares(n)\n{\n\tlet square = 0, odd = 1;\n\tfor (let x = 0; x < n; x++)\n\t{\n\t\tdocument.write(square + \" \");\n\t\tsquare = square + odd;\n\t\todd = odd + 2;\n\t}\n}", "13575": "function reversDigits(num)\n{\n\tif(num > 0)\n\t{\n\t\treversDigits(Math.floor(num/10));\n\t\trev_num += (num%10)*base_pos;\n\t\tbase_pos *= 10;\n\t}\n\treturn rev_num;\n}", "13606": "function constructArray(A, N, K)\n{\n\tlet B = new Array(N);\n\tlet totalXOR = A[0] ^ K;\n\tfor (let i = 0; i < N; i++)\n\t\tB[i] = totalXOR ^ A[i];\n\tfor (let i = 0; i < N; i++) {\n\t\tdocument.write(B[i] + \" \");\n\t}\n}", "13633": "function RecursiveFunction(ref, bit)\n{\n\tif (ref.length == 0 bit < 0)\n\t\treturn 0;\n\tlet curr_on = [], curr_off = [];\n\tfor (let i = 0; i < ref.length; i++)\n\t{\n\t\tif (((ref[i] >> bit) & 1) == 0)\n\t\t\tcurr_off.push(ref[i]);\n\t\telse\n\t\t\tcurr_on.push(ref[i]);\n\t}\n\tif (curr_off.length == 0)\n\t\treturn RecursiveFunction(curr_on, bit - 1);\n\tif (curr_on.length == 0)\n\t\treturn RecursiveFunction(curr_off, bit - 1);\n\treturn Math.min(RecursiveFunction(curr_off, bit - 1),\n\t\t\tRecursiveFunction(curr_on, bit - 1))\n\t\t+ (1 << bit);\n}\nfunction PrintMinimum(a, n)\n{\n\tlet v = [];\n\tfor (let i = 0; i < n; i++)\n\t\tv.push(a[i]);\n\tdocument.write(RecursiveFunction(v, 30) + \"<br>\");\n}", "13660": "function extraElement(A, B, n)\n{\n\tlet ans = 0;\n\tfor (let i = 0; i < n; i++)\n\t\tans ^= A[i];\n\tfor (let i = 0; i < n + 1; i++)\n\t\tans ^= B[i];\n\treturn ans;\n}", "13671": "function cntElements(arr, n)\n{\n\tlet cnt = 0;\n\tfor (let i = 0; i < n - 2; i++) {\n\t\tif (arr[i] == (arr[i + 1] ^ arr[i + 2]))\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}", "13672": "function xor_triplet(arr, n) {\n\tlet ans = 0;\n\tfor (let i = 0; i < n; i++) {\n\t\tfor (let j = i + 1; j < n; j++) {\n\t\t\tfor (let k = j; k < n; k++) {\n\t\t\t\tlet xor1 = 0, xor2 = 0;\n\t\t\t\tfor (let x = i; x < j; x++) {\n\t\t\t\t\txor1 ^= arr[x];\n\t\t\t\t}\n\t\t\t\tfor (let x = j; x <= k; x++) {\n\t\t\t\t\txor2 ^= arr[x];\n\t\t\t\t}\n\t\t\t\tif (xor1 == xor2) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}", "13684": "function bit_q(i, j) {\n\tlet sum = 0;\n\twhile (j > 0) {\n\t\tsum += bit[j];\n\t\tj -= (j & (j * -1));\n\t}\n\ti--;\n\twhile (i > 0) {\n\t\tsum -= bit[i];\n\t\ti -= (i & (i * -1));\n\t}\n\treturn sum;\n}\nfunction bit_up(i, diff) {\n\twhile (i <= n) {\n\t\tbit[i] += diff;\n\t\ti += i & -i;\n\t}\n}\nfunction dfs(node) {\n\tIdeal_pair += bit_q(Math.max(1, node - k),\n\t\tMath.min(n, node + k));\n\tbit_up(node, 1);\n\tfor (let i = 0; i < al[node].length; i++)\n\t\tdfs(al[node][i]);\n\tbit_up(node, -1);\n}\nfunction initialise() {\n\tIdeal_pair = 0;\n\tfor (let i = 0; i <= n; i++) {\n\t\troot_node[i] = true;\n\t\tbit[i] = 0;\n\t}\n}\nfunction Add_Edge(x, y) {\n\tal[x].push(y);\n\troot_node[y] = false;\n}\nfunction Idealpairs() {\n\tlet r = -1;\n\tfor (let i = 1; i <= n; i++)\n\t\tif (root_node[i]) {\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\tdfs(r);\n\treturn Ideal_pair;\n}", "13757": "function hammingDistance(n1, n2)\n{\n\tlet x = n1 ^ n2;\n\tlet setBits = 0;\n\twhile (x > 0) {\n\t\tsetBits += x & 1;\n\t\tx >>= 1;\n\t}\n\treturn setBits;\n}", "13829": "function printSubsets(n)\n\t{\n\tfor (let i = n; i > 0; i = (i - 1) & n)\n\t\tdocument.write(i + \" \");\n\t\tdocument.write(\" 0 \");\n\t}", "13830": "function printSubsets(n)\n{\n\tfor(let i = n; i > 0; i = (i - 1) & n)\n\t\tdocument.write(i +\" \");\n\t\tdocument.write(\"0\" + \"</br>\");\n}", "13875": "function isDivisibleby17(n)\n{\n\tif (n == 0 n == 17)\n\t\treturn true;\n\tif (n < 17)\n\t\treturn false;\n\treturn isDivisibleby17(Math.floor(n >> 4) - Math.floor(n & 15));\n}", "13876": "function answer(n)\n\t{\n\t\tlet m = 2;\n\t\tlet ans = 1;\n\t\tlet r = 1;\n\t\twhile (r < n) {\n\t\t\tr = (Math.pow(2, m) - 1) *\n\t\t\t\t(Math.pow(2, m - 1));\n\t\t\tif (r < n)\n\t\t\t\tans = r;\n\t\t\tm++;\n\t\t}\n\t\treturn ans;\n\t}", "13897": "function setBitNumber(n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tlet msb = 0;\n\t\tn = n / 2;\n\twhile (n != 0)\n\t{\n\t\tn = $n / 2;\n\t\tmsb++;\n\t}\n\treturn (1 << msb);\n}", "13898": "function setBitNumber(n)\n{\n\tn |= n >> 1;\n\tn |= n >> 2;\n\tn |= n >> 4;\n\tn |= n >> 8;\n\tn |= n >> 16;\n\tn = n + 1;\n\treturn (n >> 1);\n}", "13899": "function setBitNumber(n)\n\t{\n\t\tlet k = parseInt(Math.log(n) / Math.log(2), 10);\n\t\treturn 1 << k;\n\t}", "13966": "function countTrailingZero(x)\n\t{\n\t\tlet count = 0;\n\t\twhile ((x & 1) == 0)\n\t\t{\n\t\t\tx = x >> 1;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}", "13967": "function countTrailingZero(x)\n{\n\tlet lookup = [ 32, 0, 1, 26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11, 0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19, 18 ];\n\treturn lookup[(-x & x) % 37];\n}", "13987": "function maxConsecutiveOnes(x)\n{\n\tlet count = 0;\n\twhile (x != 0)\n\t{\n\t\tx = (x & (x << 1));\n\t\tcount++;\n\t}\n\treturn count;\n}", "14020": "function multiplyBySevenByEight(n)\n{\n\treturn (n - (n>>3));\n}", "14021": "function multiplyBySevenByEight(n)\n{\n\treturn ((n << 3) -n) >> 3;\n}", "14022": "function subtract(x, y)\n{\n\twhile (y != 0)\n\t{\n\t\tlet borrow = (~x) & y;\n\t\tx = x ^ y;\n\t\ty = borrow << 1;\n\t}\n\treturn x;\n}", "14023": "function subtract(x , y)\n{\n\tif (y == 0)\n\t\treturn x;\n\treturn subtract(x ^ y, (~x & y) << 1);\n}"}, "PHP": {"451": "function minCost($cost)\n{\nglobal $INF;\nglobal $N;\n\t$dist[$N]=array();\n\tfor ($i=0; $i<$N; $i++)\n\t$dist[$i] = $INF;\n\t$dist[0] = 0;\n\tfor ($i=0; $i<$N; $i++)\n\tfor ( $j=$i+1; $j<$N; $j++)\n\t\tif ($dist[$j] > $dist[$i] + $cost[$i][$j])\n\t\t\t$dist[$j] = $dist[$i] + $cost[$i][$j];\n\treturn $dist[$N-1];\n}", "455": "function numOfways( $n, $k)\n{\n$p = 1;\nif ($k % 2)\n\t$p = -1;\nreturn (pow($n - 1, $k) +\n\t\t$p * ($n - 1)) / $n;\n}", "496": "function fib($n)\n{\n\tif ($n <= 1)\n\t\treturn $n;\n\treturn fib($n - 1) + fib($n - 2);\n}\nfunction findVertices ($n)\n{\n\treturn fib($n + 2);\n}", "803": "function sortByRow(&$mat, $n, $ascending)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tif ($ascending)\n\t\t\tsort($mat[$i]);\n\t\telse\n\t\t\trsort($mat[$i]);\n\t}\t\n}\nfunction transpose(&$mat, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = $i + 1; $j < $n; $j++)\n\t\t{\n\t\t\t$temp = $mat[$i][$j];\n\t\t\t$mat[$i][$j] = $mat[$j][$i];\n\t\t\t$mat[$j][$i] = $temp;\n\t\t}\n\t}\n}\nfunction sortMatRowAndColWise(&$mat, $n)\n{\n\tsortByRow($mat, $n, true);\n\ttranspose($mat, $n);\n\tsortByRow($mat, $n, false);\n\ttranspose($mat, $n);\n}\nfunction printMat(&$mat, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = 0; $j < $n; $j++)\n\t\t\techo $mat[$i][$j] . \" \";\n\t\techo \"\\n\" ;\n\t}\n}", "815": "function sortByRow(&$mat, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t\tsort($mat[$i]);\n}\nfunction transpose(&$mat, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = $i + 1; $j < $n; $j++)\n\t\t{\n\t\t\t$t = $mat[$i][$j];\n\t\t\t$mat[$i][$j] = $mat[$j][$i];\n\t\t\t$mat[$j][$i] = $t;\n\t\t}\n\t}\n}\nfunction sortMatRowAndColWise(&$mat, $n)\n{\n\tsortByRow($mat, $n);\n\ttranspose($mat, $n);\n\tsortByRow($mat, $n);\n\ttranspose($mat, $n);\n}\nfunction printMat(&$mat, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = 0; $j < $n; $j++)\n\t\t\techo $mat[$i][$j] . \" \";\n\t\techo \"\\n\";\n\t}\n}", "818": "function doublyEven($n)\n{\n\t$arr = array_fill(0, $n,\n\t\tarray_fill(0, $n, 0));\n\tfor ( $i = 0; $i < $n; $i++)\n\t\tfor ( $j = 0; $j < $n; $j++)\n\t\t\t$arr[$i][$j] = ($n * $i) + $j + 1;\n\tfor ($i = 0; $i < $n / 4; $i++)\n\t\tfor ($j = 0; $j < $n / 4; $j++)\n\t\t\t$arr[$i][$j] = ($n * $n + 1) -\n\t\t\t\t\t\t\t$arr[$i][$j];\n\tfor ($i = 0; $i < $n / 4; $i++)\n\t\tfor ($j = 3 * ($n / 4); $j < $n; $j++)\n\t\t\t$arr[$i][$j] = ($n * $n + 1) -\n\t\t\t\t\t\t\t$arr[$i][$j];\n\tfor ($i = 3 * $n / 4; $i < $n; $i++)\n\t\tfor ($j = 0; $j < $n / 4; $j++)\n\t\t\t$arr[$i][$j] = ($n * $n + 1) -\n\t\t\t\t\t\t\t$arr[$i][$j];\n\tfor ($i = 3 * $n / 4; $i < $n; $i++)\n\t\tfor ($j = 3 * $n / 4; $j < $n; $j++)\n\t\t\t$arr[$i][$j] = ($n * $n + 1) -\n\t\t\t\t\t\t\t$arr[$i][$j];\n\tfor ($i = $n / 4; $i < 3 * $n / 4; $i++)\n\t\tfor ($j = $n / 4; $j < 3 * $n / 4; $j++)\n\t\t\t$arr[$i][$j] = ($n * $n + 1) -\n\t\t\t\t\t\t\t$arr[$i][$j];\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = 0; $j < $n; $j++)\n\t\t\techo $arr[$i][$j] . \" \";\n\t\techo \"\\n\";\n\t}\n}", "821": "function Kroneckerproduct($A, $B)\n{\n\tglobal $cola;\n\tglobal $rowa;\n\tglobal $colb;\n\tglobal $rowb;\n\t$C;\n\tfor ( $i = 0; $i < $rowa; $i++)\n\t{\n\t\tfor ($k = 0; $k < $rowb; $k++)\n\t\t{\n\t\t\tfor ( $j = 0; $j < $cola; $j++) \n\t\t\t{\n\t\t\t\tfor ($l = 0; $l < $colb; $l++)\n\t\t\t\t{\n\t\t\t\t\t$C[$i + $l + 1][$j + $k + 1] = $A[$i][$j] *\n\t\t\t\t\t\t\t\t\t\t\t\t$B[$k][$l];\n\t\t\t\t\techo ($C[$i + $l + 1][$j + $k + 1]), \"\\t\" ;\n\t\t\t\t}\n\t\t\t}\n\t\techo \"\\n\";\n\t\t}\n\t}\n}", "832": "function isLowerTriangularMatrix($mat)\n{\n\tglobal $N;\n\tfor ($i = 0; $i < $N; $i++)\n\t\tfor ($j = $i + 1; $j < $N; $j++)\n\t\t\tif ($mat[$i][$j] != 0)\n\t\t\t\treturn false;\n\treturn true;\n}", "833": "function isUpperTriangularMatrix($mat)\n{\n\tglobal $N;\n\tfor ($i = 1; $i < $N; $i++)\n\t\tfor ($j = 0; $j < $i; $j++)\n\t\t\tif ($mat[$i][$j] != 0)\n\t\t\t\treturn false;\n\treturn true;\n}", "846": "function countSets($a)\n{\n\tglobal $m, $n;\n\t$res = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$u = 0; $v = 0;\n\t\tfor ( $j = 0; $j < $m; $j++)\n\t\t\t$a[$i][$j] ? $u++ : $v++;\t\n\t\t$res += pow(2, $u) - 1 + pow(2, $v) - 1;\n\t}\n\tfor ($i = 0; $i < $m; $i++)\n\t{\n\t\t$u = 0;$v = 0;\n\t\tfor ($j = 0; $j < $n; $j++)\n\t\t\t$a[$j][$i] ? $u++ : $v++;\n\t\t$res += pow(2, $u) - 1 +\n\t\t\t\tpow(2, $v) - 1;\n\t}\n\treturn $res-($n*$m);\n}", "861": "", "862": "function isSymmetric($mat, $N)\n{\n\tfor ($i = 0; $i < $N; $i++)\n\t\tfor ($j = 0; $j < $N; $j++)\n\t\t\tif ($mat[$i][$j] != $mat[$j][$i])\n\t\t\t\treturn false;\n\treturn true;\n}", "883": "function findNormal($mat, $n)\n{\n\t$sum = 0;\n\tfor ( $i = 0; $i < $n; $i++)\n\t\tfor ( $j = 0; $j < $n; $j++)\n\t\t\t$sum += $mat[$i][$j] *\n\t\t\t\t\t$mat[$i][$j];\n\treturn floor(sqrt($sum));\n}\nfunction findTrace( $mat, $n)\n{\n\t$sum = 0;\n\tfor ( $i = 0; $i < $n; $i++)\n\t\t$sum += $mat[$i][$i];\n\treturn $sum;\n}", "895": "function maxDet($n)\n{\n\treturn (2 * $n * $n * $n);\n}\nfunction resMatrix ( $n)\n{\n\tfor ($i = 0; $i < 3; $i++)\n\t{\n\t\tfor ($j = 0; $j < 3; $j++)\n\t\t{\n\t\t\tif ($i == 0 && $j == 2)\n\t\t\t\techo \"0 \";\n\t\t\telse if ($i == 1 && $j == 0)\n\t\t\t\techo \"0 \";\n\t\t\telse if ($i == 2 && $j == 1)\n\t\t\t\techo \"0 \";\n\t\t\telse\n\t\t\t\techo $n , \" \";\n\t\t}\n\techo \"\\n\";\n\t}\n}", "918": "function countNegative($M, $n, $m)\n{\n\t$count = 0;\n\tfor( $i = 0; $i < $n; $i++)\n\t{\n\t\tfor( $j = 0; $j < $m; $j++)\n\t\t{\n\t\t\tif( $M[$i][$j] < 0 )\n\t\t\t\t$count += 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn $count;\n}", "919": "function countNegative( $M, $n, $m)\n{\n\t$count = 0;\n\t$i = 0;\n\t$j = $m - 1;\n\twhile( $j >= 0 and $i < $n )\n\t{\n\t\tif( $M[$i][$j] < 0 )\n\t\t{\n\t\t\t$count += $j + 1;\n\t\t\t$i += 1;\n\t\t}\n\t\telse\n\t\t$j -= 1;\n\t}\n\treturn $count;\n}", "926": "function findMaxValue(&$mat)\n{\n\tglobal $N;\n\t$maxValue = PHP_INT_MIN;\n\tfor ($a = 0; $a < $N - 1; $a++)\n\tfor ($b = 0; $b < $N - 1; $b++)\n\t\tfor ($d = $a + 1; $d < $N; $d++)\n\t\tfor ($e = $b + 1; $e < $N; $e++)\n\t\t\tif ($maxValue < ($mat[$d][$e] - $mat[$a][$b]))\n\t\t\t\t$maxValue = $mat[$d][$e] -\n\t\t\t\t\t\t\t$mat[$a][$b];\n\treturn $maxValue;\n}", "927": "function findMaxValue($mat)\n{\n\tglobal $N;\n\t$maxValue = PHP_INT_MIN;\n\t$maxArr[$N][$N] = array();\n\t$maxArr[$N - 1][$N - 1] = $mat[$N - 1][$N - 1];\n$maxv = $mat[$N - 1][$N - 1]; \n\tfor ($j = $N - 2; $j >= 0; $j--)\n\t{\n\t\tif ($mat[$N - 1][$j] > $maxv)\n\t\t\t$maxv = $mat[$N - 1][$j];\n\t\t$maxArr[$N - 1][$j] = $maxv;\n\t}\n$maxv = $mat[$N - 1][$N - 1]; \n\tfor ($i = $N - 2; $i >= 0; $i--)\n\t{\n\t\tif ($mat[$i][$N - 1] > $maxv)\n\t\t\t$maxv = $mat[$i][$N - 1];\n\t\t$maxArr[$i][$N - 1] = $maxv;\n\t}\n\tfor ($i = $N - 2; $i >= 0; $i--)\n\t{\n\t\tfor ($j = $N - 2; $j >= 0; $j--)\n\t\t{\n\t\t\tif ($maxArr[$i + 1][$j + 1] - $mat[$i][$j] > $maxValue)\n\t\t\t\t$maxValue = $maxArr[$i + 1][$j + 1] -\n\t\t\t\t\t\t\t$mat[$i][$j];\n\t\t\t$maxArr[$i][$j] = max($mat[$i][$j],\n\t\t\t\t\t\t\tmax($maxArr[$i][$j + 1], $maxArr[$i + 1][$j]));\n\t\t}\n\t}\n\treturn $maxValue;\n}", "955": "function printSumSimple( $mat, $k)\n{\n\tglobal $n;\n\tif ($k > $n) return;\n\tfor($i = 0; $i < $n - $k + 1; $i++)\n\t{\n\t\tfor($j = 0; $j < $n - $k + 1; $j++)\n\t\t{\n\t\t\t$sum = 0;\n\t\t\tfor ($p = $i; $p < $k + $i; $p++)\n\t\t\t\tfor ($q = $j; $q < $k + $j; $q++)\n\t\t\t\t\t$sum += $mat[$p][$q];\n\t\t\techo $sum , \" \";\n\t\t}\n\t\techo \"\\n\";\n\t}\n}", "956": "function printSumTricky($mat, $k)\n{\nglobal $n;\nif ($k > $n) return;\n$stripSum = array(array());\nfor ($j = 0; $j < $n; $j++)\n{\n\t$sum = 0;\n\tfor ($i = 0; $i < $k; $i++)\n\t\t$sum += $mat[$i][$j];\n\t$stripSum[0][$j] = $sum;\n\tfor ($i = 1; $i < $n - $k + 1; $i++)\n\t{\n\t\t\t$sum += ($mat[$i + $k - 1][$j] - $mat[$i - 1][$j]);\n\t\t\t$stripSum[$i][$j] = $sum;\n\t}\n}\nfor ($i = 0; $i < $n - $k + 1; $i++)\n{\n\t$sum = 0;\n\tfor ($j = 0; $j < $k; $j++)\n\t\t$sum += $stripSum[$i][$j];\n\techo $sum , \" \";\n\tfor ($j = 1; $j < $n - $k + 1; $j++)\n\t{\n\t\t$sum += ($stripSum[$i][$j + $k - 1] - $stripSum[$i][$j - 1]);\n\t\techo $sum , \" \";\n\t}\n\techo \"\\n\";\n}\n}", "958": "function transpose(&$A, &$B)\n{\n\tfor ($i = 0; $i < $N; $i++)\n\t\tfor ($j = 0; $j < $M; $j++)\n\t\t\t$B[$i][$j] = $A[$j][$i];\n}", "959": "function transpose(&$A)\n{\n\tfor ($i = 0; $i < $N; $i++)\n\t\tfor ($j = $i + 1; $j < $N; $j++)\n\t\t\t{\n\t\t\t\t$temp = $A[$i][$j];\n\t\t\t\t$A[$i][$j] = $A[$j][$i];\n\t\t\t\t$A[$j][$i] = $temp;\n\t\t\t}\n}", "965": "function pathCountRec( $mat, $m, $n, $k)\n{\n\tif ($m < 0 or $n < 0)\n\t\treturn 0;\n\tif ($m == 0 and $n == 0)\n\t\treturn ($k == $mat[$m][$n]);\n\treturn pathCountRec($mat, $m - 1, $n, $k - $mat[$m][$n])\n\t\t\t+ pathCountRec($mat, $m, $n - 1, $k - $mat[$m][$n]);\n}\nfunction pathCount($mat, $k)\n{\n\tglobal $R, $C;\n\treturn pathCountRec($mat, $R-1, $C-1, $k);\n}", "1072": "function PrintMinNumberForPattern($arr)\n{\n\t$curr_max = 0;\n\t$last_entry = 0;\n\t$j;\n\tfor ($i = 0; $i < strlen($arr); $i++)\n\t{\n\t\t$noOfNextD = 0;\n\t\tswitch($arr[$i])\n\t\t{\n\t\tcase 'I':\n\t\t\t$j = $i + 1;\n\t\t\twhile ($arr[$j] == 'D' &&\n\t\t\t\t$j < strlen($arr))\n\t\t\t{\n\t\t\t\t$noOfNextD++;\n\t\t\t\t$j++;\n\t\t\t}\n\t\t\tif ($i == 0)\n\t\t\t{\n\t\t\t\t$curr_max = $noOfNextD + 2;\n\t\t\t\techo \" \" , ++$last_entry;\n\t\t\t\techo \" \" , $curr_max;\n\t\t\t\t$last_entry = $curr_max;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$curr_max = $curr_max +\n\t\t\t\t\t\t\t$noOfNextD + 1;\n\t\t\t\t$last_entry = $curr_max;\n\t\t\t\techo \" \" , $last_entry;\n\t\t\t}\n\t\t\tfor ($k = 0; $k < $noOfNextD; $k++)\n\t\t\t{\n\t\t\t\techo \" \" , --$last_entry;\n\t\t\t\t$i++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif ($i == 0)\n\t\t\t{\n\t\t\t\t$j = $i+1;\n\t\t\t\twhile (($arr[$j] == 'D') &&\n\t\t\t\t\t($j < strlen($arr)))\n\t\t\t\t{\n\t\t\t\t\t$noOfNextD++;\n\t\t\t\t\t$j++;\n\t\t\t\t}\n\t\t\t\t$curr_max = $noOfNextD + 2;\n\t\t\t\techo \" \" , $curr_max ,\n\t\t\t\t\t\" \" ,$curr_max - 1;\n\t\t\t\t$last_entry = $curr_max - 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\techo \" \" , $last_entry - 1;\n\t\t\t\t$last_entry--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\necho \"\\n\";\n}", "1252": "function subset($ar, $n)\n{\n\t$res = 0;\n\tsort($ar);\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$count = 1;\n\t\tfor (; $i < $n - 1; $i++)\n\t\t{\n\t\t\tif ($ar[$i] == $ar[$i + 1])\n\t\t\t\t$count++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t$res = max($res, $count);\n\t}\n\treturn $res;\n}", "1344": "function areElementsContiguous($arr, $n)\n{\n\tsort($arr);\n\tfor ($i = 1; $i < $n; $i++)\n\t\tif ($arr[$i] - $arr[$i - 1] > 1)\n\t\t\treturn false;\n\treturn true;\n}", "1405": "function findLargestd( $S, $n)\n{\n$found = false;\n\tsort($S);\n\tfor ( $i = $n - 1; $i >= 0; $i--)\n\t{\n\t\tfor ( $j = 0; $j < $n; $j++)\n\t\t{\n\t\t\tif ($i == $j)\n\t\t\t\tcontinue;\n\t\t\tfor ( $k = $j + 1; $k < $n; $k++)\n\t\t\t{\n\t\t\t\tif ($i == $k)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor ( $l = $k + 1; $l < $n; $l++)\n\t\t\t\t{\n\t\t\t\t\tif ($i == $l)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ($S[$i] == $S[$j] + $S[$k] + $S[$l])\n\t\t\t\t\t{\n\t\t\t\t\t\t$found = true;\n\t\t\t\t\t\treturn $S[$i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ($found == false)\n\t\treturn PHP_INT_MIN;\n}", "1428": "function leftRotatebyOne(&$arr, $n)\n{\n\t$temp = $arr[0];\n\tfor ($i = 0; $i < $n - 1; $i++)\n\t\t$arr[$i] = $arr[$i + 1];\n\t$arr[$n-1] = $temp;\n}\nfunction leftRotate(&$arr, $d, $n)\n{\n\tfor ($i = 0; $i < $d; $i++)\n\t\tleftRotatebyOne($arr, $n);\n}\nfunction printArray(&$arr, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t\techo $arr[$i] . \" \";\n}", "1468": "function pushZerosToEnd(&$arr, $n)\n{\n\t$count = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\tif ($arr[$i] != 0)\n\t\t\t$arr[$count++] = $arr[$i];\n\twhile ($count < $n)\n\t\t$arr[$count++] = 0;\n}", "1478": "function printArray($arr, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t\techo($arr[$i] . \" \");\n}\nfunction RearrangePosNeg(&$arr, $n)\n{\n\t$key; $j;\n\tfor($i = 1; $i < $n; $i++)\n\t{\n\t\t$key = $arr[$i];\n\t\tif ($key > 0)\n\t\t\tcontinue;\n\t\t$j = $i - 1;\n\t\twhile ($j >= 0 && $arr[$j] > 0)\n\t\t{\n\t\t\t$arr[$j + 1] = $arr[$j];\n\t\t\t$j = $j - 1;\n\t\t}\n\t\t$arr[$j + 1] = $key;\n\t}\n}", "1515": "function findElements($arr, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$count = 0;\n\t\tfor ($j = 0; $j < $n; $j++)\n\t\t\tif ($arr[$j] > $arr[$i])\n\t\t\t\t$count++;\n\t\tif ($count >= 2)\n\t\t\techo $arr[$i].\" \";\n\t}\n}", "1516": "function findElements( $arr, $n)\n{\n\tsort($arr);\n\tfor ($i = 0; $i < $n - 2; $i++)\n\techo $arr[$i] , \" \";\n}", "1517": "function findElements($arr, $n)\n{\n\t$first = PHP_INT_MIN;\n\t$second = PHP_INT_MIN;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t\tif ($arr[$i] > $first)\n\t\t\t{\n\t\t\t\t$second = $first;\n\t\t\t\t$first = $arr[$i];\n\t\t\t}\n\t\telse if ($arr[$i] > $second)\n\t\t\t$second = $arr[$i];\n\t}\n\tfor($i = 0; $i < $n; $i++)\n\t\tif ($arr[$i] < $second)\n\t\t\techo $arr[$i] , \" \";\n}", "1535": "function findFirstMissing($array, $start, $end)\n{\n\tif ($start > $end)\n\t\treturn $end + 1;\n\tif ($start != $array[$start])\n\t\treturn $start;\n\t$mid = ($start + $end) / 2;\n\tif ($array[$mid] == $mid)\n\t\treturn findFirstMissing($array, $mid + 1, $end);\n\treturn findFirstMissing($array, $start, $mid);\n}", "1537": "function FindMaxSum($arr, $n)\n{\n\t$incl = $arr[0];\n\t$excl = 0;\n\t$excl_new;\n\t$i;\nfor ($i = 1; $i <$n; $i++)\n{\n\t$excl_new = ($incl > $excl)? $incl: $excl;\n\t$incl = $excl + $arr[$i];\n\t$excl = $excl_new;\n}\nreturn (($incl > $excl)? $incl : $excl);\n}", "1590": "function findMaxAverage($arr, $n, $k)\n{\n\tif ($k > $n)\n\t\treturn -1;\n\t$csum = array();\n\t$csum[0] = $arr[0];\n\tfor($i = 1; $i < $n; $i++)\n\t$csum[$i] = $csum[$i - 1] +\n\t\t\t\t$arr[$i];\n\t$max_sum = $csum[$k - 1];\n\t$max_end = $k - 1;\n\tfor($i = $k; $i < $n; $i++)\n\t{\n\t\t$curr_sum = $csum[$i] -\n\t\t\t\t\t$csum[$i - $k];\n\t\tif ($curr_sum > $max_sum)\n\t\t{\n\t\t\t$max_sum = $curr_sum;\n\t\t\t$max_end = $i;\n\t\t}\n\t}\n\treturn $max_end - $k + 1;\n}", "1591": "function findMaxAverage($arr, $n, $k)\n{\n\tif ($k > $n)\n\t\treturn -1;\n\t$sum = $arr[0];\n\tfor($i = 1; $i < $k; $i++)\n\t\t$sum += $arr[$i];\n\t$max_sum = $sum;\n\t$max_end = $k-1;\n\tfor($i = $k; $i < $n; $i++)\n\t{\n\t\t$sum = $sum + $arr[$i] -\n\t\t\t\t$arr[$i - $k];\n\t\tif ($sum > $max_sum)\n\t\t{\n\t\t\t$max_sum = $sum;\n\t\t\t$max_end = $i;\n\t\t}\n\t}\n\treturn $max_end - $k + 1;\n}", "1694": "function isMajority($arr, $n, $x)\n{\n\t$i;\n\t$last_index = $n % 2? ($n / 2 + 1): ($n / 2);\n\tfor ($i = 0; $i < $last_index; $i++)\n\t{\n\t\tif ($arr[$i] == $x && $arr[$i + $n / 2] == $x)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "1795": "function selection_sort(&$arr, $n) \n{\n\tfor($i = 0; $i < $n ; $i++)\n\t{\n\t\t$low = $i;\n\t\tfor($j = $i + 1; $j < $n ; $j++)\n\t\t{\n\t\t\tif ($arr[$j] < $arr[$low])\n\t\t\t{\n\t\t\t\t$low = $j;\n\t\t\t}\n\t\t}\n\t\tif ($arr[$i] > $arr[$low])\n\t\t{\n\t\t\t$tmp = $arr[$i];\n\t\t\t$arr[$i] = $arr[$low];\n\t\t\t$arr[$low] = $tmp;\n\t\t}\n\t}\n}", "1797": "function bubbleSort(&$arr)\n{\n\t$n = sizeof($arr);\n\tfor($i = 0; $i < $n; $i++)\n\t{\n\t\t$swapped = False;\n\t\tfor ($j = 0; $j < $n - $i - 1; $j++)\n\t\t{\n\t\t\tif ($arr[$j] > $arr[$j+1])\n\t\t\t{\n\t\t\t\t$t = $arr[$j];\n\t\t\t\t$arr[$j] = $arr[$j+1];\n\t\t\t\t$arr[$j+1] = $t;\n\t\t\t\t$swapped = True;\n\t\t\t}\n\t\t}\n\t\tif ($swapped == False)\n\t\t\tbreak;\n\t}\n}", "1813": "function findCrossOver($arr, $low, $high, $x)\n{\n\tif ($arr[$high] <= $x)\n\t\treturn $high;\n\tif ($arr[$low] > $x)\n\t\treturn $low;\n\t\t$mid = ($low + $high)/2;\n\tif ($arr[$mid] <= $x and $arr[$mid + 1] > $x)\n\t\treturn $mid;\n\tif($arr[$mid] < $x)\n\t\treturn findCrossOver($arr, $mid + 1, $high, $x);\n\treturn findCrossOver($arr, $low, $mid - 1, $x);\n}\nfunction printKclosest($arr, $x, $k, $n)\n{\n\t$l = findCrossOver($arr, 0, $n - 1, $x);\n\t$r = $l + 1;\n\t$count = 0;\n\tif ($arr[$l] == $x) $l--;\n\twhile ($l >= 0 and $r < $n and $count < $k)\n\t{\n\t\tif ($x - $arr[$l] < $arr[$r] - $x)\n\t\t\techo $arr[$l--],\" \";\n\t\telse\n\t\t\techo $arr[$r++],\" \";\n\t\t$count++;\n\t}\n\twhile ($count < $k and $l >= 0)\n\t\techo $arr[$l--],\" \"; $count++;\n\twhile ($count < $k and $r < $n)\n\t\techo $arr[$r++]; $count++;\n}", "1847": "function coun($S, $m, $n)\n{\n\tif ($n == 0)\n\t\treturn 1;\n\tif ($n < 0)\n\t\treturn 0;\n\tif ($m <= 0 && $n >= 1)\n\t\treturn 0;\n\treturn coun($S, $m - 1,$n ) +\n\t\tcoun($S, $m, $n - $S[$m - 1] );\n}", "1849": "function count_1( &$S, $m, $n )\n{\n\t$table = array_fill(0, $n + 1, NULl);\n\t$table[0] = 1;\n\tfor($i = 0; $i < $m; $i++)\n\t\tfor($j = $S[$i]; $j <= $n; $j++)\n\t\t\t$table[$j] += $table[$j - $S[$i]];\n\treturn $table[$n];\n}", "1853": "function MatrixChainOrder($p, $n)\n{\n\t$m[][] = array($n, $n);\n\tfor ($i = 1; $i < $n; $i++)\n\t\t$m[$i][$i] = 0;\n\tfor ($L = 2; $L < $n; $L++)\n\t{\n\t\tfor ($i = 1; $i < $n - $L + 1; $i++)\n\t\t{\n\t\t\t$j = $i + $L - 1;\n\t\t\tif($j == $n)\n\t\t\t\tcontinue;\n\t\t\t$m[$i][$j] = PHP_INT_MAX;\n\t\t\tfor ($k = $i; $k <= $j - 1; $k++)\n\t\t\t{\n\t\t\t\t$q = $m[$i][$k] + $m[$k + 1][$j] +\n\t\t\t\t\t$p[$i - 1] * $p[$k] * $p[$j];\n\t\t\t\tif ($q < $m[$i][$j])\n\t\t\t\t\t$m[$i][$j] = $q;\n\t\t\t}\n\t\t}\n\t}\n\treturn $m[1][$n-1];\n}", "1869": "function cutRod( $price, $n)\n{\n\tif ($n <= 0)\n\t\treturn 0;\n\t$max_val = PHP_INT_MIN;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t\t$max_val = max($max_val, $price[$i] +\n\t\t\t\t\tcutRod($price, $n - $i - 1));\n\treturn $max_val;\n}", "1870": "function cutRod( $price, $n)\n{\n\t$val = array();\n\t$val[0] = 0;\n\t$i; $j;\n\tfor ($i = 1; $i <= $n; $i++)\n\t{\n\t\t$max_val = PHP_INT_MIN;\n\t\tfor ($j = 0; $j < $i; $j++)\n\t\t\t$max_val = max($max_val, $price[$j] + $val[$i-$j-1]);\n\t\t$val[$i] = $max_val;\n\t}\n\treturn $val[$n];\n}", "1998": "function multiply($x, $y)\n{\nif($y == 0)\n\treturn 0;\nif($y > 0 )\n\treturn ($x + multiply($x, $y - 1));\nif($y < 0 )\n\treturn -multiply($x, -$y);\n}", "2013": "function SieveOfEratosthenes($n)\n{\n\t$prime = array_fill(0, $n+1, true);\n\tfor ($p = 2; $p*$p <= $n; $p++)\n\t{\n\t\tif ($prime[$p] == true)\n\t\t{\n\t\t\tfor ($i = $p*$p; $i <= $n; $i += $p)\n\t\t\t\t$prime[$i] = false;\n\t\t}\n\t}\n\tfor ($p = 2; $p <= $n; $p++)\n\t\tif ($prime[$p])\n\t\t\techo $p.\" \";\n}", "2024": "function binomialCoeff($n, $k)\n{\n\t$res = 1;\n\tif ($k > $n - $k)\n\t$k = $n - $k;\n\tfor ($i = 0; $i < $k; ++$i)\n\t{\n\t\t$res *= ($n - $i);\n\t\t$res /= ($i + 1);\n\t}\nreturn $res;\n}\nfunction printPascal($n)\n{\n\tfor ($line = 0; $line < $n; $line++)\n\t{\n\t\tfor ($i = 0; $i <= $line; $i++)\n\t\t\t\techo \"\".binomialCoeff($line, $i).\" \";\n\t\techo \"\\n\";\n\t}\n}", "2025": "function printPascal($n)\n{\n\t$arr = array(array());\n\tfor ($line = 0; $line < $n; $line++)\n\t{\n\t\tfor ($i = 0; $i <= $line; $i++)\n\t\t{\n\t\t\tif ($line == $i $i == 0)\n\t\t\t\t$arr[$line][$i] = 1;\n\t\t\telse\n\t\t\t\t$arr[$line][$i] = $arr[$line - 1][$i - 1] +\n\t\t\t\t\t\t\t\t$arr[$line - 1][$i];\n\t\t\techo $arr[$line][$i] . \" \";\n\t\t}\n\t\techo \"\\n\";\n\t}\n}", "2026": "function printPascal($n)\n{\n\tfor($line = 1; $line <= $n; $line++)\n\t{\n$C = 1;\n\t\tfor($i = 1; $i <= $line; $i++)\n\t\t{\n\t\t\tprint($C . \" \");\n\t\t\t$C = $C * ($line - $i) / $i;\n\t\t}\n\t\tprint(\"\\n\");\n\t}\n}", "2079": "function Add( $x, $y)\n{\n\twhile ($y != 0)\n\t{\n\t\t$carry = $x & $y;\n\t\t$x = $x ^ $y;\n\t\t$y = $carry << 1;\n\t}\n\treturn $x;\n}", "2101": "function getModulo($n, $d)\n{\nreturn ( $n & ($d - 1) );\n}", "2114": "function countSetBits($n)\n{\n\t$count = 0;\n\twhile ($n)\n\t{\n\t\t$count += $n & 1;\n\t\t$n >>= 1;\n\t}\n\treturn $count;\n}", "2117": "function countSetBits($n)\n{\n\tif ($n == 0)\n\t\treturn 0;\n\telse\n\t\treturn 1 +\n\t\tcountSetBits($n &\n\t\t\t\t\t($n - 1));\n}", "2119": "", "2120": "function countSetBitsRec( $num)\n{\n\tglobal $num_to_bits;\n\t$nibble = 0;\n\tif (0 == $num)\n\t\treturn $num_to_bits[0];\n\t$nibble = $num & 0xf;\n\treturn $num_to_bits[$nibble] +\n\t\tcountSetBitsRec($num >> 4);\n}", "2127": "function getParity( $n)\n{\n\t$parity = 0;\n\twhile ($n)\n\t{\n\t\t$parity = !$parity;\n\t\t$n = $n & ($n - 1);\n\t}\n\treturn $parity;\n}", "2129": "function Log2($x)\n{\n\treturn (log10($x) /\n\t\t\tlog10(2));\n}\nfunction isPowerOfTwo($n)\n{\n\treturn (ceil(Log2($n)) ==\n\t\t\tfloor(Log2($n)));\n}", "2130": "function isPowerOfTwo($n)\n{\nif ($n == 0)\n\treturn 0;\nwhile ($n != 1)\n{\n\tif ($n % 2 != 0)\n\t\treturn 0;\n\t$n = $n / 2;\n}\nreturn 1;\n}", "2132": "function isPowerOfTwo ($x)\n{\nreturn $x && (!($x & ($x - 1)));\n}", "2210": "function maxRepeating($arr, $n, $k)\n{\n\tfor ($i = 0; $i< $n; $i++)\n\t\t$arr[$arr[$i] % $k] += $k;\n\t\t$max = $arr[0];\n\t\t$result = 0;\n\tfor ($i = 1; $i < $n; $i++)\n\t{\n\t\tif ($arr[$i] > $max)\n\t\t{\n\t\t\t$max = $arr[$i];\n\t\t\t$result = $i;\n\t\t}\n\t}\n\treturn $result;\n}", "2226": "function fun($x)\n{\n\t$y = ((int)($x / 4) * 4);\n\t$ans = 0;\n\tfor ($i = $y; $i <= $x; $i++)\n\t\t$ans ^= $i;\n\treturn $ans;\n}\nfunction query($x)\n{\n\tif ($x == 0)\n\t\treturn 0;\n\t$k = (int)(($x + 1) / 2);\n\treturn ($x %= 2) ? 2 * fun($k) :\n\t((fun($k - 1) * 2) ^ ($k & 1));\n}\nfunction allQueries($q, $l, $r)\n{\n\tfor ($i = 0; $i < $q; $i++)\n\t\techo (query($r[$i]) ^\n\t\t\tquery($l[$i] - 1)) , \"\\n\";\n}", "2258": "function findMinSwaps($arr, $n)\n{\n\t$noOfZeroes[$n] = array();\n\t$noOfZeroes = array_fill(0, $n, true);\n\t$count = 0;\n\t$noOfZeroes[$n - 1] = 1 - $arr[$n - 1];\n\tfor ($i = $n - 2; $i >= 0; $i--)\n\t{\n\t\t$noOfZeroes[$i] = $noOfZeroes[$i + 1];\n\t\tif ($arr[$i] == 0)\n\t\t\t$noOfZeroes[$i]++;\n\t}\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tif ($arr[$i] == 1)\n\t\t\t$count += $noOfZeroes[$i];\n\t}\n\treturn $count;\n}", "2308": "function printTwoOdd($arr, $size)\n{\n\t$xor2 = $arr[0];\n\t$set_bit_no;\n\t$i;\n\t$n = $size - 2;\n\t$x = 0;$y = 0;\n\tfor($i = 1; $i < $size; $i++)\n\t\t$xor2 = $xor2 ^ $arr[$i];\n\t$set_bit_no = $xor2 & ~($xor2-1);\n\tfor($i = 0; $i < $size; $i++)\n\t{\n\t\tif($arr[$i] & $set_bit_no)\n\t\t$x = $x ^ $arr[$i];\n\t\telse\n\t\t$y = $y ^ $arr[$i];\n\t}\n\techo \"The two ODD elements are \", $x, \" & \", $y;\n\t}", "2310": "function findPair(&$arr, $size, $n)\n{\n\t$i = 0;\n\t$j = 1;\n\twhile ($i < $size && $j < $size)\n\t{\n\t\tif ($i != $j && $arr[$j] - $arr[$i] == $n)\n\t\t{\n\t\t\techo \"Pair Found: \" . \"(\" . $arr[$i] . \", \" . $arr[$j] . \")\";\n\t\t\treturn true;\n\t\t}\n\t\telse if ($arr[$j] - $arr[$i] < $n)\n\t\t\t$j++;\n\t\telse\n\t\t\t$i++;\n\t}\n\techo \"No such pair\";\n\treturn false;\n}", "2379": "function checkIsAP($arr, $n)\n{\n\tif ($n == 1)\n\t\treturn true;\n\tsort($arr);\n\t$d = $arr[1] - $arr[0];\n\tfor ($i = 2; $i < $n; $i++)\n\t\tif ($arr[$i] - $arr[$i - 1] != $d)\n\t\treturn false;\n\treturn true;\n}", "2382": "function countPairs($a, $n)\n{\n\t$mn = PHP_INT_MAX;\n\t$mx = PHP_INT_MIN;\n\tfor ($i = 0; $i < $n; $i++) {\n\t\t$mn = min($mn, $a[$i]);\n\t\t$mx = max($mx, $a[$i]);\n\t}\n\t$c1 = 0;\n$c2 = 0; \n\tfor ($i = 0; $i < $n; $i++) {\n\t\tif ($a[$i] == $mn)\n\t\t\t$c1++;\n\t\tif ($a[$i] == $mx)\n\t\t\t$c2++;\n\t}\n\tif ($mn == $mx)\n\t\treturn $n * ($n - 1) / 2;\n\telse\n\t\treturn $c1 * $c2;\n}", "2847": "function findNumbers($arr, $n)\n{\n\t$sumN = ($n * ($n + 1)) / 2;\n\t$sumSqN = ($n * ($n + 1) *\n\t\t\t\t(2 * $n + 1)) / 6;\n\t$sum = 0 ;\n\t$sumSq = 0 ;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$sum += $arr[$i];\n\t\t$sumSq += pow($arr[$i], 2);\n\t}\n\t$B = ((($sumSq - $sumSqN) / ($sum - $sumN)) + $sumN - $sum) / 2;\n\t$A = $sum - $sumN + $B;\n\techo \"A = \", $A, \"\\nB = \", $B;\n}", "3871": "function countLessThan(&$arr, $n, $key)\n{\n\t$l = 0;\n\t$r = $n - 1;\n\t$index = -1;\n\twhile ($l <= $r)\n\t{\n\t\t$m = intval(($l + $r) / 2);\n\t\tif ($arr[$m] < $key)\n\t\t{\n\t\t\t$l = $m + 1;\n\t\t\t$index = $m;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$r = $m - 1;\n\t\t}\n\t}\n\treturn ($index + 1);\n}\nfunction countGreaterThan(&$arr, $n, $key)\n{\n\t$l = 0;\n\t$r = $n - 1;\n\t$index = -1;\n\twhile ($l <= $r)\n\t{\n\t\t$m = intval(($l + $r) / 2);\n\t\tif ($arr[$m] <= $key)\n\t\t{\n\t\t\t$l = $m + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$r = $m - 1;\n\t\t\t$index = $m;\n\t\t}\n\t}\n\tif ($index == -1)\n\t\treturn 0;\n\treturn ($n - $index);\n}\nfunction countTriplets($n, &$a, &$b, &$c)\n{\n\tsort($a);\n\tsort($b);\n\tsort($c);\n\t$count = 0;\n\tfor ($i = 0; $i < $n; ++$i)\n\t{\n\t\t$current = $b[$i];\n\t\t$a_index = -1;\n\t\t$c_index = -1;\n\t\t$low = countLessThan($a, $n, $current);\n\t\t$high = countGreaterThan($c, $n, $current);\n\t\t$count += ($low * $high);\n\t}\n\treturn $count;\n}", "3885": "function Printksubstring($str, $n, $k)\n{\n\t$total = floor(($n * ($n + 1)) / 2);\n\tif ($k > $total)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\t$substring = array();\n\t$substring[0] = 0;\n\t$temp = $n;\n\tfor ($i = 1; $i <= $n; $i++)\n\t{\n\t\t$substring[$i] = $substring[$i - 1] + $temp;\n\t\t$temp--;\n\t}\n\t$l = 1;\n\t$h = $n;\n\t$start = 0;\n\twhile ($l <= $h)\n\t{\n\t\t$m = floor(($l + $h) / 2);\n\t\tif ($substring[$m] > $k)\n\t\t{\n\t\t\t$start = $m;\n\t\t\t$h = $m - 1;\n\t\t}\n\t\telse if ($substring[$m] < $k)\n\t\t\t$l = $m + 1;\n\t\telse\n\t\t{\n\t\t\t$start = $m;\n\t\t\tbreak;\n\t\t}\n\t}\n\t$end = $n - ($substring[$start] - $k);\n\tfor ($i = $start - 1; $i < $end; $i++)\n\t\tprint($str[$i]);\n}", "3932": "function LowerInsertionPoint($arr, $n, $X)\n{\n\tif ($X < $arr[0])\n\t\treturn 0;\n\telse if ($X > $arr[$n - 1])\n\t\treturn $n;\n\t$lowerPnt = 0;\n\t$i = 1;\n\twhile ($i < $n && $arr[$i] < $X)\n\t{\n\t\t$lowerPnt = $i;\n\t\t$i = $i * 2;\n\t}\n\twhile ($lowerPnt < $n && $arr[$lowerPnt] < $X)\n\t\t$lowerPnt++;\n\treturn $lowerPnt;\n}", "4039": "function getCount( $M, $N)\n{\n\t$count = 0;\n\tif ($M == 1)\n\t\treturn $N;\n\tif ($N == 1)\n\t\treturn $M;\n\tif ($N > $M)\n\t{\n\t\tfor($i = 1; $i <= $M; $i++)\n\t\t{\n\t\t\t$numerator = $N * $i - $N + $M - $i;\n\t\t\t$denominator = $M - 1;\n\t\t\tif ($numerator % $denominator == 0)\n\t\t\t{\n\t\t\t\t$j = $numerator / $denominator;\n\t\t\t\tif ($j >= 1 and $j <= $N)\n\t\t\t\t\t$count++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor ( $j = 1; $j <= $N; $j++)\n\t\t{\n\t\t\t$numerator = $M * $j - $M + $N - $j;\n\t\t\t$denominator = $N - 1;\n\t\t\tif ($numerator % $denominator == 0)\n\t\t\t{\n\t\t\t\t$i = $numerator / $denominator;\n\t\t\t\tif ($i >= 1 and $i <= $M)\n\t\t\t\t\t$count++;\n\t\t\t}\n\t\t}\n\t}\n\treturn $count;\n}", "4079": "function middleOfThree($a, $b, $c)\n{\n\tif (($a < $b && $b < $c) or\n\t\t($c < $b && $b < $a))\n\treturn $b;\n\telse if (($b < $a and $a < $c) or\n\t\t\t($c < $a and $a < $b))\n\treturn $a;\n\telse\n\treturn $c;\n}", "4080": "function middleOfThree( $a, $b, $c)\n{\n\tif ($a > $b)\n\t{\n\t\tif ($b > $c)\n\t\t\treturn $b;\n\t\telse if ($a > $c)\n\t\t\treturn $c;\n\t\telse\n\t\t\treturn $a;\n\t}\n\telse\n\t{\n\t\tif ($a > $c)\n\t\t\treturn $a;\n\t\telse if ($b > $c)\n\t\t\treturn $c;\n\t\telse\n\t\t\treturn $b;\n\t}\n}", "4081": "function middleOfThree($a, $b, $c)\n{\n\t$x = $a - $b;\n\t$y = $b - $c;\n\t$z = $a - $c;\n\tif ($x * $y > 0)\n\t\treturn $b;\n\telse if ($x * $z > 0)\n\t\treturn $c;\n\telse\n\t\treturn $a;\n}", "4099": "function missing4($arr, $n)\n{\n\t$helper = array(0, 0, 0, 0);\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$temp = abs($arr[$i]);\n\t\tif ($temp <= $n)\n\t\t\t$arr[$temp - 1] = $arr[$temp - 1] * (-1);\n\t\telse if ($temp > $n)\n\t\t{\n\t\t\tif ($temp % $n != 0)\n\t\t\t\t$helper[$temp % $n - 1] = -1;\n\t\t\telse\n\t\t\t\t$helper[($temp % $n) + $n - 1] = -1;\n\t\t}\n\t}\n\tfor ($i = 0; $i < $n; $i++)\n\t\tif ($arr[$i] > 0)\n\t\t{\n\t\t\t$a = $i + 1;\n\t\t\techo \"$a\", \" \";\n\t\t}\n\tfor ($i = 0; $i < 4; $i++)\n\t\tif ($helper[$i] >= 0)\n\t\t{\n\t\t\t$b = $n + $i + 1;\n\t\t\techo \"$b\", \" \";\n\t\t}\n\t\techo \"\\n\";\n\treturn;\n}", "4578": "function printArr($arr, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t\techo $arr[$i];\n}\nfunction compare($num1, $num2)\n{\n\t$A = (string)$num1 ;\n\t$B = (string)$num2 ;\n\tif((int)($A . $B) <= (int)($B . $A))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\nfunction sort_arr($arr)\n{\n\tfor ($i = 0; $i < count($arr) ; $i++)\n\t{\n\t\tfor ($j = $i + 1;$j < count($arr) ; $j++)\n\t\t{\n\t\t\tif (compare($arr[$i], $arr[$j]) == false)\n\t\t\t{\n\t\t\t\t$temp = $arr[$i] ;\n\t\t\t\t$arr[$i] = $arr[$j] ;\n\t\t\t\t$arr[$j] = $temp ;\n\t\t\t}\n\t\t}\n\t}\n\t\treturn $arr ;\n\t}\nfunction printSmallest($N, $arr)\n{\n\t$arr = sort_arr($arr);\n\tprintArr($arr, $N);\n}", "4585": "function getMaxMedian($arr, $n, $k)\n{\n\t$size = $n + $k;\n\tsort($arr, $n);\n\tif ($size % 2 == 0)\n\t{\n\t\t$median = (float)($arr[($size / 2) - 1] + $arr[$size / 2]) / 2;\n\t\treturn $median;\n\t}\n\t$median = $arr[$size / 2];\n\treturn $median;\n}", "4620": "function partSort( $arr, $N, $a, $b)\n{\n\t$l = min($a, $b);\n\t$r = max($a, $b);\n\t$temp = array();\n\t$j = 0;\n\tfor ($i = $l; $i <= $r; $i++) {\n\t\t$temp[$j] = $arr[$i];\n\t\t$j++;\n\t}\n\tsort($temp);\n\t$j = 0;\n\tfor ($i = $l; $i <= $r; $i++) {\n\t\t\t$arr[$i] = $temp[$j];\n\t\t\t$j++;\n\t}\n\tfor ($i = 0; $i < $N; $i++) {\n\t\t\techo $arr[$i].\" \" ;\n\t\t}\n}", "4622": "function minMovesToSort($arr, $n)\n{\n\t$moves = 0;\n\t$mn = $arr[$n - 1];\n\tfor ($i = $n - 2; $i >= 0; $i--)\n\t{\n\t\tif ($arr[$i] > $mn)\n\t\t\t$moves += $arr[$i] - $mn;\n\t}\n\treturn $moves;\n}", "4701": "function findOptimalPairs($arr, $N)\n{\n\tsort($arr);\n\tfor ($i = 0, $j = $N - 1; $i <= $j; $i++, $j--)\n\t\t\techo \"(\", $arr[$i], \", \", $arr[$j], \")\", \" \";\n}", "4783": "function printSorted($a, $b, $c)\n{\n\t$get_max = max($a, max($b, $c));\n\t$get_min = -max(-$a, max(-$b, -$c));\n\t$get_mid = ($a + $b + $c) -\n\t\t\t($get_max + $get_min);\n\techo $get_min , \" \" , $get_mid, \" \" , $get_max;\n}", "4786": "function insertionSortRecursive(&$arr, $n)\n\t{\n\t\tif ($n <= 1)\n\t\t\treturn;\n\t\tinsertionSortRecursive($arr, $n - 1);\n\t\t$last = $arr[$n - 1];\n\t\t$j = $n - 2;\n\t\twhile ($j >= 0 && $arr[$j] > $last)\n\t\t{\n\t\t\t$arr[$j + 1] = $arr[$j];\n\t\t\t$j--;\n\t\t}\n\t\t$arr[$j + 1] = $last;\n\t}\nfunction printArray(&$arr, $n)\n\t{\n\t\tfor ($i = 0; $i < $n; $i++)\n\t\t\techo $arr[$i].\" \";\n\t}", "4804": "function isPossible( $a, $b, $n, $k)\n{\n\tsort($a);\n\trsort($b);\n\tfor ( $i = 0; $i < $n; $i++)\n\t\tif ($a[$i] + $b[$i] < $k)\n\t\t\treturn false;\n\treturn true;\n}", "4855": "function insertionSort(&$arr, $n)\n{\n\tfor ($i = 1; $i < $n; $i++)\n\t{\n\t\t$key = $arr[$i];\n\t\t$j = $i-1;\n\t\twhile ($j >= 0 && $arr[$j] > $key)\n\t\t{\n\t\t\t$arr[$j + 1] = $arr[$j];\n\t\t\t$j = $j - 1;\n\t\t}\n\t\t$arr[$j + 1] = $key;\n\t}\n}\nfunction printArray(&$arr, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t\techo $arr[$i].\" \";\n\techo \"\\n\";\n}", "5636": "function minOperations($arr, $n)\n{\n\t$result = 0;\n\t$freq = array();\n\tfor($i = 0; $i < $n; $i++)\n\t{\n\t\t$freq[$arr[$i]] = 0;\n\t}\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$x = $arr[$i];\n\t\t$freq[$x]++;\n\t}\n\t$maxi = max($arr);\n\tfor ($i = 1; $i <= $maxi; $i++)\n\t{\n\t\tif ($freq[$i] != 0)\n\t\t{\n\t\t\tfor ($j = $i * 2; $j <= $maxi; $j = $j + $i)\n\t\t\t{\n\t\t\t\t$freq[$j] = 0;\n\t\t\t}\n\t\t\t$result++;\n\t\t}\n\t}\n\treturn $result;\n}", "5675": "function encryptString($str, $n)\n{\n\t$i = 0 ;\n\t$cnt = 0;\n\t$encryptedStr = \"\";\n\twhile ($i < $n)\n\t{\n\t\t$cnt = $i + 1;\n\t\twhile ($cnt--)\n\t\t\t$encryptedStr .= $str[$i];\n\t\t$i++;\n\t}\n\treturn $encryptedStr;\n}", "5676": "function __gcd($a, $b)\n{\n\tif ($a == 0)\n\t\treturn $b;\n\treturn __gcd($b % $a, $a);\n}\nfunction minGCD($arr, $n)\n{\n\t$minGCD = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$minGCD = __gcd($minGCD, $arr[$i]);\n\treturn $minGCD;\n}\nfunction minLCM($arr, $n)\n{\n\t$minLCM = $arr[0];\n\tfor ($i = 1; $i < $n; $i++)\n\t\t$minLCM = min($minLCM, $arr[$i]);\n\treturn $minLCM;\n}", "5687": "function formStringMinOperations($s)\n{\n\t$count = array_fill(0, 3, 0);\n\tfor ($i = 0; $i < strlen($s) ; $i++)\n\t\t$count[$s[$i] - '0']++;\n\t$processed = array_fill(0, 3, 0);\n\t$reqd = floor(strlen($s) / 3);\n\tfor ($i = 0; $i < strlen($s); $i++)\n\t{\n\t\tif ($count[$s[$i] - '0'] == $reqd)\n\t\t\tcontinue;\n\t\tif ($s[$i] == '0' && $count[0] > $reqd && $processed[0] >= $reqd)\n\t\t{\n\t\t\tif ($count[1] < $reqd)\n\t\t\t{\n\t\t\t\t$s[$i] = '1';\n\t\t\t\t$count[1]++;\n\t\t\t\t$count[0]--;\n\t\t\t}\n\t\t\telse if ($count[2] < $reqd)\n\t\t\t{\n\t\t\t\t$s[$i] = '2';\n\t\t\t\t$count[2]++;\n\t\t\t\t$count[0]--;\n\t\t\t}\n\t\t}\n\t\tif ($s[$i] == '1' && $count[1] > $reqd)\n\t\t{\n\t\t\tif ($count[0] < $reqd)\n\t\t\t{\n\t\t\t\t$s[$i] = '0';\n\t\t\t\t$count[0]++;\n\t\t\t\t$count[1]--;\n\t\t\t}\n\t\t\telse if (count[2] < $reqd && $processed[1] >= $reqd)\n\t\t\t{\n\t\t\t\t$s[$i] = '2';\n\t\t\t\t$count[2]++;\n\t\t\t\t$count[1]--;\n\t\t\t}\n\t\t}\n\t\tif ($s[$i] == '2' && $count[2] > $reqd)\n\t\t{\n\t\t\tif ($count[0] < $reqd)\n\t\t\t{\n\t\t\t\t$s[$i] = '0';\n\t\t\t\t$count[0]++;\n\t\t\t\t$count[2]--;\n\t\t\t}\n\t\t\telse if ($count[1] < $reqd)\n\t\t\t{\n\t\t\t\t$s[$i] = '1';\n\t\t\t\t$count[1]++;\n\t\t\t\t$count[2]--;\n\t\t\t}\n\t\t}\n\t\t$processed[$s[$i] - '0']++;\n\t}\n\treturn $s;\n}", "5730": "function minDiff($n, $x, $A)\n{\n\t$mn = $A[0];\n\t$mx = $A[0];\n\tfor ($i = 0; $i < $n; ++$i) {\n\t\t$mn = min($mn, $A[$i]);\n\t\t$mx = max($mx, $A[$i]);\n\t}\n\treturn max(0, $mx - $mn - 2 * $x);\n}", "5739": "", "5742": "function isWaveArray( $arr, $n)\n{\n\t$result = true;\n\tif ($arr[1] > $arr[0] && $arr[1] > $arr[2])\n\t{\n\t\tfor ( $i = 1; $i < ($n - 1); $i += 2)\n\t\t{\n\t\t\tif ($arr[$i] > $arr[$i - 1] && $arr[$i] > $arr[$i + 1])\n\t\t\t{\n\t\t\t\t$result = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$result = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ($result == true && $n % 2 == 0)\n\t\t{\n\t\t\tif ($arr[$n - 1] <= $arr[$n - 2])\n\t\t\t{\n\t\t\t\t$result = false;\n\t\t\t}\n\t\t}\n\t}\n\telse if ($arr[1] < $arr[0] && $arr[1] < $arr[2])\n\t{\n\t\tfor ($i = 1; $i < $n - 1; $i += 2)\n\t\t{\n\t\t\tif ($arr[$i] < $arr[$i - 1] && $arr[$i] < $arr[$i + 1])\n\t\t\t{\n\t\t\t\t$result = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$result = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ($result == true && $n % 2 == 0)\n\t\t{\n\t\t\tif ($arr[$n - 1] >= $arr[$n - 2])\n\t\t\t{\n\t\t\t\t$result = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn $result;\n}", "6454": "function pre_process($dp, $s)\n{\n\t$n = strlen($s);\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = 0; $j < $n; $j++)\n\t\t\t$dp[$i][$j] = false;\n\t}\n\tfor ($j = 1; $j <= $n; $j++)\n\t{\n\t\tfor ($i = 0; $i <= $n - $j; $i++)\n\t\t{\n\t\t\tif ($j <= 2)\n\t\t\t{\n\t\t\t\tif ($s[$i] == $s[$i + $j - 1])\n\t\t\t\t\t$dp[$i][$i + $j - 1] = true;\n\t\t\t}\n\t\t\telse if ($s[$i] == $s[$i + $j - 1])\n\t\t\t\t$dp[$i][$i + $j - 1] = $dp[$i + 1][$i + $j - 2];\n\t\t}\n\t}\n\treturn $dp;\n}\nfunction countPairs($s)\n{\n\t$dp = array(array());\n\t$dp = pre_process($dp, $s);\n\t$n = strlen($s);\n\t$left = array_fill(0, $n, 0);\n\t$right = array_fill(0, $n, 0);\n\t$left[0] = 1;\n\tfor ($i = 1; $i < $n; $i++)\n\t{\n\t\tfor ($j = 0; $j <= $i; $j++)\n\t\t{\n\t\t\tif ($dp[$j][$i] == 1)\n\t\t\t\t$left[$i]++;\n\t\t}\n\t}\n\t$right[$n - 1] = 1;\n\tfor ($i = $n - 2; $i >= 0; $i--)\n\t{\n\t\t$right[$i] = $right[$i + 1];\n\t\tfor ($j = $n - 1; $j >= $i; $j--)\n\t\t{\n\t\t\tif ($dp[$i][$j] == 1)\n\t\t\t\t$right[$i]++;\n\t\t}\n\t}\n\t$ans = 0;\n\tfor ($i = 0; $i < $n - 1; $i++)\n\t\t$ans += $left[$i] * $right[$i + 1];\n\treturn $ans;\n}", "6469": "function FindMaximumSum($ind, $kon, $a, $b, $c, $n, $dp)\n{\n\tglobal $N;\n\tif ($ind == $n)\n\t\treturn 0;\n\tif ($dp[$ind][$kon] != -1)\n\t\treturn $dp[$ind][$kon];\n\t$ans = -1e9 + 5;\n\tif ($kon == 0)\n\t{\n\t\t$ans = max($ans, $b[$ind] +\n\t\t\t\tFindMaximumSum($ind + 1, 1, $a, $b, $c, $n, $dp));\n\t\t$ans = max($ans, $c[$ind] +\n\t\t\t\tFindMaximumSum($ind + 1, 2, $a, $b, $c, $n, $dp));\n\t}\n\telse if ($kon == 1)\n\t{\n\t\t$ans = max($ans, $a[$ind] +\n\t\t\t\tFindMaximumSum($ind + 1, 0, $a, $b, $c, $n, $dp));\n\t\t$ans = max($ans, $c[$ind] +\n\t\t\t\tFindMaximumSum($ind + 1, 2, $a, $b, $c, $n, $dp));\n\t}\n\telse if ($kon == 2)\n\t{\n\t\t$ans = max($ans, $a[$ind] +\n\t\t\t\tFindMaximumSum($ind + 1, 1, $a, $b, $c, $n, $dp));\n\t\t$ans = max($ans, $b[$ind] +\n\t\t\t\tFindMaximumSum($ind + 1, 0, $a, $b, $c, $n, $dp));\n\t}\n\treturn $dp[$ind][$kon] = $ans;\n}", "6471": "function noOfBinaryStrings($N, $k)\n{\n\tglobal $mod;\n\t$dp = array(0, 100002, NULL);\n\tfor ($i = 1; $i <= $k - 1; $i++)\n\t{\n\t\t$dp[$i] = 1;\n\t}\n\t$dp[$k] = 2;\n\tfor ($i = $k + 1; $i <= $N; $i++)\n\t{\n\t\t$dp[$i] = ($dp[$i - 1] + $dp[$i - $k]) % $mod;\n\t}\n\treturn $dp[$N];\n}", "6478": "function findWaysToPair($p)\n{\n\t$dp = array();\n\t$dp[1] = 1;\n\t$dp[2] = 2;\n\tfor ($i = 3; $i <= $p; $i++)\n\t{\n\t\t$dp[$i] = $dp[$i - 1] +\n\t\t\t\t\t($i - 1) * $dp[$i - 2];\n\t}\n\treturn $dp[$p];\n}", "6531": "function sumOddFibonacci($n)\n{\n\tglobal $mod;\n\t$Sum[$n + 1] = array();\n\t$Sum[0] = 0;\n\t$Sum[1] = 1;\n\t$Sum[2] = 2;\n\t$Sum[3] = 5;\n\t$Sum[4] = 10;\n\t$Sum[5] = 23;\n\tfor ($i = 6; $i <= $n; $i++)\n\t{\n\t\t$Sum[$i] = (($Sum[$i - 1] +\n\t\t\t\t\t(4 * $Sum[$i - 2]) % $mod -\n\t\t\t\t\t(4 * $Sum[$i - 3]) % $mod + $mod) % $mod + ($Sum[$i - 4] - $Sum[$i - 5] + $mod) % $mod) % $mod;\n\t}\n\treturn $Sum[$n];\n}", "6536": "function CountWays($n)\n{\n\tif ($n == 0) {\n\t\treturn 1;\n\t}\n\tif ($n == 1) {\n\t\treturn 1;\n\t}\n\tif ($n == 2) {\n\t\treturn 1 + 1;\n\t}\n\treturn CountWays($n - 1) + CountWays($n - 3);\n}", "6554": "function partitions($n)\n{\n\t$p = array_fill(0, $n + 1, 0);\n\t$p[0] = 1;\n\tfor ($i = 1; $i < $n + 1; $i++)\n\t{\n\t\t$k = 1;\n\t\twhile (($k * (3 * $k - 1)) / 2 <= $i)\n\t\t{\n\t\t\t$p[$i] += (($k % 2 ? 1 : -1) *\n\t\t\t\t\t\t$p[$i - ($k * (3 * $k - 1)) / 2]);\n\t\t\tif ($k > 0)\n\t\t\t\t$k *= -1;\n\t\t\telse\n\t\t\t\t$k = 1 - $k;\n\t\t}\n\t}\n\treturn $p[$n];\n}", "6589": "function solve($N, $K)\n{\n\t$combo[$N + 1] = array();\n\t$combo[0] = 1;\n\tfor ($i = 1; $i <= $K; $i++)\n\t{\n\t\tfor ($j = 0; $j <= $N; $j++)\n\t\t{\n\t\t\tif ($j >= $i)\n\t\t\t{\n\t\t\t\t$combo[$j] += $combo[$j - $i];\n\t\t\t}\n\t\t}\n\t}\n\treturn $combo[$N];\n}", "6679": "function maxSubArraySumRepeated($a, $n, $k)\n{\n\t$INT_MIN=0;\n\t$max_so_far = $INT_MIN; $max_ending_here = 0;\n\tfor ($i = 0; $i < $n*$k; $i++)\n\t{\n\t\t$max_ending_here = $max_ending_here +\n\t\t\t\t\t\t\t\t$a[$i % $n];\n\t\tif ($max_so_far < $max_ending_here)\n\t\t\t$max_so_far = $max_ending_here;\n\t\tif ($max_ending_here < 0)\n\t\t\t$max_ending_here = 0;\n\t}\n\treturn $max_so_far;\n}", "6712": "function longOddEvenIncSeq(&$arr, $n)\n{\n\t$lioes= array_fill(0, $n, NULL);\n\t$maxLen = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$lioes[$i] = 1;\n\tfor ($i = 1; $i < $n; $i++)\n\t\tfor ($j = 0; $j < $i; $j++)\n\t\t\tif ($arr[$i] > $arr[$j] &&\n\t\t\t($arr[$i] + $arr[$j]) % 2 != 0 && $lioes[$i] < $lioes[$j] + 1)\n\t\t\t\t$lioes[$i] = $lioes[$j] + 1;\n\tfor ($i = 0; $i < $n; $i++)\n\t\tif ($maxLen < $lioes[$i])\n\t\t\t$maxLen = $lioes[$i];\n\treturn $maxLen;\n}", "6787": "function computeLIS($circBuff, $start, $end, $n)\n{\n\t$LIS = Array();\n\tfor ($i = $start; $i < $end; $i++)\n\t\t$LIS[$i] = 1;\n\tfor ($i = $start + 1; $i < $end; $i++)\n\t\tfor ( $j = $start; $j < $i; $j++ )\n\t\t\tif ($circBuff[$i] > $circBuff[$j] && $LIS[$i] < $LIS[$j] + 1)\n\t\t\t\t$LIS[$i] = $LIS[$j] + 1;\n\t$res = PHP_INT_MIN;\n\tfor ($i = $start; $i < $end; $i++)\n\t\t$res = max($res, $LIS[$i]);\n\treturn $res;\n}\nfunction LICS($arr, $n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$circBuff[$i] = $arr[$i];\n\tfor ($i = $n; $i < 2 * $n; $i++)\n\t\t$circBuff[$i] = $arr[$i - $n];\n\t$res = PHP_INT_MIN;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$res = max(computeLIS($circBuff, $i, $i + $n, $n), $res);\n\treturn $res;\n}", "6791": "function countPaths($n, $m)\n{\n\tif ($n == 0 $m == 0)\n\t\treturn 1;\n\treturn (countPaths($n - 1, $m) + \n\t\t\tcountPaths($n, $m - 1));\n}", "6792": "function countPaths($n, $m)\n{\n\tfor ($i = 0; $i <= $n; $i++)\n\t\t$dp[$i][0] = 1;\n\tfor ($i = 0; $i <= $m; $i++)\n\t\t$dp[0][$i] = 1;\n\tfor ($i = 1; $i <= $n; $i++)\n\tfor ($j = 1; $j <= $m; $j++)\n\t\t$dp[$i][$j] = $dp[$i - 1][$j] + \n\t\t\t\t\t$dp[$i][$j - 1];\n\treturn $dp[$n][$m];\n}", "6848": "function getMaxGold($gold, $m, $n)\n{\n\t$MAX = 100 ;\n\t$goldTable = array(array());\n\tfor ($i = 0; $i < $m ; $i ++)\n\t\tfor($j = 0; $j < $n ; $j ++)\n\t\t\t$goldTable[$i][$j] = 0 ;\n\tfor ($col = $n - 1; $col >= 0 ; $col--)\n\t{\n\t\tfor ($row = 0 ; $row < $m ; $row++)\n\t\t{\n\t\t\tif ($col == $n - 1)\n\t\t\t\t$right = 0 ;\n\t\t\telse\n\t\t\t\t$right = $goldTable[$row][$col + 1];\n\t\t\tif ($row == 0 or $col == $n - 1)\n\t\t\t\t$right_up = 0 ;\n\t\t\telse\n\t\t\t\t$right_up = $goldTable[$row - 1][$col + 1];\n\t\t\tif ($row == $m - 1 or $col == $n - 1)\n\t\t\t\t$right_down = 0 ;\n\t\t\telse\n\t\t\t\t$right_down = $goldTable[$row + 1][$col + 1];\n\t\t\t$goldTable[$row][$col] = $gold[$row][$col] +\n\t\t\t\t\t\t\t\tmax($right, $right_up, $right_down);\n\t\t}\n\t}\n\t$res = $goldTable[0][0] ;\n\tfor ($i = 0; $i < $m; $i++)\n\t\t$res = max($res, $goldTable[$i][0]);\n\treturn $res;\n}", "6933": "function minAdjustmentCost( $A, $n, $target)\n{\n\tglobal $M;\n\t$dp = array(array());\n\tfor($j = 0; $j <= $M; $j++)\n\t\t$dp[0][$j] = abs($j - $A[0]);\n\tfor($i = 1; $i < $n; $i++)\n\t{\n\t\tfor($j = 0; $j <= $M; $j++)\n\t\t{\n\t\t\t$dp[$i][$j] = PHP_INT_MAX;\n\t\t\tfor($k = max($j - $target, 0);\n\t\t\t\t$k <= min($M, $j + $target); $k++)\n\t\t\t\t$dp[$i][$j] = min($dp[$i][$j],\n\t\t\t\t\t\t\t$dp[$i - 1][$k] +\n\t\t\t\t\t\t\tabs($A[$i] - $j));\n\t\t}\n\t}\n\t$res = PHP_INT_MAX;\n\tfor($j = 0; $j <= $M; $j++)\n\t\t$res = min($res, $dp[$n - 1][$j]);\n\treturn $res;\n}", "6944": "function LCIS($arr1, $n, $arr2, $m)\n{\n\t$table = Array();\n\tfor ($j = 0; $j < $m; $j++)\n\t\t$table[$j] = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$current = 0;\n\t\tfor ($j = 0; $j < $m; $j++)\n\t\t{\n\t\t\tif ($arr1[$i] == $arr2[$j])\n\t\t\t\tif ($current + 1 > $table[$j])\n\t\t\t\t\t$table[$j] = $current + 1;\n\t\t\tif ($arr1[$i] > $arr2[$j])\n\t\t\t\tif ($table[$j] > $current)\n\t\t\t\t\t$current = $table[$j];\n\t\t}\n\t}\n\t$result = 0;\n\tfor ($i = 0; $i < $m; $i++)\n\t\tif ($table[$i] > $result)\n\t\t$result = $table[$i];\n\treturn $result;\n}", "7051": "function cutRod( $price, $n)\n{\n\t$val = array();\n\t$val[0] = 0;\n\t$i; $j;\n\tfor ($i = 1; $i <= $n; $i++)\n\t{\n\t\t$max_val = PHP_INT_MIN;\n\t\tfor ($j = 0; $j < $i; $j++)\n\t\t\t$max_val = max($max_val, $price[$j] + $val[$i-$j-1]);\n\t\t$val[$i] = $max_val;\n\t}\n\treturn $val[$n];\n}", "7068": "function MatrixChainOrder(&$p, $i, $j)\n{\n\tif($i == $j)\n\t\treturn 0;\n\t$min = PHP_INT_MAX;\n\tfor ($k = $i; $k < $j; $k++)\n\t{\n\t\t$count = MatrixChainOrder($p, $i, $k) +\n\t\t\t\tMatrixChainOrder($p, $k + 1, $j) +\n\t\t\t\t\t\t\t\t$p[$i - 1] *\n\t\t\t\t\t\t\t\t$p[$k] * $p[$j];\n\t\tif ($count < $min)\n\t\t\t$min = $count;\n\t}\n\treturn $min;\n}", "7071": "function coun($S, $m, $n)\n{\n\tif ($n == 0)\n\t\treturn 1;\n\tif ($n < 0)\n\t\treturn 0;\n\tif ($m <= 0 && $n >= 1)\n\t\treturn 0;\n\treturn coun($S, $m - 1,$n ) +\n\t\tcoun($S, $m, $n - $S[$m - 1] );\n}", "7276": "function getCount($a, $b)\n{\n\tif(strlen($b) % strlen($a) != 0)\n\t\treturn -1;\n\t$count = floor(strlen($b) / strlen($a));\n\t$str = \"\";\n\tfor($i = 0; $i < $count; $i++)\n\t{\n\t\t$str = $str . $a ;\n\t}\n\tif(strcmp($a,$b))\n\t\treturn $count;\n\treturn -1;\n}", "7309": "function countPattern($str)\n{\n\t$len = strlen($str);\n\t$oneSeen = 0;\n\tfor ($i = 0; $i < $len ; $i++)\n\t{\n\t\tif ($str[$i] == '1' && $oneSeen == 1)\n\t\t\tif ($str[$i - 1] == '0')\n\t\t\t\t$count++;\n\t\tif ($str[$i] == '1' && $oneSeen == 0)\n\t\t\t$oneSeen = 1;\n\t\tif ($str[$i] != '0' && $str[$i] != '1')\n\t\t\t$oneSeen = 0;\n\t}\n\treturn $count;\n}", "7989": "function minOperations($s, $t, $n)\n{\n\t$ct0 = 0 ; $ct1 = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tif ($s[$i] == $t[$i])\n\t\t\tcontinue;\n\t\tif ($s[$i] == '0')\n\t\t\t$ct0++;\n\t\telse\n\t\t\t$ct1++;\n\t}\n\treturn max($ct0, $ct1);\n}", "7991": "function maxValue($a, $b)\n{\n\tsort($b);\n\t$n = sizeof($a);\n\t$m = sizeof($b);\n\t$j = $m - 1;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tif ($j < 0)\n\t\t\tbreak;\n\t\tif ($b[$j] > $a[$i])\n\t\t{\n\t\t\t$a[$i] = $b[$j];\n\t\t\t$j--;\n\t\t}\n\t}\n\t$a = implode(\"\",$a);\n\treturn $a ;\n}", "8004": "function decryptString($str, $n)\n{\n\t$i = 0 ;\n\t$jump = 1 ;\n\t$decryptedStr = \"\";\n\twhile ($i < $n)\n\t{\n\t\t$decryptedStr .= $str[$i];\n\t\t$i += $jump;\n\t\t$jump++;\n\t}\n\treturn $decryptedStr;\n}", "8015": "function steps($str, $n)\n{\n\t$x = 0;\n\tfor ($i = 0; $i < strlen($str); $i++)\n\t{\n\t\tif ($x == 0)\n\t\t\t$flag = true;\n\t\tif ($x == $n - 1)\n\t\t\t$flag = false;\n\t\tfor ($j = 0; $j < $x; $j++)\n\t\t\techo \"*\";\n\t\techo $str[$i], \"\\n\";\n\t\tif ($flag == true)\n\t\t\t$x++;\n\t\telse\n\t\t\t$x--;\n\t}\n}", "8054": "function bitToBeFlipped($s)\n{\n\t$last = $s[strlen($s) - 1];\n\t$first = $s[0];\n\tif ($last == $first)\n\t{\n\t\tif ($last == '0')\n\t\t{\n\t\t\treturn '1';\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn '0';\n\t\t}\n\t}\n\telse if ($last != $first)\n\t{\n\t\treturn $last;\n\t}\n}", "8078": "function countChar($str, $x)\n{\n\t$count = 0;\n\t$n = 10;\n\tfor ($i = 0; $i < strlen($str); $i++)\n\t\tif ($str[$i] == $x)\n\t\t\t$count++;\n\t$repetitions = (int)($n / strlen($str));\n\t$count = $count * $repetitions;\n\tfor ($i = 0; $i < $n % strlen($str); $i++)\n\t{\n\t\tif ($str[$i] == $x)\n\t\t\t$count++;\n\t}\n\treturn $count;\n}", "8099": "function checkIfUnequal($n, $q)\n{\n\t$s1 = strval($n);\n\t$a = array_fill(0, 26, NULL);\n\tfor ($i = 0; $i < strlen($s1); $i++)\n\t\t$a[ord($s1[$i]) - ord('0')]++;\n\t$prod = $n * $q;\n\t$s2 = strval($prod);\n\tfor ($i = 0; $i < strlen($s2); $i++)\n\t{\n\tif ($a[ord($s2[$i]) - ord('0')])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nfunction countInRange($l, $r, $q)\n{\n\t$count = 0;\n\tfor ($i = $l; $i <= $r; $i++)\n\t{\n\t\tif (checkIfUnequal($i, $q))\n\t\t\t$count++;\n\t}\n\treturn $count;\n}", "8110": "function is_possible($s)\n{\n\t$l = strlen($s);\n\t$one = 0;\n\t$zero = 0;\n\tfor ($i = 0; $i < $l; $i++)\n\t{\n\t\tif ($s[$i] == '0')\n\t\t\t$zero++;\n\t\telse\n\t\t\t$one++;\n\t}\n\tif ($l % 2 == 0)\n\t\treturn ($one == $zero);\n\telse\n\t\treturn (abs($one - $zero) == 1);\n}", "8213": "function check($s, $m)\n{\n\t$l = count($s);\n\t$c1 = 0;\n\t$c2 = 0;\n\tfor ($i = 0; $i <= $l; $i++)\n\t{\n\t\tif ($s[$i] == '0')\n\t\t{\n\t\t\t$c2 = 0;\n\t\t\t$c1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$c1 = 0;\n\t\t\t$c2++;\n\t\t}\n\t\tif ($c1 == $m or $c2 == $m)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "8241": "function isDivisible($str, $k)\n{\n\t$n = strlen($str);\n\t$c = 0;\n\tfor ($i = 0; $i < $k; $i++)\n\t\tif ($str[$n - $i - 1] == '0')\t\n\t\t\t$c++;\n\treturn ($c == $k);\n}", "8281": "function productAtKthLevel($tree, $k)\n{\n\t$level = -1;\n\t$n = strlen($tree);\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tif ($tree[$i] == '(')\n\t\t\t$level++;\n\t\telse if ($tree[$i] == ')')\n\t\t\t$level--;\n\t\telse\n\t\t{\n\t\t\tif ($level == $k)\n\t\t\t\t$product *= (ord($tree[$i]) -\n\t\t\t\t\t\t\tord('0'));\n\t\t}\n\t}\n\treturn $product;\n}", "8301": "function findSubSequence($s, $num)\n{\n\t$res = 0;\n\t$i = 0;\n\twhile ($num) {\n\t\tif ($num & 1)\n\t\t\t$res += $s[$i] - '0';\n\t\t$i++;\n\t\t$num = $num >> 1;\n\t}\n\treturn $res;\n}\nfunction combinedSum(string $s)\n{\n\t$n = strlen($s);\n\t$c_sum = 0;\n\t$range = (1 << $n) - 1;\n\tfor ($i = 0; $i <= $range; $i++)\n\t\t$c_sum += findSubSequence($s, $i);\n\treturn $c_sum;\n}", "8304": "function findSubsequence($str, $k)\n{\n\t$a = array(1024);\n\tfor($i = 0; $i < 26; $i++)\n\t\t$a[$i] = 0;\n\tfor ($i = 0; $i < strlen($str); $i++)\n\t{\n\t\t$temp = ord($str[$i]) - ord('a');\n\t\t$a[$temp] += 1;\n\t}\n\tfor ($i = 0; $i < strlen($str); $i++)\n\t\tif ($a[ord($str[$i]) - ord('a')] >= $k)\n\t\t\techo $str[$i];\n}", "8315": "function convert($str)\n{\n\t$w = \"\"; $z = \"\";\n\t$str = strtoupper($str) . \" \";\n\tfor ($i = 0;\n\t\t$i < strlen($str); $i++)\n\t{\n\t\t$ch = $str[$i];\n\t\tif ($ch != ' ')\n\t\t\t$w = $w . $ch;\n\t\telse\n\t\t{\n\t\t\t$z = $z . strtolower($w[0]) .\n\t\t\t\t\t\tsubstr($w, 1) . \" \";\n\t\t\t$w = \"\";\n\t\t}\n\t}\n\treturn $z;\n}", "8316": "function convert($s)\n{\n\t$n = strlen($s);\n\t$s[0] = strtolower($s[0]);\n\tfor ($i = 1; $i < $n; $i++)\n\t{\n\t\tif ($s[$i] == ' ' && $i < $n)\n\t\t{\n\t\t\t$s[$i + 1] = strtolower($s[$i + 1]);\n\t\t\t$i++;\n\t\t}\n\t\telse\n\t\t\t$s[$i] = strtoupper($s[$i]);\n\t}\n\treturn $s;\n}", "8317": "function change_case($a)\n{\n\t$l = strlen($a);\n\tfor($i = 0 ; $i < $l ; $i++)\n\t{\n\t\tif($a[$i] >= 'a' && $a[$i] <= 'z')\n\t\t\t$a[$i] = chr(65 +\n\t\t\t\t\t\t(ord($a[$i]) -\n\t\t\t\t\t\tord('a')));\n\t\telse if($a[$i] >= 'A' && $a[$i] <= 'Z')\n\t\t\t$a[$i] = chr(97 +\n\t\t\t\t(ord($a[$i]) -\n\t\t\t\tord('a')));\n\t}\n\treturn $a;\n}\nfunction delete_vowels($a)\n{\n\t$temp = \"\";\n\t$l = strlen($a);\n\tfor($i = 0 ; $i < $l ; $i++)\n\t{\n\t\tif($a[$i] != 'a' && $a[$i] != 'e' && $a[$i] != 'i' && $a[$i] != 'o' && $a[$i] != 'u' && $a[$i] != 'A' && $a[$i] != 'E' && $a[$i] != 'O' && $a[$i] != 'U' && $a[$i] != 'I')\n\t\t\t$temp = $temp.$a[$i];\n\t}\t\n\treturn $temp;\t\n}\nfunction insert_hash($a)\n{\n\t$temp = \"\";\n\t$l = strlen($a);\n\tfor($i = 0 ; $i < $l ; $i++)\n\t{\n\t\tif(($a[$i] >= 'a' && $a[$i] <= 'z') ||\n\t\t($a[$i] >= 'A' && $a[$i] <= 'Z'))\n\t\t\t$temp = $temp . '#' .\n\t\t\t\t\t$a[$i];\n\t\telse\n\t\t\t$temp = $temp.$a[$i];\n\t}\t\n\treturn $temp;\t\n}\nfunction transformSting($a)\n{\n\t$b = delete_vowels($a);\n\t$c = change_case($b);\n\t$d = insert_hash($c);\n\techo ($d);\n}", "8366": "function isVowel($c)\n{\n\treturn ($c == 'a' $c == 'e' $c == 'i' $c == 'o' $c == 'u');\n}\nfunction encryptString($s, $n, $k)\n{\n\t$countVowels = 0;\n\t$countConsonants = 0;\n\t$ans = \"\";\n\tfor ($l = 0; $l <= $n - $k; $l++)\n\t{\n\t\t$countVowels = 0;\n\t\t$countConsonants = 0;\n\t\tfor ($r = $l; $r <= $l + $k - 1; $r++)\n\t\t{\n\t\t\tif (isVowel($s[$r]) == true)\n\t\t\t\t$countVowels++;\n\t\t\telse\n\t\t\t\t$countConsonants++;\n\t\t}\n\t\t$ans = $ans . (string)($countVowels * $countConsonants);\n\t}\n\treturn $ans;\n}", "8374": "function countOccurrences($str, $word)\n{\n\t$a = explode(\" \", $str);\n\t$count = 0;\n\tfor ($i = 0; $i < sizeof($a); $i++)\n\t{\n\tif ($word == $a[$i])\n\t\t$count++;\n\t}\n\treturn $count;\n}", "8396": "function isValidISBN($isbn)\n{\n\t$n = strlen($isbn);\n\tif ($n != 10)\n\t\treturn -1;\n\t$sum = 0;\n\tfor ($i = 0; $i < 9; $i++)\n\t{\n\t\t$digit = $isbn[$i] - '0';\n\t\tif (0 > $digit 9 < $digit)\n\t\t\treturn -1;\n\t\t$sum += ($digit * (10 - $i));\n\t}\n\t$last = $isbn[9];\n\tif ($last != 'X' && ($last < '0' $last > '9'))\n\t\treturn -1;\n\t$sum += (($last == 'X')\n\t? 10 : ($last - '0'));\n\treturn ($sum % 11 == 0);\n}", "8490": "function permute($input)\n{\n\t$n = strlen($input);\n\t$max = 1 << $n;\n\t$input = strtolower($input);\n\tfor($i = 0; $i < $max; $i++)\n\t{\n\t\t$combination = $input;\n\t\tfor($j = 0; $j < $n; $j++)\n\t\t{\n\t\t\tif((($i >> $j) & 1) == 1)\n\t\t\t\t$combination[$j] = chr(ord($combination[$j]) - 32);\n\t\t}\n\t\techo $combination . \" \";\n\t}\n}", "8501": "function isNumber($s)\n{\n\tfor ($i = 0; $i < strlen($s); $i++)\n\t\tif (is_numeric($s[$i]) == false)\n\t\t\treturn false;\n\treturn true;\n}", "8705": "function isPalindrome($str)\n{\n\t$l = 0;\n\t$h = strlen($str) - 1;\n\twhile ($h > $l)\n\t\tif ($str[$l++] != $str[$h--])\n\t\t\treturn false;\n\treturn true;\n}\nfunction minRemovals($str)\n{\nif ($str[0] == '')\n\treturn 0;\nif (isPalindrome($str))\n\treturn 1;\nreturn 2;\n}", "8795": "function reverse($str)\n{\n\tif (($str == null) ||\n\t\t(strlen($str) <= 1))\n\techo ($str);\n\telse\n\t{\n\t\techo ($str[strlen($str) - 1]);\n\t\treverse(substr($str, 0,\n\t\t\t(strlen($str) - 1)));\n\t}\n}", "8939": "function power($x, $y, $p)\n{\n\t$res = 1;\n\t$x = $x % $p;\n\twhile ($y > 0)\n\t{\n\t\tif ($y&1)\n\t\t\t$res = ($res * $x) % $p;\n\t\t$y = $y >> 1;\n\t\t$x = ($x * $x) % $p;\n\t}\n\treturn $res;\n}\nfunction findModuloByM($X, $N, $M)\n{\n\tif ($N < 6)\n\t{\n\t\t$temp = chr(48 + $X) * $N;\n\t\t$res = intval($temp) % $M;\n\t\treturn $res;\n\t}\n\tif ($N % 2 == 0)\n\t{\n\t\t$half = findModuloByM($X, (int)($N / 2), $M) % $M;\n\t\t$res = ($half * power(10,(int)($N / 2), $M) + $half) % $M;\n\t\treturn $res;\n\t}\n\telse\n\t{\n\t\t$half = findModuloByM($X, (int)($N / 2), $M) % $M;\n\t\t$res = ($half * power(10, (int)($N / 2) + 1, $M) + $half * 10 + $X) % $M;\n\t\treturn $res;\n\t}\n}", "9195": "function lengtang($r1, $r2, $d)\n{\n\techo \"The length of the direct common tangent is \"\n\t\t,sqrt(pow($d, 2) - pow(($r1 - $r2), 2)) ;\n}", "9196": "function rad($d, $h)\n{\n\techo \"The radius of the circle is \",\n\t\t(($d * $d) / (8 * $h) + $h / 2), \"\\n\";\n}", "9197": "function shortdis($r, $d)\n{\n\techo \"The shortest distance \";\n\techo \"from the chord to centre \";\n\techo sqrt(($r * $r) - (($d * $d) / 4));\n}", "9200": "function lengtang($r1, $r2, $d)\n{\n\techo \"The length of the direct\",\n\t\t\t\" common tangent is \",\n\t\tsqrt(pow($d, 2) -\n\t\t\tpow(($r1 - $r2), 2)), \"\\n\";\n}", "9201": "function length_of_chord($r, $x)\n{\n\techo \"The length of the chord\",\n\t\" of the circle is \"\n\t,2 * $r * sin($x * (3.14 / 180)) ;\n}", "9232": "function square($a )\n{\n\tif ($a < 0)\n\t\treturn -1;\n\t$x = 0.464 * $a;\n\treturn $x;\n}", "9238": "function polyapothem($n, $a)\n{\n\tif ($a < 0 && $n < 0)\n\t\treturn -1;\n\treturn $a / (2 * tan((180 / $n) * 3.14159 / 180));\n}", "9240": "function polyarea($n, $r)\n{\n\tif ($r < 0 && $n < 0)\n\t\treturn -1;\n\t$A = (($r * $r * $n) * sin((360 / $n) * 3.14159 / 180)) / 2;\n\treturn $A;\n}", "9241": "function polyarea($n, $a)\n{\n\tif ($a < 0 && $n < 0)\n\t\treturn -1;\n\t$A = ($a * $a * $n) / (4 * tan((180 / $n) * 3.14159 / 180));\n\treturn $A;\n}", "9247": "function hexDiagonal($a)\n{\n\tif ($a < 0)\n\t\treturn -1;\n\t$d = 1.73 * $a;\n\treturn $d;\n}", "9250": "function calculateSide($n, $r)\n{\n\t$theta; $theta_in_radians;\n\t$theta = 360 / $n;\n\t$theta_in_radians = $theta * 3.14 / 180;\n\treturn 2 * $r * sin($theta_in_radians / 2);\n}", "9257": "function cyl($r, $R, $h)\n{\n\tif ($h < 0 && $r < 0 && $R < 0)\n\t\treturn -1;\n\t$r1 = $r;\n\t$h1 = $h;\n\t$V = (3.14 * pow($r1, 2) * $h1);\n\treturn $V;\n}", "9258": "function findVolume($a)\n{\n\tif ($a < 0)\n\t\treturn -1;\n\t$r = $a / 2;\n\t$h = $a;\n\t$V = 3.14 * pow($r, 2) * $h;\n\treturn $V;\n}", "9290": "function Perimeter($s, $n)\n{\n\t$perimeter = 1;\n\t$perimeter = $n * $s;\n\treturn $perimeter;\n}", "9291": "function area($r)\n{\n\treturn (0.5) * (3.14) * ($r * $r);\n}\nfunction perimeter($r)\n{\n\treturn (3.14) * ($r);\n}", "9302": "", "9305": "function rhombusarea($l, $b)\n{\n\tif ($l < 0 $b < 0)\n\t\treturn -1;\n\treturn ($l * $b) / 2;\n}", "9318": "function area($a)\n{\n\tif ($a < 0)\n\t\treturn -1;\n\t$area = sqrt($a) / 6;\n\treturn $area;\n}", "9329": "function longestRodInCuboid($length, $breadth, $height)\n{\n\t$result;\n\t$temp;\n\t$temp = $length * $length +\n\t\t\t$breadth * $breadth +\n\t\t\t$height * $height;\n\t$result = sqrt($temp);\n\treturn $result;\n}", "9348": "function LiesInsieRectangle($a, $b, $x, $y)\n{\n\tif ($x - $y - $b <= 0 && $x - $y + $b >= 0 && $x + $y - 2 * $a + $b <= 0 && $x + $y - $b >= 0)\n\t\treturn true;\n\treturn false;\n}", "9358": "function FindPoint($x1, $y1, $x2, $y2, $x, $y)\n{\n\tif ($x > $x1 and $x < $x2 and $y > $y1 and $y < $y2)\n\t\treturn true;\n\treturn false;\n}", "9359": "function distance($a1, $b1, $c1, $d1, $a2, $b2, $c2, $d2)\n{\n\tif ($a1 / $a2 == $b1 / $b2 && $b1 / $b2 == $c1 / $c2)\n\t{\n\t\t$x1 = $y1 = 0;\n\t\t$z1 =- $d1 / $c1;\n\t\t$d = abs(($c2 * $z1 + $d2)) /\n\t\t\t(sqrt($a2 * $a2 + $b2 * $b2 + $c2 * $c2));\n\t\techo \"Perpendicular distance is \", $d;\n\t}\n\telse\n\t\techo \"Planes are not parallel\";\n}", "9362": "function shortest_distance($x1, $y1, $z1, $a, $b, $c, $d)\n{\n\t$d = abs(($a * $x1 + $b * $y1 + $c * $z1 + $d));\n\t$e = sqrt($a * $a + $b * $b + $c * $c);\n\techo \"Perpendicular distance is \". $d / $e;\n}", "9369": "function findVolume($l, $b, $h)\n{\n\t$volume = ($l * $b * $h) / 2;\n\treturn $volume;\n}", "9405": "function findPCSlope($m)\n{\n\treturn -1.0 / $m;\n}", "9430": "function area_of_segment($radius, $angle)\n{\n\t$pi = 3.14159;\n\t$area_of_sector = $pi * ($radius * $radius) *\n\t\t\t\t\t\t\t\t($angle / 360);\n\t$area_of_triangle = 1 / 2 *\t($radius * $radius)\n\t\t\t\t\t\t\t* sin(($angle * $pi) / 180);\n\treturn $area_of_sector - $area_of_triangle;\n}", "9432": "function midpoint($x1, $x2, $y1, $y2)\n{\n\techo((float)($x1 + $x2)/2 . \" , \" .\n\t\t\t\t(float)($y1 + $y2)/2) ;\n}", "9445": "function maxvolume( $s)\n{\n\t$maxvalue = 0;\n\tfor ( $i = 1; $i <= $s - 2; $i++)\n\t{\n\t\tfor ( $j = 1; $j <= $s - 1; $j++)\n\t\t{\n\t\t\t$k = $s - $i - $j;\n\t\t\t$maxvalue = max($maxvalue, $i * $j * $k);\n\t\t}\n\t}\n\treturn $maxvalue;\n}", "9446": "function maxvolume($s)\n{\n\t$length = (int)($s / 3);\n\t$s -= $length;\n\t$breadth = (int)($s / 2);\n\t$height = $s - $breadth;\n\treturn $length * $breadth * $height;\n}", "9452": "function volumeTriangular($a, $b, $h)\n{\n\t$vol = (0.1666) * $a * $b * $h;\n\treturn $vol;\n}\nfunction volumeSquare($b, $h)\n{\n\t$vol = (0.33) * $b * $b * $h;\n\treturn $vol;\n}\nfunction volumePentagonal($a, $b, $h)\n{\n\t$vol = (0.83) * $a * $b * $h;\n\treturn $vol;\n}\nfunction volumeHexagonal($a, $b, $h)\n{\n\t$vol = $a * $b * $h;\n\treturn $vol;\n}", "9457": "function Area( $b1, $b2, $h)\n{\n\treturn (($b1 + $b2) / 2) * $h;\n}", "9458": "function hexagonArea( $s)\n{\n\treturn ((3 * sqrt(3) *\n\t\t\t($s * $s)) / 2);\n}", "9467": "function arcLength($diameter, $angle)\n\t{\n\t\t$pi = 22.0 / 7.0;\n\t\t$arc;\n\t\tif ($angle >= 360)\n\t\t{\n\t\t\techo \"Angle cannot\",\n\t\t\t\t\" be formed\";\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$arc = ($pi * $diameter) *\n\t\t\t\t($angle / 360.0);\n\t\t\treturn $arc;\n\t\t}\n\t}", "9468": "function SectorArea( $radius, $angle)\n{\n\tif($angle >= 360)\n\t\techo(\"Angle not possible\");\n\telse\n\t{\n\t\t$sector = ((22 * $radius * $radius) / 7) * ($angle / 360);\n\t\techo($sector);\n\t}\n}", "9476": "function maxSquare($b, $m)\n{\n\treturn ($b / $m - 1) *\n\t\t($b / $m) / 2;\n}", "9478": "function checkCollision($a, $b, $c, $x, $y, $radius)\n{\n\t$dist = (abs($a * $x + $b * $y + $c)) /\n\t\t\t\tsqrt($a * $a + $b * $b);\n\tif ($radius == $dist)\n\t\techo \"Touch\";\n\telse if ($radius > $dist)\n\t\techo \"Intersect\";\n\telse\n\t\techo \"Outside\" ;\n}", "9496": "function numberOfDiagonals($n)\n{\n\treturn $n * ($n - 3) / 2;\n}", "9505": "function findRightAngle($A, $H)\n{\n\t$D = pow($H, 4) - 16 * $A * $A;\n\tif ($D >= 0)\n\t{\n\t\t$root1 = ($H * $H + sqrt($D)) / 2;\n\t\t$root2 = ($H * $H - sqrt($D)) / 2;\n\t\t$a = sqrt($root1);\n\t\t$b = sqrt($root2);\n\t\tif ($b >= $a)\n\t\t\techo $a , \" \", $b , \" \" , $H;\n\t\telse\n\t\techo $b , \" \" , $a , \" \" , $H;\n\t}\n\telse\n\t\techo \"-1\";\n}", "9507": "function numberOfSquares( $base)\n\t{\n\t\t$base = ($base - 2);\n\t\t$base = intdiv($base, 2);\n\t\treturn $base * ($base + 1)/2;\n\t}", "9528": "function polygonArea( $X, $Y, $n)\n{\n\t$area = 0.0;\n\t$j = $n - 1;\n\tfor ( $i = 0; $i < $n; $i++)\n\t{\n\t\t$area += ($X[$j] + $X[$i]) *\n\t\t\t\t($Y[$j] - $Y[$i]);\n\t\t$j = $i;\n\t}\n\treturn abs($area / 2.0);\n}", "11418": "function getAverage($x, $y)\n{\n\t$avg = ($x & $y) + (($x ^ $y) >> 1);\n\treturn $avg;\n}", "11435": "function primeCount($arr, $n)\n{\n\t$max_val = max($arr);\n\t$prime = array_fill(0, $max_val + 1, true);\n\t$prime[0] = false;\n\t$prime[1] = false;\n\tfor ($p = 2; $p * $p <= $max_val; $p++)\n\t{\n\t\tif ($prime[$p] == true)\n\t\t{\n\t\t\tfor ($i = $p * 2; $i <= $max_val; $i += $p)\n\t\t\t\t$prime[$i] = false;\n\t\t}\n\t}\n\t$count = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\tif ($prime[$arr[$i]])\n\t\t\t$count++;\n\treturn $count;\n}\nfunction getPrefixArray($arr, $n, $pre)\n{\n\t$pre[0] = $arr[0];\n\tfor ($i = 1; $i < $n; $i++)\n\t{\n\t\t$pre[$i] = $pre[$i - 1] + $arr[$i];\n\t}\n\treturn $pre ;\n}", "11510": "function smallestIndex($a, $n)\n{\n\t$right1 = 0; $right0 = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tif ($a[$i] == 1)\n\t\t\t$right1 = $i;\n\t\telse\n\t\t\t$right0 = $i;\n\t}\n\treturn min($right1, $right0);\n}", "11523": "function freqPairs($arr, $n)\n{\n\t$max = max($arr);\n\t$freq = array_fill(0, $max + 1, 0);\n\t$count = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$freq[$arr[$i]]++;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = 2 * $arr[$i]; $j <= $max; $j += $arr[$i])\n\t\t{\n\t\t\tif ($freq[$j] >= 1)\n\t\t\t\t$count += $freq[$j];\n\t\t}\n\t\tif ($freq[$arr[$i]] > 1)\n\t\t{\n\t\t\t$count += $freq[$arr[$i]] - 1;\n\t\t\t$freq[$arr[$i]]--;\n\t\t}\n\t}\n\treturn $count;\n}", "11533": "function countSquares($r, $c, $m)\n{\n\t$squares = 0;\n\tfor ($i = 1; $i <= 8; $i++)\n\t{\n\t\tfor ($j = 1; $j <= 8; $j++)\n\t\t{\n\t\t\tif (max(abs($i - $r),\n\t\t\t\t\tabs($j - $c)) <= $m)\n\t\t\t\t$squares++;\n\t\t}\n\t}\n\treturn $squares;\n}", "11549": "function Loss($SP, $P)\n{\n\t$loss = 0;\n\t$loss = ((2 * $P * $P * $SP) /\n\t\t(100 * 100 - $P * $P));\n\tprint(\"Loss = \" . round($loss, 3));\n}", "11611": "function sieve()\n{\n\tglobal $spf, $MAXN, $hash1;\n\t$spf[1] = 1;\n\tfor ($i = 2; $i < $MAXN; $i++)\n\t\t$spf[$i] = $i;\n\tfor ($i = 4; $i < $MAXN; $i += 2)\n\t\t$spf[$i] = 2;\n\tfor ($i = 3; $i * $i < $MAXN; $i++)\n\t{\n\t\tif ($spf[$i] == $i)\n\t\t{\n\t\t\tfor ($j = $i * $i; $j < $MAXN; $j += $i)\n\t\t\t\tif ($spf[$j] == $j)\n\t\t\t\t\t$spf[$j] = $i;\n\t\t}\n\t}\n}\nfunction getFactorization($x)\n{\n\tglobal $spf,$MAXN,$hash1;\n\twhile ($x != 1)\n\t{\n\t\t$temp = $spf[$x];\n\t\tif ($x % $temp == 0)\n\t\t{\n\t\t\t$hash1[$spf[$x]]++;\n\t\t\t$x = (int)($x / $spf[$x]);\n\t\t}\n\t\twhile ($x % $temp == 0)\n\t\t\t$x = (int)($x / $temp);\n\t}\n}\nfunction check($x)\n{\n\tglobal $spf,$MAXN,$hash1;\n\twhile ($x != 1)\n\t{\n\t\t$temp = $spf[$x];\n\t\tif ($x % $temp == 0 && $hash1[$temp] > 1)\n\t\t\treturn false;\n\t\twhile ($x % $temp == 0)\n\t\t\t$x = (int)($x / $temp);\n\t}\n\treturn true;\n}\nfunction hasValidNum($arr, $n)\n{\n\tglobal $spf,$MAXN,$hash1;\n\tsieve();\n\tfor ($i = 0; $i < $n; $i++)\n\t\tgetFactorization($arr[$i]);\n\tfor ($i = 0; $i < $n; $i++)\n\t\tif (check($arr[$i]))\n\t\t\treturn true;\n\treturn false;\n}", "11626": "function countNumbers($L, $R, $K)\n{\n\tif ($K == 9)\n\t\t$K = 0;\n\t$totalnumbers = $R - $L + 1;\n\t$factor9 = intval($totalnumbers / 9);\n\t$rem = $totalnumbers % 9;\n\t$ans = $factor9;\n\tfor ($i = $R; $i > $R - $rem; $i--)\n\t{\n\t\t$rem1 = $i % 9;\n\t\tif ($rem1 == $K)\n\t\t\t$ans++;\n\t}\n\treturn $ans;\n}", "11627": "function countWays($N)\n{\n\t$E = ($N * ($N - 1)) / 2;\n\tif ($N == 1)\n\t\treturn 0;\n\treturn (int)pow(2, $E - 1);\n}", "11629": "function BalanceArray($A, &$Q)\n{\n\t$ANS = array();\n\t$sum = 0;\n\tfor ($i = 0; $i < count($A); $i++)\n\t\tif ($A[$i] % 2 == 0)\n\t\t\t$sum = $sum + $A[$i];\n\tfor ($i = 0; $i < count($Q); $i++)\n\t{\n\t\t$index = $Q[$i][0];\n\t\t$value = $Q[$i][1];\n\t\tif ($A[$index] % 2 == 0)\n\t\t\t$sum = $sum - $A[$index];\n\t\t$A[$index] = $A[$index] + $value;\n\t\tif ($A[$index] % 2 == 0)\n\t\t\t$sum = $sum + $A[$index];\n\t\tarray_push($ANS,$sum);\n\t}\n\tfor ($i = 0; $i < count($ANS); $i++)\n\t\techo $ANS[$i] . \" \";\n}", "11658": "function Cycles($N)\n{\n\t$fact = 1 ;\n\t$result = 0;\n\t$result = $N - 1;\n\t$i = $result;\n\twhile ($i > 0)\n\t{\n\t\t$fact = $fact * $i;\n\t\t$i--;\n\t}\n\treturn floor($fact / 2);\n}", "11667": "function findAndSum($arr, $n)\n{\n\t$sum = 0;\n\t$mul = 1;\n\tfor ($i = 0; $i < 30; $i++)\n\t{\n\t\t$count_on = 0;\n\t\t$l = 0;\n\t\tfor ($j = 0; $j < $n; $j++)\n\t\t{\n\t\t\tif (($arr[$j] & (1 << $i)) > 0)\n\t\t\t\tif ($count_on)\n\t\t\t\t\t$l++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$count_on = 1;\n\t\t\t\t\t$l++;\n\t\t\t\t}\n\t\t\telse if ($count_on)\n\t\t\t{\n\t\t\t\t$sum += (($mul * $l * ($l + 1)) / 2);\n\t\t\t\t$count_on = 0;\n\t\t\t\t$l = 0;\n\t\t\t}\n\t\t}\n\t\tif ($count_on)\n\t\t{\n\t\t\t$sum += (($mul * $l * ($l + 1)) / 2);\n\t\t\t$count_on = 0;\n\t\t\t$l = 0;\n\t\t}\n\t\t$mul *= 2;\n\t}\n\treturn $sum;\n}", "11687": "function minValue($n, $x, $y)\n{\n\t$val = ($y * $n) / 100;\n\tif ($x >= $val)\n\t\treturn 0;\n\telse\n\t\treturn (ceil($val) - $x);\n}", "11707": "function digitWell($n, $m, $k)\n{\n\t$cnt = 0;\n\twhile ($n > 0)\n\t{\n\t\tif ($n % 10 == $m)\n\t\t\t++$cnt;\n\t\t$n = floor($n / 10);\n\t}\n\treturn $cnt == $k;\n}\nfunction findInt($n, $m, $k)\n{\n\t$i = $n + 1;\n\twhile (true)\n\t{\n\t\tif (digitWell($i, $m, $k))\n\t\t\treturn $i;\n\t\t$i++;\n\t}\n}", "11709": "function minAbsDiff($n)\n{\n\t$mod = $n % 4;\n\tif ($mod == 0 $mod == 3)\n\t\treturn 0;\n\treturn 1;\n}", "11722": "function countOdd($arr, $n)\n{\n\t$odd = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tif ($arr[$i] % 2 == 1)\n\t\t\t$odd++;\n\t}\n\treturn $odd;\n}\nfunction countValidPairs($arr, $n)\n{\n\t$odd = countOdd($arr, $n);\n\treturn ($odd * ($odd - 1)) / 2;\n}", "11748": "function gcd($a, $b)\n{\n\tif ($b == 0)\n\t\treturn $a;\n\telse\n\t\treturn gcd($b, $a % $b);\n}\nfunction lcmOfArray(&$arr, $n)\n{\n\tif ($n < 1)\n\t\treturn 0;\n\t$lcm = $arr[0];\n\tfor ($i = 1; $i < $n; $i++)\n\t\t$lcm = ($lcm * $arr[$i]) /\n\t\t\tgcd($lcm, $arr[$i]);\n\treturn $lcm;\n}\nfunction minPerfectCube(&$arr, $n)\n{\n\t$lcm = lcmOfArray($arr, $n);\n\t$minPerfectCube = $lcm;\n\t$cnt = 0;\n\twhile ($lcm > 1 && $lcm % 2 == 0)\n\t{\n\t\t$cnt++;\n\t\t$lcm /= 2;\n\t}\n\tif ($cnt % 3 == 2)\n\t\t$minPerfectCube *= 2;\n\telse if ($cnt % 3 == 1)\n\t\t$minPerfectCube *= 4;\n\t$i = 3;\n\twhile ($lcm > 1)\n\t{\n\t\t$cnt = 0;\n\t\twhile ($lcm % $i == 0)\n\t\t{\n\t\t\t$cnt++;\n\t\t\t$lcm /= $i;\n\t\t}\n\t\tif ($cnt % 3 == 1)\n\t\t\t$minPerfectCube *= $i * $i;\n\t\telse if ($cnt % 3 == 2)\n\t\t\t$minPerfectCube *= $i;\n\t\t$i += 2;\n\t}\n\treturn $minPerfectCube;\n}", "11772": "function isPrime($n)\n{\n\tif ($n <= 1)\n\t\treturn false;\n\tif ($n <= 3)\n\t\treturn true;\n\tif ($n % 2 == 0 $n % 3 == 0)\n\t\treturn false;\n\tfor ($i = 5; $i * $i <= $n; $i = $i + 6)\n\t\tif ($n % $i == 0 ||\n\t\t\t$n % ($i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nfunction isStrongPrime($n)\n{\n\tif (!isPrime($n) $n == 2)\n\t\treturn false;\n\t$previous_prime = $n - 1;\n\t$next_prime = $n + 1;\n\twhile (!isPrime($next_prime))\n\t\t$next_prime++;\n\twhile (!isPrime($previous_prime))\n\t\t$previous_prime--;\n\t$mean = ($previous_prime + $next_prime) / 2;\n\tif ($n > $mean)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "11774": "function isPrime($n)\n{\n\tif ($n <= 1)\n\t\treturn false;\n\tif ($n <= 3)\n\t\treturn true;\n\tif ($n % 2 == 0 $n % 3 == 0)\n\t\treturn false;\n\tfor ($i = 5; $i * $i <= $n; $i = $i + 6)\n\t\tif ($n % $i == 0 || $n % ($i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nfunction isFactorialPrime($n)\n{\n\tif (!isPrime($n))\n\t\treturn false;\n\t$fact = 1;\n\t$i = 1;\n\twhile ($fact <= $n + 1)\n\t{\n\t\t$fact = $fact * $i;\n\t\tif ($n + 1 == $fact $n - 1 == $fact)\n\t\t\treturn true;\n\t\t$i++;\n\t}\n\treturn false;\n}", "11815": "function countDigitsToBeRemoved($N, $K)\n{\n\t$s = strval($N);\n\t$res = 0;\n\t$f_zero = 0;\n\tfor ($i = strlen($s)-1; $i >= 0; $i--) {\n\t\tif ($K == 0)\n\t\t\treturn $res;\n\t\tif ($s[$i] == '0') {\n\t\t\t$f_zero = 1;\n\t\t\t$K--;\n\t\t}\n\t\telse\n\t\t\t$res++;\n\t}\n\tif (!$K)\n\t\treturn $res;\n\telse if ($f_zero)\n\t\treturn strlen($s) - 1;\n\treturn -1;\n}", "11906": "function getSum($a, $n)\n{\n\t$sum = 0;\n\tfor ($i = 1; $i <= $n; ++$i)\n\t{\n\t\t$sum += ($i / pow($a, $i));\n\t}\n\treturn $sum;\n}", "11948": "function check($s)\n{\n\t$freq =array_fill(0,10,0);\n\twhile($s != 0)\n\t{\n\t\t$r = $s % 10;\n\t\t$s = (int)($s/10);\n\t\t$freq[$r]+= 1;\n\t}\n\t$xor = 0;\n\tfor($i=0;$i<10;$i++)\n\t\t$xor = $xor ^ $freq[$i];\n\tif($xor == 0)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "11998": "function largestPrimeFactor($n)\n{\n\t$max = -1;\n\twhile ($n % 2 == 0) {\n\t\t$max = 2;\n\t}\n\tfor ($i = 3; $i <= sqrt($n); $i += 2) {\n\t\twhile ($n % $i == 0) {\n\t\t\t$max = $i;\n\t\t\t$n = $n / $i;\n\t\t}\n\t}\n\tif ($n > 2)\n\t\t$max = $n;\n\treturn $max;\n}\nfunction checkUnusual($n)\n{\n\t$factor = largestPrimeFactor($n);\n\tif ($factor > sqrt($n)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "12002": "function Nth_Term($n)\n{\n\treturn (2 * pow($n, 3) - 3 *\n\t\t\t\tpow($n, 2) + $n + 6) / 6;\n}", "12035": "function isHalfReducible($arr, $n, $m)\n{\n\t$frequencyHash = array_fill(0, $m + 1, 0);\n\t$i = 0;\n\tfor (;$i < $n; $i++)\n\t{\n\t\t$frequencyHash[($arr[$i] % ($m + 1))]++;\n\t}\n\tfor ($i = 0; $i <= $m; $i++)\n\t{\n\t\tif ($frequencyHash[$i] >= ($n / 2))\n\t\t\tbreak;\n\t}\n\tif ($i <= $m)\n\t\techo \"Yes\\n\";\n\telse\n\t\techo \"No\\n\";\n}", "12058": "", "12070": "function printLines($n, $k)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\techo ($k * (6 * $i + 1));\n\t\techo (\" \");\n\t\techo ($k * (6 * $i + 2));\n\t\techo (\" \");\n\t\techo ($k * (6 * $i + 3));\n\t\techo (\" \");\n\t\techo ($k * (6 * $i + 5));\n\t\techo (\"\\n\");\n\t}\n}", "12078": "function isPrime($n)\n{\n\tif ($n <= 1)\n\t\treturn false;\n\tif ($n <= 3)\n\t\treturn true;\n\tif ($n % 2 == 0 or $n % 3 == 0)\n\t\treturn false;\n\tfor ($i = 5; $i * $i <= $n; $i = $i + 6)\n\t{\n\t\tif ($n % $i == 0 or\n\t\t\t$n % ($i + 2) == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nfunction isPowerOfTwo($n)\n{\n\treturn ($n && !($n & ($n - 1)));\n}", "12117": "function area($a)\n{\n\tif ($a < 0)\n\t\treturn -1;\n\t$area = pow(($a * sqrt(3)) /\n\t\t\t\t(sqrt(2)), 2);\n\treturn $area;\n}", "12147": "function nthTerm($n)\n{\n\treturn 3 * pow($n, 2) -\n\t\t4 * $n + 2;\n}", "12157": "function calculateSum($n)\n{\n\treturn $n * ($n + 1) / 2 +\n\tpow(($n * ($n + 1) / 2), 2);\n}", "12170": "function findNthNo($n)\n{\n\t$res = \"\";\n\twhile ($n >= 1)\n\t{\n\t\tif ($n & 1)\n\t\t{\n\t\t\t$res = $res + \"3\";\n\t\t\t$n = ($n - 1) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$res = $res . \"5\";\n\t\t\t$n = ($n - 2) / 2;\n\t\t}\n\t}\n\t$res = strrev($res);\n\treturn $res;\n}", "12180": "function printNthElement($n)\n{\n\t$arr = array_fill(0, ($n + 1), NULL);\n\t$arr[1] = 3;\n\t$arr[2] = 5;\n\tfor ($i = 3; $i <= $n; $i++)\n\t{\n\t\tif ($i % 2 != 0)\n\t\t\t$arr[$i] = $arr[$i / 2] * 10 + 3;\n\t\telse\n\t\t\t$arr[$i] = $arr[($i / 2) - 1] * 10 + 5;\n\t}\n\treturn $arr[$n];\n}", "12185": "function arePermutations($a, $b, $n, $m)\n{\n\t$sum1 = 0; $sum2 = 0;\n\t$mul1 = 1; $mul2 = 1;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$sum1 += $a[$i];\n\t\t$mul1 *= $a[$i];\n\t}\n\tfor ($i = 0; $i < $m; $i++)\n\t{\n\t\t$sum2 += $b[$i];\n\t\t$mul2 *= $b[$i];\n\t}\n\treturn (($sum1 == $sum2) &&\n\t\t\t($mul1 == $mul2));\n}", "12191": "function nextPerfectCube($N)\n{\n\t$nextN = (int)(floor(pow($N,(1/3))) + 1);\n\treturn $nextN * $nextN * $nextN ;\n}", "12192": "function nthTerm($N)\n{\n\treturn ($N * ((int)($N / 2) +\n\t\t(($N % 2) * 2) + $N));\n}", "12225": "function Race($B, $C)\n{\n\t$result = 0;\n\t$result = (($C * 100) / $B);\n\treturn 100 - $result;\n}", "12228": "function calculateSum( $n)\n{\n\treturn (pow(2, $n + 1) + $n - 2);\n}", "12239": "function T_ime($arr, $n, $Emptypipe)\n{\n\t$fill = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$fill += 1 / $arr[$i];\n\t$fill = $fill - (1 / $Emptypipe);\n\treturn 1 / $fill;\n}", "12261": "function isPrime($n)\n{\n\t$c = 0;\n\tfor ($i = 1; $i < $n / 2; $i++)\n\t{\n\t\tif ($n % $i == 0)\n\t\t\t$c++;\n\t}\n\tif ($c == 1)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\nfunction findMinNum($arr, $n)\n{\n\t$first = 0; $last = 0;\n\t$num; $rev ; $i;\n\t$hash = array_fill(0, 20, 0);\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$hash[$arr[$i]]++;\n\t}\n\techo \"Minimum number: \";\n\tfor ( $i = 0; $i <= 9; $i++)\n\t{\n\t\tfor ($j = 0; $j < $hash[$i]; $j++)\n\t\t\techo $i;\n\t}\n\tfor ($i = 0; $i <= 9; $i++)\n\t{\n\t\tif ($hash[$i] != 0)\n\t\t{\n\t\t\t$first = $i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor ($i = 9; $i >= 0; $i--)\n\t{\n\t\tif ($hash[$i] != 0)\n\t\t{\n\t\t\t$last = $i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t$num = $first * 10 + $last;\n\t$rev = $last * 10 + $first;\n\techo \"\\nPrime combinations: \";\n\tif (isPrime($num) && isPrime($rev))\n\t\techo $num. \" \" . $rev;\n\telse if (isPrime($num))\n\t\techo $num;\n\telse if (isPrime($rev))\n\t\techo $rev;\n\telse\n\t\techo \"No combinations exist\";\n}", "12264": "function check($n)\n{\n\t$sum = 0;\n\twhile ($n != 0)\n\t{\n\t\t$sum += $n % 10;\n\t\t$n = (int)($n / 10);\n\t}\n\tif ($sum % 7 == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "12314": "function isPrime($n)\n{\n\tglobal $N;\n\tif ($n <= 1)\n\t\treturn false;\n\tif ($n <= 3)\n\t\treturn true;\n\tif ($n % 2 == 0 $n % 3 == 0)\n\t\treturn false;\n\tfor ($i = 5; $i * $i <= $n; $i = $i + 6)\n\t\tif ($n % $i == 0 ||\n\t\t\t$n % ($i + 2) == 0)\n\t\t\treturn false;\n\treturn true;\n}\nfunction SumOfPrimeDivisors($n)\n{\n\t$sum = 0;\n\tfor ($i = 1; $i <= $n; $i++)\n\t{\n\t\tif ($n % $i == 0)\n\t\t{\n\t\t\tif (isPrime($i))\n\t\t\t\t$sum += $i;\n\t\t}\n\t}\n\treturn $sum;\n}", "12315": "function Sum($N)\n{\n\tfor($i = 0; $i <= $N; $i++)\n\t\t$SumOfPrimeDivisors[$i] = 0;\n\tfor ($i = 2; $i <= $N; ++$i)\n\t{\n\t\tif (!$SumOfPrimeDivisors[$i])\n\t\t{\n\t\t\tfor ($j = $i; $j <= $N; $j += $i)\n\t\t\t{\n\t\t\t\t$SumOfPrimeDivisors[$j] += $i;\n\t\t\t}\n\t\t}\n\t}\n\treturn $SumOfPrimeDivisors[$N];\n}", "12333": "function findNthNonSquare($n)\n{\n\t$x = $n;\n\t$ans = $x + floor(0.5 + sqrt($x));\n\treturn (int)$ans;\n}", "12340": "function power($x, $y, $p)\n{\n\t$x = $x % $p;\n\twhile ($y > 0)\n\t{\n\t\tif ($y & 1)\n\t\t\t$res = ($res * $x) % $p;\n\t\t$x = ($x * $x) % $p;\n\t}\n\treturn $res;\n}", "12422": "function find_Square_369($num)\n{\n\tif ($num[0] == '3')\n\t{\n\t\t$a = '1';\n\t\t$b = '0';\n\t\t$c = '8';\n\t\t$d = '9';\n\t}\n\telse if ($num[0] == '6')\n\t{\n\t\t$a = '4';\n\t\t$b = '3';\n\t\t$c = '5';\n\t\t$d = '6';\n\t}\n\telse\n\t{\n\t\t$a = '9';\n\t\t$b = '8';\n\t\t$c = '0';\n\t\t$d = '1';\n\t}\n\t$result = \"\";\n\t$size = strlen($num);\n\tfor ($i = 1; $i < $size; $i++)\n\t\t$result = $result.$a;\n\t$result = $result.$b;\n\tfor ($i = 1; $i < $size; $i++)\n\t\t$result = $result.$c;\n\t$result = $result.$d;\n\treturn $result;\n}", "12430": "", "12439": "function findpos($n)\n{\n\t$pos = 0;\n\tfor ($i = 0; isset($n[$i]) != NULL; $i++)\n\t{\n\t\tswitch ($n[$i])\n\t\t{\n\t\t\tcase '2':\n\t\t\t\t$pos = $pos * 4 + 1;\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\t\t\t$pos = $pos * 4 + 2;\n\t\t\t\tbreak;\n\t\t\tcase '5':\n\t\t\t\t$pos = $pos * 4 + 3;\n\t\t\t\tbreak;\n\t\t\tcase '7':\n\t\t\t\t$pos = $pos * 4 + 4;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn $pos;\n}", "12462": "function fact($n)\n{\n\tif ($n == 0 $n == 1)\n\t\treturn 1;\n\t$ans = 1;\n\tfor ($i = 1 ; $i <= $n; $i++)\n\t\t$ans = $ans * $i;\n\treturn $ans;\n}\nfunction nCr($n, $r)\n{\n\t$Nr = $n ; $Dr = 1 ; $ans = 1;\n\tfor ($i = 1 ; $i <= $r ; $i++ )\n\t{\n\t\t$ans = ($ans * $Nr) /\n\t\t\t\t\t($Dr);\n\t\t$Nr--;\n\t\t$Dr++;\n\t}\n\treturn $ans ;\n}\nfunction solve ( $n )\n{\n\t$N = 2* $n - 2 ;\n\t$R = $n - 1 ;\n\treturn nCr ($N, $R) *\n\t\tfact($n - 1) ;\n}", "12485": "function gcd($a, $b)\n{\n\tif ($a == 0)\n\t\treturn $b;\n\treturn gcd($b % $a, $a);\n}\nfunction coprime($a, $b)\n{\n\treturn (gcd($a, $b) == 1);\n}\nfunction possibleTripletInRange($L, $R)\n{\n\t$flag = false;\n\t$possibleA;\n\t$possibleB;\n\t$possibleC;\n\tfor ($a = $L; $a <= $R; $a++)\n\t{\n\t\tfor ($b = $a + 1; $b <= $R; $b++)\n\t\t{\n\t\t\tfor ( $c = $b + 1; $c <= $R; $c++)\n\t\t\t{\n\t\t\t\tif (coprime($a, $b) &&\n\t\t\t\t\tcoprime($b, $c) &&\n\t\t\t\t!coprime($a, $c))\n\t\t\t\t{\n\t\t\t\t\t$flag = true;\n\t\t\t\t\t$possibleA = $a;\n\t\t\t\t\t$possibleB = $b;\n\t\t\t\t\t$possibleC = $c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif ($flag == true)\n\t{\n\t\techo \"(\" ,$possibleA , \", \" , $possibleB, \", \" , $possibleC , \")\",\n\t\t\t\" is one such possible triplet between \",\n\t\t\t$L , \" and \" , $R , \"\\n\";\n\t}\n\telse\n\t{\n\t\techo \"No Such Triplet exists between \",\n\t\t\t\t\t$L , \" and \" , $R , \"\\n\";\n\t}\n}", "12496": "function possibleToReach($a, $b)\n{\n\t$c =($a * $b);\n\t$re1 = $a / $c;\n\t$re2 = $b / $c;\n\tif (($re1 * $re1 * $re2 == $a) &&\n\t\t($re2 * $re2 * $re1 == $b))\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}", "12520": "function isUndulating($n)\n{\n\tif (strlen($n) <= 2)\n\t\treturn false;\n\tfor ($i = 2; $i < strlen($n); $i++)\n\t\tif ($n[$i - 2] != $n[$i])\n\t\t\tfalse;\n\treturn true;\n}", "12523": "function pythagoreanTriplet($n)\n{\n\tfor ( $i = 1; $i <= $n / 3; $i++)\n\t{\n\t\tfor ( $j = $i + 1; $j <= $n / 2; $j++)\n\t\t{\n\t\t\t$k = $n - $i - $j;\n\t\t\tif ($i * $i + $j * $j == $k * $k)\n\t\t\t{\n\t\t\t\techo $i , \", \", $j ,\", \", $k;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\techo \"No Triplet\";\n}", "12532": "function factorial($n)\n{\n\t$f = 1;\n\tfor ($i = 2; $i <= $n; $i++)\n\t\t$f *= $i;\n\treturn $f;\n}\nfunction series($A, $X, $n)\n{\n\t$nFact = factorial($n);\n\tfor ($i = 0; $i < $n + 1; $i++)\n\t{\n\t\t$niFact = factorial($n - $i);\n\t\t$iFact = factorial($i);\n\t\t$aPow = pow($A, $n - $i);\n\t\t$xPow = pow($X, $i);\n\t\techo ($nFact * $aPow * $xPow) /\n\t\t\t($niFact * $iFact) , \" \";\n\t}\n}", "12533": "function series($A, $X, $n)\n{\n\t$term = pow($A, $n);\n\techo $term , \" \";\n\tfor ($i = 1; $i <= $n; $i++)\n\t{\n\t\t$term = $term * $X * ($n - $i + 1) /\n\t\t\t\t\t\t\t\t($i * $A);\n\t\techo $term , \" \";\n\t}\n}", "12547": "function seiresSum($n, $a)\n{\n\t$res = 0;\n\tfor ( $i = 0; $i < 2 * $n; $i++)\n\t{\n\t\tif ($i % 2 == 0)\n\t\t\t$res += $a[$i] * $a[$i];\n\t\telse\n\t\t\t$res -= $a[$i] * $a[$i];\n\t}\n\treturn $res;\n}", "12548": "function seiresSum( $n, $a)\n{\n\treturn $n * ($a[0] * $a[0] - $a[2 * $n - 1] * $a[2 * $n - 1]) /\n\t\t\t\t(2 * $n - 1);\n}", "12550": "function checkdigit($n, $k)\n{\n\twhile ($n)\n\t{\n\t\t$rem = $n % 10;\n\t\tif ($rem == $k)\n\t\t\treturn 1;\n\t\t$n = $n / 10;\n\t}\n\treturn 0;\n}\nfunction findNthNumber($n, $k)\n{\n\tfor ($i = $k + 1, $count = 1; $count < $n; $i++)\n\t{\n\t\tif (checkdigit($i, $k) ||\n\t\t\t\t\t($i % $k == 0))\n\t\t\t$count++;\n\t\tif ($count == $n)\n\t\treturn $i;\n\t}\n\treturn -1;\n}", "12561": "function power($n, $r)\n{\t\t\n\t$count = 0;\n\tfor ($i = $r; ($n / $i) >= 1; $i = $i * $r)\n\t\t$count += $n / $i;\n\treturn $count;\n}", "12564": "function digitNumber($n)\n{\n\tglobal $mod;\n\tif ($n == 0)\n\t\treturn 1;\n\tif ($n == 1)\n\t\treturn 9;\n\tif ($n % 2 != 0)\n\t{\n\t\t$temp = digitNumber(($n - 1) / 2) % $mod;\n\t\treturn (9 * ($temp * $temp) % $mod) % $mod;\n\t}\n\telse\n\t{\n\t\t$temp = digitNumber($n / 2) % $mod;\n\t\treturn ($temp * $temp) % $mod;\n\t}\n}\nfunction countExcluding($n, $d)\n{\n\tglobal $mod;\n\tif ($d == 0)\n\t\treturn (9 * digitNumber($n - 1)) % $mod;\n\telse\n\t\treturn (8 * digitNumber($n - 1)) % $mod;\n}", "12587": "function Div_by_8($n)\n{\n\treturn ((($n >> 3) << 3) == $n);\n}", "12603": "function avg_of_odd_num($n)\n{\n\t$sum = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$sum += (2 * $i + 1);\n\treturn $sum / $n;\n}", "12604": "function avg_of_odd_num($n)\n{\n\treturn $n;\n}", "12615": "function fib(&$f, $N)\n{\n\t$f[1] = 1;\n\t$f[2] = 1;\n\tfor ($i = 3; $i <= $N; $i++)\n\t\t$f[$i] = $f[$i - 1] +\n\t\t\t\t$f[$i - 2];\n}\nfunction fiboTriangle($n)\n{\n\t$N = $n * ($n + 1) / 2;\n\t$f = array();\n\tfib($f, $N);\n\t$fiboNum = 1;\n\tfor ($i = 1; $i <= $n; $i++)\n\t{\n\t\tfor ($j = 1;$j <= $i; $j++)\n\t\t\techo ($f[$fiboNum++] . \" \");\n\t\techo(\"\\n\");\n\t}\n}", "12638": "function averageEven( $n)\n{\n\tif ($n % 2 != 0)\n\t{\n\t\techo(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\t$sum = 0;\n\t$count = 0;\n\twhile ($n >= 2)\n\t{\n\t\t$count++;\n\t\t$sum += $n;\n\t\t$n = $n - 2;\n\t}\n\treturn $sum / $count;\n}", "12639": "function averageEven( $n)\n{\n\tif ($n % 2 != 0)\n\t{\n\t\techo(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\treturn ($n + 2) / 2;\n}", "12645": "function averageOdd($n)\n{\n\tif ($n % 2 == 0)\n\t{\n\t\techo(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\t$sum = 0;\n\t$count = 0;\n\twhile ($n >= 1)\n\t{\n\t\t$count++;\n\t\t$sum += $n;\n\t\t$n = $n - 2;\n\t}\n\treturn $sum / $count;\n}", "12646": "function averageOdd( $n)\n{\n\tif ($n % 2 == 0)\n\t{\n\t\techo(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\treturn ($n + 1) / 2;\n}", "12714": "function TrinomialValue($n, $k)\n{\n\tif ($n == 0 && $k == 0)\n\t\treturn 1;\n\tif($k < -$n $k > $n)\n\t\treturn 0;\n\treturn TrinomialValue ($n - 1, $k - 1) +\n\t\tTrinomialValue ($n - 1, $k) +\n\t\tTrinomialValue ($n - 1, $k + 1);\n}\nfunction printTrinomial($n)\n{\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = -$i; $j <= 0; $j++)\n\t\t\techo TrinomialValue($i, $j), \" \";\n\t\tfor ($j = 1; $j <= $i; $j++)\n\t\t\techo TrinomialValue($i, $j) , \" \";\n\t\techo \"\\n\";\n\t}\n}", "12715": "function TrinomialValue($dp, $n, $k)\n{\n\tif ($k < 0)\n\t\t$k = -$k;\n\tif ($dp[$n][$k] != 0)\n\t\treturn $dp[$n][$k];\n\tif ($n == 0 && $k == 0)\n\t\treturn 1;\n\tif($k < -$n $k > $n)\n\t\treturn 0;\n\treturn ($dp[$n][$k] = TrinomialValue($dp, $n - 1, $k - 1) +\n\t\t\t\t\t\tTrinomialValue($dp, $n - 1, $k) +\n\t\t\t\t\t\tTrinomialValue($dp, $n - 1, $k + 1));\n}\nfunction printTrinomial($n)\n{\n\tglobal $MAX;\n\t$dp;\n\tfor ($i = 0; $i < $MAX; $i++)\n\tfor ($j = 0; $j < $MAX; $j++)\n\t\t$dp[$i][$j] = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\tfor ($j = -$i; $j <= 0; $j++)\n\t\t\techo TrinomialValue($dp, $i, $j).\" \";\n\t\tfor ($j = 1; $j <= $i; $j++)\n\t\t\techo TrinomialValue($dp, $i, $j).\" \";\n\t\techo \"\\n\";\n\t}\n}", "12716": "function Series($n)\n{\n\t$i;\n\t$sums = 0;\n\tfor ($i = 1; $i <= $n; $i++)\n\t\t$sums += ($i * $i);\n\treturn $sums;\n}", "12745": "function isPrime($n)\n{\n\tif ($n <= 1)\n\t\treturn -1;\n\tfor ($i = 2; $i < $n; $i++)\n\t\tif ($n % $i == 0)\n\t\t\treturn -1;\n\treturn 1;\n}\nfunction isEmirp($n)\n{\n\tif (isPrime($n) == -1)\n\t\treturn -1;\n\t$rev = 0;\n\twhile ($n != 0)\n\t{\n\t\t$d = $n % 10;\n\t\t$rev = $rev * 10 + $d;\n\t\t$n /= 10;\n\t}\n\treturn isPrime($rev);\n}", "12747": "function sumOfLargePrimeFactor($n)\n{\n\t$prime=array_fill(0,$n+1,0);\n\t$sum = 0;\n\t$max = (int)($n / 2);\n\tfor ($p=2; $p<=$max; $p++)\n\t{\n\t\tif ($prime[$p] == 0)\n\t\t{\n\t\t\tfor ($i=$p*2; $i<=$n; $i += $p)\n\t\t\t\t$prime[$i] = $p;\n\t\t}\n\t}\n\tfor ($p=2; $p<=$n; $p++)\n\t{\n\t\tif ($prime[$p])\n\t\t\t$sum += $prime[$p];\n\t\telse\n\t\t\t$sum += $p;\n\t}\n\treturn $sum;\t\n}", "12750": "function gcd($a, $b)\n{\n\tif ($a == 0 $b == 0)\n\t\treturn 0;\n\tif ($a == $b)\n\t\treturn $a;\n\tif ($a > $b)\n\t\treturn gcd($a - $b, $b);\n\treturn gcd($a, $b - $a);\n}\nfunction cpFact( $x, $y)\n{\n\twhile (gcd($x, $y) != 1)\n\t{\n\t\t$x = $x / gcd($x, $y);\n\t}\n\treturn $x;\n}", "12764": "function counLastDigitK($low, $high, $k)\n{\n\t$count = 0;\n\tfor ($i = $low; $i <= $high; $i++)\n\t\tif ($i % 10 == $k)\n\t\t\t$count++;\n\treturn $count;\n}", "12794": "function Convert($radian)\n{\n\t$pi = 3.14159;\n\treturn($radian * (180 / $pi));\n}", "12799": "function sn($n, $an)\n{\n\treturn ($n * (1 + $an)) / 2;\n}\nfunction trace($n, $m)\n{\n\t$an = 1 + ($n - 1) * ($m + 1);\n\t$rowmajorSum = sn($n, $an);\n\t$an = 1 + ($n - 1) * ($n + 1);\n\t$colmajorSum = sn($n, $an);\n\treturn $rowmajorSum + $colmajorSum;\n}", "12810": "function avgOfFirstN($n)\n{\n\treturn (float)(1 + $n) / 2;\n}", "12842": "function sum($L, $R)\n{\n\t$p = intval($R / 6);\n\t$q = intval(($L - 1) / 6);\n\t$sumR = intval(3 * ($p * ($p + 1)));\n\t$sumL = intval(($q * ($q + 1)) * 3);\n\treturn $sumR - $sumL;\n}", "12844": "function max_area($n, $m, $k)\n{\n\tif ($k > ($n + $m - 2))\n\t\techo \"Not possible\" ,\"\\n\";\n\telse\n\t{\n\t\t$result;\n\t\tif ($k < max($m, $n) - 1)\n\t\t{\n\t\t\t$result = max($m * ($n / ($k + 1)),\n\t\t\t\t\t\t$n * ($m / ($k + 1)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$result = max($m / ($k - $n + 2),\n\t\t\t\t\t\t$n / ($k - $m + 2));\n\t\t}\n\techo $result ,\"\\n\";\n\t}\n}", "12855": "function prevNum( $str)\n{\n\t$len = strlen($str);\n\t$index = -1;\n\tfor ($i = $len - 2; $i >= 0; $i--)\n\t{\n\t\tif ($str[$i] > $str[$i + 1])\n\t\t{\n\t\t\t$index = $i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t$smallGreatDgt = -1;\n\tfor ($i = $len - 1; $i > $index; $i--)\n\t{\n\t\tif ($str[$i] < $str[$index])\n\t\t{\n\t\t\tif ($smallGreatDgt == -1)\n\t\t\t\t$smallGreatDgt = $i;\n\t\t\telse if ($str[$i] >= $str[$smallGreatDgt])\n\t\t\t\t$smallGreatDgt = $i;\n\t\t}\n\t}\n\tif ($index == -1)\n\t\treturn \"-1\";\n\tif ($smallGreatDgt != -1)\n\t{\n\t\tlist($str[$index], $str[$smallGreatDgt]) = array($str[$smallGreatDgt], $str[$index]);\n\t\treturn $str;\n\t}\n\treturn \"-1\";\n}", "12891": "function calculate_sum($a, $N)\n{\n\t$m = $N / $a;\n\t$sum = $m * ($m + 1) / 2;\n\t$ans = $a * $sum;\n\treturn $ans;\n}", "12895": "function horner( $poly, $n, $x)\n{\n\t$result = $poly[0];\n\tfor ($i = 1; $i < $n; $i++)\n\t\t$result = $result * $x + $poly[$i];\n\treturn $result;\n}\nfunction findSign($poly, $n, $x)\n{\n\t$result = horner($poly, $n, $x);\n\tif ($result > 0)\n\t\treturn 1;\n\telse if ($result < 0)\n\t\treturn -1;\n\treturn 0;\n}", "12905": "function isPowerOf2($str)\n{\n\t$len_str = strlen($str);\n\t$num = 0;\n\tif ($len_str == 1 && $str[$len_str - 1] == '1')\n\t\treturn 0;\n\twhile ($len_str != 1 $str[$len_str - 1] != '1')\n\t{\n\t\tif (ord($str[$len_str - 1] - '0') % 2 == 1)\n\t\t\treturn 0;\n\t\t$j=0;\n\t\tfor ($i = 0; $i < $len_str; $i++)\n\t\t{\n\t\t\t$num = $num * 10 + (ord($str[$i]) - ord('0'));\n\t\t\tif ($num < 2)\n\t\t\t{\n\t\t\t\tif ($i != 0)\n\t\t\t\t\t$str[$j++] = '0';\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$str[$j++] = chr((int)($num / 2) + ord('0'));\n\t\t\t$num = ($num) - (int)($num / 2) * 2;\n\t\t}\n\t\t$len_str = $j;\n\t}\n\treturn 1;\n}", "12906": "function ispowerof2 ( $num )\n{\n\tif (($num & ($num - 1 )) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "12970": "function counDivisors($X)\n{\n\t$count = 0;\n\tfor ($i = 1; $i <= $X; ++$i) {\n\t\tif ($X % $i == 0) {\n\t\t\t$count++;\n\t\t}\n\t}\n\treturn $count;\n}\nfunction countDivisorsMult($arr, $n)\n{\n\t$mul = 1;\n\tfor ($i = 0; $i < $n; ++$i)\n\t\t$mul *= $arr[$i];\n\treturn counDivisors($mul);\n}", "12983": "function printTaxicab2($N)\n{\n\t$i = 1; $count = 0;\n\twhile ($count < $N)\n\t{\n\t\t$int_count = 0;\n\t\tfor ($j = 1; $j <= pow($i, 1.0/3); $j++)\n\t\t\tfor ( $k = $j + 1; $k <= pow($i, 1.0/3); $k++)\n\t\t\t\tif ($j * $j * $j + $k * $k * $k == $i)\n\t\t\t\t\t$int_count++;\n\t\tif ($int_count == 2)\n\t\t{\n\t\t\t$count++;\n\t\t\techo $count, \" \", $i, \"\\n\";\n\t\t}\n\t\t$i++;\n\t}\n}", "12991": "function isComposite($n)\n{\n\tif ($n <= 1)\n\t\treturn false;\n\tif ($n <= 3)\n\t\treturn false;\n\tif ($n%2 == 0 $n % 3 == 0)\n\t\treturn true;\n\tfor ($i = 5; $i * $i <= $n; $i = $i + 6)\n\t\tif ($n % $i == 0 || $n % ($i + 2) == 0)\n\t\treturn true;\n\treturn false;\n}", "13022": "function area_fun($side)\n{\n\t$area = $side * $side;\n\treturn $area;\n}", "13040": "function countConsecutive($N)\n{\n\t$count = 0;\n\tfor ($L = 1;\n\t\t$L * ($L + 1) < 2 * $N; $L++)\n\t{\n\t\t$a = (int)(1.0 * $N - ($L *\n\t\t\t(int)($L + 1)) / 2) / ($L + 1);\n\t\tif ($a - (int)$a == 0.0)\n\t\t\t$count++;\n\t}\n\treturn $count;\n}", "13048": "function isPrime($n)\n{\n\tif ($n <= 1)\n\t\treturn false;\n\tfor ($i = 2; $i < $n; $i++)\n\t\tif ($n % $i == 0)\n\t\t\treturn false;\n\treturn true;\n}\nfunction findPrime($n)\n{\n\t$num = $n + 1;\n\twhile ($num)\n\t{\n\t\tif (isPrime($num))\n\t\t\treturn $num;\n\t\t$num = $num + 1;\n\t}\n\treturn 0;\n}\nfunction minNumber($arr, $n)\n{\n\t$sum = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$sum += $arr[$i];\n\tif (isPrime($sum))\n\t\treturn 0;\n\t$num = findPrime($sum);\n\treturn $num - $sum;\n}", "13049": "function sieveOfEratostheneses()\n{\n\t$isPrime = array_fill(true,$MAX, NULL);\n\t$isPrime[1] = false;\n\tfor ($i = 2; $i * $i < $MAX; $i++) \n\t{\n\t\tif ($isPrime[$i]) \n\t\t{\n\t\t\tfor ($j = 2 * $i; $j < $MAX; $j += $i)\n\t\t\t\t$isPrime[$j] = false;\n\t\t}\n\t}\n}\nfunction findPrime($n)\n{\n\t$num = $n + 1;\n\twhile ($num) \n\t{\n\t\tif ($isPrime[$num])\n\t\t\treturn $num;\n\t\t$num = $num + 1;\n\t}\n\treturn 0;\n}\nfunction minNumber(&$arr, $n)\n{\n\tsieveOfEratostheneses();\n\t$sum = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$sum += $arr[$i];\n\tif ($isPrime[$sum])\n\t\treturn 0;\n\t$num = findPrime($sum);\n\treturn $num - $sum;\n}", "13140": "function fact($n)\n{\n\tif ($n == 0)\n\t\treturn 1;\n\treturn $n * fact($n - 1);\n}\nfunction div($x)\n{\n\t$ans = 0;\n\tfor ($i = 1; $i<= $x; $i++)\n\t\tif ($x % $i == 0)\n\t\t\t$ans += $i;\n\treturn $ans;\n}\nfunction sumFactDiv($n)\n{\n\treturn div(fact($n));\n}", "13141": "function sieve($n)\n{\n\tglobal $allPrimes;\n\t$prime=array_fill(0,$n+1,true);\n\tfor ($p = 2; $p*$p <= $n; $p++)\n\t{\n\t\tif ($prime[$p] == true)\n\t\t{\n\t\t\tfor ($i = $p*2; $i <= $n; $i += $p)\n\t\t\t\t$prime[$i] = false;\n\t\t}\n\t}\n\tfor ($p = 2; $p <= $n; $p++)\n\t\tif ($prime[$p])\n\t\t\tarray_push($allPrimes,$p);\n}\nfunction factorialDivisors($n)\n{\n\tglobal $allPrimes;\n\t$result = 1;\n\tfor ($i = 0; $i < count($allPrimes); $i++)\n\t{\n\t\t$p = $allPrimes[$i];\n\t\t$exp = 0;\n\t\twhile ($p <= $n)\n\t\t{\n\t\t\t$exp = $exp + (int)($n/$p);\n\t\t\t$p = $p*$allPrimes[$i];\n\t\t}\n\t\t$result = $result*(pow($allPrimes[$i], $exp+1)-1)/\n\t\t\t\t\t\t\t\t\t($allPrimes[$i]-1);\n\t}\n\treturn $result;\n}", "13144": "function isAutomorphic($N)\n{\n\t$sq = $N * $N;\n\twhile ($N > 0)\n\t{\n\t\tif ($N % 10 != $sq % 10)\n\t\t\treturn -1;\n\t\t$N /= 10;\n\t\t$sq /= 10;\n\t}\n\treturn 1;\n}", "13179": "function checkPandigital($b, $n)\n{\n\tif (strlen($n) < $b)\n\t\treturn 0;\n\t$hash = array();\n\tfor($i = 0; $i< $b; $i++)\n\t$hash[$i] = 0;\n\tfor ($i = 0; $i < strlen($n); $i++)\n\t{\n\t\tif ($n[$i] >= '0' && $n[$i] <= '9')\n\t\t\t$hash[$n[$i] - '0'] = 1;\n\t\telse if (ord($n[$i]) - ord('A') <= $b - 11)\n\t\t\t$hash[ord($n[$i]) - ord('A') + 10] = 1;\n\t}\n\tfor ($i = 0; $i < $b; $i++)\n\t\tif ($hash[$i] == 0)\n\t\t\treturn 0;\n\treturn 1;\n}", "13180": "function convert($m, $n)\n{\n\tif ($m == $n)\n\t\treturn 0;\n\tif ($m > $n)\n\t\treturn $m - $n;\n\tif ($m <= 0 && $n > 0)\n\t\treturn -1;\n\tif ($n % 2 == 1)\n\t\treturn 1 + convert($m, $n + 1);\n\telse\n\t\treturn 1 + convert($m, $n / 2);\n}", "13236": "function getDigitProduct($x)\n{\n\tglobal $prodDig;\n\tif ($x < 10)\n\treturn $x;\n\tif ($prodDig[$x] != 0)\n\treturn $prodDig[$x];\n\t$prod = (int)($x % 10) *\n\t\t\t\tgetDigitProduct((int)($x / 10));\n\t$prodDig[$x] = $prod;\n\treturn $prod;\n}\nfunction findSeed($n)\n{\n\t$res = array();\n\tfor ($i = 1; $i <= (int)($n / 2 + 1); $i++)\n\t\tif ($i * getDigitProduct($i) == $n)\n\t\t\tarray_push($res, $i);\n\tif (count($res) == 0)\n\t{\n\t\techo \"NO seed exists\\n\";\n\t\treturn;\n\t}\n\tfor ($i = 0; $i < count($res); $i++)\n\t\techo $res[$i] . \" \";\n}", "13240": "function maxPrimefactorNum($N)\n{\n\t$arr[$N + 5] = array();\n\t$arr = array_fill(0, $N + 1, NULL);\n\tfor ($i = 2; ($i * $i) <= $N; $i++)\n\t{\n\t\tif (!$arr[$i])\n\t\t\tfor ($j = 2 * $i; $j <= $N; $j += $i)\n\t\t\t\t$arr[$j]++;\n\t\t$arr[$i] = 1;\n\t}\n\t$maxval = 0;\n\t$maxint = 1;\n\tfor ($i = 1; $i <= $N; $i++)\n\t{\n\t\tif ($arr[$i] > $maxval)\n\t\t{\n\t\t\t$maxval = $arr[$i];\n\t\t\t$maxint = $i;\n\t\t}\n\t}\n\treturn $maxint;\n}", "13241": "function maxPrimefactorNum($N)\n{\n\t$arr = array_fill(0, $N + 5, true);\n\tfor ($i = 3; $i * $i <= $N; $i += 2)\n\t{\n\t\tif ($arr[$i])\n\t\t\tfor ($j = $i * $i; $j <= $N; $j += $i)\n\t\t\t\t$arr[$j] = false;\n\t}\n\t$prime = array();\n\tarray_push($prime, 2);\n\tfor($i = 3; $i <= $N; $i += 2)\n\t\tif($arr[$i])\n\t\t\tarray_push($prime, $i);\n\t$i = 0;\n\t$ans = 1;\n\twhile ($ans * $prime[$i] <= $N &&\n\t\t\t\t$i < count($prime))\n\t{\n\t\t$ans *= $prime[$i];\n\t\t$i++;\n\t}\n\treturn $ans;\n}", "13250": "function SubArraySum($arr, $n)\n{\n\t$result = 0;\n\t$temp=0;\n\tfor ($i = 0; $i < $n; $i++)\n\t{\n\t\t$temp=0;\n\t\tfor ($j = $i; $j < $n; $j++)\n\t\t{\n\t\t\t$temp+=$arr[$j]\n\t\t\t$result += $temp ;\n\t\t}\n\t}\n\treturn $result ;\n}", "13251": "function SubArraySum($arr , $n)\n{\n\t$result = 0;\n\tfor ($i = 0; $i < $n; $i++)\n\t\t$result += ($arr[$i] *\n\t\t\t\t\t($i + 1) *\n\t\t\t\t\t($n - $i));\n\treturn $result ;\n}", "13288": "function highestPowerof2($n)\n{\n\t$res = 0;\n\tfor ($i = $n; $i >= 1; $i--)\n\t{\n\t\tif (($i & ($i - 1)) == 0)\n\t\t{\n\t\t\t$res = $i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $res;\n}", "13290": "function highestPowerof2($n)\n{\n\t$p = (int)log($n, 2);\n\treturn (int)pow(2, $p);\n}", "13307": "function aModM($s, $mod)\n{\n\t$number = 0;\n\tfor ($i = 0; $i < strlen($s); $i++)\n\t{\n\t\t$number = ($number * 10 +\n\t\t\t\t($s[$i] - '0'));\n\t\t$number %= $mod;\n\t}\n\treturn $number;\n}\nfunction ApowBmodM($a, $b,$m)\n{\n\t$ans = aModM($a, $m);\n\t$mul = $ans;\n\tfor ($i = 1; $i < $b; $i++)\n\t\t$ans = ($ans * $mul) % $m;\n\treturn $ans;\n}", "13352": "function divSum($num)\n{\n\t$result = 0;\n\tfor ($i = 2; $i <= sqrt($num); $i++)\n\t{\n\t\tif ($num % $i == 0)\n\t\t{\n\t\t\tif ($i == ($num / $i))\n\t\t\t\t$result += $i;\n\t\t\telse\n\t\t\t\t$result += ($i + $num / $i);\n\t\t}\n\t}\n\treturn ($result + 1);\n}", "13400": "function findPairs( $n)\n{\n\t$cubeRoot = pow($n, 1.0 / 3.0);\n\t$cube = array();\n\tfor ($i = 1; $i <= $cubeRoot; $i++)\n\t\t$cube[$i] = $i * $i * $i;\n\t$l = 1;\n\t$r = $cubeRoot;\n\twhile ($l < $r)\n\t{\n\t\tif ($cube[$l] + $cube[$r] <$n)\n\t\t\t$l++;\n\t\telse if($cube[$l] + $cube[$r] > $n)\n\t\t\t$r--;\n\t\telse\n\t\t{\n\t\t\techo \"(\" , $l , \", \" , floor($r) , \")\" ;\n\t\t\t\techo \"\\n\";\n\t\t\t$l++;$r--;\n\t\t}\n\t}\n}", "13409": "function gcd($a, $b)\n{\n\twhile ($b != 0)\n\t{\n\t\t$t = $b;\n\t\t$b = $a % $b;\n\t\t$a = $t;\n\t}\n\treturn $a;\n}\nfunction findMinDiff($a, $b, $x, $y)\n{\n\t$g = gcd($a, $b);\n\t$diff = abs($x - $y) % $g;\n\treturn min($diff, $g - $diff);\n}", "13429": "function printDivisors($n)\n{\n\t$v;\n\t$t = 0;\n\tfor ($i = 1;\n\t\t$i <= (int)sqrt($n); $i++)\n\t{\n\t\tif ($n % $i == 0)\n\t\t{\n\t\t\tif ((int)$n / $i == $i)\n\t\t\t\techo $i . \" \";\n\t\t\telse\n\t\t\t{\n\t\t\t\techo $i . \" \";\n\t\t\t\t$v[$t++] = (int)$n / $i;\n\t\t\t}\n\t\t}\n\t}\n\tfor ($i = count($v) - 1; $i >= 0; $i--)\n\t\techo $v[$i] . \" \";\n}", "13431": "function printDivisors($n)\n{\n\tfor ($i = 1; $i <= $n; $i++)\n\t\tif ($n % $i == 0)\n\t\t\techo $i,\" \";\n}", "13432": "function printDivisors($n)\n{\n\tfor ($i = 1; $i <= sqrt($n); $i++)\n\t{\n\t\tif ($n%$i == 0)\n\t\t{\n\t\t\tif ($n / $i == $i)\n\t\t\t\techo $i,\" \";\n\t\t\telse\n\t\t\t\techo $i,\" \", $n/$i,\" \";\n\t\t}\n\t}\n}", "13453": "function SieveOfAtkin($limit)\n{\n\tif ($limit > 2)\n\t\techo 2 , \" \";\n\tif ($limit > 3)\n\t\techo 3 , \" \";\n\t$sieve[$limit] = 0;\n\tfor ($i = 0; $i < $limit; $i++)\n\t\t$sieve[$i] = false;\n\tfor ($x = 1; $x * $x < $limit; $x++)\n\t{\n\t\tfor ($y = 1; $y * $y < $limit; $y++)\n\t\t{\n\t\t\t$n = (4 * $x * $x) + ($y * $y);\n\t\t\tif ($n <= $limit && ($n % 12 == 1 $n % 12 == 5))\n\t\t\t\t$sieve[$n] ^= true;\n\t\t\t$n = (3 * $x * $x) + ($y * $y);\n\t\t\tif ($n <= $limit && $n % 12 == 7)\n\t\t\t\t$sieve[$n] = true;\n\t\t\t$n = (3 * $x * $x) - ($y * $y);\n\t\t\tif ($x > $y && $n <= $limit && $n % 12 == 11)\n\t\t\t\t$sieve[$n] ^= true;\n\t\t}\n\t}\n\tfor ($r = 5; $r * $r < $limit; $r++) {\n\t\tif ($sieve[$r]) {\n\t\t\tfor ($i = $r * $r; $i < $limit; $i += $r * $r)\n\t\t\t\t$sieve[$i] = false;\n\t\t}\n\t}\n\tfor ($a = 5; $a < $limit; $a++)\n\t\tif ($sieve[$a])\n\t\t\techo $a , \" \";\n}", "13454": "function SieveOfSundaram($n)\n{\n\t$nNew = ($n - 1) / 2;\n\t$marked = array_fill(0, ($nNew + 1), false);\n\tfor ($i = 1; $i <= $nNew; $i++)\n\t\tfor ($j = $i;\n\t\t\t($i + $j + 2 * $i * $j) <= $nNew; $j++)\n\t\t\t$marked[$i + $j + 2 * $i * $j] = true;\n\tif ($n > 2)\n\t\techo \"2 \";\n\tfor ($i = 1; $i <= $nNew; $i++)\n\t\tif ($marked[$i] == false)\n\t\t\techo (2 * $i + 1) . \" \";\n}", "13460": "function power($x, $y, $p)\n{\n\t$res = 1;\t\n\t$x = $x % $p;\n\twhile ($y > 0)\n\t{\n\t\tif ($y & 1)\n\t\t\t$res = ($res * $x) % $p;\n\t\t$y = $y >> 1;\n\t\t$x = ($x * $x) % $p;\n\t}\n\treturn $res;\n}\nfunction squareRoot($n, $p)\n{\n\tif ($p % 4 != 3)\n\t{\n\t\techo \"Invalid Input\";\n\t\treturn;\n\t}\n\t$n = $n % $p;\n\t$x = power($n, ($p + 1) / 4, $p);\n\tif (($x * $x) % $p == $n)\n\t{\n\t\techo \"Square root is \", $x;\n\t\treturn;\n\t}\n\t$x = $p - $x;\n\tif (($x * $x) % $p == $n)\n\t{\n\t\techo \"Square root is \", $x;\n\t\treturn;\n\t}\n\techo \"Square root doesn't exist \";\n}", "13468": "function power($x, $y, $p)\n{\n\t$res = 1;\n\t$x = $x % $p;\n\twhile ($y > 0)\n\t{\n\t\tif ($y & 1)\n\t\t\t$res = ($res*$x) % $p;\n\t\t$x = ($x*$x) % $p;\n\t}\n\treturn $res;\n}\nfunction miillerTest($d, $n)\n{\n\t$a = 2 + rand() % ($n - 4);\n\t$x = power($a, $d, $n);\n\tif ($x == 1 $x == $n-1)\n\treturn true;\n\twhile ($d != $n-1)\n\t{\n\t\t$x = ($x * $x) % $n;\n\t\t$d *= 2;\n\t\tif ($x == 1)\treturn false;\n\t\tif ($x == $n-1) return true;\n\t}\n\treturn false;\n}\nfunction isPrime( $n, $k)\n{\n\tif ($n <= 1 $n == 4) return false;\n\tif ($n <= 3) return true;\n\t$d = $n - 1;\n\twhile ($d % 2 == 0)\n\t\t$d /= 2;\n\tfor ($i = 0; $i < $k; $i++)\n\t\tif (!miillerTest($d, $n))\n\t\t\treturn false;\n\treturn true;\n}", "13489": "function isInside($circle_x, $circle_y, $rad, $x, $y)\n{\n\tif (($x - $circle_x) * ($x - $circle_x) +\n\t\t($y - $circle_y) * ($y - $circle_y) <= $rad * $rad)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "13501": "function eval1($a, $op, $b)\n{\n\tif ($op == '+') return $a + $b;\n\tif ($op == '-') return $a - $b;\n\tif ($op == '*') return $a * $b;\n}\nfunction eval1uateAll($expr, $low, $high)\n{\n\t$res = array();\n\tif ($low == $high)\n\t{\n\t\tarray_push($res, ord($expr[$low]) -\n\t\t\t\t\t\tord('0'));\n\t\treturn $res;\n\t}\n\tif ($low == ($high - 2))\n\t{\n\t\t$num = eval1(ord($expr[$low]) -\n\t\t\t\t\tord('0'), $expr[$low + 1],\n\t\t\t\t\tord($expr[$low + 2]) -\n\t\t\t\t\tord('0'));\n\t\tarray_push($res, $num);\n\t\treturn $res;\n\t}\n\tfor ($i = $low + 1; $i <= $high; $i += 2)\n\t{\n\t\t$l = eval1uateAll($expr, $low, $i - 1);\n\t\t$r = eval1uateAll($expr, $i + 1, $high);\n\t\tfor ($s1 = 0; $s1 < count($l); $s1++)\n\t\t{\n\t\t\tfor ($s2 = 0; $s2 < count($r); $s2++)\n\t\t\t{\n\t\t\t\t$val = eval1($l[$s1], $expr[$i], $r[$s2]);\n\t\t\t\tarray_push($res, $val);\n\t\t\t}\n\t\t}\n\t}\n\treturn $res;\n}", "13504": "function isLucky($n)\n{\n\t$arr = array();\n\tfor ($i = 0; $i < 10; $i++)\n\t\t$arr[$i] = false;\n\twhile ($n > 0)\n\t{\n\t\t$digit = $n % 10;\n\t\tif ($arr[$digit])\n\t\treturn false;\n\t\t$arr[$digit] = true;\n\t\t$n = (int)($n / 10);\n\t}\n\treturn true;\n}", "13535": "function printSquares($n)\n{\n\t$square = 0; $odd = 1;\n\tfor ($x = 0; $x < $n; $x++)\n\t{\n\t\techo $square , \" \";\n\t\t$square = $square + $odd;\n\t\t$odd = $odd + 2;\n\t}\n}", "13575": "function reversDigits($num)\n{\n\tglobal $rev_num;\n\tglobal $base_pos;\n\tif($num > 0)\n\t{\n\t\treversDigits((int)($num / 10));\n\t\t$rev_num += ($num % 10) *\n\t\t\t\t\t$base_pos;\n\t\t$base_pos *= 10;\n\t}\n\treturn $rev_num;\n}", "13757": "function hammingDistance($n1, $n2)\n{\n\t$x = $n1 ^ $n2;\n\t$setBits = 0;\n\twhile ($x > 0)\n\t{\n\t\t$setBits += $x & 1;\n\t\t$x >>= 1;\n\t}\n\treturn $setBits;\n}", "13829": "function printSubsets($n)\n{\nfor ($i = 0; $i <= $n; $i++)\n\tif (($n & $i) == $i)\n\techo $i.\" \";\n}", "13830": "function printSubsets($n)\n{\n\tfor ($i = $n; $i > 0;\n\t\t$i = ($i - 1) & $n)\n\t\techo $i.\" \";\n\techo \"0\";\n}", "13875": "function isDivisibleby17($n)\n{\n\tif ($n == 0 $n == 17)\n\t\treturn true;\n\tif ($n < 17)\n\t\treturn false;\n\treturn isDivisibleby17((int)($n >> 4) -\n\t\t\t\t\t\t\t(int)($n & 15));\n}", "13876": "function answer( $n)\n{\n\t$m = 2;\n\t$ans = 1;\n\t$r = 1;\n\twhile ($r < $n)\n\t{\n\t\t$r = (pow(2, $m) - 1) *\n\t\t\t(pow(2, $m - 1));\n\t\tif ($r < $n)\n\t\t\t$ans = $r;\n\t\t$m++;\n\t}\n\treturn $ans;\n}", "13897": "function setBitNumber($n)\n{\n\tif ($n == 0)\n\t\treturn 0;\n\t$msb = 0;\n\t\t$n = $n / 2;\n\twhile ($n != 0)\n\t{\n\t\t$n = $n / 2;\n\t\t$msb++;\n\t}\n\treturn (1 << $msb);\n}", "13898": "function setBitNumber($n)\n{\n\t$n |= $n >> 1;\n\t$n |= $n >> 2;\n\t$n |= $n >> 4;\n\t$n |= $n >> 8;\n\t$n |= $n >> 16;\n\t$n = $n + 1;\n\treturn ($n >> 1);\n}", "13899": "function setBitNumber($n)\n{\n\t$k =(int)(log($n, 2));\n\treturn 1 << $k;\n}", "13966": "function countTrailingZero($x)\n{\n\t$count = 0;\n\twhile (($x & 1) == 0)\n\t{\n\t\t$x = $x >> 1;\n\t\t$count++;\n\t}\n\treturn $count;\n}", "13967": "function countTrailingZero($x)\n{\n\t$lookup = array (32, 0, 1, 26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11, 0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19, 18);\n\treturn $lookup[(-$x & $x) % 37];\n}", "13987": "function maxConsecutiveOnes($x)\n{\n\t$count = 0;\n\twhile ($x != 0)\n\t{\n\t\t$x = ($x & ($x << 1));\n\t\t$count++;\n\t}\n\treturn $count;\n}", "14020": "function multiplyBySevenByEight( $n)\n{\n\treturn ($n - ($n >> 3));\n}", "14021": "function multiplyBySevenByEight( $n)\n{\n\treturn (($n << 3) -$n) >> 3;\n}", "14022": "function subtract($x, $y)\n{\n\twhile ($y != 0)\n\t{\n\t\t$borrow = (~$x) & $y;\n\t\t$x = $x ^ $y;\n\t\t$y = $borrow << 1;\n\t}\n\treturn $x;\n}", "14023": "function subtract($x, $y)\n{\n\tif ($y == 0)\n\t\treturn $x;\n\treturn subtract($x ^ $y,\n\t\t\t\t(~$x & $y) << 1);\n}"}, "C": {"821": "void Kroneckerproduct(int A[][cola], int B[][colb])\n{\n\tint C[rowa * rowb][cola * colb];\n\tfor (int i = 0; i < rowa; i++) {\n\t\tfor (int k = 0; k < rowb; k++) {\n\t\t\tfor (int j = 0; j < cola; j++) {\n\t\t\t\tfor (int l = 0; l < colb; l++) {\n\t\t\t\t\tC[i + l + 1][j + k + 1] = A[i][j] * B[k][l];\n\t\t\t\t\tprintf(\"%d\\t\", C[i + l + 1][j + k + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}", "1344": "bool areElementsContiguous(int arr[], int n)\n{\n\tsort(arr, arr+n);\n\tfor (int i = 1; i < n; i++)\n\t\tif (arr[i] - arr[i-1] > 1)\n\t\t\treturn false;\n\treturn true;\n}", "1428": "void leftRotatebyOne(int arr[], int n)\n{\n\tint temp = arr[0], i;\n\tfor (i = 0; i < n - 1; i++)\n\t\tarr[i] = arr[i + 1];\n\tarr[n-1] = temp;\n}\nvoid leftRotate(int arr[], int d, int n)\n{\n\tint i;\n\tfor (i = 0; i < d; i++)\n\t\tleftRotatebyOne(arr, n);\n}\nvoid printArray(int arr[], int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tprintf(\"%d \", arr[i]);\n}", "1535": "int findFirstMissing(int array[], int start, int end)\n{\n\tif (start > end)\n\t\treturn end + 1;\n\tif (start != array[start])\n\t\treturn start;\n\tint mid = (start + end) / 2;\n\tif (array[mid] == mid)\n\t\treturn findFirstMissing(array, mid+1, end);\n\treturn findFirstMissing(array, start, mid);\n}", "1537": "int FindMaxSum(int arr[], int n)\n{\nint incl = arr[0];\nint excl = 0;\nint excl_new;\nint i;\nfor (i = 1; i < n; i++)\n{\n\texcl_new = (incl > excl)? incl: excl;\n\tincl = excl + arr[i];\n\texcl = excl_new;\n}\nreturn ((incl > excl)? incl : excl);\n}", "1694": "bool isMajority(int arr[], int n, int x)\n{\n\tint i;\n\tint last_index = n%2? (n/2+1): (n/2);\n\tfor (i = 0; i < last_index; i++)\n\t{\n\t\tif (arr[i] == x && arr[i+n/2] == x)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "1695": "int _binarySearch(int arr[], int low, int high, int x)\n{\n\tif (high >= low)\n\t{\n\t\tint mid = (low + high)/2; \n\t\tif ( (mid == 0 x > arr[mid-1]) && (arr[mid] == x) )\n\t\t\treturn mid;\n\t\telse if (x > arr[mid])\n\t\t\treturn _binarySearch(arr, (mid + 1), high, x);\n\t\telse\n\t\t\treturn _binarySearch(arr, low, (mid -1), x);\n\t}\n\treturn -1;\n}\nbool isMajority(int arr[], int n, int x)\n{\n\tint i = _binarySearch(arr, 0, n-1, x);\n\tif (i == -1)\n\t\treturn false;\n\tif (((i + n/2) <= (n -1)) && arr[i + n/2] == x)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "1696": "bool isMajorityElement(int arr[], int n, int key)\n{\n\tif (arr[n / 2] == key)\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "1795": "void swap(int *xp, int *yp)\n{\n\tint temp = *xp;\n\t*xp = *yp;\n\t*yp = temp;\n}\nvoid selectionSort(int arr[], int n)\n{\n\tint i, j, min_idx;\n\tfor (i = 0; i < n-1; i++)\n\t{\n\t\tmin_idx = i;\n\t\tfor (j = i+1; j < n; j++)\n\t\tif (arr[j] < arr[min_idx])\n\t\t\tmin_idx = j;\n\t\tswap(&arr[min_idx], &arr[i]);\n\t}\n}\nvoid printArray(int arr[], int size)\n{\n\tint i;\n\tfor (i=0; i < size; i++)\n\t\tprintf(\"%d \", arr[i]);\n\tprintf(\"\\n\");\n}", "1853": "int MatrixChainOrder(int p[], int n)\n{\n\tint m[n][n];\n\tint i, j, k, L, q;\n\tfor (i = 1; i < n; i++)\n\t\tm[i][i] = 0;\n\tfor (L = 2; L < n; L++) {\n\t\tfor (i = 1; i < n - L + 1; i++)\n\t\t{\n\t\t\tj = i + L - 1;\n\t\t\tm[i][j] = INT_MAX;\n\t\t\tfor (k = i; k <= j - 1; k++)\n\t\t\t{\n\t\t\t\tq = m[i][k] + m[k + 1][j]\n\t\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\t\t\tif (q < m[i][j])\n\t\t\t\t\tm[i][j] = q;\n\t\t\t}\n\t\t}\n\t}\n\treturn m[1][n - 1];\n}", "1871": "int max(int a, int b)\n{\n return (a > b) ? a : b;\n}\nint un_kp(int price[], int length[], int Max_len, int n)\n{\n\tif (n == 0 Max_len == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (length[n - 1] <= Max_len)\n\t{\n\t\tt[n][Max_len]\n\t\t\t= max(price[n - 1]\n\t\t\t\t\t+ un_kp(price, length, Max_len - length[n - 1], n),\n\t\t\t\tun_kp(price, length, Max_len, n - 1));\n\t}\n\telse\n\t{\n\t\tt[n][Max_len]\n\t\t\t= un_kp(price, length, Max_len, n - 1);\n\t}\n\treturn t[n][Max_len];\n}", "1998": "int multiply(int x, int y)\n{\n if(y == 0)\n\treturn 0;\n if(y > 0 )\n\treturn (x + multiply(x, y-1));\n if(y < 0 )\n\treturn -multiply(x, -y);\n}", "2025": "void printPascal(int n)\n{\nint arr[n][n];\nfor (int line = 0; line < n; line++)\n{\n\tfor (int i = 0; i <= line; i++)\n\t{\n\tif (line == i i == 0)\n\t\tarr[line][i] = 1;\n\telse\n\t\tarr[line][i] = arr[line-1][i-1] + arr[line-1][i];\n\tprintf(\"%d \", arr[line][i]);\n\t}\n\tprintf(\"\\n\");\n}\n}", "2026": "void printPascal(int n)\n{\nfor (int line = 1; line <= n; line++)\n{\nint C = 1; \n\tfor (int i = 1; i <= line; i++)\n\t{\nprintf(\"%d \", C); \n\tC = C * (line - i) / i;\n\t}\n\tprintf(\"\\n\");\n}\n}", "2079": "int Add(int x, int y)\n{\n\twhile (y != 0)\n\t{\n\t\tint carry = x & y; \n\t\tx = x ^ y;\n\t\ty = carry << 1;\n\t}\n\treturn x;\n}", "2080": "int Add(int x, int y)\n{\n\tif (y == 0)\n\t\treturn x;\n\telse\n\t\treturn Add( x ^ y, (x & y) << 1);\n}", "2114": "unsigned int countSetBits(unsigned int n)\n{\n\tunsigned int count = 0;\n\twhile (n) {\n\t\tcount += n & 1;\n\t\tn >>= 1;\n\t}\n\treturn count;\n}", "2120": "unsigned int countSetBitsRec(unsigned int num)\n{\n\tint nibble = 0;\n\tif (0 == num)\n\t\treturn num_to_bits[0];\n\tnibble = num & 0xf;\n\treturn num_to_bits[nibble] + countSetBitsRec(num >> 4);\n}", "2121": "int countSetBits(int N)\n{\n\tint count = 0;\n\tfor (int i = 0; i < sizeof(int) * 8; i++) {\n\t\tif (N & (1 << i))\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "2127": "bool getParity(unsigned int n)\n{\n\tbool parity = 0;\n\twhile (n)\n\t{\n\t\tparity = !parity;\n\t\tn\t= n & (n - 1);\n\t}\t\n\treturn parity;\n}", "2129": "bool isPowerOfTwo(int n)\n{\n if(n==0)\n return false;\n return (ceil(log2(n)) == floor(log2(n)));\n}", "2130": "bool isPowerOfTwo(int n)\n{\n if (n == 0)\n\treturn 0;\n while (n != 1)\n {\n\tif (n%2 != 0)\n\t\treturn 0;\n\tn = n/2;\n }\n return 1;\n}", "2132": "bool isPowerOfTwo (int x)\n{\n return x && (!(x&(x-1)));\n}", "2308": "void printTwoOdd(int arr[], int size)\n{\n int xor2 = arr[0]; \n int set_bit_no; \n int i;\n int n = size - 2;\n int x = 0, y = 0;\n for(i = 1; i < size; i++)\n\txor2 = xor2 ^ arr[i];\n set_bit_no = xor2 & ~(xor2-1);\n for(i = 0; i < size; i++)\n {\n\tif(arr[i] & set_bit_no)\n\tx = x ^ arr[i];\n\telse\n\ty = y ^ arr[i];\n }\n printf(\"\\n The two ODD elements are %d & %d \", x, y);\n}", "2310": "bool findPair(int arr[], int size, int n)\n{\n\tint i = 0; \n\tint j = 1;\n\twhile (i<size && j<size)\n\t{\n\t\tif (i != j && arr[j]-arr[i] == n)\n\t\t{\n\t\t\tprintf(\"Pair Found: (%d, %d)\", arr[i], arr[j]);\n\t\t\treturn true;\n\t\t}\n\t\telse if (arr[j]-arr[i] < n)\n\t\t\tj++;\n\t\telse\n\t\t\ti++;\n\t}\n\tprintf(\"No such pair\");\n\treturn false;\n}", "4847": "int binarySearch(int a[], int item, int low, int high)\n{\n\twhile (low <= high) {\n\t\tint mid = low + (high - low) / 2;\n\t\tif (item == a[mid])\n\t\t\treturn mid + 1;\n\t\telse if (item > a[mid])\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\treturn low;\n}\nvoid insertionSort(int a[], int n)\n{\n\tint i, loc, j, k, selected;\n\tfor (i = 1; i < n; ++i) {\n\t\tj = i - 1;\n\t\tselected = a[i];\n\t\tloc = binarySearch(a, selected, 0, j);\n\t\twhile (j >= loc) {\n\t\t\ta[j + 1] = a[j];\n\t\t\tj--;\n\t\t}\n\t\ta[j + 1] = selected;\n\t}\n}", "4855": "void insertionSort(int arr[], int n)\n{\n\tint i, key, j;\n\tfor (i = 1; i < n; i++) {\n\t\tkey = arr[i];\n\t\tj = i - 1;\n\t\twhile (j >= 0 && arr[j] > key) {\n\t\t\tarr[j + 1] = arr[j];\n\t\t\tj = j - 1;\n\t\t}\n\t\tarr[j + 1] = key;\n\t}\n}\nvoid printArray(int arr[], int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tprintf(\"%d \", arr[i]);\n\tprintf(\"\\n\");\n}", "7051": "int max(int a, int b) { return (a > b)? a : b;}\nint cutRod(int price[], int n)\n{\n int val[n+1];\n val[0] = 0;\n int i, j;\n for (i = 1; i<=n; i++)\n {\n\tint max_val = INT_MIN;\n\tfor (j = 0; j < i; j++)\n\t\tmax_val = max(max_val, price[j] + val[i-j-1]);\n\tval[i] = max_val;\n }\n return val[n];\n}", "7052": "int max(int a, int b)\n{\n return (a > b) ? a : b;\n}\nint un_kp(int price[], int length[], int Max_len, int n)\n{\n\tif (n == 0 Max_len == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (length[n - 1] <= Max_len)\n\t{\n\t\tt[n][Max_len]\n\t\t\t= max(price[n - 1]\n\t\t\t\t\t+ un_kp(price, length, Max_len - length[n - 1], n),\n\t\t\t\tun_kp(price, length, Max_len, n - 1));\n\t}\n\telse\n\t{\n\t\tt[n][Max_len]\n\t\t\t= un_kp(price, length, Max_len, n - 1);\n\t}\n\treturn t[n][Max_len];\n}", "7068": "int MatrixChainOrder(int p[], int i, int j)\n{\n\tif (i == j)\n\t\treturn 0;\n\tint k;\n\tint min = INT_MAX;\n\tint count;\n\tfor (k = i; k < j; k++)\n\t{\n\t\tcount = MatrixChainOrder(p, i, k)\n\t\t\t\t+ MatrixChainOrder(p, k + 1, j)\n\t\t\t\t+ p[i - 1] * p[k] * p[j];\n\t\tif (count < min)\n\t\t\tmin = count;\n\t}\n\treturn min;\n}", "7071": "int count( int S[], int m, int n )\n{\n\tif (n == 0)\n\t\treturn 1;\n\tif (n < 0)\n\t\treturn 0;\n\tif (m <=0 && n >= 1)\n\t\treturn 0;\n\treturn count( S, m - 1, n ) + count( S, m, n-S[m-1] );\n}", "8786": "void reverseWords(char* s)\n{\n\tchar* word_begin = NULL;\n\tchar* temp = s;\n\twhile (*temp)\n\t{\n\t\tif ((word_begin == NULL) &&\n\t\t\t\t(*temp != ' '))\n\t\t{\n\t\t\tword_begin = temp;\n\t\t}\n\t\tif (word_begin && ((*(temp + 1) == ' ') ||\n\t\t\t(*(temp + 1) == '\\0')))\n\t\t{\n\t\t\treverse(word_begin, temp);\n\t\t\tword_begin = NULL;\n\t\t}\n\t\ttemp++;\n\t} \n\treverse(s, temp - 1);\n}", "8795": "void reverse(char *str)\n{\n if (*str)\n {\n\treverse(str+1);\n\tprintf(\"%c\", *str);\n }\n}", "9290": "float Perimeter(float s, int n)\n{\n\tfloat perimeter = 1;\n\tperimeter = n * s;\n\treturn perimeter;\n}", "9291": "float area(float r)\n{\n\treturn (0.5)*(3.14)*(r * r);\n}\nfloat perimeter(float r)\n{\n\treturn (3.14)*(r);\n}", "9359": "void distance(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2)\n{\n\tfloat x1,y1,z1,d;\n\tif (a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2)\n\t{\n\t\tx1 = y1 = 0;\n\t\tz1 =-d1 / c1;\n\t\td = fabs(( c2 * z1 + d2)) / (sqrt(a2 * a2 + b2 * b2 + c2 * c2));\n\t\tprintf(\"Perpendicular distance is %f\\n\", d);\n\t}\n\telse\n\t\tprintf(\"Planes are not parallel\");\n\treturn;\n}", "9362": "void shortest_distance(float x1, float y1, float z1, float a, float b, float c, float d)\n{\n\td = fabs((a * x1 + b * y1 + c * z1 + d));\n\tfloat e = sqrt(a * a + b * b + c * c);\n\tprintf(\"Perpendicular distance is %f\", d/e);\n\t\treturn;\n}", "9457": "double Area(int b1, int b2, int h)\n{\n\treturn ((b1 + b2) / 2) * h;\n}", "12639": "int averageEven(int n)\n{\n\tif (n % 2 != 0) {\n\t\tprintf(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\treturn (n + 2) / 2;\n}", "12646": "int averageOdd(int n)\n{\n\tif (n % 2 == 0) {\n\t\tprintf(\"Invalid Input\");\n\t\treturn -1;\n\t}\n\treturn (n + 1) / 2;\n}", "12715": "int TrinomialValue(int dp[MAX][MAX], int n, int k)\n{\n\tif (k < 0)\n\t\tk = -k;\n\tif (dp[n][k] != 0)\n\t\treturn dp[n][k];\n\tif (n == 0 && k == 0)\n\t\treturn 1;\n\tif(k < -n k > n)\n\t\treturn 0;\n\treturn (dp[n][k] = TrinomialValue(dp, n - 1, k - 1)\n\t\t+ TrinomialValue(dp, n - 1, k)\n\t\t+ TrinomialValue(dp, n - 1, k + 1));\n}\nvoid printTrinomial(int n)\n{\n\tint dp[MAX][MAX] = { 0 };\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = -i; j <= 0; j++)\n\t\t\tcout << TrinomialValue(dp, i, j) << \" \";\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tcout << TrinomialValue(dp, i, j) << \" \";\n\t\tcout << endl;\n\t}\n}", "12716": "int Series(int n)\n{\n\tint i;\n\tint sums = 0;\n\tfor (i = 1; i <= n; i++)\n\t\tsums += (i * i);\n\treturn sums;\n}", "12794": "double Convert(double radian){\n\tdouble pi = 3.14159;\n\treturn(radian * (180/pi));\n}", "12905": "int isPowerOf2(char* str)\n{\n\tint len_str = strlen(str);\n\tint num = 0;\n\tif (len_str == 1 && str[len_str - 1] == '1')\n\t\treturn 0;\n\twhile (len_str != 1 str[len_str - 1] != '1') {\n\t\tif ((str[len_str - 1] - '0') % 2 == 1)\n\t\t\treturn 0;\n\t\tfor (int i = 0, j = 0; i < len_str; i++) {\n\t\t\tnum = num * 10 + str[i] - '0';\n\t\t\tif (num < 2) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tstr[j++] = '0';\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstr[j++] = (int)(num / 2) + '0';\n\t\t\tnum = (num) - (num / 2) * 2;\n\t\t}\n\t\tstr[j] = '\\0';\n\t\tlen_str = j;\n\t}\n\treturn 1;\n}", "13140": "int fact(int n) {\n\tif (n == 0)\n\t\treturn 1;\n\treturn n * fact(n - 1);\n}\nint div(int x) {\n\tint ans = 0;\n\tfor (int i = 1; i<= x; i++)\n\t\tif (x % i == 0)\n\t\t\tans += i;\n\treturn ans;\n}\nint sumFactDiv(int n) {\n\treturn div(fact(n));\n}", "13430": "void printDivisors(int n)\n{ int i;\n\tfor ( i = 1; i*i < n; i++) {\n\t\tif (n % i == 0)\n\t\t\tprintf(\"%d \", i);\n\t}\n if(i-(n/i)==1)\n\t{\n\ti--;\n\t}\n\tfor (; i >= 1; i--) {\n\t\tif (n % i == 0)\n\t\t\tprintf(\"%d \", n / i);\n\t}\n}", "13431": "void printDivisors(int n)\n{\n\tfor (int i=1;i<=n;i++)\n\t\tif (n%i==0)\n\t\t\tprintf(\"%d \",i);\n}", "13432": "void printDivisors(int n)\n{\n\tfor (int i=1; i<=sqrt(n); i++)\n\t{\n\t\tif (n%i == 0)\n\t\t{\n\t\t\tif (n/i == i)\n\t\t\t\tprintf(\"%d \", i);\n\t\t\t\tprintf(\"%d %d \", i, n/i);\n\t\t}\n\t}\n}", "13575": "int reversDigits(int num)\n{\n\tstatic int rev_num = 0;\n\tstatic int base_pos = 1;\n\tif (num > 0) {\n\t\treversDigits(num / 10);\n\t\trev_num += (num % 10) * base_pos;\n\t\tbase_pos *= 10;\n\t}\n\treturn rev_num;\n}", "14020": "int multiplyBySevenByEight(unsigned int n)\n{\n\treturn (n - (n >> 3));\n}", "14021": "int multiplyBySevenByEight(unsigned int n)\n{ \n return ((n << 3) -n) >> 3;\n}", "14022": "int subtract(int x, int y)\n{\n\twhile (y != 0)\n\t{\n\t\tint borrow = (~x) & y;\n\t\tx = x ^ y;\n\t\ty = borrow << 1;\n\t}\n\treturn x;\n}", "14023": "int subtract(int x, int y)\n{\n\tif (y == 0)\n\t\treturn x;\n\treturn subtract(x ^ y, (~x & y) << 1);\n}"}}