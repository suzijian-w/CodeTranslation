def subtract(x, y):	if (y == 0):		return x	return subtract(x ^ y, (~x & y) << 1)
def subtract(x, y):	while (y != 0):		borrow = (~x) & y		x = x ^ y		y = borrow << 1	return x
def multiplyBySevenByEight(n):	return ((n << 3) -n) >> 3;
def multiplyBySevenByEight(n):
def maxConsecutiveOnes(x):	count = 0	while (x!=0):		x = (x & (x << 1))		count=count+1	return count
def countTrailingZero(x):	lookup = [32, 0, 1, 26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11, 0, 13, 4, 7, 17, 0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19, 18]	return lookup[(-x & x) % 37]
def countTrailingZero(x):	count = 0	while ((x & 1) == 0):		x = x >> 1		count += 1	return count
def setBitNumber(n):	k = int(math.log(n, 2))	return 1 << k
def setBitNumber(n):	n |= n>>1	n |= n>>2 	n |= n>>4 	n |= n>>8	n |= n>>16	n = n + 1	return (n >> 1)
def setBitNumber(n):	if (n == 0):		return 0;	msb = 0;	n = int(n / 2);	while (n > 0):		n = int(n / 2);		msb += 1;	return (1 << msb);
def answer(n):	m = 2;	ans = 1;	r = 1;	while r < n:		r = (int)((pow(2, m) - 1) *				(pow(2, m - 1)));		if r < n:			ans = r;		m = m + 1;	return ans;
def isDivisibleby17(n):	if (n == 0 or n == 17):		return True	if (n < 17):		return False	return isDivisibleby17((int)(n >> 4) - (int)(n & 15))
def printSubsets(n):	i=n	while(i != 0):		print(i,end=" ")		i=(i - 1) & n	print("0")
def printSubsets(n):	for i in range(n + 1):		if ((n & i) == i):			print(i ," ", end = "")
def hammingDistance(n1, n2) :	x = n1 ^ n2	setBits = 0	while (x > 0) :		setBits += x & 1		x >>= 1	return setBits
def bit_q(i, j):	sum = 0	while (j > 0):		sum += bit[j]		j -= (j & (j * -1))	i -= 1	while (i > 0):		sum -= bit[i]		i -= (i & (i * -1))	return sumdef bit_up(i, diff):	while (i <= n):		bit[i] += diff		i += i & -idef dfs(node, x):	Ideal_pair = x	Ideal_pair += bit_q(max(1, node - k),						min(n, node + k))	bit_up(node, 1)	for i in range(len(al[node])):		Ideal_pair = dfs(al[node][i], Ideal_pair)	bit_up(node, -1)	return Ideal_pairdef initialise():	Ideal_pair = 0;	for i in range(n + 1):		root_node[i] = True		bit[i] = 0def Add_Edge(x, y):	al[x].append(y)	root_node[y] = Falsedef Idealpairs():	r = -1	for i in range(1, n + 1, 1):		if (root_node[i]):			r = i			break	Ideal_pair = dfs(r, 0)	return Ideal_pair
def xor_triplet(arr, n):	ans = 0;	for i in range(n):		for j in range(i + 1, n):			for k in range(j, n):				xor1 = 0; xor2 = 0;				for x in range(i, j):					xor1 ^= arr[x];				for x in range(j, k + 1):					xor2 ^= arr[x];				if (xor1 == xor2):					ans += 1;	return ans;
def cntElements(arr, n):	cnt = 0	for i in range(n - 2):		if (arr[i] == (arr[i + 1] ^ arr[i + 2])):			cnt += 1	return cnt
def extraElement(A, B, n):	ans = 0;	for i in range(n):		ans ^= A[i];	for i in range(n + 1):		ans ^= B[i];	return ans;
def RecursiveFunction(ref, bit):	if(len(ref) == 0 or bit < 0):		return 0;	curr_on = []	curr_off = []	for i in range(len(ref)):		if(((ref[i] >> bit) & 1) == 0):			curr_off.append(ref[i])		else:			curr_on.append(ref[i])	if(len(curr_off) == 0):		return RecursiveFunction(curr_on, bit - 1)	if(len(curr_on) == 0):		return RecursiveFunction(curr_off, bit - 1)	return(min(RecursiveFunction(curr_off, bit - 1),			RecursiveFunction(curr_on, bit - 1)) + (1 << bit))def PrintMinimum(a, n):	v = []	for i in range(n):		v.append(a[i])	print(RecursiveFunction(v, 30))
def constructArray(A, N, K):	B = [0] * N;	totalXOR = A[0] ^ K;	for i in range(N):		B[i] = totalXOR ^ A[i];	for i in range(N):		print(B[i], end = " ");
def reversDigits(num):	global rev_num	global base_pos	if(num > 0):		reversDigits((int)(num / 10))		rev_num += (num % 10) * base_pos		base_pos *= 10	return rev_num
def printSquares(n):	square = 0	odd = 1	for x in range(0 , n):		print(square, end= " ")
def isLucky(n):	ar = [0] * 10	while (n > 0):		digit = math.floor(n % 10)		if (ar[digit]):			return 0		ar[digit] = 1		n = n / 10	return 1
def eval(a, op, b):	if op == '+': return a + b	if op == '-': return a - b	if op == '*': return a * bdef evaluateAll(expr, low, high):	res = []	if low == high:		res.append(int(expr[low]))		return res	if low == (high - 2):		num = eval(int(expr[low]),					expr[low + 1],				int(expr[low + 2]))		res.append(num)		return res	for i in range(low + 1, high + 1, 2):
def isInside(circle_x, circle_y, rad, x, y):	if ((x - circle_x) * (x - circle_x) +		(y - circle_y) * (y - circle_y) <= rad * rad):		return True;	else:		return False;
def power(x, y, p):	res = 1;	x = x % p;	while (y > 0):		if (y & 1):			res = (res * x) % p;		x = (x * x) % p;	return res;def miillerTest(d, n):	a = 2 + random.randint(1, n - 4);	x = power(a, d, n);	if (x == 1 or x == n - 1):		return True;	while (d != n - 1):		x = (x * x) % n;		d *= 2;		if (x == 1):			return False;		if (x == n - 1):			return True;	return False;def isPrime( n, k):	if (n <= 1 or n == 4):		return False;	if (n <= 3):		return True;	d = n - 1;	while (d % 2 == 0):		d //= 2;	for i in range(k):		if (miillerTest(d, n) == False):			return False;	return True;
def power(x, y, p) :	while (y > 0):		if (y & 1):			res = (res * x) % p		x = (x * x) % p	return resdef squareRoot(n, p):	if (p % 4 != 3) :		print( "Invalid Input" )		return	n = n % p	x = power(n, (p + 1) // 4, p)	if ((x * x) % p == n):		print( "Square root is ", x)		return	x = p - x	if ((x * x) % p == n):		print( "Square root is ", x )		return	print( "Square root doesn't exist " )
def SieveOfSundaram(n):	nNew = int((n - 1) / 2);	marked = [0] * (nNew + 1);	for i in range(1, nNew + 1):		j = i;		while((i + j + 2 * i * j) <= nNew):			marked[i + j + 2 * i * j] = 1;			j += 1;	if (n > 2):		print(2, end = " ");	for i in range(1, nNew + 1):		if (marked[i] == 0):			print((2 * i + 1), end = " ");
def SieveOfAtkin(limit):	if (limit > 2):		print(2 , end = " ")	if (limit > 3):		print(3 , end = " ")	sieve = [False] * limit	for i in range( 0 , limit ):		sieve[i] = False	x = 1	while(x * x < limit ) :		y = 1		while(y * y < limit ) :			n = (4 * x * x) + (y * y)			if (n <= limit and (n % 12 == 1 or n % 12 == 5)):				sieve[n] ^= True			n = (3 * x * x) + (y * y)			if (n <= limit and n % 12 == 7):				sieve[n] ^= True			n = (3 * x * x) - (y * y)			if (x > y and n <= limit and n % 12 == 11):				sieve[n] ^= True			y += 1		x += 1	r = 5	while(r * r < limit) :		if (sieve[r]) :			for i in range(r * r, limit, r * r):				sieve[i] = False	for a in range(5 , limit ):		if (sieve[a]):			print(a , end = " ")
def interpolate(f: list, xi: int, n: int) -> float:	result = 0.0	for i in range(n):		term = f[i].y		for j in range(n):			if j != i:				term = term * (xi - f[j].x) / (f[i].x - f[j].x)		result += term	return resultdef __init__(self, x, y):		self.x = x		self.y = y
def printDivisors(n) :	i = 1	while i <= math.sqrt(n):		if (n % i == 0) :			if (n / i == i) :				print i,			else :				print i , n/i,		i = i + 1
def printDivisors(n) :	i = 1	while i <= n :		if (n % i==0) :			print i,		i = i + 1
def printDivisors (n):	i = 1	while (i * i < n):		if (n % i == 0):			print(i, end = " ")		i += 1	for i in range(int(sqrt(n)), 0, -1):		if (n % i == 0):			print(n // i, end = " ")
def printDivisors(n) :	list = []	for i in range(1, int(math.sqrt(n) + 1)) :		if (n % i == 0) :			if (n / i == i) :				print (i, end =" ")			else :				print (i, end =" ")				list.append(int(n / i))	for i in list[::-1] :		print (i, end =" ")
def gcd(a,b):	while (b != 0):		t = b		b = a % b		a = t	return adef findMinDiff (a, b, x, y):	g = gcd(a,b)	diff = abs(x-y) % g	return min(diff, g - diff)
def findPairs(n):	cubeRoot = pow(n, 1.0 / 3.0);	s = {}	for x in range(int(cubeRoot)):		for y in range(x + 1,		int(cubeRoot) + 1):			sum = x * x * x + y * y * y;			if (sum != n):				continue;			if sum in s.keys():				print("(" + str(s[sum][0]) +					", " + str(s[sum][1]) + ") and (" + str(x) +							", " + str(y) + ")" + "\n")			else:				s[sum] = [x, y]
def findPairs( n):	cubeRoot = int(math.pow(n, 1.0 / 3.0));
def divSum(num) :	result = 0
def aModM(s, mod):	number = 0	for i in range(len(s)):		number = (number*10 + int(s[i]))		number = number % m	return numberdef ApowBmodM(a, b, m):	ans = aModM(a, m)	mul = ans	for i in range(1,b):		ans = (ans*mul) % m	return ans
def highestPowerof2(n):	p = int(math.log(n, 2));	return int(pow(2, p));
def highestPowerof2(n):	res = 0;	for i in range(n, 0, -1):		if ((i & (i - 1)) == 0):			res = i;			break;	return res;
def SubArraySum(arr, n ):	result = 0	for i in range(0, n):		result += (arr[i] * (i+1) * (n-i))	return result
def SubArraySum(arr, n):	temp,result = 0,0	for i in range(0, n):		temp=0;		for j in range(i, n):			temp+=arr[j]			result += temp	return result
def maxPrimefactorNum(N):	arr = [True] * (N + 5);	i = 3;	while (i * i <= N):		if (arr[i]):			for j in range(i * i, N + 1, i):				arr[j] = False;		i += 2;	prime = [];	prime.append(2);	for i in range(3, N + 1, 2):		if(arr[i]):			prime.append(i);	i = 0;	ans = 1;	while (ans * prime[i] <= N and					i < len(prime)):		ans *= prime[i];		i += 1;	return ans;
def maxPrimefactorNum(N):	arr = [0 for i in range(N + 5)]	for i in range(2, int(sqrt(N)) + 1, 1):		if (arr[i] == 0):			for j in range(2 * i, N + 1, i):				arr[j] += 1		arr[i] = 1	maxval = 0	maxint = 1	for i in range(1, N + 1, 1):		if (arr[i] > maxval):			maxval = arr[i]			maxint = i	return maxint
def getDigitProduct(x):	if (x < 10):		return x;	if (prodDig[x] != 0):		return prodDig[x];	prod = (int(x % 10) *			getDigitProduct(int(x / 10)));	prodDig[x] = prod;	return prod;def findSeed(n):	res = [];	for i in range(1, int(n / 2 + 2)):		if (i * getDigitProduct(i) == n):			res.append(i);	if (len(res) == 0):		print("NO seed exists");		return;	for i in range(len(res)):		print(res[i], end = " ");
def conver(m, n):	if(m == n):		return 0	if(m > n):		return m - n	if(m <= 0 and n > 0):		return -1	if(n % 2 == 1):		return 1 + conver(m, n + 1)	else:		return 1 + conver(m, n / 2)
static void sieve(int n){	boolean[] prime=new boolean[n+1];	for (int p = 2; p*p <= n; p++)	{		if (prime[p] == false)		{			for (int i = p*2; i <= n; i += p)				prime[i] = true;		}	}	for (int p = 2; p <= n; p++)		if (prime[p]==false)			allPrimes.add(p);}static int factorialDivisors(int n){	int result = 1;	for (int i = 0; i < allPrimes.size(); i++)	{		int p = allPrimes.get(i);		int exp = 0;		while (p <= n)		{			exp = exp + (n/p);			p = p*allPrimes.get(i);		}		result = result*((int)Math.pow(allPrimes.get(i), exp+1)-1)/									(allPrimes.get(i)-1);	}	return result;}
static int fact(int n)	{		if (n == 0)			return 1;		return n*fact(n-1);	}static int div(int x)	{		int ans = 0;		for (int i = 1; i<= x; i++)			if (x%i == 0)				ans += i;		return ans;	}static int sumFactDiv(int n)	{		return div(fact(n));	}
static void sieveOfEratostheneses(){	isPrime[1] = true;	for (int i = 2; i * i < MAX; i++)	{		if (!isPrime[i])		{			for (int j = 2 * i; j < MAX; j += i)				isPrime[j] = true;		}	}}static int findPrime(int n){	int num = n + 1;	while (num > 0)	{		if (!isPrime[num])			return num;		num = num + 1;	}	return 0;}static int minNumber(int arr[], int n){	sieveOfEratostheneses();	int sum = 0;	for (int i = 0; i < n; i++)		sum += arr[i];	if (!isPrime[sum])		return 0;	int num = findPrime(sum);	return num - sum;}
static boolean isPrime(int n)		{			if (n <= 1)				return false;			for (int i = 2; i < n; i++)				if (n % i == 0)					return false;			return true;		}static int findPrime(int n)		{			int num = n + 1;			while (num > 0)				{					if (isPrime(num))						return num;					num = num + 1;				}			return 0;		}static int minNumber(int arr[], int n)		{			int sum = 0;			for (int i = 0; i < n; i++)				sum += arr[i];			if (isPrime(sum))				return 0;			int num = findPrime(sum);			return num - sum;		}
static int countConsecutive(int N)	{		int count = 0;		for (int L = 1; L * (L + 1) < 2 * N; L++) {			double a = (double)((1.0 * N - (L * (L + 1)) / 2) / (L + 1));			if (a - (int)a == 0.0)				count++;		}		return count;	}
static int area_fun(int side){int area = side * side;return area;}
static boolean isComposite(int n)	{		if (n <= 1)		System.out.println("False");		if (n <= 3)		System.out.println("False");		if (n % 2 == 0 n % 3 == 0) return true;		for (int i = 5; i * i <= n; i = i + 6)			if (n % i == 0 || n % (i + 2) == 0)			return true;		return false;	}
public static void printTaxicab2(int N)	{		int i = 1, count = 0;		while (count < N)		{		int int_count = 0;		for (int j = 1; j <= Math.pow(i, 1.0/3); j++)			for (int k = j + 1; k <= Math.pow(i, 1.0/3); k++)				if (j * j * j + k * k * k == i)					int_count++;		if (int_count == 2)		{			count++;			System.out.println(count + " " + i); 		}		i++;		}	}
static void SieveOfEratosthenes(int largest, ArrayList<Integer> prime) {	boolean[] isPrime = new boolean[largest + 1];	Arrays.fill(isPrime, true);	for (int p = 2; p * p <= largest; p++)	{	if (isPrime[p] == true)	{		for (int i = p * 2; i <= largest; i += p)		isPrime[i] = false;	}	}	for (int p = 2; p <= largest; p++)	if (isPrime[p])		prime.add(p); }static long countDivisorsMult(int[] arr, int n) {	int largest = 0;	for(int a : arr )	{	largest=Math.max(largest, a);	}	ArrayList<Integer> prime = new ArrayList<Integer>();	SieveOfEratosthenes(largest, prime);	Map<Integer,Integer> mp = new HashMap<>();	for (int i = 0; i < n; i++)	{	for (int j = 0; j < prime.size(); j++)	{		while(arr[i] > 1 && arr[i]%prime.get(j) == 0)		{		arr[i] /= prime.get(j);		if(mp.containsKey(prime.get(j)))		{			mp.put(prime.get(j), mp.get(prime.get(j)) + 1);		}		else		{			mp.put(prime.get(j), 1);		}		}	}	if (arr[i] != 1)	{		if(mp.containsKey(arr[i]))		{		mp.put(arr[i], mp.get(arr[i]) + 1);		}		else		{		mp.put(arr[i], 1);		}	}	}	long res = 1;	for (int it : mp.keySet())	res *= (mp.get(it) + 1L);	return res; }
static int counDivisors(int X)	{		int count = 0;		for (int i = 1; i <= X; ++i)		{			if (X % i == 0) {				count++;			}		}		return count;	}static int countDivisorsMult(int arr[], int n)	{		int mul = 1;		for (int i = 0; i < n; ++i)			mul *= arr[i];		return counDivisors(mul);	}
static long ispowerof2 ( long num ){	if ((num & (num - 1)) == 0)		return 1;	return 0;}
static int isPowerOf2(String s){	char []str = s.toCharArray();	int len_str = s.length();	int num = 0;	if (len_str == 1 && str[len_str - 1] == '1')		return 0;	while (len_str != 1 str[len_str - 1] != '1')	{		if ((str[len_str - 1] - '0') % 2 == 1)			return 0;		int j = 0;		for (int i = 0; i < len_str; i++)		{			num = num * 10 + (int)str[i] - (int)'0';			if (num < 2)			{				if (i != 0)					str[j++] = '0';					continue;			}			str[j++] = (char)((int)(num / 2) + (int)'0');			num = (num) - (num / 2) * 2;		}		str[j] = '\0';		len_str = j;	}	return 1;}
static int horner(int poly[], int n, int x)	{		int result = poly[0];		for (int i = 1; i < n; i++)			result = result * x + poly[i];		return result;	}static int findSign(int poly[], int n, int x)	{		int result = horner(poly, n, x);		if (result > 0)			return 1;		else if (result < 0)			return -1;		return 0;	}
static int calculate_sum(int a, int N) {	int m = N / a;	int sum = m * (m + 1) / 2;	int ans = a * sum;	return ans;}
static String prevNum(String str)	{		int len = str.length();		int index = -1;		for (int i = len - 2; i >= 0; i--)		{			if (str.charAt(i) > str.charAt(i + 1))			{				index = i;				break;			}		}		int smallGreatDgt = -1;		for (int i = len - 1; i > index; i--)		{			if (str.charAt(i) < str.charAt(index))			{				if (smallGreatDgt == -1)				{					smallGreatDgt = i;				}				else if (str.charAt(i) >=						str.charAt(smallGreatDgt))				{					smallGreatDgt = i;				}			}		}		if (index == -1)		{			return "-1";		}		if (smallGreatDgt != -1)		{			str = swap(str, index, smallGreatDgt);			return str;		}		return "-1";	}static String swap(String str, int i, int j)	{		char ch[] = str.toCharArray();		char temp = ch[i];		ch[i] = ch[j];		ch[j] = temp;		return String.valueOf(ch);	}
static void max_area(int n, int m, int k)	{		if (k > (n + m - 2))			System.out.println("Not possible");		else {			int result;			if (k < Math.max(m, n) - 1)			{				result = Math.max(m * (n / (k + 1)),						n * (m / (k + 1)));			}			else {				result = Math.max(m / (k - n + 2),						n / (k - m + 2));			}			System.out.println(result);		}	}
static float avgOfFirstN(int n)	{		return (float)(1 + n) / 2;	}
static int sn(int n, int an)	{		return (n * (1 + an)) / 2;	}static int trace(int n, int m)	{		int an = 1 + (n - 1) * (m + 1);		int rowmajorSum = sn(n, an);		an = 1 + (n - 1) * (n + 1);		int colmajorSum = sn(n, an);		return rowmajorSum + colmajorSum;	}
static double Convert(double radian){		double pi = 3.14159;		return(radian * (180/pi));	}
public static int counLastDigitK(int low, int high, int k)	{		int mlow = 10 * (int)					Math.ceil(low/10.0);		int mhigh = 10 * (int)					Math.floor(high/10.0);		int count = (mhigh - mlow)/10;		if (high % 10 >= k)			count++;		if (low % 10 <= k && (low%10) > 0)			count++;		return count;	}
public static int counLastDigitK(int low, int high, int k)	{		int count = 0;		for (int i = low; i <= high; i++)			if (i % 10 == k)				count++;		return count;	}
static int gcd(int a, int b)	{		if (a == 0 b == 0)			return 0;		if (a == b)			return a;		if (a > b)			return gcd(a - b, b);		return gcd(a, b - a);	}static int cpFact(int x, int y)	{		while (gcd(x, y) != 1) {			x = x / gcd(x, y);		}		return x;	}
static int sumOfLargePrimeFactor(int n)	{		int prime[] = new int[n + 1], sum = 0;		Arrays.fill(prime, 0);		int max = n / 2;		for (int p = 2; p <= max; p++)		{			if (prime[p] == 0)			{				for (int i = p * 2; i <= n; i += p)					prime[i] = p;			}		}		for (int p = 2; p <= n; p++)		{			if (prime[p] != 0)				sum += prime[p];			else				sum += p;		}		return sum;		}
public static boolean isPrime(int n)	{		if (n <= 1)			return false;		for (int i = 2; i < n; i++)			if (n % i == 0)				return false;		return true;	}public static boolean isEmirp(int n)	{		if (isPrime(n) == false)			return false;		int rev = 0;		while (n != 0) {			int d = n % 10;			rev = rev * 10 + d;			n /= 10;		}		return isPrime(rev);	}
static int Series(int n)	{		int i;		int sums = 0;		for (i = 1; i <= n; i++)			sums += (i * i);		return sums;	}
public static int TrinomialValue(int dp[][], int n, int k)	{		if (k < 0)			k = -k;		if (dp[n][k] != 0)			return dp[n][k];		if (n == 0 && k == 0)			return 1;		if (k < -n k > n)			return 0;		return (dp[n][k] = TrinomialValue(dp, n - 1, k - 1)						+ TrinomialValue(dp, n - 1, k)						+ TrinomialValue(dp, n - 1, k + 1));	}public static void printTrinomial(int n)	{		int[][] dp = new int[MAX][MAX];		for (int i = 0; i < n; i++) {			for (int j = -i; j <= 0; j++)				System.out.print(TrinomialValue(dp, i, j) + " ");			for (int j = 1; j <= i; j++)				System.out.print(TrinomialValue(dp, i, j) + " ");			System.out.println();		}	}
public static int TrinomialValue(int n, int k)	{		if (n == 0 && k == 0)			return 1;		if (k < -n k > n)			return 0;		return TrinomialValue(n - 1, k - 1)			+ TrinomialValue(n - 1, k)			+ TrinomialValue(n - 1, k + 1);	}public static void printTrinomial(int n)	{		for (int i = 0; i < n; i++)		{			for (int j = -i; j <= 0; j++)				System.out.print(TrinomialValue(i, j) + " ");			for (int j = 1; j <= i; j++)				System.out.print(TrinomialValue(i, j) + " ");			System.out.println();		}	}
static int lcm(int a, int b){	return (a * b) / (__gcd(a, b));}static Rational maxRational(Rational first, Rational sec){	int k = lcm(first.deno, sec.deno);	int nume1 = first.nume;	int nume2 = sec.nume;	nume1 *= k / (first.deno);	nume2 *= k / (sec.deno);	return (nume2 < nume1)? first : sec;}static int __gcd(int a, int b){	return b == 0 ? a:__gcd(b, a % b);	}
static int averageOdd(int n)	{		if (n % 2 == 0)		{			System.out.println("Invalid Input");			return -1;		}		return (n + 1) / 2;	}
static int averageOdd(int n)	{		if (n % 2 == 0) {			System.out.println("Invalid Input");			return -1;		}		int sum = 0, count = 0;		while (n >= 1) {			count++;			sum += n;			n = n - 2;		}		return sum / count;	}
static int averageEven(int n)	{		if (n % 2 != 0) {		System.out.println("Invalid Input");			return -1;		}		return (n + 2) / 2;	}
static int averageEven(int n)	{		if (n % 2 != 0) {		System.out.println("Invalid Input");			return -1;		}		int sum = 0, count = 0;		while (n >= 2) {		count++;		sum += n;		n = n - 2;		}		return sum / count;	}
static void fib(int f[], int N)	{		f[1] = 1;		f[2] = 1;		for (int i = 3; i <= N; i++)			f[i] = f[i - 1] + f[i - 2];	}static void fiboTriangle(int n)	{		int N = n * (n + 1) / 2;		int f[] = new int[N + 1];		fib(f, N);		int fiboNum = 1;		for (int i = 1; i <= n; i++) {			for (int j = 1; j <= i; j++)				System.out.print(f[fiboNum++] + " ");			System.out.println();		}	}
static int avg_of_odd_num(int n)	{		return n;	}
static int avg_of_odd_num(int n)	{		int sum = 0;		for (int i = 0; i < n; i++)			sum += (2 * i + 1);		return sum / n;	}
static boolean Div_by_8(int n)	{		return (((n >> 3) << 3) == n);	}
static int digitNumber(long n) {	if (n == 0)	return 1;	if (n == 1)	return 9;	if (n % 2 != 0) {	int temp = digitNumber((n - 1) / 2) % mod;	return (9 * (temp * temp) % mod) % mod;	}	else {	int temp = digitNumber(n / 2) % mod;	return (temp * temp) % mod;	}}static int countExcluding(int n, int d) {	if (d == 0)	return (9 * digitNumber(n - 1)) % mod;	else	return (8 * digitNumber(n - 1)) % mod;}
static int power(int n, int r) {	int count = 0;	for (int i = r; (n / i) >= 1; i = i * r)	count += n / i;	return count;}
public static boolean checkdigit(int n, int k)	{		while (n != 0)		{			int rem = n % 10;			if (rem == k)				return true;			n = n / 10;		}		return false;	}public static int findNthNumber(int n, int k)	{		for (int i = k + 1, count = 1; count < n; i++)		{		if (checkdigit(i, k) || (i % k == 0))			count++;		if (count == n)		return i;		}	return -1;	}
static int seiresSum(int n, int[] a)	{	return n * (a[0] * a[0] - a[2 * n - 1] * a[2 * n - 1]) / (2 * n - 1);	}
static int seiresSum(int n, int[] a)	{		int res = 0, i;		for (i = 0; i < 2 * n; i++)		{			if (i % 2 == 0)				res += a[i] * a[i];			else				res -= a[i] * a[i];		}		return res;	}
static void series(int A, int X, int n)	{		int term = (int)Math.pow(A, n);		System.out.print(term + " ");		for (int i = 1; i <= n; i++) {			term = term * X * (n - i + 1)								/ (i * A);			System.out.print(term + " ");		}	}
static int factorial(int n)	{		int f = 1;		for (int i = 2; i <= n; i++)			f *= i;		return f;	}static void series(int A, int X, int n)	{		int nFact = factorial(n);		for (int i = 0; i < n + 1; i++) {			int niFact = factorial(n - i);			int iFact = factorial(i);			int aPow = (int)Math.pow(A, n - i);			int xPow = (int)Math.pow(X, i);			System.out.print((nFact * aPow * xPow)						/ (niFact * iFact) + " ");		}	}
static void pythagoreanTriplet(int n)	{		for (int i = 1; i <= n / 3; i++)		{			for (int j = i + 1; j <= n / 2; j++)			{				int k = n - i - j;				if (i * i + j * j == k * k)				{					System.out.print(i + ", "+ j + ", " + k);					return;				}			}		}		System.out.print("No Triplet");	}
public static boolean isUndulating(String n)	{			if (n.length() <= 2)				return false;		for (int i = 2; i < n.length(); i++)			if (n.charAt(i-2) != n.charAt(i))				return false;		return true;	}
static boolean possibleToReach(int a, int b)	{		int c = (int)Math.cbrt(a * b);		int re1 = a / c;		int re2 = b / c;		if ((re1 * re1 * re2 == a) &&						(re2 * re2 * re1 == b))			return true;		else			return false;	}
static void possibleTripletInRange(int L, int R){	boolean flag = false;	int possibleA = 0,		possibleB = 0,		possibleC = 0;	int numbersInRange = (R - L + 1);	if (numbersInRange < 3)	{		flag = false;	}	else if (numbersInRange > 3)	{		flag = true;		if (L % 2 > 0)		{			L++;		}		possibleA = L;		possibleB = L + 1;		possibleC = L + 2;	}	else	{		if (!(L % 2 > 0))		{			flag = true;			possibleA = L;			possibleB = L + 1;			possibleC = L + 2;		}		else		{			flag = false;		}	}	if (flag == true)	{		System.out.println("(" + possibleA + ", " + possibleB + ", " + possibleC + ")" + " is one such possible" + " triplet between " + L + " and " + R );	}	else {		System.out.println("No Such Triplet" + " exists between " + L + " and " + R);	}}
static int gcd(int a, int b)	{		if (a == 0)			return b;		return gcd(b % a, a);	}static boolean coprime(int a, int b)	{		return (gcd(a, b) == 1);	}static void possibleTripletInRange(int L, int R)	{		boolean flag = false;		int possibleA = 0, possibleB = 0,						possibleC = 0;		for (int a = L; a <= R; a++) {			for (int b = a + 1; b <= R; b++) {				for (int c = b + 1; c <= R; c++)				{					if (coprime(a, b) && coprime(b, c)									&& !coprime(a, c))					{						flag = true;						possibleA = a;						possibleB = b;						possibleC = c;						break;					}				}			}		}		if (flag == true) {			System.out.println("(" + possibleA + ", " + possibleB + ", " + possibleC + ")" + " is one such possible triplet " + "between " + L + " and " + R);		}		else {			System.out.println("No Such Triplet exists" + "between " + L + " and " + R);		}	}
static int fact(int n){	if (n == 0 n == 1)		return 1 ;	int ans = 1;	for (int i = 1 ; i <= n; i++)		ans = ans * i ;	return ans ;}static int nCr(int n, int r){	int Nr = n , Dr = 1 , ans = 1;	for (int i = 1 ; i <= r ; i++ )	{		ans = ( ans * Nr ) / ( Dr ) ;		Nr-- ;		Dr++ ;	}	return ans ;}static int solve ( int n ){	int N = 2 * n - 2 ;	int R = n - 1 ;	return nCr (N, R) * fact(n - 1) ;}
def findpos(n):	pos = 0	for i in n:		if i == '2':			pos = pos * 4 + 1		elif i == '3':			pos = pos * 4 + 2		elif i == '5':			pos = pos * 4 + 3		elif i == '7':			pos = pos * 4 + 4	return pos
def find_Square_369(num):	if (num[0] == '3'):		a = '1'		b = '0'		c = '8'		d = '9'	elif (num[0] == '6'):		a = '4'		b = '3'		c = '5'		d = '6'	else:		a = '9'		b = '8'		c = '0'		d = '1'	result = ""	size = len(num)	for i in range(1, size):		result += a	result += b	for i in range(1, size):		result += c	result += d	return result
def findNthNonSquare(n):	x = n;	ans = x + math.floor(0.5 + math.sqrt(x));	return int(ans);
def isPrime(n) :	if (n <= 1) :		return False	if (n <= 3) :		return True	if (n % 2 == 0 or n % 3 == 0) :		return False	i = 5	while i * i <= n :		if (n % i == 0 or n % (i + 2) == 0) :			return False		i = i + 6	return Truedef SumOfPrimeDivisors(n) :	Sum = 0	root_n = (int)(math.sqrt(n))	for i in range(1, root_n + 1) :		if (n % i == 0) :			if (i == (int)(n / i) and isPrime(i)) :				Sum += i			else :				if (isPrime(i)) :					Sum += i				if (isPrime((int)(n / i))) :					Sum += (int)(n / i)	return Sum
def Sum(N):	SumOfPrimeDivisors = [0] * (N + 1)	for i in range(2, N + 1) :		if (SumOfPrimeDivisors[i] == 0) :			for j in range(i, N + 1, i) :				SumOfPrimeDivisors[j] += i	return SumOfPrimeDivisors[N]
def isPrime(n):	if n <= 1:		return False	if n <= 3:		return True	if n % 2 == 0 or n % 3 == 0:		return False	i = 5	while i * i <= n:		if (n % i == 0 or			n % (i + 2) == 0):			return False		i = i + 6	return Truedef SumOfPrimeDivisors(n):	sum = 0	for i in range(1, n + 1) :		if n % i == 0 :			if isPrime(i):				sum += i	return sum
def check(n):	sum = 0	while n != 0 :		sum += n % 10		n = n // 10	if sum % 7 == 0 :		return 1	else:		return 0
def isPrime(n):	i, c = 0, 0	for i in range(1, n // 2):		if (n % i == 0):			c += 1	if (c == 1):		return 1	else:		return 0def findMinNum(arr, n):	first, last = 0, 0	Hash = [0 for i in range(10)]	for i in range(n):		Hash[arr[i]] += 1	print("Minimum number: ", end = "")	for i in range(0, 10):		for j in range(Hash[i]):			print(i, end = "")	print()	for i in range(10):		if (Hash[i] != 0):			first = i			break	for i in range(9, -1, -1):		if (Hash[i] != 0):			last = i			break	num = first * 10 + last	rev = last * 10 + first	print("Prime combinations: ", end = "")	if (isPrime(num) and isPrime(rev)):		print(num, " ", rev)	elif (isPrime(num)):		print(num)	elif (isPrime(rev)):		print(rev)	else:		print("No combinations exist")
def Time(arr, n, Emptypipe) :	fill = 0	for i in range(0,n) :		fill += (1 / arr[i])	fill = fill - (1 / float(Emptypipe))	return int(1 / fill)
def calculateSum(n):	return (2**(n + 1) + n - 2)
def Race(B, C):	result = 0;	result = ((C * 100) // B)	return 100 - result
def nthTerm( N):	return (N * ((N // 2) + ((N % 2) * 2) + N))
def nextPerfectCube(N) :	nextN = floor(N ** (1/3)) + 1	return nextN ** 3
def arePermutations(a, b, n, m) :	sum1, sum2, mul1, mul2 = 0, 0, 1, 1	for i in range(n) :		sum1 += a[i]		mul1 *= a[i]	for i in range(m) :		sum2 += b[i]		mul2 *= b[i]	return((sum1 == sum2) and (mul1 == mul2))
def printNthElement(n) :	arr =[0] * (n + 1);	arr[1] = 3	arr[2] = 5	for i in range(3, n + 1) :		if (i % 2 != 0) :			arr[i] = arr[i // 2] * 10 + 3		else :			arr[i] = arr[(i // 2) - 1] * 10 + 5	return arr[n]
def reverse(s):	if len(s) == 0:		return s	else:		return reverse(s[1:]) + s[0]def findNthNo(n):	res = "";	while (n >= 1):		if (n & 1):			res = res + "3";			n = (int)((n - 1) / 2);		else:			res = res + "5";			n = (int)((n - 2) / 2);	return reverse(res);
def calculateSum(n):	return (n * (n + 1) // 2 +		pow((n * (n + 1) // 2), 2))
def nthTerm(n):	return 3 * pow(n, 2) - 4 * n + 2
def area(a):	if (a < 0):		return -1	area = pow((a * sqrt(3)) /				(sqrt(2)), 2)	return area
def isPrime(n) : 	if (n <= 1) : 		return False	if (n <= 3) : 		return True	if (n % 2 == 0 or n % 3 == 0) : 		return False	i = 5	while(i * i <= n) : 		if (n % i == 0 or n % (i + 2) == 0) : 			return False		i = i + 6	return Truedef isPowerOfTwo(n):	return (n and (not(n & (n - 1))))
def SieveOfEratosthenes():	prime = [True] * (MAX)	prime[0], prime[1] = False, False	for p in range(2, 100):		if prime[p] == True:			for i in range(p * 2, MAX, p):				prime[i] = Falsedef isEuclid(n):	if n in s:		return True	else:		return False
def SieveOfEratosthenes():	prime = [True] * MAX	p = 2	while p * p < MAX :		if (prime[p] == True):			for i in range(p * 2, MAX, p):				prime[i] = False		p += 1def isEuclid(n):	product = 1	i = 0	while (product < n) :		product = product * arr[i]		if (product + 1 == n):			return True		i += 1	return False
def printLines(n, k) :	for i in range(n) :		print( k * (6 * i + 1),				k * (6 * i + 2),			k * (6 * i + 3),			k * (6 * i + 5))
def generateDivisors(n):	for i in range(1, int(n**(0.5)) + 1):		if n % i == 0:def harmonicMean(n):	generateDivisors(n)	Sum = 0	length = len(arr)	for i in range(0, length):		Sum = Sum + (n / arr[i])	Sum = Sum / n	return length / Sumdef isOreNumber(n):	mean = harmonicMean(n)	if mean - int(mean) == 0:		return True	else:		return False
def isHalfReducible(arr, n, m):	frequencyHash =[0]*(m + 1);	i = 0;	while(i < n):		frequencyHash[(arr[i] % (m + 1))] += 1;		i += 1;	i = 0;	while(i <= m):		if(frequencyHash[i] >= (n / 2)):			break;		i += 1;	if (i <= m):		print("Yes");	else:		print("No");
def Nth_Term(n):	return (2 * pow(n, 3) - 3 * pow(n, 2) + n + 6) // 6
def largestPrimeFactor(n):	max = -1	while n % 2 == 0:		max = 2;	for i in range(3,int(sqrt(n))+1,2):		while n % i == 0:			max = i;			n = n / i;	if n > 2:		max = n	return maxdef checkUnusual(n):	factor = largestPrimeFactor(n)	if factor > sqrt(n):		return True	else :		return False
def check(s):	freq =[0]*10	while(s != 0):		r = s % 10		s = s//10		freq[r]+= 1	xor = 0	for i in range(10):		xor = xor ^ freq[i]	if(xor == 0):		return True	else:		return False
def getSum(a, n):	sum = 0;	for i in range (1, n + 1):		sum += (i / math.pow(a, i));	return sum;
def countDigitsToBeRemoved(N, K):	s = str(N);	res = 0;	f_zero = 0;	for i in range(len(s) - 1, -1, -1):		if (K == 0):			return res;		if (s[i] == '0'):			f_zero = 1;			K -= 1;		else:			res += 1;	if (K == 0):		return res;	elif (f_zero > 0):		return len(s) - 1;	return -1;
def isPrime(n) :	if (n <= 1) :		return False	if (n <= 3) :		return True	if (n % 2 == 0 or n % 3 == 0) :		return False	for i in range(5, int(sqrt(n)) + 1, 6) :		if (n % i == 0 or n % (i + 2) == 0) :			return False	return Truedef isFactorialPrime(n) :	if (not isPrime(n)) :		return False	fact = 1	i = 1	while (fact <= n + 1) :		fact = fact * i		if (n + 1 == fact or n - 1 == fact) :			return True		i += 1	return False
def isPrime(n):	if (n <= 1):		return False	if (n <= 3):		return True	if (n % 2 == 0 or n % 3 == 0):		return False	k = int(sqrt(n)) + 1	for i in range(5, k, 6):		if (n % i == 0 or n % (i + 2) == 0):			return False	return Truedef isStrongPrime(n):	if (isPrime(n) == False or n == 2):		return False	previous_prime = n - 1	next_prime = n + 1	while (isPrime(next_prime) == False):		next_prime += 1	while (isPrime(previous_prime) == False):		previous_prime -= 1	mean = (previous_prime + next_prime) / 2	if (n > mean):		return True	else:		return False
def countOdd(arr, n):	odd = 0;	for i in range(0, n):		if (arr[i] % 2 == 1):			odd = odd + 1;	return odd;def countValidPairs(arr, n):	odd = countOdd(arr, n);	return (odd * (odd - 1)) / 2;
def minAbsDiff(n) :	mod = n % 4;	if (mod == 0 or mod == 3) :		return 0;	return 1;
def digitWell(n, m, k):	cnt = 0	while (n > 0):		if (n % 10 == m):			cnt = cnt + 1;		n = (int)(n / 10);	return cnt == k;def findInt(n, m, k):	i = n + 1;	while (True):		if (digitWell(i, m, k)):			return i;		i = i + 1;
def minValue(n, x, y):	val = (y * n)/100	if x >= val:		return 0	else:		return math.ceil(val) - x
def initialize():	l[0][0] = 1	for i in range(1, 1001):		l[i][0] = 1		for j in range(1, i + 1):			l[i][j] = (l[i - 1][j - 1] + l[i - 1][j])def nCr(n, r):	return l[n][r]
def findAndSum(arr, n):	Sum = 0	mul = 1	for i in range(30):		count_on = 0		l = 0		for j in range(n):			if ((arr[j] & (1 << i)) > 0):				if (count_on):					l += 1				else:					count_on = 1					l += 1			elif (count_on):				Sum += ((mul * l * (l + 1)) // 2)				count_on = 0				l = 0		if (count_on):			Sum += ((mul * l * (l + 1)) // 2)			count_on = 0			l = 0		mul *= 2	return Sum
def Cycles(N):	fact = 1	result = N - 1	i = result	while (i > 0):		fact = fact * i		i -= 1	return fact // 2
def BalanceArray(A, Q) :	ANS = []	sum = 0	for i in range(len(A)) :		if (A[i] % 2 == 0) :			sum += A[i];	for i in range(len(Q)) :		index = Q[i][0];		value = Q[i][1];		if (A[index] % 2 == 0) :			sum -= A[index];		A[index] += value;		if (A[index] % 2 == 0) :			sum += A[index];		ANS.append(sum);	for i in range(len(ANS)) :		print(ANS[i], end = " ");
def EvenSum(A, index, value):	A[index] = A[index] + value	sum = 0	for i in A:		if (i % 2 == 0):			sum = sum + i	return sumdef BalanceArray(A,Q):	ANS = []	i, sum = 0, 0	for i in range(len(Q)):		index = Q[i][0]		value = Q[i][1]		sum = EvenSum(A, index, value)		ANS.append(sum)	for i in ANS:		print(i, end = " ")
def countWays(N):	E = (N * (N - 1)) / 2	if (N == 1):		return 0	return int(pow(2, E - 1))
def countNumbers(L, R, K):	if (K == 9):		K = 0	totalnumbers = R - L + 1	factor9 = totalnumbers // 9	rem = totalnumbers % 9	ans = factor9	for i in range(R, R - rem, -1):		rem1 = i % 9		if (rem1 == K):			ans += 1	return ans
def countQuadruples(a, n) :	mpp = dict.fromkeys(a, 0);	for i in range(n) :		mpp[a[i]] += 1;	count = 0;	for j in range(n) :		for k in range(n) :			if (j == k) :				continue;			mpp[a[j]] -= 1;			mpp[a[k]] -= 1;			first = a[j] - (a[k] - a[j]);			if first not in mpp :				mpp[first] = 0;			fourth = (a[k] * a[k]) // a[j];			if fourth not in mpp :				mpp[fourth] = 0;			if ((a[k] * a[k]) % a[j] == 0) :				if (a[j] != a[k]) :					count += mpp[first] * mpp[fourth];				else :					count += (mpp[first] *							(mpp[fourth] - 1));			mpp[a[j]] += 1;			mpp[a[k]] += 1;	return count;
def sieve():	for i in range(4, MAXN, 2):		spf[i] = 2	for i in range(3, MAXN):		if i * i >= MAXN:			break		if (spf[i] == i):			for j in range(i * i, MAXN, i):				if (spf[j] == j):					spf[j] = idef getFactorization(x):	while (x != 1):		temp = spf[x]		if (x % temp == 0):			hash1[spf[x]] += 1			x = x // spf[x]		while (x % temp == 0):			x = x // tempdef check(x):	while (x != 1):		temp = spf[x]		if (x % temp == 0 and hash1[temp] > 1):			return False		while (x % temp == 0):			x = x //temp	return Truedef hasValidNum(arr, n):	sieve()	for i in range(n):		getFactorization(arr[i])	for i in range(n):		if (check(arr[i])):			return True	return False
def Loss(SP, P):	loss = 0	loss = ((2 * P * P * SP) /			(100 * 100 - P * P))	print("Loss =", round(loss, 3))
def countSquares(r, c, m):	squares = 0	for i in range (1, 9):		for j in range (1, 9):			if(max(abs(i - r), abs(j - c)) <= m):				squares = squares + 1	return squares
void Loss(int SP, int P){	float loss = 0;	loss = (2 * P * P * SP) / float(100 * 100 - P * P);	cout << "Loss = " << loss;}
int countSquares(int r, int c, int m){	int squares = 0;	for (int i = 1; i <= 8; i++) {		for (int j = 1; j <= 8; j++) {			if (max(abs(i - r), abs(j - c)) <= m)				squares++;		}	}	return squares;}
int freqPairs(int arr[], int n){	int max = *(std::max_element(arr, arr + n));	int freq[max + 1] = { 0 };	int count = 0;	for (int i = 0; i < n; i++)		freq[arr[i]]++;	for (int i = 0; i < n; i++) {		for (int j = 2 * arr[i]; j <= max; j += arr[i]) {			if (freq[j] >= 1)				count += freq[j];		}		if (freq[arr[i]] > 1) {			count += freq[arr[i]] - 1;			freq[arr[i]]--;		}	}	return count;}
int smallestIndex(int a[], int n){	int right1 = 0, right0 = 0;	for (int i = 0; i < n; i++) {		if (a[i] == 1)			right1 = i;		else			right0 = i;	}	return min(right1, right0);}
int primeCount(int arr[], int n){	int max_val = *max_element(arr, arr + n);	vector<bool> prime(max_val + 1, true);	prime[0] = false;	prime[1] = false;	for (int p = 2; p * p <= max_val; p++) {		if (prime[p] == true) {			for (int i = p * 2; i <= max_val; i += p)				prime[i] = false;		}	}	int count = 0;	for (int i = 0; i < n; i++)		if (prime[arr[i]])			count++;	return count;}void getPrefixArray(int arr[], int n, int pre[]){	pre[0] = arr[0];	for (int i = 1; i < n; i++) {		pre[i] = pre[i - 1] + arr[i];	}}
int getAverage(int x, int y){	int avg = (x & y) + ((x ^ y) >> 1);	return avg;}
int numberOfDays(int a, int b, int n){	int Days = b * (n + a) / (a + b);	return Days;}
int count(int N){	int a = 0;	a = (N * (N + 1)) / 2;	return a;}
bool canConvert(int a, int b){	while (b > a) {		if (b % 10 == 1) {			b /= 10;			continue;		}		if (b % 2 == 0) {			b /= 2;			continue;		}		return false;	}	if (b == a)		return true;	return false;}
void MinimumValue(int x, int y){	if (x > y)		swap(x, y);	int a = 1;	int b = x - 1;	int c = y - b;	cout << a << " " << b << " " << c;}
void decimalToBinary(int n){	if (n == 0) {		cout << "0";		return;	}	decimalToBinary(n / 2);	cout << n % 2;}
int Max_sum(int a[], int n){	int pos = 0, neg = 0;	for(int i = 0; i < n; i++)	{		if(a[i] > 0)			pos = 1;		else if(a[i] < 0)			neg = 1;		if(pos == 1 and neg == 1)			break;	}	int sum = 0;	if(pos==1 and neg==1)	{		for(int i=0; i < n ; i++)			sum += abs(a[i]);	}	else if(pos == 1)	{		int mini = a[0];		sum = a[0];		for(int i=1; i < n; i++)		{			mini = min(mini, a[i]);			sum += a[i];		} 		sum -= 2*mini;	} 	else if(neg == 1)	{		for(int i = 0; i < n; i++)			a[i] = abs(a[i]);		int mini = a[0];		sum = a[0];		for(int i=1; i < n; i++)		{			mini = min(mini, a[i]);			sum += a[i];		} 		sum -= 2*mini;	}	return sum;}
int Wedderburn(int n){	if (n <= 2)		return store[n];	else if (n % 2 == 0)	{		int x = n / 2, ans = 0;		for (int i = 1; i < x; i++) {			ans += store[i] * store[n - i];		}		ans += (store[x] * (store[x] + 1)) / 2;		store[n] = ans;		return ans;	}	else	{		int x = (n + 1) / 2, ans = 0;		for (int i = 1; i < x; i++) {			ans += store[i] * store[n - i];		}		store[n] = ans;		return ans;	}}void Wedderburn_Etherington(int n){	store[0] = 0;	store[1] = 1;	store[2] = 1;	for (int i = 0; i < n; i++)	{		cout << Wedderburn(i);		if(i!=n-1)			cout << ", ";	}}
vector<int> addPrimes(){	int n = MAX;	bool prime[n + 1];	memset(prime, true, sizeof(prime));	for (int p = 2; p * p <= n; p++) {		if (prime[p] == true) {			for (int i = p * p; i <= n; i += p)				prime[i] = false;		}	}	vector<int> ans;	for (int p = 2; p <= n; p++)		if (prime[p])			ans.push_back(p);	return ans;}bool is_prime(int n){	return (n == 3 n == 5 n == 7);}int find_Sum(int n){	int sum = 0;	vector<int> v = addPrimes();	for (int i = 0; i < v.size() and n; i++)	{		int flag = 1;		int a = v[i];		while (a != 0)		{			int d = a % 10;			a = a / 10;			if (is_prime(d)) {				flag = 0;				break;			}		}		if (flag==1)		{			n--;			sum = sum + v[i];		}	}	return sum;}
int find_count(vector<int> ele){	int count = 0;	for (int i = 0; i < ele.size(); i++) {		vector<int> p;		int c = 0;		for (int j = ele.size() - 1;			j >= (ele.size() - 1 - i) && j >= 0; j--)			p.push_back(ele[j]);		int j = ele.size() - 1, k = 0;		while (j >= 0) {			if (ele[j] != p[k])				break;			j--;			k++;			if (k == p.size()) {				c++;				k = 0;			}		}		count = max(count, c);	}	return count;}void solve(int n){	int count = 1;	vector<int> ele;	for (int i = 0; i < n; i++) {		cout << count << ", ";		ele.push_back(count);		count = find_count(ele);	}}
void ZigZag(int n){	long long fact[n + 1], zig[n + 1] = { 0 };	fact[0] = 1;	for (int i = 1; i <= n; i++)		fact[i] = fact[i - 1] * i;	zig[0] = 1;	zig[1] = 1;	cout << "zig zag numbers: ";	cout << zig[0] << " " << zig[1] << " ";	for (int i = 2; i < n; i++)	{		long long sum = 0;		for (int k = 0; k <= i - 1; k++)		{			sum += (fact[i - 1]/(fact[i - 1 - k]*fact[k]))								*zig[k] * zig[i - 1 - k];		}		zig[i] = sum / 2;		cout << sum / 2 << " ";	}}
void compareValues(int a, int b, int c, int d){	double log1 = log10(a);	double num1 = log1 * b;	double log2 = log10(c);	double num2 = log2 * d;	if (num1 > num2)		cout << a << "^" << b;	else		cout << c << "^" << d;}
void compareVal(int x, int y){	long double a = y * log(x);	long double b = x * log(y);	if (a > b)		cout << x << "^" << y << " > "			<< y << "^" << x;	else if (a < b)		cout << x << "^" << y << " < "			<< y << "^" << x;	else if (a == b)		cout << x << "^" << y << " = "			<< y << "^" << x;}
void least_prime_factor(){	for (int i = 2; i < N; i++)		if (!lpf[i])			for (int j = i; j < N; j += i)				if (!lpf[j])					lpf[j] = i;}void Mobius(){	for (int i = 1; i < N; i++) {		if (i == 1)			mobius[i] = 1;		else {			if (lpf[i / lpf[i]] == lpf[i])				mobius[i] = 0;			else				mobius[i] = -1 * mobius[i / lpf[i]];		}	}}int gcd_pairs(int a[], int n){	int maxi = 0;	int fre[N] = { 0 };	for (int i = 0; i < n; i++) {		fre[a[i]]++;		maxi = max(a[i], maxi);	}	least_prime_factor();	Mobius();	int ans = 0;	for (int i = 1; i <= maxi; i++) {		if (!mobius[i])			continue;		int temp = 0;		for (int j = i; j <= maxi; j += i)			temp += fre[j];		ans += temp * (temp - 1) / 2 * mobius[i];	}	return ans;}
long long power(int p){	long long res = 1;	for (int i = 1; i <= p; ++i) {		res *= 2;		res %= mod;	}	return res % mod;}long long subset_square_sum(vector<int>& A){	int n = (int)A.size();	long long ans = 0;	for (int i : A) {		ans += (1LL * i * i) % mod;		ans %= mod;	}	return (1LL * ans * power(n - 1)) % mod;}
double calculate_angle(int n, int i, int j, int k){	int x, y;	if (i < j)		x = j - i;	else		x = j + n - i;	if (j < k)		y = k - j;	else		y = k + n - j;	double ang1 = (180 * x) / n;	double ang2 = (180 * y) / n;	double ans = 180 - ang1 - ang2;	return ans;}
int gcd(int a, int b){	if (a == 0)		return b;	return gcd(b % a, a);}long divTermCount(long a, long b, long c, long num){	return ((num / a) + (num / b) + (num / c)			- (num / ((a * b) / gcd(a, b)))			- (num / ((c * b) / gcd(c, b)))			- (num / ((a * c) / gcd(a, c)))			+ (num / ((((a*b)/gcd(a, b))* c) / gcd(((a*b)/gcd(a, b)), c))));}int findNthTerm(int a, int b, int c, long n){	long low = 1, high = LONG_MAX, mid;	while (low < high) {		mid = low + (high - low) / 2;		if (divTermCount(a, b, c, mid) < n)			low = mid + 1;		else			high = mid;	}	return low;}
void preCompute(){	fact[0] = 1;	result[0] = 1;	for (int i = 1; i <= MAX; i++) {		fact[i] = ((fact[i - 1] % MOD) * i) % MOD;		result[i] = ((result[i - 1] % MOD) * (fact[i] % MOD)) % MOD;	}}void performQueries(int q[], int n){	preCompute();	for (int i = 0; i < n; i++)		cout << result[q[i]] << "\n";}
int modFact(int n, int m){	int result = 1;	for (int i = 1; i <= m; i++)		result = (result * i) % MOD;	return result;}
int findMinValue(int arr[], int n){	long sum = 0;	for (int i = 0; i < n; i++)		sum += arr[i];	return ((sum / n) + 1);}
int count(int n){	return n * (3 * n - 1) / 2;}
int diameter(int n){	int L, H, templen;	L = 1;	H = 0;	if (n == 1) {		return 1;	}	if (n == 2) {		return 2;	}	if (n == 3) {		return 3;	}	while (L * 2 <= n) {		L *= 2;		H++;	}	if (n >= L * 2 - 1)		return 2 * H + 1;	else if (n >= L + (L / 2) - 1)		return 2 * H;	return 2 * H - 1;}
int lcm(int a, int b){	int GCD = __gcd(a, b);	return (a * b) / GCD;}int MinLCM(int a[], int n){	int Prefix[n + 2];	int Suffix[n + 2];	Prefix[1] = a[0];	for (int i = 2; i <= n; i += 1) {		Prefix[i] = lcm(Prefix[i - 1], a[i - 1]);	}	Suffix[n] = a[n - 1];	for (int i = n - 1; i >= 1; i -= 1) {		Suffix[i] = lcm(Suffix[i + 1], a[i - 1]);	}	int ans = min(Suffix[2], Prefix[n - 1]);	for (int i = 2; i < n; i += 1) {		ans = min(ans, lcm(Prefix[i - 1], Suffix[i + 1]));	}	return ans;}
bool isFactorial(int n){ for (int i = 1;; i++) {	if (n % i == 0) {	n /= i;	}	else {	break;	} } if (n == 1) {	return true; } else {	return false; }}
bool digitDividesK(int num, int k){	while (num) {		int d = num % 10;		if (d != 0 and k % d == 0)			return true;		num = num / 10;	}	return false;}int findCount(int l, int r, int k){	int count = 0;	for (int i = l; i <= r; i++) {		if (digitDividesK(i, k))			count++;	}	return count;}
int maxXOR(int* arr, int n){	int xorArr = 0;	for (int i = 0; i < n; i++)		xorArr ^= arr[i];	int ans = 0;	for (int i = 0; i < n; i++)		ans = max(ans, (xorArr ^ arr[i]));	return ans;}
void find_composite_nos(int n){	cout << 9 * n << " " << 8 * n;}
void decBinary(int arr[], int n){	int k = log2(n);	while (n > 0) {		arr[k--] = n % 2;		n /= 2;	}}int binaryDec(int arr[], int n){	int ans = 0;	for (int i = 0; i < n; i++)		ans += arr[i] << (n - i - 1);	return ans;}int getNum(int n, int k){	int l = log2(n) + 1;	int a[l] = { 0 };	decBinary(a, n);	if (k > l)		return n;	a[k - 1] = (a[k - 1] == 0) ? 1 : 0;	return binaryDec(a, l);}
int Count_subarray(int arr[], int n){	int total_sum = 0, subarray_sum,		remaining_sum, count = 0;	for (int i = 0; i < n; i++) {		total_sum += arr[i];	}	for (int i = 0; i < n; i++) {		subarray_sum = 0;		for (int j = i; j < n; j++) {			subarray_sum += arr[j];			remaining_sum = total_sum - subarray_sum;			if (subarray_sum > remaining_sum) {				count += 1;			}		}	}	return count;}
int Count_subarray(int arr[], int n){	int subarray_sum, remaining_sum, count = 0;	for (int i = 0; i < n; i++) {		for (int j = i; j < n; j++) {			subarray_sum = 0;			remaining_sum = 0;			for (int k = i; k <= j; k++) {				subarray_sum += arr[k];			}			for (int l = 0; l < i; l++) {				remaining_sum += arr[l];			}			for (int l = j + 1; l < n; l++) {				remaining_sum += arr[l];			}			if (subarray_sum > remaining_sum) {				count += 1;			}		}	}	return count;}
string smallestPoss(string s, int n){	string ans = "";	int arr[10] = { 0 };	for (int i = 0; i < n; i++) {		arr[s[i] - 48]++;	}	for (int i = 0; i < 10; i++) {		for (int j = 0; j < arr[i]; j++)			ans = ans + to_string(i);	}	return ans;}
int noOfCards(int n){	return n * (3 * n + 1) / 2;}
int powOfPositive(int n){	int pos = floor(log2(n));	return pow(2, pos);}int powOfNegative(int n){	int pos = ceil(log2(n));	return (-1 * pow(2, pos));}void highestPowerOf2(int n){	if (n > 0) {		cout << powOfPositive(n);	}	else {		n = -n;		cout << powOfNegative(n);	}}
void printValueOfPi(int N){	double pi = 2 * acos(0.0);	printf("%.*lf\n", N, pi);}
int nearest(int n){	int prevSquare = sqrt(n);	int nextSquare = prevSquare + 1;	prevSquare = prevSquare * prevSquare;	nextSquare = nextSquare * nextSquare;	int ans		= (n - prevSquare) < (nextSquare - n)			? (prevSquare - n)			: (nextSquare - n);	return ans;}
long long power(int p){	long long res = 1;	for (int i = 1; i <= p; ++i) {		res *= 2;		res %= mod;	}	return res % mod;}long long subset_cube_sum(vector<int>& A){	int n = (int)A.size();	long long ans = 0;	for (int i : A) {		ans += (1LL * i * i * i) % mod;		ans %= mod;	}	return (1LL * ans * power(n - 1))		% mod;}
void printPairs(int arr[], int n){	for (int i = 0; i < n; i++) {		for (int j = 0; j < n; j++) {			cout << "(" << arr[i] << ", " << arr[j] << ")"				<< ", ";		}	}}
void isPrime(int N){	bool isPrime = true;	int arr[8] = { 7, 11, 13, 17,				19, 23, 29, 31 };	if (N < 2) {		isPrime = false;	}	if (N % 2 == 0 N % 3 == 0 N % 5 == 0) {		isPrime = false;	}	for (int i = 0; i < sqrt(N); i += 30) {		for (int c : arr) {			if (c > sqrt(N)) {				break;			}			else {				if (N % (c + i) == 0) {					isPrime = false;					break;				}			}			if (!isPrime)				break;		}	}	if (isPrime)		cout << "Prime Number";	else		cout << "Not a Prime Number";}
void canBeReduced(int x, int y){	int maxi = max(x, y);	int mini = min(x, y);	if (((x + y) % 3) == 0 && maxi <= 2*mini)		cout << "YES" << endl;	else		cout << "NO" << endl;}
int largest_sum(int arr[], int n){	int maximum = -1;	map<int, int> m;	for (int i = 0; i < n; i++) {		m[arr[i]]++;	}	for (auto j : m) {		if (j.second > 1) {			m[2 * j.first]				= m[2 * j.first]				+ j.second / 2;			if (2 * j.first > maximum)				maximum = 2 * j.first;		}	}	return maximum;}
bool isPerfectCube(int x){	long double cr = round(cbrt(x));	return (cr * cr * cr == x);}void checkCube(int a, int b){	string s1 = to_string(a);	string s2 = to_string(b);	int c = stoi(s1 + s2);	if (isPerfectCube(c)) {		cout << "Yes";	}	else {		cout << "No";	}}
float round(float var,int digit){ float value = (int)(var *				pow(10, digit) + .5); return (float)value /		pow(10, digit);}int probability(int N){ int a = 2; int b = 3; if (N == 1) {	return a; } else if(N == 2) {	return b; } else {	for(int i = 3; i <= N; i++)	{	int c = a + b;	a = b;	b = c;	}	return b; }}float operations(int N) { int x = probability(N); int y = pow(2, N); return round((float)x /			(float)y, 2);}
int NthSmallest(int K){	queue<int> Q;	int x;	for (int i = 1; i < 10; i++)		Q.push(i);	for (int i = 1; i <= K; i++) {		x = Q.front();		Q.pop();		if (x % 10 != 0) {			Q.push(x * 10 + x % 10 - 1);		}		Q.push(x * 10 + x % 10);		if (x % 10 != 9) {			Q.push(x * 10 + x % 10 + 1);		}	}	return x;}
int power(int x, int y, int p){	int res = 1;	x = x % p;	while (y > 0)	{		if (y & 1)			res = (res * x) % p;		x = (x * x) % p;	}	return res;}int modInverse(int n, int p){	return power(n, p - 2, p);}int nCrModPFermat(int n, int r, int p){	if (r == 0)		return 1;	if (n < r)		return 0;	int fac[n + 1];	fac[0] = 1;	for (int i = 1; i <= n; i++)		fac[i] = fac[i - 1] * i % p;	return (fac[n] * modInverse(fac[r], p) % p			* modInverse(fac[n - r], p) % p) % p;}int SumOfXor(int a[], int n){	int mod = 10037;	int answer = 0;	for (int k = 0; k < 32; k++)	{		int x = 0, y = 0;		for (int i = 0; i < n; i++)		{			if (a[i] & (1 << k))				x++;			else				y++;		}		answer += ((1 << k) % mod *				(nCrModPFermat(x, 3, mod)					+ x * nCrModPFermat(y, 2, mod)) % mod) % mod;	}	return answer;}
void Solve(int arr[], int size, int n){	vector<int> v(n + 1);	for (int i = 0; i < size; i++)		v[arr[i]]++;	int max1 = (max_element(v.begin(), v.end())									- v.begin());	int diff1 = n + 1 - count(v.begin(), v.end(), 0);	int max_size = max(min(v[max1] - 1, diff1),							min(v[max1], diff1 - 1));	cout << "Maximum size is :" << max_size << "\n";	cout << "The First Array Is : \n";	for (int i = 0; i < max_size; i++) {		cout << max1 << " ";		v[max1] -= 1;	}	cout << "\n";	cout << "The Second Array Is : \n";	for (int i = 0; i < (n + 1); i++) {		if (v[i] > 0) {			cout << i << " ";			max_size--;		}		if (max_size < 1)			break;	}	cout << "\n";}
function CountWays(n){	let ans = Math.floor((n - 1) / 2);	return ans;}
function printKNumbers(N, K)	{		for (let i = 0; i < K - 1; i++)			document.write(1 + " ");		document.write(N - K + 1);	}
function findMaxPrimeDivisor(n){	let max_possible_prime = 0;	while (n % 2 == 0)	{		max_possible_prime++;		n = Math.floor(n / 2);	}	for(let i = 3; i * i <= n; i = i + 2)	{		while (n % i == 0)		{			max_possible_prime++;			n = Math.floor(n / i);		}	}	if (n > 2)	{		max_possible_prime++;	}	document.write(max_possible_prime + "\n");}
function countValues(N){	var div = [];	for (var i = 2; i * i <= N; i++) {		if (N % i == 0) {			div.push(i);			if (N != i * i) {				div.push(N / i);			}		}	}	var answer = 0;	for (var i = 1; i * i <= N - 1; i++) {		if ((N - 1) % i == 0) {			if (i * i == N - 1)				answer++;			else				answer += 2;		}	}	div.forEach(d => {		var K = N;		while (K % d == 0)			K /= d;		if ((K - 1) % d == 0) answer++; });	return answer;}
function countValues(n)	{		let answer = 0;		for (let i = 2; i <= n; i++) {			let k = n;			while (k >= i) {				if (k % i == 0)					k /= i;				else					k -= i;			}			if (k == 1)				answer++;		}		return answer;	}
function sumOfDigits(n){	var sum = 0;	while (n > 0)	{		sum += n % 10;		n = parseInt(n/10);	}	return sum;}function smallestNum(X , Y){	var res = -1;	for (i = X; i < MAXN; i++)	{		var sum_of_digit = sumOfDigits(i);		if (sum_of_digit % Y == 0)		{			res = i;			break;		}	}	return res;}
function calculateWays(n){	let x = 0;	let v = Array.from({length: n}, (_, i) => 0);	for(let i = 0; i < n; i++)		v[i] = 0;	for(let i = 0; i < n / 2; i++)	{		if(n % 2 == 0 && i == n / 2)			break;		x = n * (i + 1) - (i + 1) * i;		v[i] = x;		v[n - i - 1] = x;	}	return v;}function prletArray(v){	for(let i = 0; i < v.length; i++)		document.write(v[i] + " ");}
function isPerfectSquare(x){	var sr = Math.sqrt(x);	return((sr - Math.floor(sr)) == 0);}function checkSunnyNumber(N){	if (isPerfectSquare(N + 1)) {		document.write( "Yes");	}	else {		document.write( "No");	}}
function sumEvenNumbers(N, K){	let check = N - 2 * (K - 1);	if (check > 0 && check % 2 == 0)	{		for(let i = 0; i < K - 1; i++)		{		document.write("2 ");		}		document.write(check);	}	else	{		document.write("-1");	}}
function checksum(n , k)	{		var first_term = (((2 * n) / k + (1 - k)) / 2.0);		if (first_term - parseInt( (first_term)) == 0) {			for (i = parseInt( first_term); i <= first_term + k - 1; i++) {				document.write(i + " ");			}		} else			document.write("-1");	}
function getFactorization(x){	let count = 0;	let v = [];	while (x % 2 == 0)	{		count++;		x = Math.floor(x / 2);	}	if (count != 0)		v.push(count);	for (let i = 3;		i <= Math.floor(Math.sqrt(x)); i += 2)	{		count = 0;		while (x % i == 0)		{			count++;			x = Math.floor(x / i);		}		if (count != 0)		v.push(count);	}	if (x > 1)	{		v.push(1);	}	return v;}function nonPrimeDivisors(N){	let v = getFactorization(N);	let ret = 1;	for (let i = 0; i < v.length; i++)		ret = ret * (v[i] + 1);	ret = ret - v.length;	return ret;}
function nCr(n, r){	return fact(n) / (fact(r) * 		fact(n - r));}function fact(n){	var res = 1;	for(var i = 2; i <= n; i++)		res = res * i;	return res;}function sumSubsequences(arr, n, k){	var sum = 0;	for(var i = 0; i < n; i++)	{		sum += arr[i];	}	var kLengthSubSequence;	kLengthSubSequence = nCr(n, k);	var ans = sum * ((k * kLengthSubSequence) / n);	return ans;}
function isPrime(n){	if (n <= 1)		return false;	for (var i = 2; i < n; i++)		if (n % i == 0)			return false;	return true;}function countSubsequences( arr, n){	var totalSubsequence = Math.pow(2, n) - 1;	var countPrime = 0, countOnes = 0;	for (var i = 0; i < n; i++) {		if (arr[i] == 1)			countOnes++;		else if (isPrime(arr[i]))			countPrime++;	}	var compositeSubsequence;	var onesSequence = Math.pow(2, countOnes) - 1;	compositeSubsequence		= totalSubsequence - countPrime		- onesSequence		- onesSequence * countPrime;	return compositeSubsequence;}
function constructArray(N){	let arr = new Array(N);	for (let i = 1; i <= N; i++)	{		arr[i - 1] = i;	}	for (let i = 0; i < N; i++)	{		document.write(arr[i] + ", ");	}}
function power(x, y){	let p = 1000000007;	let res = 1;	x = x % p;	while (y > 0)	{		if (y % 2 == 1)			res = (res * x) % p;		y = y >> 1;		x = (x * x) % p;	}	return res;}function productPairs(arr, n){	let product = 1;	for (let i = 0; i < n; i++)	{		product = (product % mod *				power(arr[i],							(2 * n)) % mod) % mod;	}	return product % mod;}
function productPairs(arr, n){	let product = 1;	for (let i = 0; i < n; i++) {		for (let j = 0; j < n; j++) {			product *= (arr[i] % mod * arr[j] % mod)					% mod;			product = product % mod;		}	}	return product % mod;}
function checkSolution(a, b, c)	{		if (a == c)			document.write("Yes");		else			document.write("No");	}
function insert_element(a, n)	{		let Xor = 0;		let Sum = 0;		for(let i = 0; i < n; i++)		{			Xor ^= a[i];			Sum += a[i];		}		if(Sum == 2 * Xor)		{			document.write("0" + "</br>");			return;		}		if(Xor == 0)		{			document.write("1" + "</br>");			document.write(Sum + "</br>");			return;		}		let num1 = Sum + Xor;		let num2 = Xor;		document.write("2" + "</br>");		document.write(num1 + " " + num2 + "</br>");	}
function MegagonNum(n){	return (999998 * n * n - 999996 * n) / 2;}
function EnneacontahexagonNum( n) {		return (94 * n * n - 92 * n) / 2;	}
function func(arr, n){	let ans = 0;	let maxx = 0;	let freq = Array.from({length: 100005}, (_, i) => 0);	let temp;	for(let i = 0; i < n; i++)	{	temp = arr[i];	freq[temp]++;	maxx = Math.max(maxx, temp);	}	for(let i = 1; i <= maxx; i++)	{	freq[i] += freq[i - 1];	}	for(let i = 1; i <= maxx; i++)	{	if (freq[i] != 0)	{		let j;		let cur = Math.ceil(0.5 * i) - 1.0;		for(j = 1.5;; j++)		{			let val = Math.min(maxx,				(Math.ceil(i * j) - 1.0));			let times = (freq[i] - freq[i - 1]),					con = (j - 0.5);			ans += times * con * (freq[val] - freq[cur]);			cur = val;			if (val == maxx)				break;		}	}	}	return ans;}
function checkArray(n , k , arr) {		var cnt = 0;		for (i = 0; i < n; i++) {			if ((arr[i] & 1) != 0)				cnt += 1;		}		if (cnt >= k && cnt % 2 == k % 2)			return true;		else			return false;	}
function printSeries( n, a, b, c){	let d;	if (n == 1) {		document.write( a + " ");		return;	}	if (n == 2) {		document.write( a + " " + b + " ");		return;	}	document.write( a + " " + b + " " + c + " ");	for (let i = 4; i <= n; i++) {		d = a + b + c;		document.write( d + " ");		a = b;		b = c;		c = d;	}}
function rev(num){	var rev_num = 0;	while (num > 0) {		rev_num = rev_num * 10 + num % 10;		num = Math.floor(num / 10);	}	return rev_num;}function divSum(num){	var result = 0;	for (var i = 2; i <= Math.floor(Math.sqrt(num)); i++) {		if (num % i == 0) {			if (i == (num / i))				result += rev(i);			else				result += (rev(i)						+ rev(num / i));		}	}	result += 1;	return result;}function isAntiPerfect(n){	return divSum(n) == n;}
function findNthTerm(n){	document.write(n * n - n + 1);}
function isDouble(num){	let s = num.toString();	let l = s.length;	if (s[0] == s.charAt[1])	return false;	if (l % 2 == 1)	{		s = s + s[1];		l++;	}	let s1 = s.substr(0, l / 2);	let s2 = s.substr(l / 2);	return (s1 == s2);}function isNontrivialUndulant(N){	return N > 100 && isDouble(N);}
function linearSum(n){	return (n * (n + 1) / 2) % mod;}function rangeSum(b, a){	return (linearSum(b) -			linearSum(a)) % mod;}function totalSum(n){	let result = 0;	let i = 1;	while(true)	{		result += rangeSum(Math.floor(n / i),						Math.floor(n / (i + 1))) *									(i % mod) % mod;		result %= mod;		if (i == n)			break;		i = Math.floor(n / (n / (i + 1)));	}	return result;}
function maxAdjacentDifference(N, K){	if (N == 1)	{		return 0;	}	if (N == 2) 	{		return K;	}	return 2 * K;}
function Is_possible( N){	let C = 0;	let D = 0;	while (N % 10 == 0)	{		N = N / 10;		C += 1;	}	if(Math.pow(2, (Math.log(N) /						(Math.log(2)))) == N)	{		D = (Math.log(N) / (Math.log(2)));		if (C >= D)			document.write("YES");		else			document.write("NO");	}	else		document.write("NO");}
function Sum( N) {		let SumOfPrimeDivisors = Array(N + 1).fill(0);		for ( let i = 2; i <= N; ++i) {			if (SumOfPrimeDivisors[i] == 1) {				for (let j = i; j <= N; j += i) {					SumOfPrimeDivisors[j] += i;				}			}		}		return SumOfPrimeDivisors[N];	}function RuthAaronNumber( n) {		if (Sum(n) == Sum(n + 1))			return true;		else			return false;	}
function isPrime(n)	{		if (n == 1)			return true;		if (n <= 3)			return true;		if (n % 2 == 0 n % 3 == 0)			return false;		for (let i = 5; i * i <= n; i = i + 6)			if (n % i == 0				|| n % (i + 2) == 0)				return false;		return true;	}function checkExpression(n)	{		if (isPrime(n))			document.write("Yes");		else			document.write("No");	}
function isDNum( n) {		if (n < 4)			return false;		let numerator = 0, hcf = 0;		for ( k = 2; k <= n; k++) {			numerator = parseInt( (Math.pow(k, n - 2) - k));			hcf = __gcd(n, k);		}		if (hcf == 1 && (numerator % n) != 0)			return false;		return true;	}function __gcd( a, b) {		return b == 0 ? a : __gcd(b, a % b);	}
function sigma(n){	if (n == 1)		return 1;	var result = 0;	for (var i = 2; i <= Math.sqrt(n); i++) {		if (n % i == 0) {			if (i == (n / i))				result += i;			else				result += (i + n / i);		}	}	return (result + n + 1);}function isSuperabundant(N){	for (var i = 1; i < N; i++) {		var x = sigma(i) / i;		var y = sigma(N) / (N * 1.0);		if (x > y)			return false;	}	return true;}
function isInsolite( n) {		let N = n;		let sum = 0;		let product = 1;		while (n != 0) {			let r = n % 10;			sum = sum + r * r;			product = product * r * r;			n = parseInt(n / 10);		}		return (N % sum == 0) && (N % product == 0);	}
function reverse( num) {		let rev_num = 0;		while (num > 0) {			rev_num = rev_num * 10 + num % 10;			num = parseInt(num / 10);		}		return rev_num;	}function properDivSum( num) {		let result = 0;		for ( i = 2; i <= Math.sqrt(num); i++) {			if (num % i == 0) {				if (i == (num / i))					result += i;				else					result += (i + num / i);			}		}		return (result + 1);	}function isTcefrep( n) {		return properDivSum(n) == reverse(n);	}
function print_product( a, b, c, d){	let prod1 = a * c;	let prod2 = b * d;	let prod3 = (a + b) * (c + d);	let real = prod1 - prod2;	let imag = prod3 - (prod1 + prod2);	document.write(real + " + " + imag + "i");}
function sieve(){	v[1] = 1;	for (let i = 2; i < x; i++)		v[i] = i;	for (let i = 4; i < x; i += 2)		v[i] = 2;	for (let i = 3; i * i < x; i++) {		if (v[i] == i) {			for (let j = i * i; j < x; j += i) {				if (v[j] == j) {					v[j] = i;				}			}		}	}}function prime_factors(n){	let s = new Set();	while (n != 1) {		s.add(v[n]);		n = n / v[n];	}	return s.size;}function distinctPrimes(m, k){	let result = new Array();	for (let i = 14; i < m + k; i++) {		let count			= prime_factors(i);		if (count == k) {			result.push(i);		}	}	let p = result.length;	for (let index = 0; index < p - 1; index++) {		let element = result[index];		let count = 1, z = index;		while (z < p - 1 && count <= k && result[z] + 1 == result[z + 1]) {			count++;			z++;		}		if (count >= k)			document.write(element + ' ');	}}
function findMaximumGcd(n){	let max_gcd = 1;	for(let i = 1; i * i <= n; i++)	{		if (n % i == 0)		{			if (i > max_gcd)				max_gcd = i;			if ((n / i != i) &&				(n / i != n) &&			((n / i) > max_gcd))				max_gcd = n / i;		}	}	return max_gcd;}
function powerOptimised(a, n){	let ans = 1;	while (n > 0)	{		let last_bit = (n & 1);		if (last_bit > 0)		{			ans = ans * a;		}		a = a * a;		n = n >> 1;	}	return ans;}
function nCr(n, r){	let res = 1;	if (r > n - r)		r = n - r;	for (let i = 0; i < r; ++i)	{		res *= (n - i);		res /= (i + 1);	}	return res;}
function nCr(n, r){	let res = 1;	if (r > n - r)		r = n - r;	for (let i = 0; i < r; ++i)	{		res *= (n - i);		res /= (i + 1);	}	return res;}function solve(n, m, k){	let sum = 0;	for (let i = 0; i <= k; i++)		sum += nCr(n, i)			* nCr(m, k - i);	return sum;}
function gcd(a, b){	if (a == 0)		return b;	return gcd(b % a, a);}function lcm(a, b){	return (a * b) / gcd(a, b);}function findLCM(arr){	var nth_lcm = arr[0];	for (var i = 1; i < arr.length; i++)		nth_lcm = lcm(nth_lcm, arr[i]);	Landau = Math.max(Landau, nth_lcm);}function findWays(arr, i, n){	if (n == 0)		findLCM(arr);	for (var j = i; j <= n; j++) {		arr.push(j);		findWays(arr, j, n - j);		arr.pop();	}}function Landau_function(n){	arr = [];	findWays(arr, 1, n);	document.write( Landau);}
function prime(n)	{		if (n == 1)			return false;		for (i = 2; i * i <= n; i++)		{			if (n % i == 0)				return false;		}		return true;	}function minDivisior(n)	{		if (prime(n))		{			document.write(1 + " " + (n - 1));		}		else		{			for (i = 2; i * i <= n; i++)			{				if (n % i == 0)				{					document.write(n / i + " " + (n / i * (i - 1)));					break;				}			}		}	}
function functionMax( arr, n){	var setBit = Array.from(Array(32), ()=>new Array());	for (var i = 0; i < n; i++) {		for (var j = 0; j < size_int; j++) {			if (arr[i] & (1 << j))				setBit[j].push(i);		}	}	for (var i = size_int-1; i >= 0; i--) {		if (setBit[i].length == 1) {			[arr[0], arr[setBit[i][0]]] = [arr[setBit[i][0]], arr[0]];			break;		}	}	var maxAnd = arr[0];	for (var i = 1; i < n; i++) {		maxAnd = maxAnd & (~arr[i]);	}	return maxAnd;}
function findPrimeNos(L, R, M){	for(var i = L; i <= R; i++)	{		if (M.has(i))			M.set(i, M.get(i) + 1)		else			M.set(i, 1)	}	if (M.has(1))	{		M.delete(1);	}	for(var i = 2; i <= parseInt(Math.sqrt(R)); i++)	{		var multiple = 2;		while ((i * multiple) <= R)		{			if (M.has(i * multiple))			{				M.delete(i * multiple);			}			multiple++;		}	}	return M;}function getPrimePairs(L, R, K){	var M = new Map();	M = findPrimeNos(L, R, M);	M.forEach((value, key) => {		if (M.has(key + K))		{			document.write("(" + key + ", " +						(key + K) + ") "); } });}
function checkRearrangements(mat, N, M){ for (let i = 0; i < N; i++) {	for (let j = 1; j < M; j++)	{	if (mat[i][0] != mat[i][j])	{		return "Yes";	}	} } return "No";}function nonZeroXor(mat, N, M){ let res = 0; for (let i = 0; i < N; i++) {	res = res ^ mat[i][0]; } if (res != 0)	return "Yes"; else	return checkRearrangements(mat, N, M);}
function findTheGreatestX(P, Q){	var divisiors = new Map();	for(var i = 2; i * i <= Q; i++)	{		while (Q % i == 0 && Q > 1)		{			Q = parseInt(Q / i);			if (divisiors.has(i))				divisiors.set(i, divisiors.get(i) + 1)			else				divisiors.set(i, 1)		}	}	if (Q > 1)		if (divisiors.has(Q))			divisiors.set(Q, divisiors.get(Q) + 1)		else			divisiors.set(Q, 1)	var ans = 0;	divisiors.forEach((value, key) => {		var frequency = value;		var temp = P;		var cur = 0;		while (temp % key == 0)		{			temp = parseInt(temp / key);			cur++;		}		if (cur < frequency)		{			ans = P;		}		temp = P;		for(var j = cur; j >= frequency; j--)		{			temp = parseInt(temp / key);		}		ans = Math.max(temp, ans); });	document.write(ans);}
function minimumSubsetDifference(N){	let blockOfSize8 = N / 8;	let str = "ABBABAAB";	let subsetDifference = 0;	let partition = "";	while (blockOfSize8-- > 0)	{		partition += str;	}	let A = [];	let B = [];	let x = 0, y = 0;	for(let i = 0; i < N; i++)	{		if (partition[i] == 'A')		{			A[x++] = ((i + 1) * (i + 1));		}		else		{			B[y++] = ((i + 1) * (i + 1));		}	}	document.write(subsetDifference + "<br/>");	for(let i = 0; i < x; i++)		document.write(A[i] + " ");	document.write("<br/>");	for(let i = 0; i < y; i++)		document.write(B[i] + " ");}
function minMoves(arr, N){	var odd_element_cnt = 0;	var i;	for(i = 0; i < N; i++) {		if (arr[i] % 2 != 0) {			odd_element_cnt++;		}	}	var moves = Math.floor((odd_element_cnt)/2);	if (odd_element_cnt % 2 != 0)		moves += 2;	document.write(moves);}
function countSetBits(N){	let count = 0;	while (N != 0)	{		N = N & (N - 1);		count++;	}	return count;}
def maxAdjacent(arr, N):	res = []	arr_max = -sys.maxsize - 1	for i in range(1, N):		arr_max = max(arr_max,					abs(arr[i - 1] - arr[i]))	for i in range(1, N - 1):		curr_max = abs(arr[i - 1] - arr[i + 1])		ans = max(curr_max, arr_max)		res.append(ans)	for x in res:		print(x, end=" ")	print()
def maxAdjacent(arr, N):	res = []	for i in range(1, N - 1):		prev = arr[0]		maxi = -1* float('inf')		for j in range(1,N):			if (i == j):				continue			maxi = max(maxi, abs(arr[j] - prev))			prev = arr[j]		res.append(maxi)	for x in res:		print(x,end=' ')	print()
def minSum(A, N):	mp = {}	sum = 0	for i in range(N):		sum += A[i]		if A[i] in mp:			mp[A[i]] += 1		else:			mp[A[i]] = 1	minSum = float('inf')	for it in mp:		minSum = min(minSum, sum - (it * mp[it]))	return minSum
def countElements(N):	Cur_Ele = 1	Count = 0	while (Cur_Ele <= N):		Count += 1		Cur_Ele = Cur_Ele * 2	print(N - Count)
def isPossible(N):	return ((N & (N - 1)) and N)def countElements(N):	count = 0	for i in range(1, N + 1):		if (isPossible(i)):			count += 1	print (count)
def singleDigitSubarrayCount(arr, N):	res = 0	count = 0	for i in range(N):		if (arr[i] <= 9):			count += 1			res += count		else:			count = 0	print (res)
def productExceptSelf(arr, N) :	product = 1	z = 0	for i in range(N):		if (arr[i] != 0) :			product *= arr[i]		if(arr[i] == 0):			z += 1	a = abs(product)	for i in range(N):		if (z == 1) :			if (arr[i] != 0) :				arr[i] = 0			else :				arr[i] = product			continue		elif (z > 1) :			arr[i] = 0			continue		b = abs(arr[i])		curr = round(math.exp(math.log(a) - math.log(b)))		if (arr[i] < 0 and product < 0):			arr[i] = curr		elif (arr[i] > 0 and product > 0):			arr[i] = curr		else:			arr[i] = -1 * curr	for i in range(N):		print(arr[i], end = " ")
def convertToASCII(N):	num = str(N)	i = 0	for ch in num:		print(ch, "(", ord(ch), ")")
def isPossible(target): max = 0 index = 0 for i in range(len(target)):	if (max < target[i]):	max = target[i]	index = i if (max == 1):	return True for i in range(len(target)):	if (i != index):	max -= target[i]	if (max <= 0):		return False target[index] = max return isPossible(target)
def gcd(a, b) :	while (b > 0) :		rem = a % b		a = b		b = rem	return adef countNumberOfWays(n) :	if (n == 1) :		return -1	g = 0	power = 0	while (n % 2 == 0) :		power += 1		n //= 2	g = gcd(g, power)	for i in range(3, int(math. sqrt(g)) + 1, 2):		power = 0		while (n % i == 0) :			power += 1			n //= i			g = gcd(g, power)	if (n > 2) :		g = gcd(g, 1)	ways = 1	power = 0	while (g % 2 == 0) :		g //= 2		power += 1	ways *= (power + 1)	for i in range(3, int(math. sqrt(g)) + 1, 2):		power = 0		while (g % i == 0) :			power += 1			g /= i		ways *= (power + 1)	if (g > 2) :		ways *= 2	return ways
def countPrimeFactors(n) :	count = 0	while (n % 2 == 0) :		n = n // 2		count += 1	for i in range(3, int(math.sqrt(n) + 1), 2) :		while (n % i == 0) :			n = n // i			count += 1	if (n > 2) :		count += 1	return (count)def findSum(n) :	sum = 0	i = 1	num = 2	while(i <= n) :		if (countPrimeFactors(num) == 2) :			sum += num			i += 1		num += 1	return sumdef check(n, k) :	s = findSum(k - 1)	if (s >= n) :		print("No")	else :		print("Yes")
def partitionArray(a, n) : Min = [0] * n Mini = sys.maxsize for i in range(n - 1, -1, -1):	Mini = min(Mini, a[i])	Min[i] = Mini Maxi = -sys.maxsize - 1 ind = -1 for i in range(n - 1):	Maxi = max(Maxi, a[i])	if (Maxi < Min[i + 1]) :	ind = i	break if (ind != -1) :	for i in range(ind + 1):	print(a[i], end = " ")	print()	for i in range(ind + 1 , n , 1):	print(a[i], end = " ") else :	print("Impossible")
def perfectSquare(num):	sr = int(sqrt(num))	a = sr * sr	b = (sr + 1) * (sr + 1)	if ((num - a) < (b - num)):		return a	else:		return bdef powerOfTwo(num):	lg = int(log2(num))	p = int(pow(2, lg))	return pdef uniqueElement(arr, N):	ans = True	freq = {}	for i in range(N):		if (arr[i] in freq):			freq[arr[i]] += 1		else:			freq[arr[i]] = 1	res = []	for key,value in freq.items():		if (value == 1):			ans = False			ps = perfectSquare(key)			res.append(powerOfTwo(ps))	res.sort(reverse = False)	for x in res:	print(x, end = " ")	if (ans):		print("-1")
def multiplyByMersenne(N, M) :	x = int(math.log2(M + 1))	return ((N << x) - N)
def checkCommonDivisor(arr, N, X):	G = 0	for i in range(N):		G = math.gcd(G, arr[i])	copy_G = G	for divisor in range(2, X + 1):		while (G % divisor == 0):			G = G // divisor	if (G <= X):		print("Yes")		for i in range(N):			print(arr[i] // copy_G, end = " ")		print()	else:		print("No")
def check(Adj, Src, N, visited):	color = [0] * N	visited = [True] * Src	q = deque()	q.append(Src)	while (len(q) > 0):		u = q.popleft()		Col = color[u]		for x in Adj[u]:			if (visited[x] == True and color[x] == Col):				return False			elif (visited[x] == False):				visited[x] = True				q.append(x)				color[x] = 1 - Col	return Truedef addEdge(Adj, u, v):	Adj[u].append(v)	Adj[v].append(u)	return Adjdef isPossible(Arr, N):	Adj = [[] for i in range(N)]	for i in range(N - 1):		for j in range(i + 1, N):			if (Arr[i][0] < Arr[j][1] or Arr[i][1] > Arr[j][0]):				continue			else:				if (Arr[i][2] == Arr[j][2]):					Adj = addEdge(Adj, i, j)	visited = [False] * N	for i in range(N):		if (visited[i] == False and len(Adj[i]) > 0):			if (check(Adj, i, N, visited) == False):				print ("No")				return	print ("Yes")
def minimumSteps(x, y):	cnt = 0	while (x != 0 and y != 0):		if (x > y):			cnt += x / y			x %= y		else:			cnt += y / x			y %= x	cnt -= 1	if (x > 1 or y > 1):		cnt = -1	print(int(cnt))
def vectorMagnitude(x, y, z):	sum = x * x + y * y + z * z	return sqrt(sum)
def findMedian(Mean, Mode):	Median = (2 * Mean + Mode) // 3	print(Median)
def sieveOfEratosthenes(N, s):	prime = [False]*(N + 1)	for i in range(2, N + 1, 2):		s[i] = 2	for i in range(3, N, 2):		if (prime[i] == False):			s[i] = i			for j in range(i, N, 2):				if j * i > N:					break				if (not prime[i * j]):					prime[i * j] = True					s[i * j] = idef findDifference(N):	s = [0]*(N+1)	sieveOfEratosthenes(N, s)	total , odd , even =1, 1, 0	curr = s[N]	cnt = 1	while (N > 1):		N //= s[N]		if (curr == s[N]):			cnt += 1			continue		if (curr == 2):			total = total * (cnt + 1)		else:			total = total * (cnt + 1)			odd = odd * (cnt + 1)		curr = s[N]		cnt = 1	even = total - odd	print(abs(even - odd))
def findPermutation(arr):	N = len(arr)	i = N - 2	while (i >= 0 and arr[i] <= arr[i + 1]):		i -= 1	if (i == -1) :		print("-1")		return	j = N - 1	while (j > i and arr[j] >= arr[i]):		j -= 1	while (j > i and arr[j] == arr[j - 1]) :		j -= 1	temp = arr[i];	arr[i] = arr[j];	arr[j] = temp;	for it in arr :		print(it, end = " ")
def evenOddBitwiseXOR(N):	print("Even: ", 0, end = " ")	for i in range(4, N + 1, 4):		print(i, end = " ")	print()	print("Odd: ", 1, end = " ")	for i in range(4, N + 1, 4):		print(i - 1, end = " ")	if (N % 4 == 2):		print(N + 1)	elif (N % 4 == 3):		print(N)
def check(n):	sumOfDigit = 0	prodOfDigit = 1	while n > 0:		rem = n % 10		sumOfDigit += rem		prodOfDigit *= rem		n = n // 10	if sumOfDigit > prodOfDigit:		print("Yes")	else:		print("No")
def findbitwiseOR(a, n):	res = 0	for i in range(n):		res = res | a[i]	print(res)
def findbitwiseOR(a, n):	res = 0	for i in range(n):		curr_sub_array = a[i]		res = res | curr_sub_array		for j in range(i, n):			curr_sub_array = curr_sub_array & a[j]			res = res | curr_sub_array	print (res)
def KthSmallest(A, B, N, K):	M = 0	for i in range(N):		M = max(A[i], M)	freq = [0] * (M + 1)	for i in range(N):		freq[A[i]] += B[i]	sum = 0	for i in range(M + 1):		sum += freq[i]		if (sum >= K):			return i	return -1
def isDivisibleByDivisor(S, D):	S %= D	hashMap = set()	hashMap.add(S)	for i in range(D+1):		S += (S % D)		S %= D		if (S in hashMap):			if (S == 0):				return "Yes"			return "No"		else:			hashMap.add(S)	return "Yes"
def PrimeFactor(N):	ANS = dict()	while N % 2 == 0:		if 2 in ANS:			ANS[2] += 1		else:			ANS[2] = 1		N = N//2	for i in range(3, int(math.sqrt(N))+1, 2):		while N % i == 0:			if i in ANS:				ANS[i] += 1			else:				ANS[i] = 1			N = N // i	if 2 < N:		ANS[N] = 1	return ANSdef CountToMakeEqual(X, Y):	GCD = math.gcd(X, Y)	newY = X//GCD	newX = Y//GCD	primeX = PrimeFactor(newX)	primeY = PrimeFactor(newY)	ans = 0	for factor in primeX:		if X % factor != 0:			return -1		ans += primeX[factor]	for factor in primeY:		if Y % factor != 0:			return -1		ans += primeY[factor]	return ans
def isPrime(X):	for i in range(2, int(sqrt(X)) + 1, 1):		if (X % i == 0):			return False	return Truedef printPrimes(A, N):	for i in range(N):		j = A[i] - 1		while(1):			if (isPrime(j)):				print(j, end = " ")				break			j -= 1		j = A[i] + 1		while (1):			if (isPrime(j)):				print(j, end = " ")				break			j += 1		print("\n", end = "")
def countSubarray(arr, n):	count = 0	L = 0	R = 0	mx = max(arr)	for i in range(n):		if (arr[i] * 2 > mx):			L = i			break	i = n - 1	while (i >= 0):		if (arr[i] * 2 > mx):			R = i			break		i -= 1	print((L + 1) * (n - R))
def countSubarray(arr, n):	count = 0	for i in range(n):		for j in range(i, n, 1):			mxSubarray = 0			mxOther = 0			for k in range(i, j + 1, 1):				mxSubarray = max(mxSubarray, arr[k])			for k in range(0, i, 1):				mxOther = max(mxOther, arr[k])			for k in range(j + 1,n,1):				mxOther = max(mxOther, arr[k])			if (mxSubarray > (2 * mxOther)):				count += 1	print(count)
def gcd(a, b):	if b == 0:		return a	return gcd(b, a % b)def countPairs(arr, N):	for i in range(0, N):		count = 0		for x in range(1, arr[i] + 1):			for y in range(x, arr[i] + 1):				if gcd(x, y) > 1:					count += 1		print(count, end = " ")
def factorial(n):	if (n == 0):		return 1	return n * factorial(n - 1)def numOfNecklace(N):	ans = factorial(N) // (factorial(N // 2) * factorial(N // 2))	ans = ans * factorial(N // 2 - 1)	ans = ans * factorial(N // 2 - 1)	ans //= 2	return ans
def maxSubArraySumRepeated(arr, N, K):	sum = 0	for i in range(N):		sum += arr[i]	curr = arr[0]	ans = arr[0]	if (K == 1):		for i in range(1,N,1):			curr = max(arr[i], curr + arr[i])			ans = max(ans, curr)		return ans	V = []	for i in range(2 * N):		V.append(arr[i % N])	maxSuf = V[0]	maxPref = V[2 * N - 1]	curr = V[0]	for i in range(1,2 * N,1):		curr += V[i]		maxPref = max(maxPref, curr)	curr = V[2 * N - 1]	i = 2 * N - 2	while(i >= 0):		curr += V[i]		maxSuf = max(maxSuf, curr)		i -= 1	curr = V[0]	for i in range(1, 2 * N, 1):		curr = max(V[i], curr + V[i])		ans = max(ans, curr)	if (sum > 0):		temp = sum * (K - 2)		ans = max(ans, max(temp + maxPref, temp + maxSuf))	return ans
def ExpoFactorial(N):	res = 1	mod = (int)(1000000007)	for i in range(2, N + 1):		res = pow(i, res, mod)	return res
def rangeSum(arr, N, L, R):	prefix = [0 for i in range(N + 1)]	prefix[0] = 0	for i in range(1,N+1,1):		prefix[i] = prefix[i - 1] + arr[i - 1]	leftsum = ((L - 1) // N) * prefix[N] + prefix[(L - 1) % N]	rightsum = (R // N) * prefix[N] + prefix[R % N]	print(rightsum - leftsum)
def rangeSum(arr, N, L, R):	sum = 0	for i in range(L - 1,R,1):		sum += arr[i % N]	print(sum)
def check(N):	twos = 0	fives = 0	while (N % 2 == 0):		N /= 2		twos += 1	while (N % 5 == 0):		N /= 5		fives += 1	if (N == 1 and twos <= fives):		print(2 * fives - twos)	else:		print(-1)
def getPairsCount(arr, n):	count = 0	for i in range(n):		for j in range(arr[i] - (i % arr[i]),n,arr[i]):			if (i < j and abs(arr[i] - arr[j]) >= min(arr[i], arr[j])):				count += 1	return count
def smallest(k, d):	cnt = 1	m = d % k	v = [0 for i in range(k)];	v[m] = 1	while (1):		if (m == 0):			return cnt		m = (((m * (10 % k)) % k) + (d % k)) % k		if (v[m] == 1):			return -1		v[m] = 1		cnt += 1	return -1
def performQuery(arr, Q):	for i in range (0, len(Q)):		orr = 0		x = Q[i][0]		arr[x - 1] = Q[i][1]		for j in range(0,len(arr)):			orr = orr | arr[j]		print(orr ,end= " ")
def countSubsequences(arr):	odd = 0	for x in arr:		if (x & 1):			odd = odd + 1	return (1 << odd) - 1
def polygonArea(X,Y, n) :	area = 0.0	j = n - 1	for i in range( 0, n) :		area = area + (X[j] + X[i]) * (Y[j] - Y[i])	return abs(area // 2.0)
def numberOfSquares(base):	base = (base - 2)	base = base // 2	return base * (base + 1) / 2
def findRightAngle(A, H):	D = pow(H,4) - 16 * A * A	if D >= 0:		root1 = (H * H + sqrt(D))/2		root2 = (H * H - sqrt(D))/2		a = sqrt(root1)		b = sqrt(root2)		if b >= a:			print a, b, H		else:			print b, a, H	else:		print "-1"
def numberOfDiagonals(n):	return n * (n - 3) / 2
def checkCollision(a, b, c, x, y, radius):	dist = ((abs(a * x + b * y + c)) /			math.sqrt(a * a + b * b))	if (radius == dist):		print("Touch")	elif (radius > dist):		print("Intersect")	else:		print("Outside")
static double area(int R)	{		double Base = 1.732 * R;		double height = (1.5) * R;		double area = 0.5 * Base * height;		return area;	}
static double area_of_circle(int m, int n) { 	int square_of_radius = ( m * n ) / 4; 	double area = ( 3.141 * square_of_radius ); 	return area; }
static int Icosihenagonal_num(int n){	return (19 * n * n - 17 * n) / 2;}
static int Icositetragonal_num(int n){	return (22 * n * n - 20 * n) / 2;}
static int maxPointOfIntersection(int x, int y){	int k = y * (y - 1) / 2;	k = k + x * (2 * y + x - 1);	return k;}
static int areaOfSquare(int S){	int area = S * S;	return area;}
static void findHeight(float p1, float p2, float b, float c){	float a = Math.Max(p1, p2) - Math.Min(p1, p2);	float s = (a + b + c) / 2;	float area = (int)Math.Sqrt(s * (s - a)					* (s - b) * (s - c));	float height = (area * 2) / a;	Console.Write("Height is: " + height);}
static float distance(int m, int n, int p, int q){	return (float)Math.Sqrt(Math.Pow(n - m, 2) +							Math.Pow(q - p, 2) * 1.0);}static void Excenters(int x1, int y1, int x2, int y2, int x3, int y3){	float a = distance(x2, x3, y2, y3);	float b = distance(x3, x1, y3, y1);	float c = distance(x1, x2, y1, y2);	pair[] excenter = new pair[4];	excenter[1] = new pair((-(a * x1) + (b * x2) +							(c * x3)) / (-a + b + c),						(-(a * y1) + (b * y2) +							(c * y3)) / (-a + b + c));	excenter[2] = new pair(((a * x1) - (b * x2) +							(c * x3)) / (a - b + c),						((a * y1) - (b * y2) +							(c * y3)) / (a - b + c));	excenter[3] = new pair(((a * x1) + (b * x2) -							(c * x3)) / (a + b - c),						((a * y1) + (b * y2) -							(c * y3)) / (a + b - c));	for (int i = 1; i <= 3; i++)	{		Console.WriteLine((int)excenter[i].first + " " +						(int)excenter[i].second);	}}
static void triangleArea(int a, int b){	double ratio = (double)b / a;	Console.WriteLine(ratio);}
static float calculateArea(float A, float B, float C, float D){	float S = (A + B + C + D) / 2;	float area = (float)Math.Sqrt((S - A) * (S - B) *								(S - C) * (S - D));	return area;}
static double eccHyperbola(double A, double B){	double r = (double)B * B / A * A;	r += 1;	return Math.Sqrt(r);}
static bool check(circle []C){	double C1C2 = Math.Sqrt(		(C[1].x - C[0].x) * (C[1].x - C[0].x) +		(C[1].y - C[0].y) * (C[1].y - C[0].y));	bool flag = false;	if (C1C2 < (C[0].r + C[1].r))	{		if ((C[0].x + C[1].x) == 2 * C[2].x &&			(C[0].y + C[1].y) == 2 * C[2].y)		{			flag = true;		}	}	return flag;}static bool IsFairTriplet(circle []c){	bool f = false;	f |= check(c);	for(int i = 0; i < 2; i++)	{		swap(c[0], c[2]);		f |= check(c);	}	return f;}static void swap(circle circle1, circle circle2){	circle temp = circle1;	circle1 = circle2;	circle2 = temp;}
static int power(int x, int y, int p)	{		int res = 1;		x = x % p;		while (y > 0)		{			if (y % 2 == 1)				res = (res * x) % p;			y = y >> 1;			x = (x * x) % p;		}		return res;	}static int findModuloByM(int X, int N, int M)	{		if (N < 6)		{			string temp="";			for(int i = 0; i< N ; i++)				temp = temp + (char)(X + 48);			int res = Convert.ToInt32(temp) % M;			return res;		}		if (N % 2 == 0)		{			int half = findModuloByM(X, N / 2, M) % M;			int res = (half * power(10, N / 2, M) + half)					% M;			return res;		}		else		{			int half = findModuloByM(X, N / 2, M) % M;			int res = (half * power(10, N / 2 + 1, M) + half * 10 + X)					% M;			return res;		}	}
static int numPairs(int []a, int n){	int ans, i, index;	ans = 0;	for (i = 0; i < n; i++)		a[i] = Math.Abs(a[i]);	Array.Sort(a);	for (i = 0; i < n; i++)	{		index = 2;		ans += index - i - 1;	}	return ans;}
static void dfs(int i, int j, int[,] grid, bool[,] vis, int z, int z_count) {	int n = grid.GetLength(0), m = grid.GetLength(1);	vis[i,j] = true;	if (grid[i,j] == 0)	z++;	if (grid[i,j] == 2)	{	if (z == z_count)		ans++;	vis[i,j] = false;	return;	}	if (i >= 1 && !vis[i - 1,j] && grid[i - 1,j] != -1)	dfs(i - 1, j, grid, vis, z, z_count);	if (i < n - 1 && !vis[i + 1,j] && grid[i + 1,j] != -1)	dfs(i + 1, j, grid, vis, z, z_count);	if (j >= 1 && !vis[i,j - 1] && grid[i,j - 1] != -1)	dfs(i, j - 1, grid, vis, z, z_count);	if (j < m - 1 && !vis[i,j + 1] && grid[i,j + 1] != -1)	dfs(i, j + 1, grid, vis, z, z_count);	vis[i,j] = false; }static int uniquePaths(int[,] grid) {	int n = grid.GetLength(0), m = grid.GetLength(1);	bool[,] vis = new bool[n,m];	for (int i = 0; i < n; i++)	{		for(int j = 0; j < m; j++)		{			vis[i,j] = false;		}	}	int x = 0, y = 0;	for (int i = 0; i < n; ++i)	{	for (int j = 0; j < m; ++j)	{		if (grid[i,j] == 0)		z_count++;		else if (grid[i,j] == 1)		{		x = i;		y = j;		}	}	}	dfs(x, y, grid, vis, 0, z_count);	return ans; }
static void dfs(int u, int count)	{		visited[u] = true;		int temp = 0;		for (int i = 0; i < adjacent[u].Count; i++)		{			if (!visited[adjacent[u][i]])			{				temp++;				dfs(adjacent[u][i], count + 1);			}		}		if (temp == 0)		{			if (maxi < count)			{				maxi = count;				startnode = u;			}		}	}static void dfs1(int u, int count)	{		visited[u] = true;		int temp = 0;		for (int i = 0; i < adjacent[u].Count; i++)		{			if (!visited[adjacent[u][i]])			{				temp++;				parent[adjacent[u][i]] = u;				dfs1(adjacent[u][i], count + 1);			}		}		if (temp == 0)		{			if (maxi < count)			{				maxi = count;				endnode = u;			}		}	}static void dfs2(int u, int count)	{		visited[u] = true;		int temp = 0;		for (int i = 0; i < adjacent[u].Count; i++)		{			if (!visited[adjacent[u][i]] && !vis[adjacent[u][i]])			{				temp++;				dfs2(adjacent[u][i], count + 1);			}		}		if (temp == 0)		{			if (maxi < count)			{				maxi = count;				thirdnode = u;			}		}	}static void findNodes()	{		dfs(1, 0);		for (int i = 0; i <= N; i++)			visited[i] = false;		maxi = -1;		dfs1(startnode, 0);		for (int i = 0; i <= N; i++)			visited[i] = false;		int x = endnode;		vis[startnode] = true;		while (x != startnode)		{			vis[x] = true;			x = parent[x];		}		maxi = -1;		for (int i = 1; i <= N; i++)		{			if (vis[i])				dfs2(i, 0);		}	}
static void parity(List<int> even, List<int> odd, List<int> v, int i) { 	if (i == v.Count even.Count == 0 && odd.Count == 0) 	{		int count = 0; 		for(int j = 0; j < v.Count - 1; j++)		{			if (v[j] % 2 != v[j + 1] % 2) 				count++; 		} 		if (count < min) 			min = count; 		return; 	} 	if (v[i] != -1) 		parity(even, odd, v, i + 1); 	else 	{		if (even.Count != 0)		{ 			int x = even[even.Count - 1]; 			even.RemoveAt(even.Count - 1); 			v[i] = x; 			parity(even, odd, v, i + 1); 			even.Add(x); 		} 		if (odd.Count != 0)		{ 			int x = odd[odd.Count - 1]; 			odd.RemoveAt(odd.Count - 1); 			v[i] = x; 			parity(even, odd, v, i + 1); 			odd.Add(x); 		} 	} }static void minDiffParity(List<int> v, int n) { 	List<int> even = new List<int>();	List<int> odd = new List<int>();	Dictionary<int, 			int> m = new Dictionary<int, 									int>(); 	for(int i = 1; i <= n; i++)	{		if (m.ContainsKey(i))		{			m[i] = 1;		}		else		{			m.Add(i, 1);		}	}	for(int i = 0; i < v.Count; i++)	{ 		if (v[i] != -1) 			m.Remove(v[i]); 	} 	foreach(KeyValuePair<int, int> i in m)	{			if (i.Key % 2 == 0) 		{			even.Add(i.Key); 		}		else		{			odd.Add(i.Key);		}	} 	min = 1000;	parity(even, odd, v, 0); 	Console.WriteLine(min); }
public static double getProbability(int[] balls)	{		factorial(10);		box2 = balls.Length;		int K = 0;		for (int i = 0; i < balls.Length; i++)			K += balls[i];		if (K % 2 == 1)			return 0;		long all = comb(K, K / 2);		long validPermutationss = validPermutations((K / 2), balls, 0, 0);		return (double)validPermutationss / all;	}static long validPermutations(int n, int[] balls, int usedBalls, int i)	{		if (usedBalls == n)		{			return box1 == box2 ? 1 : 0;		}		if (i >= balls.Length)			return 0;		long res = validPermutations(n, balls, usedBalls, i + 1);		box1++;		for (int j = 1; j <= balls[i]; j++)		{			if (j == balls[i])				box2--;			long combinations = comb(balls[i], j);			res += combinations * validPermutations(n, balls, usedBalls + j, i + 1);		}		box1--;		box2++;		return res;	}static void factorial(int N)	{		fact[0] = 1;		for (int i = 1; i <= N; i++)			fact[i] = fact[i - 1] * i;	}static long comb(int n, int r)	{		long res = fact[n] / fact[r];		res /= fact[n - r];		return res;	}
static void reverse(String str)	{		if ((str == null) || (str.Length <= 1))		Console.Write(str);		else		{			Console.Write(str[str.Length-1]);			reverse(str.Substring(0,(str.Length-1)));		}	}
public static String[] RevString(String[] s, int l){	if (l % 2 == 0)	{		int j = l / 2;		while (j <= l - 1)		{			String temp;			temp = s[l - j - 1];			s[l - j - 1] = s[j];			s[j] = temp;			j += 1;		}	}	else	{		int j = (l / 2) + 1;		while (j <= l - 1)		{			String temp;			temp = s[l - j - 1];			s[l - j - 1] = s[j];			s[j] = temp;			j += 1;		}	}	return s;}
static bool isPalindrome(String str)	{		int l = 0;		int h = str.Length - 1;		while (h > l)			if (str[l++] != str[h--])				return false;		return true;	}static int minRemovals(String str)	{		if (str[0] == '')			return 0;		if (isPalindrome(str))			return 1;		return 2;	}
static int countTriplets(int []A){	int cnt = 0;	Dictionary<int,int> tuples = new Dictionary<int,int>();	foreach (int a in A)		foreach (int b in A)		{			if(tuples.ContainsKey(a & b))				tuples[a & b] = tuples[a & b] + 1;			else				tuples.Add(a & b, 1);		}	foreach (int a in A)		foreach (KeyValuePair<int, int> t in tuples)			if ((t.Key & a) == 0)				cnt += t.Value;	return cnt;}
static string toString(char[] a) {	string String = new string(a);	return String; }static void generate(int k, char[] ch, int n) {	if (n == k) {	Console.Write(toString(ch)+" ");	return;	}	if (ch[n - 1] == '0') {	ch[n] = '0';	generate(k, ch, n + 1);	ch[n] = '1';	generate(k, ch, n + 1);	}	if (ch[n - 1] == '1') {	ch[n] = '0';	generate(k, ch, n + 1);	} }static void fun(int k) {	if (k <= 0)	{	return;	}	char[] ch = new char[k];	ch[0] = '0';	generate(k, ch, 1);	ch[0] = '1';	generate(k, ch, 1); }
static String maximumPalinUsingKChanges(String str, int k) {	char[] palin = str.ToCharArray();	String ans = "";	int l = 0;	int r = str.Length - 1;	while (l < r) {	if (str[l] != str[r]) {		palin[l] = palin[r]		= (char)Math.Max(str[l], str[r]);		k--;	}	l++;	r--;	}	if (k < 0) {	return "Not possible";	}	l = 0;	r = str.Length - 1;	while (l <= r) {	if (l == r) {		if (k > 0) {		palin[l] = '9';		}	}	if (palin[l] < '9') {		if (k >= 2 && palin[l] == str[l] && palin[r] == str[r]) {		k -= 2;		palin[l] = palin[r] = '9';		}		else if (k >= 1				&& (palin[l] != str[l] palin[r] != str[r])) {		k--;		palin[l] = palin[r] = '9';		}	}	l++;	r--;	}	for (int i = 0; i < palin.Length; i++)	ans += palin[i];	return ans; }
static char largest_alphabet(String a, int n)	{		char max = 'A';		for (int i = 0; i < n; i++)			if (a[i] > max)				max = a[i];		return max;	}static char smallest_alphabet(String a, int n)	{		char min = 'z';		for (int i = 0; i < n - 1; i++)			if (a[i] < min)				min = a[i];		return min;	}
public static String processWords(String input){		String []s = input.Split(' ');		foreach(String values in s)		{			charBuffer.Append(values[0]);		}	return charBuffer.ToString();}
static String firstLetterWord(String str)	{		String result = "";		bool v = true;		for (int i = 0; i < str.Length; i++)		{			if (str[i] == ' ')			{				v = true;			}			else if (str[i] != ' ' && v == true)			{				result += (str[i]);				v = false;			}		}		return result;	}
static Boolean isVowel(char c)	{		return (c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U');	}static String reverseVowel(String str){	int i = 0;	int j = str.Length-1;	char[] str1 = str.ToCharArray();	while (i < j)	{		if (!isVowel(str1[i]))		{			i++;			continue;		}		if (!isVowel(str1[j]))		{			j--;			continue;		}		char t = str1[i];		str1[i]= str1[j];		str1[j]= t;		i++;		j--;	}	String str2 = String.Join("",str1);	return str2;}
static bool isVowel(char c)	{		return (c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U');	}static String reverseVowel(String str1)	{		int j = 0;		char[] str = str1.ToCharArray();		String vowel = "";		for (int i = 0; i < str.Length; i++)		{			if (isVowel(str[i]))			{				j++;				vowel += str[i];			}		}		for (int i = 0; i < str.Length; i++)		{			if (isVowel(str[i]))			{				str[i] = vowel[--j];			}		}		return String.Join("",str);	}
static public void printString(string str, char ch, int count)	{		int occ = 0, i;		if (count == 0) {			Console.WriteLine(str);			return;		}		for (i = 0; i < str.Length; i++)		{			if (str[i] == ch)				occ++;			if (occ == count)				break;		}		if (i < str.Length - 1)			Console.WriteLine(str.Substring(i + 1));		else			Console.WriteLine("Empty string");	}
static bool isNumber(string s)	{		for (int i = 0; i < s.Length; i++)			if (char.IsDigit(s[i]) == false)				return false;		return true;	}
static void permute(String input)	{		int n = input.Length;		int max = 1 << n;		input = input.ToLower();		for(int i = 0;i < max; i++)		{			char []combination = input.ToCharArray();			for(int j = 0; j < n; j++)			{				if(((i >> j) & 1) == 1)					combination[j] = (char) (combination[j] - 32);			}			Console.Write(combination);			Console.Write(" ");		}	}
static bool canFormPalindrome(string str)	{		int[] count = new int[NO_OF_CHARS];		for (int i = 0; i < str.Length; i++)			count[str[i]]++;		int odd = 0;		for (int i = 0; i < NO_OF_CHARS; i++) {			if ((count[i] & 1) != 0)				odd++;			if (odd > 1)				return false;		}		return true;	}
static bool isValidISBN(string isbn)	{		int n = isbn.Length;		if (n != 10)			return false;		int sum = 0;		for (int i = 0; i < 9; i++)		{			int digit = isbn[i] - '0';			if (0 > digit 9 < digit)				return false;			sum += (digit * (10 - i));		}		char last = isbn[9];		if (last != 'X' && (last < '0' last > '9'))			return false;		sum += ((last == 'X') ? 10 :						(last - '0'));		return (sum % 11 == 0);	}
static int countOccurrences(string str, string word){	string[] a = str.Split(' ');	int count = 0;	for (int i = 0; i < a.Length; i++)	{	if (word.Equals(a[i]))		count++;	}	return count;}
static bool isVowel(char c)	{		return (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');	}static String encryptString(char[] s, int n, int k)	{		int[] cv = new int[n];		int[] cc = new int[n];		if (isVowel(s[0]))			cv[0] = 1;		else			cc[0] = 1;		for (int i = 1; i < n; i++)		{			cv[i] = cv[i - 1] +				(isVowel(s[i]) == true ? 1 : 0);			cc[i] = cc[i - 1] +				(isVowel(s[i]) == true ? 0 : 1);		}		String ans = "";		int prod = 0;		prod = cc[k - 1] * cv[k - 1];		ans += String.Join("", prod);		for (int i = k; i < s.Length; i++)		{			prod = (cc[i] - cc[i - k]) *				(cv[i] - cv[i - k]);			ans += String.Join("", prod);		}		return ans;	}
static bool isVowel(char c) {		return (c == 'a' c == 'e' c == 'i' c == 'o' c == 'u');	}static String encryptString(String s, int n, int k) {		int countVowels = 0;		int countConsonants = 0;		String ans = "";		for (int l = 0; l <= n - k; l++) {			countVowels = 0;			countConsonants = 0;			for (int r = l; r <= l + k - 1; r++) {				if (isVowel(s[r]) == true) {					countVowels++;				} else {					countConsonants++;				}			}			ans += Convert.ToString(countVowels * countConsonants);		}		return ans;	}
public static String change_case(string a)	{		string temp = "";		int l = a.Length;		for(int i = 0 ; i < l ; i++)		{			char ch=a[i];			if(ch >= 'a' &&ch <= 'z')			ch = (char)(65 + (int)(ch - 'a'));			else if(ch >= 'A' &&ch <= 'Z')			ch = (char)(97 +				(int)(ch - 'A'));			temp += ch;		}		return temp;	}public static String delete_vowels(String a)	{		String temp = "";		int l = a.Length;		for(int i = 0 ; i < l ; i++)		{			char ch = a[i];			if(ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' && ch != 'A' && ch != 'E' && ch != 'O' && ch != 'U'&&ch != 'I')				temp += ch;		}		return temp;	}public static String insert_hash(String a)	{		String temp = "";		int l = a.Length;		char hash = '#';		for(int i = 0 ; i < l ; i++)		{			char ch=a[i];			if((ch >= 'a' && ch <= 'z') ||			(ch >= 'A' && ch <= 'Z'))				temp = temp + hash + ch;			else				temp = temp + ch;		}		return temp;	}public static void transformString(string a)	{		string b = delete_vowels(a);		string c = change_case(b);		string d = insert_hash(c);		Console.WriteLine(d);	}
static String convert(String s)	{		int n = s.Length;		String s1 = "";		s1 = s1 + Char.ToLower(s[0]);		for (int i = 1; i < n; i++)		{			if (s[i] == ' ' && i < n)			{				s1 = s1 + " " + Char.ToLower								(s[i + 1]);				i++;			}			else			s1= s1 + Char.ToUpper(s[i]);		}		return s1;	}
static string convert(string str)	{		string w = "", z = "";		str = str.ToUpper() + " ";		for (int i = 0; i < str.Length; i++)		{			char ch = str[i];			if (ch != ' ')				w = w + ch;			else			{				z = z + (Char.ToLower(w[0])) +						w.Substring(1) + " ";				w = "";			}		}		return z;	}
static void findDuplciates(string []a, int n, int m)	{		bool [,]isPresent = new bool[n, m];		for (int i = 0; i < n; i++)		{			for (int j = 0; j < m; j++)			{				for (int k = 0; k < n; k++)				{					if (a[i][j] == a[k][j] && i != k)					{						isPresent[i, j] = true;						isPresent[k, j] = true;					}				}				for (int k = 0; k < m; k++)				{					if (a[i][j] == a[i][k] && j != k)					{						isPresent[i, j] = true;						isPresent[i, k] = true;					}				}			}		}		for (int i = 0; i < n; i++)			for (int j = 0; j < m; j++)				if (!isPresent[i, j])					Console.Write(a[i][j]);	}
static void findSubsequence(string str, int k)	{		int []a = new int[MAX_CHAR];		for (int i = 0; i < str.Length; i++)			a[str[i] - 'a']++;		for (int i = 0; i < str.Length; i++)			if (a[str[i] - 'a'] >= k)				Console.Write(str[i]);	}
static int findSubSequence(string s, int num)	{		int res = 0;		int i = 0;		while (num > 0) {			if ((num & 1) == 1)				res += s[i] - '0';			i++;			num = num >> 1;		}		return res;	}static int combinedSum(string s)	{		int n = s.Length;		int c_sum = 0;		int range = (1 << n) - 1;		for (int i = 0; i <= range; i++)			c_sum += findSubSequence(s, i);		return c_sum;	}
static bool isPalindrome(string str)	{		int i = 0, j = str.Length - 1;		while (i < j)		{			if (str[i++] != str[j--])			return false;		}		return true;	}static String removePalinWords(string str)	{		string final_str = "", word = "";		str = str + " ";		int n = str.Length;		for (int i = 0; i < n; i++)		{			if (str[i] != ' ')				word = word + str[i];			else			{				if (!(isPalindrome(word)))					final_str += word + " ";				word = "";			}		}		return final_str;	}
static int productAtKthLevel(string tree, int k)	{		int level = -1;		int product = 1;		int n = tree.Length;		for (int i = 0; i < n; i++)		{			if (tree[i] == '(')				level++;			else if (tree[i] == ')')				level--;			else			{				if (level == k)					product *= (tree[i] - '0');			}		}		return product;	}
static bool isDivisible(String str, int k)	{		int n = str.Length;		int c = 0;		for (int i = 0; i < k; i++)			if (str[n - i - 1] == '0')					c++;		return (c == k);	}
static bool check(string s, int m){	int l = s.Length;	int c1 = 0;	int c2 = 0;	for (int i = 0; i < l; i++)	{		if (s[i] == '0')		{			c2 = 0;			c1++;		}		else		{			c1 = 0;			c2++;		}		if (c1 == m c2 == m)			return true;	}	return false;}
static int __builtin_popcount(int n)	{		int count = 0;		while (n > 0) {			count += n & 1;			n >>= 1;		}		return count;	}static void countEvenOdd(int []arr, int n, int K)	{		int even = 0, odd = 0;		for (int i = 0; i < n; i++) {			int x = __builtin_popcount(arr[i]);			if (x % 2 == 0)				even++;			else				odd++;		}		int y;		y = __builtin_popcount(K);		if ((y & 1) != 0) {			Console.WriteLine("Even = "+ odd + ", Odd = " + even);		}		else {			Console.WriteLine("Even = " + even + ", Odd = " + odd);		}	}
public static boolean is_possible(String s)	{		int l = s.length();		int one = 0, zero = 0;		for (int i = 0; i < l; i++) {			if (s.charAt(i) == '0')				zero++;			else				one++;		}		if (l % 2 == 0) 			return (one == zero);		else			return (Math.abs(one - zero) == 1);	}
static boolean checkIfUnequal(int n, int q)	{		String s1 = Integer.toString(n);		int a[] = new int[26];		for (int i = 0; i < s1.length(); i++)			a[s1.charAt(i) - '0']++;		int prod = n * q;		String s2 = Integer.toString(prod);		for (int i = 0; i < s2.length(); i++)		{			if (a[s2.charAt(i) - '0'] > 0)				return false;		}		return true;	}static int countInRange(int l, int r, int q)	{		int count = 0;		for (int i = l; i <= r; i++) {			if (checkIfUnequal(i, q))				count++;		}		return count;	}
public static boolean multipleOrFactor(String s1, String s2)	{		HashMap<Character, Integer> m1 = new HashMap<>();		HashMap<Character, Integer> m2 = new HashMap<>();		for (int i = 0; i < s1.length(); i++)		{			if (m1.containsKey(s1.charAt(i)))			{				int x = m1.get(s1.charAt(i));				m1.put(s1.charAt(i), ++x);			}			else				m1.put(s1.charAt(i), 1);		}		for (int i = 0; i < s2.length(); i++)		{			if (m2.containsKey(s2.charAt(i)))			{				int x = m2.get(s2.charAt(i));				m2.put(s2.charAt(i), ++x);			}			else				m2.put(s2.charAt(i), 1);		}		for (HashMap.Entry<Character, Integer> entry : m1.entrySet())		{			if (!m2.containsKey(entry.getKey()))				continue;			if (m2.get(entry.getKey()) != null &&				(m2.get(entry.getKey()) % entry.getValue() == 0				|| entry.getValue() % m2.get(entry.getKey()) == 0))				continue;			else				return false;		}		return true;	}
static int countChar(String str, char x){	int count = 0;	int n = 10;	for (int i = 0; i < str.length(); i++)		if (str.charAt(i) == x)			count++;	int repetitions = n / str.length();	count = count * repetitions;	for (int i = 0;			i < n % str.length(); i++)	{		if (str.charAt(i) == x)			count++;	}	return count;}
static void SieveOfEratosthenes(boolean prime[], int p_size)	{		prime[0] = false;		prime[1] = false;		for (int p = 2; p * p <= p_size; p++)		{			if (prime[p])			{				for (int i = p * 2; i < p_size; i += p)				{					prime[i] = false;				}			}		}	}static void sumProdOfPrimeFreq(char[] s)	{		boolean[] prime = new boolean[s.length + 1];		Arrays.fill(prime, true);		SieveOfEratosthenes(prime, s.length + 1);		int i, j;		Map<Character, Integer> mp = new HashMap<>();		for (i = 0; i < s.length; i++)		{			mp.put(s[i], mp.get(s[i]) == null ? 1 : mp.get(s[i]) + 1);		}		int sum = 0, product = 1;		for (Map.Entry<Character, Integer> it : mp.entrySet())		{			if (prime[it.getValue()])			{				sum += it.getValue();				product *= it.getValue();			}		}		System.out.print("Sum = " + sum);		System.out.println("\nProduct = " + product);	}
static char bitToBeFlipped(String s){	char last = s.charAt(s.length() - 1);	char first = s.charAt(0);	if (last == first) {		if (last == '0') {			return '1';		}		else {			return '0';		}	}	else if (last != first) {		return last;	}	return last;}
static void steps(String str, int n){	boolean flag = false;	int x = 0;	for (int i = 0; i < str.length(); i++) {		if (x == 0)			flag = true;		if (x == n - 1)			flag = false;		for (int j = 0; j < x; j++)			System.out.print("*");		System.out.print(str.charAt(i)+"\n");		if (flag == true)			x++;		else			x--;	}}
static String decryptString(String str, int n){	int i = 0, jump = 1;	String decryptedStr = "";	while (i < n)	{		decryptedStr += str.charAt(i);		i += jump;		jump++;	}	return decryptedStr;}
static String maxValue(char []a, char []b){	Arrays.sort(b);	int n = a.length;	int m = b.length;	int j = m - 1;	for (int i = 0; i < n; i++) {		if (j < 0)			break;		if (b[j] > a[i]) {			a[i] = b[j];			j--;		}	}	return String.valueOf(a);}
static int minOperations(String s, String t, int n){	int ct0 = 0, ct1 = 0;	for (int i = 0; i < n; i++)	{		if (s.charAt(i) == t.charAt(i))			continue;		if (s.charAt(i) == '0')			ct0++;		else			ct1++;	}	return Math.max(ct0, ct1);}
static int prefixOccurrences(String str){	char c = str.charAt(0);	int countc = 0;	for (int i = 0; i < str.length(); i++)	{		if (str.charAt(i) == c)			countc++;	}	return countc;}
static String replaceConsonants(String str)	{		String res = "";		int i = 0, count = 0;		while (i < str.length()) {			if (str.charAt(i) != 'a'				&& str.charAt(i) != 'e'				&& str.charAt(i) != 'i'				&& str.charAt(i) != 'o'				&& str.charAt(i) != 'u') {				i++;				count++;			}			else {				if (count > 0)					res += count;				res += str.charAt(i);				i++;				count = 0;			}		}		if (count > 0)			res += count;		return res;	}
static int totalPairs(String s1, String s2)	{		int a1 = 0, b1 = 0;		for (int i = 0; i < s1.length(); i++)		{			if ((int)s1.charAt(i) % 2 != 0)				a1++;			else				b1++;		}		int a2 = 0, b2 = 0;		for (int i = 0; i < s2.length(); i++)		{			if ((int)s2.charAt(i) % 2 != 0)				a2++;			else				b2++;		}		return ((a1 * a2) + (b1 * b2));	}
static int countMinReversals(String expr){	int len = expr.length();	if (len % 2 != 0)		return -1;	int ans = 0;	int i;	int open = 0;	int close = 0;	for (i = 0; i < len; i++)	{		if (expr.charAt(i) == '{')			open++;		else		{			if (open == 0)				close++;			else				open--;		}	}	ans = (close / 2) + (open / 2);	close %= 2;	open %= 2;	if (close != 0)		ans += 2;	return ans;}
static boolean equalIgnoreCase(String str1, String str2){	int i = 0;	str1 = str1.toLowerCase();	str2 = str2.toLowerCase();	int x = str1.compareTo(str2);	return x == 0;}static void equalIgnoreCaseUtil(String str1, String str2){	boolean res = equalIgnoreCase(str1, str2);	if (res == true)		System.out.println("Same");	else		System.out.println("Not Same");}
static boolean equalIgnoreCase(String str1, String str2)	{		int i = 0;		str1 = str1.toUpperCase();		str2 = str2.toUpperCase();		int x = str1.compareTo(str2);		if (x != 0)		{			return false;		}		else		{			return true;		}	}static void equalIgnoreCaseUtil(String str1, String str2)	{		boolean res = equalIgnoreCase(str1, str2);		if (res == true)		{			System.out.println("Same");		}		else		{			System.out.println("Not Same");		}	}
static boolean isPalin(int i, int j, int k, int l, int p, int q, String s)	{		int start = i, end = q;		while (start < end) {			if (s.charAt(start) != s.charAt(end))			{				return false;			}			start++;			if (start == j + 1)			{				start = k;			}			end--;			if (end == p - 1)			{				end = l;			}		}		return true;	}static int countSubStr(String s)	{		int count = 0;		int n = s.length();		for (int i = 0; i < n - 2; i++)		{			for (int j = i; j < n - 2; j++)			{				for (int k = j + 1; k < n - 1; k++)				{					for (int l = k; l < n - 1; l++)					{						for (int p = l + 1; p < n; p++)						{							for (int q = p; q < n; q++)							{								if (isPalin(i, j, k, l, p, q, s))								{									count++;								}							}						}					}				}			}		}		return count;	}
static void printUncommon(String str1, String str2)	{		int a1 = 0, a2 = 0;		for (int i = 0; i < str1.length(); i++)		{			int ch = (str1.charAt(i)) - 'a';			a1 = a1 | (1 << ch);		}		for (int i = 0; i < str2.length(); i++)		{			int ch = (str2.charAt(i)) - 'a';			a2 = a2 | (1 << ch);		}		int ans = a1 ^ a2;		int i = 0;		while (i < 26)		{			if (ans % 2 == 1)			{				System.out.print((char) ('a' + i));			}			ans = ans / 2;			i++;		}	}
static boolean isPossible(char[] str)	{		Map<Character, Integer> freq = new HashMap<>();		int max_freq = 0;		for (int j = 0; j < (str.length); j++) {			if (freq.containsKey(str[j])) {				freq.put(str[j], freq.get(str[j]) + 1);				if (freq.get(str[j]) > max_freq)					max_freq = freq.get(str[j]);			}			else {				freq.put(str[j], 1);				if (freq.get(str[j]) > max_freq)					max_freq = freq.get(str[j]);			}		}		if (max_freq <= (str.length - max_freq + 1))			return true;		return false;	}
static void getOrgString(String s)	{		System.out.print(s.charAt(0));		int i = 1;		while (i < s.length())		{			if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z')				System.out.print(" "+ Character.toLowerCase(s.charAt(i)));			else				System.out.print(s.charAt(i));			i++;		}	}
static String encryptStr(String str, int n, int x)	{		x = x % MAX;		char arr[] = str.toCharArray();		int freq[] = new int[MAX];		for (int i = 0; i < n; i++)			freq[arr[i] - 'a']++;		for (int i = 0; i < n; i++) {			if (freq[arr[i] - 'a'] % 2 == 0) {				int pos = (arr[i] - 'a' + x) % MAX;				arr[i] = (char)(pos + 'a');			}			else {				int pos = (arr[i] - 'a' - x);				if (pos < 0)					pos += MAX;				arr[i] = (char)(pos + 'a');			}		}		return String.valueOf(arr);	}
public static void findWord(String c, int n){	int co = 0, i;	char s[] = new char[n];	for (i = 0; i < n ; i++)	{		if (i < n / 2)			co++;		else			co = n - i;		if ((c.charAt(i) + co) <= 122)			s[i] = (char)((int)c.charAt(i) + co);		else			s[i] = (char)((int)c.charAt(i) + co - 26);	}	String str = Arrays.toString(s);	System.out.println(str);}
static int countSubStr(String s, int n)	{		int c1 = 0, c2 = 0;		for (int i = 0; i < n; i++)		{			if (i < n - 5 &&				"geeks".equals(s.substring(i, i + 5)))			{				c1++;			}			if (i < n - 3 &&				"for".equals(s.substring(i, i + 3)))			{				c2 = c2 + c1;			}		}		return c2;	}
static void findSubStr(String str, int cnt, int start){	if (start == str.length())	{		minCnt = Math.min(cnt, minCnt);	}	for (int len = 1;			len <= (str.length() - start); len++)	{		String subStr = str.substring(start, start + len);		if (uSet.contains(subStr))		{			findSubStr(str, cnt + 1, start + len);		}	}}static void findMinSubStr(String arr[], int n, String str){	for (int i = 0; i < n; i++)		uSet.add(arr[i]);	findSubStr(str, 0, 0);}
static int cntWays(String str, int n){	int x = n + 1;	int ways = x * x * (x * x - 1) / 12;	return ways;}
static int maxSubStr(char []str1, int len1, char []str2, int len2)	{		if (len1 > len2)			return 0;		int freq1[] = new int[MAX];		for (int i = 0; i < len1; i++)			freq1[i] = 0;		for (int i = 0; i < len1; i++)			freq1[str1[i] - 'a']++;		int freq2[] = new int[MAX];		for (int i = 0; i < len2; i++)			freq2[i] = 0;		for (int i = 0; i < len2; i++)			freq2[str2[i] - 'a']++;		int minPoss = Integer.MAX_VALUE;		for (int i = 0; i < MAX; i++)		{			if (freq1[i] == 0)				continue;			if (freq1[i] > freq2[i])				return 0;			minPoss = Math.min(minPoss, freq2[i] / freq1[i]);		}		return minPoss;	}
public static boolean isPalindrome(float num)	{		String s = String.valueOf(num);		int low = 0;		int high = s.length() - 1;		while (low < high) {			if (s.charAt(low) != s.charAt(high))				return false;			low++;			high--;		}		return true;	}
static void sub_segments(String str, int n){	int l = str.length();	for (int x = 0; x < l; x += n)	{		String newlist = str.substring(x, x + n);		List<Character> arr = new ArrayList<Character>();		for (char y : newlist.toCharArray())		{			if (!arr.contains(y))				arr.add(y);		}		for (char y : arr)			System.out.print(y);		System.out.println();	}}
static void findMostOccurringChar(Vector<String> str){	int []hash = new int[26];	for (int i = 0; i < str.size(); i++)	{		for (int j = 0; j < str.get(i).length(); j++)		{			hash[str.get(i).charAt(j)-97]++;		}	}	int max = 0;	for (int i = 0; i < 26; i++)	{		max = hash[i] > hash[max] ? i : max;	}	System.out.print((char)(max + 97) +"\n");}
static int productAtKthLevel( String tree, int k, int level){		if (tree.charAt(i++) == '(') {			if (tree.charAt(i) == ')')				return 1;			int product = 1;			if (level == k)				product = tree.charAt(i) - '0';			++i;			int leftproduct = productAtKthLevel( tree, k, level + 1);			++i;			int rightproduct = productAtKthLevel( tree, k, level + 1);			++i;			return product * leftproduct			* rightproduct;		}		return Integer.MIN_VALUE;	}
static String removeChars(char arr[], int k){	int []hash = new int[MAX_CHAR];	int n = arr.length;	for (int i = 0; i < n; ++i)		hash[arr[i] - 'a']++;	String ans = "";	for (int i = 0; i < n; ++i) {		if (hash[arr[i] - 'a'] != k) {			ans += arr[i];		}	}	return ans;}
static String removeOddFrequencyCharacters(String s)	{		HashMap<Character, Integer> m = new HashMap<Character,Integer>();		for (int i = 0; i < s.length(); i++) {			char p = s.charAt(i);			Integer count = m.get(p);			if( count == null)			{				count=0;				m.put(p,1);			}			else				m.put(p,count + 1);		}		String new_string = "";		for (int i = 0; i < s.length(); i++) {			if ((m.get(s.charAt(i))& 1)==1)				continue;			new_string += s.charAt(i);		}		return new_string;	}
public static void distinct(String[] S, int M){	int count = 0;	for(int i = 0; i < S.length; i++)	{	Set<Character> set = new HashSet<>();	for(int j = 0; j < S[i].length(); j++)	{		if (!set.contains(S[i].charAt(j)))			set.add(S[i].charAt(j));	}	int c = set.size();	if (c <= M)		count += 1;	}	System.out.println(count);}
static void flip(String s){	StringBuilder sb = new StringBuilder(s);	for(int i = 0; i < sb.length(); i++)	{	if (sb.charAt(i) == '0')	{		while (sb.charAt(i) == '0')		{			sb.setCharAt(i, '1');			i++;		}		break;	}	}	System.out.println(sb.toString());}
static void findNumOfValidWords(Vector<String> w, Vector<String> p){ HashMap<Integer,		Integer> m = new HashMap<>(); Vector<Integer> res = new Vector<>(); for (String s : w) {	int val = 0;	for (char c : s.toCharArray())	{	val = val | (1 << (c - 'a'));	}	if(m.containsKey(val))	m.put(val, m.get(val) + 1);	else	m.put(val, 1); } for (String s : p) {	int val = 0;	for (char c : s.toCharArray())	{	val = val | (1 << (c - 'a'));	}	int temp = val;	int first = s.charAt(0) - 'a';	int count = 0;	while (temp != 0)	{	if (((temp >> first) & 1) == 1)	{		if (m.containsKey(temp))		{		count += m.get(temp);		}	}	temp = (temp - 1) & val;	}	res.add(count); } for (int it : res) {	System.out.println(it); }}
static boolean can_Construct(String S, int K){	Map<Character, Integer> m = new HashMap<>();	int p = 0;	if (S.length() == K)		return true;	for(int i = 0; i < S.length(); i++)		m.put(S.charAt(i),			m.getOrDefault(S.charAt(i), 0) + 1);	if (K > S.length())		return false;	else	{		for(Integer h : m.values())		{			if (h % 2 != 0)				p = p + 1;		}	}	if (K < p)		return false;	return true;}
static boolean check(String s, int n){	Stack<Character> st = new Stack<Character>();	for(int i = 0; i < n; i++)	{	if (!st.isEmpty() &&			st.peek() == s.charAt(i))		st.pop();	else		st.add(s.charAt(i));	}	if (st.isEmpty())	{		return true;	}	else	{		return false;	}}
static boolean isValid(char a1, char a2, String str, int flag){ char v1, v2; if (flag == 0) {	v1 = str.charAt(4);	v2 = str.charAt(3); } else {	v1 = str.charAt(1);	v2 = str.charAt(0); } if (v1 != a1 && v1 != '?')	return false; if (v2 != a2 && v2 != '?')	return false; return true;}static boolean inRange(int hh, int mm, int L, int R){ int a = Math.abs(hh - mm); if (a < L a > R)	return false; return true;}static void displayTime(int hh, int mm){ if (hh > 10)	System.out.print(hh + ":"); else if (hh < 10)	System.out.print("0" + hh + ":"); if (mm > 10)	System.out.println(mm); else if (mm < 10)	System.out.println("0" + mm);}static void maximumTimeWithDifferenceInRange(String str, int L, int R){ int i = 0, j = 0; int h1, h2, m1, m2; for (i = 23; i >= 0; i--) {	h1 = i % 10;	h2 = i / 10;	if (!isValid((char)h1,				(char)h2, str, 1))	{	continue;	}	for (j = 59; j >= 0; j--)	{	m1 = j % 10;	m2 = j / 10;	if (!isValid((char)m1,				(char)m2, str, 0))	{		continue;	}	if (inRange(i, j, L, R))	{		displayTime(i, j);		return;	}	} } if (inRange(i, j, L, R))	displayTime(i, j); else	System.out.println("-1");}
static String checkString(String s, int K){	int n = s.length();	Map<Character,		Integer> mp = new HashMap<>();	for(int i = 0; i < n; i++)	{		mp.put(s.charAt(i), i);	}	int cnt = 0, f = 0;	Set<Character> st = new HashSet<>();	for(int i = 0; i < n; i++)	{		st.add(s.charAt(i));		if (st.size() > K)		{			f = 1;			break;		}		if (mp.get(s.charAt(i)) == i)			st.remove(s.charAt(i));	}	return (f == 1 ? "Yes" : "No");}
static String removeCharRecursive(String str, char X){	if (str.length() == 0)	{		return "";	}	if (str.charAt(0) == X)	{		return removeCharRecursive(			str.substring(1), X);	}	return str.charAt(0) +		removeCharRecursive(		str.substring(1), X);}
static int binomialCoeff(int n, int k){	int res = 1;	if (k > n - k)		k = n - k;	for(int i = 0; i < k; ++i)	{		res *= (n - i);		res /= (i + 1);	}	return res;}static int countOfString(int N){	int Stotal = (int) Math.pow(2, N);	int Sequal = 0;	if (N % 2 == 0)		Sequal = binomialCoeff(N, N / 2);	int S1 = (Stotal - Sequal) / 2;	return S1;}
static int longComPre(String arr[], int N){ int [][]freq = new int[N][256]; for (int i = 0; i < N; i++) {	int M = arr[i].length();	for (int j = 0; j < M; j++)	{	freq[i][arr[i].charAt(j)]++;	} } int maxLen = 0; for (int j = 0; j < 256; j++) {	int minRowVal = Integer.MAX_VALUE;	for (int i = 0; i < N; i++)	{	minRowVal = Math.min(minRowVal, freq[i][j]);	}	maxLen += minRowVal; } return maxLen;}
static int findMinimumChanges(int N, int K, char[] S){	int ans = 0;	for(int i = 0; i < (K + 1) / 2; i++)	{		HashMap<Character, Integer> mp = new HashMap<>();		for(int j = i; j < N; j += K)		{			if (mp.containsKey(S[j]))			{				mp.put(S[j], mp.get(S[j]) + 1);			}			else			{				mp.put(S[j], 1);			}		}		for(int j = N - i - 1; j >= 0; j -= K)		{			if (K % 2 == 1 && i == K / 2)				break;			if (mp.containsKey(S[j]))			{				mp.put(S[j], mp.get(S[j]) + 1);			}			else			{				mp.put(S[j], 1);			}		}		int curr_max = Integer.MIN_VALUE;		for(Map.Entry<Character,					Integer> p : mp.entrySet())		{			curr_max = Math.max(curr_max,								p.getValue());		}		if ((K % 2 == 1) && i == K / 2)			ans += (N / K - curr_max);		else			ans += (N / K * 2 - curr_max);	}	return ans;}
static void minMaxDigits(String str, int N){	int arr[] = new int[N];	for(int i = 0; i < N; i++)		arr[i] = (str.charAt(i) - '0') % 3;	int zero = 0, one = 0, two = 0;	for(int i = 0; i < N; i++)	{		if (arr[i] == 0)			zero++;		if (arr[i] == 1)			one++;		if (arr[i] == 2)			two++;	}	int sum = 0;	for(int i = 0; i < N; i++)	{		sum = (sum + arr[i]) % 3;	}	if (sum == 0)	{		System.out.print(0 + " ");	}	if (sum == 1)	{		if ((one != 0) && (N > 1))			System.out.print(1 + " ");		else if (two > 1 && N > 2)			System.out.print(2 + " ");		else			System.out.print(-1 + " ");	}	if (sum == 2)	{		if (two != 0 && N > 1)			System.out.print(1 + " ");		else if (one > 1 && N > 2)			System.out.print(2 + " ");		else			System.out.print(-1 + " ");	}	if (zero > 0)		System.out.print(N - 1 + " ");	else if (one > 0 && two > 0)		System.out.print(N - 2 + " ");	else if (one > 2 two > 2)		System.out.print(N - 3 + " ");	else		System.out.print(-1 + " ");}
static void DFA(String str, int N) {	if (N <= 1)	{	System.out.print("No");	return;	}	int count = 0;	if (str.charAt(0) == 'C')	{	count++;	for (int i = 1; i < N; i++)	{		if (str.charAt(i) == 'A' ||			str.charAt(i) == 'B')		count++;		else		break;	}	}	else	{	System.out.print("No");	return;	}	if (count == N)	System.out.print("Yes");	else	System.out.print("No"); }
static void findWinner(String a, int n) {	Vector<Integer> v = new Vector<Integer>(); 	int c = 0;	for (int i = 0; i < n; i++)	{	if (a.charAt(i) == '0')	{		c++;	}	else	{		if (c != 0)		v.add(c);		c = 0;	}	}	if (c != 0)	v.add(c);	if (v.size() == 0)	{	System.out.print("Player B");	return;	}	if (v.size() == 1)	{	if ((v.get(0) & 1) != 0)		System.out.print("Player A");	else		System.out.print("Player B");	return;	}	int first = Integer.MIN_VALUE;	int second = Integer.MIN_VALUE;	for (int i = 0; i < v.size(); i++)	{	if (a.charAt(i) > first) {		second = first;		first = a.charAt(i);	}	else if (a.charAt(i) > second			&& a.charAt(i) != first)		second = a.charAt(i);	}	if ((first & 1) != 0		&& (first + 1) / 2 > second)	System.out.print("Player A");	else	System.out.print("Player B"); }
static void countOccurrences(String S, String X, String Y)	{		int count = 0;		int N = S.length(), A = X.length();		int B = Y.length();		for (int i = 0; i < N; i++) {			if (S.substring(i, Math.min(N, i + B))					.equals(Y))				count++;			if (S.substring(i, Math.min(N, i + A))					.equals(X))				System.out.print(count + " ");		}	}
static void generatePalindrome(String S)	{		HashMap<Character, Integer> Hash = new HashMap<>();		for(int i = 0; i < S.length(); i++)		{			if (Hash.containsKey(S.charAt(i)))				Hash.put(S.charAt(i), Hash.get(S.charAt(i))+1);			else				Hash.put(S.charAt(i), 1);		}		TreeSet<String> st = new TreeSet<String>();		for(char i = 'a'; i <= 'z'; i++)		{			if (Hash.containsKey(i) && Hash.get(i) == 2)			{				for(char j = 'a'; j <= 'z'; j++)				{					String s = "";					if (Hash.containsKey(j) && i != j)					{						s += i;						s += j;						s += i;						st.add(s);					}				}			}			if (Hash.containsKey(i) && Hash.get(i) >= 3)			{				for(char j = 'a'; j <= 'z'; j++)				{					String s = "";					if (Hash.containsKey(j))					{						s += i;						s += j;						s += i;						st.add(s);					}				}			}		}		for(String ans : st)		{			System.out.println(ans);		}	}
